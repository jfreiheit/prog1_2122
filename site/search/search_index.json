{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programmieren I \u00b6 Herzlich willkommen zur Programmieren I Veranstaltung! Wir werden unter Verwendung der Programmiersprache Java die wesentlichen Konzepte lernen, die f\u00fcr das Verst\u00e4ndnis modernen Programmierens notwendig sind. Es sind keinerlei Vorkenntnisse erforderlich. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung! Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren! Sie m\u00fcssen es tun . Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler! Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df! Organisatorisches \u00b6 Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in der Vorlesung vorgestellt und in diesem Skript beschrieben. Es ist geplant, die neuen Themen stets vorab in diesem Skript hier zu ver\u00f6ffentlichen. Sie k\u00f6nnen sich also bereits vorab mit dem jeweiligen neuen Thema besch\u00e4ftigen. Zusammen mit dem Skript (das neue Thema) werden sowohl die dazugeh\u00f6rige \u00dcbung als auch die dazugeh\u00f6rige Aufgabe hochgeladen. Die beiden \u00dcbungen am Mittwoch sind jeweils gleich (d.h. dort werden die gleichen \u00dcbungsaufgaben gel\u00f6st). Die \u00dcbungen behandeln den Stoff, der am Mittwoch in der Vorwoche und am Dienstag in der gleichen Woche besprochen wird. Das bedeutet: das neue Thema wird am Mittwoch und am darauffolgenden Dienstag in der Vorlesung vermittelt und an dem Mittwoch darauf in der \u00dcbung angewendet. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Sie k\u00f6nnen auch beliebig w\u00f6chentlich wechseln. Es wird ein Tutorium angeboten (Termin wird noch bekanntgegeben). Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu. Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie die Aufgaben (Hausaufgaben) l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 12 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr \"Programmieren 1\". Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht meistens jeweils einem Wochenthema. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, dass Sie sich diese gegenseitig beantworten. Damit w\u00e4re allen geholfen und wir k\u00f6nnen besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Bei Bedarf beantworten die Lehrenden die Fragen nat\u00fcrlich. Es wird ein Programmier-Tutorium angeboten. Dieses findet montags um 16:00 Uhr in C 639 statt - Start ist am 25.10.2021. Unsere Tutorin ist Lisanne Delfs . Planung (vorl\u00e4ufig - kann sich noch \u00e4ndern) \u00b6 Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) Aufgabe Abgabe Aufgabe bis 1. 11.-15.10.2021 Einf\u00fchrung und Organisatorisches, erstes Programm - - 2. 18.-22.10.2021 Klassen und Objekte - BlueJ Aufgabe 1 25.10.2021 3. 25.-29.10.2021 Datentypen und Variablen, logische Ausdr\u00fccke Aufgabe 2 01.11.2021 4. 01.-05.11.2021 Sequenzen, Iterationen und Selektion Aufgabe 3 08.11.2021 5. 08.-12.11.2021 N\u00fctzliche Klassen, Einf\u00fchrung Arrays Aufgabe 4 15.11.2021 6. 15.-19.11.2021 Sortieren von Arrays Aufgabe 5 22.11.2021 7. 22.-26.11.2021 Konstruktoren, this, eigene Datentypen, R\u00fcckgabe von Objekten Aufgabe 6 29.11.2021 8. 29.-03.12.2021 Klassen- und Objekt-Variablen und -Methoden Aufgabe 7 06.12.2021 9. 06.-10.12.2021 Vererbung Aufgabe 8 13.12.2021 10. 13.-17.12.2021 Object und Polymorphie Aufgabe 9 20.12.2021 11. 20.-24.12.2021 return Aufgabe 10 03.01.2022 12. 03.-07.01.2022 Enumerations Aufgabe 11 10.01.2022 13. 10.-14.01.2022 Exceptions Aufgabe 12 17.01.2022 14. 17.-21.01.2022 JavaDoc - - 15. 24.-28.01.2021 Neuerungen ab Java 8 - - 16. 31.-03.02.2022 Wiederholung, Klausurvorbereitung Fragen - 17. 07.-11.02.2021 Wiederholung, Klausurvorbereitung Fragen -","title":"Home"},{"location":"#programmieren-i","text":"Herzlich willkommen zur Programmieren I Veranstaltung! Wir werden unter Verwendung der Programmiersprache Java die wesentlichen Konzepte lernen, die f\u00fcr das Verst\u00e4ndnis modernen Programmierens notwendig sind. Es sind keinerlei Vorkenntnisse erforderlich. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung! Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren! Sie m\u00fcssen es tun . Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler! Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df!","title":"Programmieren I"},{"location":"#organisatorisches","text":"Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in der Vorlesung vorgestellt und in diesem Skript beschrieben. Es ist geplant, die neuen Themen stets vorab in diesem Skript hier zu ver\u00f6ffentlichen. Sie k\u00f6nnen sich also bereits vorab mit dem jeweiligen neuen Thema besch\u00e4ftigen. Zusammen mit dem Skript (das neue Thema) werden sowohl die dazugeh\u00f6rige \u00dcbung als auch die dazugeh\u00f6rige Aufgabe hochgeladen. Die beiden \u00dcbungen am Mittwoch sind jeweils gleich (d.h. dort werden die gleichen \u00dcbungsaufgaben gel\u00f6st). Die \u00dcbungen behandeln den Stoff, der am Mittwoch in der Vorwoche und am Dienstag in der gleichen Woche besprochen wird. Das bedeutet: das neue Thema wird am Mittwoch und am darauffolgenden Dienstag in der Vorlesung vermittelt und an dem Mittwoch darauf in der \u00dcbung angewendet. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Sie k\u00f6nnen auch beliebig w\u00f6chentlich wechseln. Es wird ein Tutorium angeboten (Termin wird noch bekanntgegeben). Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu. Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie die Aufgaben (Hausaufgaben) l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 12 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr \"Programmieren 1\". Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht meistens jeweils einem Wochenthema. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, dass Sie sich diese gegenseitig beantworten. Damit w\u00e4re allen geholfen und wir k\u00f6nnen besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Bei Bedarf beantworten die Lehrenden die Fragen nat\u00fcrlich. Es wird ein Programmier-Tutorium angeboten. Dieses findet montags um 16:00 Uhr in C 639 statt - Start ist am 25.10.2021. Unsere Tutorin ist Lisanne Delfs .","title":"Organisatorisches"},{"location":"#planung-vorlaufig-kann-sich-noch-andern","text":"Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) Aufgabe Abgabe Aufgabe bis 1. 11.-15.10.2021 Einf\u00fchrung und Organisatorisches, erstes Programm - - 2. 18.-22.10.2021 Klassen und Objekte - BlueJ Aufgabe 1 25.10.2021 3. 25.-29.10.2021 Datentypen und Variablen, logische Ausdr\u00fccke Aufgabe 2 01.11.2021 4. 01.-05.11.2021 Sequenzen, Iterationen und Selektion Aufgabe 3 08.11.2021 5. 08.-12.11.2021 N\u00fctzliche Klassen, Einf\u00fchrung Arrays Aufgabe 4 15.11.2021 6. 15.-19.11.2021 Sortieren von Arrays Aufgabe 5 22.11.2021 7. 22.-26.11.2021 Konstruktoren, this, eigene Datentypen, R\u00fcckgabe von Objekten Aufgabe 6 29.11.2021 8. 29.-03.12.2021 Klassen- und Objekt-Variablen und -Methoden Aufgabe 7 06.12.2021 9. 06.-10.12.2021 Vererbung Aufgabe 8 13.12.2021 10. 13.-17.12.2021 Object und Polymorphie Aufgabe 9 20.12.2021 11. 20.-24.12.2021 return Aufgabe 10 03.01.2022 12. 03.-07.01.2022 Enumerations Aufgabe 11 10.01.2022 13. 10.-14.01.2022 Exceptions Aufgabe 12 17.01.2022 14. 17.-21.01.2022 JavaDoc - - 15. 24.-28.01.2021 Neuerungen ab Java 8 - - 16. 31.-03.02.2022 Wiederholung, Klausurvorbereitung Fragen - 17. 07.-11.02.2021 Wiederholung, Klausurvorbereitung Fragen -","title":"Planung (vorl\u00e4ufig - kann sich noch \u00e4ndern)"},{"location":"aufgaben/","text":"Aufgaben \u00b6 Hier finden Sie die Aufgaben. Die Abgabefristen der einzelnen Aufgaben stehen hier . Beachten Sie die nachfolgenden Hinweise zum Hochladen der Aufgaben. Hinweise zur Abgabe der Aufgaben \u00b6 Die Aufgaben laden Sie in Moodle unter dem Reiter \"Aufgaben\" hoch. Dort ist f\u00fcr jede Aufgabe eine Moodle-Aufgabe erstellt. Beachten Sie, dass ein Hochladen nach Ablauf der Abgabefrist nicht mehr m\u00f6glich ist. BlueJ vs. Eclipse \u00b6 Die ersten Wochen verwenden wir als Entwicklungsumgebung BlueJ. F\u00fcr die Aufgaben, die wir mit BlueJ l\u00f6sen, werde ich Ihnen jeweils Hinweise zur Abgabe f\u00fcr jede Aufgabe einzeln geben. Sobald wir Eclipse verwenden, gelten die folgenden Hinweise: Achten Sie darauf, dass Sie die Quelldateien (also die .java -Dateien aus dem src -Verzeichnis) hochladen. Ihre Klassen erstellen Sie immer in einem package aufgaben.aufgabeX . Das hei\u00dft, Aufgabe1 ist im package aufgaben.aufgabe1 , Aufgabe2 im package aufgaben.aufgabe2 usw. In Ihrem workspace gibt es dann einen Ordner f\u00fcr Ihr Java-Projekt, z.B. WS21 (je nachdem, wie Sie Ihr Java-Projekt genannt haben) und darin befindet sich ein bin - und ein src -Ordner. In dem src -Ordner befindet sich dann ein Ordner aufgaben und darin ein Ordner aufgaben1 (f\u00fcr Aufgabe1). Darin befindet sich Ihre .java -Datei, die Sie hochladen sollen. Angenommen, Sie haben Ihre Klasse Aufgabe1 genannt, dann hei\u00dft die Klasse also Aufgabe1.java . Sie folgen also dem Pfad workspace \u2192 Java-Projekt (z.B. WS21 ) \u2192 src \u2192 aufgaben \u2192 aufgabe X . Wenn Ihre L\u00f6sung aus mehreren Klassen (mehreren .java -Dateien) besteht, k\u00f6nnen Sie entweder die Dateien einzeln hochladen oder Sie zippen Ihre Dateien (am besten dann den aufgabeX -Ordner und laden das .zip -File hoch. In Ihrer L\u00f6sung (Ihrer/n Klasse/n) f\u00fcgen Sie direkt oberhalb Ihrer Klassendefinition einen JavaDoc-Kommentar ein ( /** ... */ ). Dieser enth\u00e4lt ein @author -Tag. dahinter schreiben Sie Ihren Namen. Das sieht dann z.B. so aus: package aufgaben.aufgabe1 ; /** * * @author J\u00f6rn Freiheit * * Diese Klasse gibt auf die Konsole ein Rhombus (eine Raute) aus. * Der Rhombus ist entweder gefuellt oder ungefuellt. * */ public class Aufgabe1 { // hier Ihre Implementierung } Sie k\u00f6nnen Ihre Aufgaben zu zweit l\u00f6sen. Tragen Sie dann hinter das @author -Tag beide Namen ein und laden Sie bitte beide die L\u00f6sung in Moodle hoch! Code Review \u00b6 F\u00fcr jede abgegebene Aufgabe wird Ihnen die L\u00f6sung einer Kommilitonin zum Review zugewiesen. Analysieren Sie den Code Ihrer Kommilitonin und geben Sie ihr dazu eine R\u00fcckmeldung! Es gen\u00fcgen 2 bis 3 Review-Kommentare. Zur offiziellen Abgabe einer Aufgabe geh\u00f6ren also das Hochladen der eigenen L\u00f6sung, das Analysieren/Kommentieren einer fremden L\u00f6sung. Hinweise zum Review: \u00b6 Es geht nicht darum, das Programm zu \u00fcberarbeiten, sondern darum es nachzuvollziehen und Ihrer Kommilitonin eine R\u00fcckmeldung und eventuell Anregungen zu geben. Weisen Sie sowohl auf St\u00e4rken als auch auf Schw\u00e4chen des Quelltexts hin. Worauf Sie u.a. achten k\u00f6nnen: Ist der Quelltext gut strukturiert und verst\u00e4ndlich? Haben Variablen und Methoden passende Namen? Werden die Namen konsistent verwendet? Werden Konventionen eingehalten? Beispiel: Klassennamen starten immer mit Gro\u00dfbuchstaben, Objektnamen immer mit Kleinbuchstaben Ist das Programm \u00fcbersichtlich formatiert? Beispiel: kein horizontales Scrolling n\u00f6tig Machen Sie ggf. Vorschl\u00e4ge f\u00fcr (alternative) L\u00f6sungen. Gehen Sie respektvoll miteinander um, es gibt keinen Grund, unh\u00f6flich zu sein. Lesen Sie Ihre Kommentare noch einmal durch, bevor Sie sie an Ihre Kommilitonin weitergeben. Aufgaben \u00b6","title":"Aufgaben"},{"location":"aufgaben/#aufgaben","text":"Hier finden Sie die Aufgaben. Die Abgabefristen der einzelnen Aufgaben stehen hier . Beachten Sie die nachfolgenden Hinweise zum Hochladen der Aufgaben.","title":"Aufgaben"},{"location":"aufgaben/#hinweise-zur-abgabe-der-aufgaben","text":"Die Aufgaben laden Sie in Moodle unter dem Reiter \"Aufgaben\" hoch. Dort ist f\u00fcr jede Aufgabe eine Moodle-Aufgabe erstellt. Beachten Sie, dass ein Hochladen nach Ablauf der Abgabefrist nicht mehr m\u00f6glich ist.","title":"Hinweise zur Abgabe der Aufgaben"},{"location":"aufgaben/#bluej-vs-eclipse","text":"Die ersten Wochen verwenden wir als Entwicklungsumgebung BlueJ. F\u00fcr die Aufgaben, die wir mit BlueJ l\u00f6sen, werde ich Ihnen jeweils Hinweise zur Abgabe f\u00fcr jede Aufgabe einzeln geben. Sobald wir Eclipse verwenden, gelten die folgenden Hinweise: Achten Sie darauf, dass Sie die Quelldateien (also die .java -Dateien aus dem src -Verzeichnis) hochladen. Ihre Klassen erstellen Sie immer in einem package aufgaben.aufgabeX . Das hei\u00dft, Aufgabe1 ist im package aufgaben.aufgabe1 , Aufgabe2 im package aufgaben.aufgabe2 usw. In Ihrem workspace gibt es dann einen Ordner f\u00fcr Ihr Java-Projekt, z.B. WS21 (je nachdem, wie Sie Ihr Java-Projekt genannt haben) und darin befindet sich ein bin - und ein src -Ordner. In dem src -Ordner befindet sich dann ein Ordner aufgaben und darin ein Ordner aufgaben1 (f\u00fcr Aufgabe1). Darin befindet sich Ihre .java -Datei, die Sie hochladen sollen. Angenommen, Sie haben Ihre Klasse Aufgabe1 genannt, dann hei\u00dft die Klasse also Aufgabe1.java . Sie folgen also dem Pfad workspace \u2192 Java-Projekt (z.B. WS21 ) \u2192 src \u2192 aufgaben \u2192 aufgabe X . Wenn Ihre L\u00f6sung aus mehreren Klassen (mehreren .java -Dateien) besteht, k\u00f6nnen Sie entweder die Dateien einzeln hochladen oder Sie zippen Ihre Dateien (am besten dann den aufgabeX -Ordner und laden das .zip -File hoch. In Ihrer L\u00f6sung (Ihrer/n Klasse/n) f\u00fcgen Sie direkt oberhalb Ihrer Klassendefinition einen JavaDoc-Kommentar ein ( /** ... */ ). Dieser enth\u00e4lt ein @author -Tag. dahinter schreiben Sie Ihren Namen. Das sieht dann z.B. so aus: package aufgaben.aufgabe1 ; /** * * @author J\u00f6rn Freiheit * * Diese Klasse gibt auf die Konsole ein Rhombus (eine Raute) aus. * Der Rhombus ist entweder gefuellt oder ungefuellt. * */ public class Aufgabe1 { // hier Ihre Implementierung } Sie k\u00f6nnen Ihre Aufgaben zu zweit l\u00f6sen. Tragen Sie dann hinter das @author -Tag beide Namen ein und laden Sie bitte beide die L\u00f6sung in Moodle hoch!","title":"BlueJ vs. Eclipse"},{"location":"aufgaben/#code-review","text":"F\u00fcr jede abgegebene Aufgabe wird Ihnen die L\u00f6sung einer Kommilitonin zum Review zugewiesen. Analysieren Sie den Code Ihrer Kommilitonin und geben Sie ihr dazu eine R\u00fcckmeldung! Es gen\u00fcgen 2 bis 3 Review-Kommentare. Zur offiziellen Abgabe einer Aufgabe geh\u00f6ren also das Hochladen der eigenen L\u00f6sung, das Analysieren/Kommentieren einer fremden L\u00f6sung.","title":"Code Review"},{"location":"aufgaben/#hinweise-zum-review","text":"Es geht nicht darum, das Programm zu \u00fcberarbeiten, sondern darum es nachzuvollziehen und Ihrer Kommilitonin eine R\u00fcckmeldung und eventuell Anregungen zu geben. Weisen Sie sowohl auf St\u00e4rken als auch auf Schw\u00e4chen des Quelltexts hin. Worauf Sie u.a. achten k\u00f6nnen: Ist der Quelltext gut strukturiert und verst\u00e4ndlich? Haben Variablen und Methoden passende Namen? Werden die Namen konsistent verwendet? Werden Konventionen eingehalten? Beispiel: Klassennamen starten immer mit Gro\u00dfbuchstaben, Objektnamen immer mit Kleinbuchstaben Ist das Programm \u00fcbersichtlich formatiert? Beispiel: kein horizontales Scrolling n\u00f6tig Machen Sie ggf. Vorschl\u00e4ge f\u00fcr (alternative) L\u00f6sungen. Gehen Sie respektvoll miteinander um, es gibt keinen Grund, unh\u00f6flich zu sein. Lesen Sie Ihre Kommentare noch einmal durch, bevor Sie sie an Ihre Kommilitonin weitergeben.","title":"Hinweise zum Review:"},{"location":"aufgaben/#aufgaben_1","text":"","title":"Aufgaben"},{"location":"bluej/","text":"BlueJ \u00b6 Wir lernen unsere Entwicklungsumgebung kennen, die wir in den ersten Wochen f\u00fcr das Programmieren nutzen werden. Es handelt sich um BlueJ . BlueJ wurde extra f\u00fcr Studierende entwickelt, die Programmieren lernen. Das J in BlueJ steht f\u00fcr Java . Mit BlueJ wird also das Programmieren mit Java gelernt. Eine wesentliche Idee hinter der Entwicklung von BlueJ bestand darin, gleich am Anfang mit der objektorientierten Programmierung zu beginnen, d.h. sich gleich mit Klassen und Objekten zu besch\u00e4ftigen. Das passiert h\u00e4ufig erst recht sp\u00e4t in der Programmierausbildung. Wir geben zun\u00e4chst einen groben \u00dcberblick und lernen dabei in kurzer Zeit viele neue Konzepte und Begriffe kennen. Aber keine Sorge, mit all diesen Konzepten besch\u00e4ftigen wir uns jeweils noch ganz ausf\u00fchrlich. Objekte und Klassen \u00b6 Wenn wir uns die Welt betrachten, dann besteht diese aus lauter Objekten , die miteinander in Beziehung stehen. Man ganz konkret \u00fcber bestimmte Objekte sprechen: \u201edas ist ein sch\u00f6ner Stuhl\u201c \u201edas ist ein teurer Tisch\u201c \u201edas Auto ist blau\u201c oder ganz allgemein \u00fcber eine Klasse von Objekten: \u201eInformatikerInnen sind Nerds\u201c \u201eComputer machen immer, was sie wollen\u201c \u201edie Bahnen kommen immer zu sp\u00e4t\u201c In der Welt des objektorientierten Programmierens sind die Klassen die \"Muster\" oder die \"Bauanleitungen\" f\u00fcr konkrete Objekte . Mit Klassen beschreiben wir die allgemeinen Eigenschaften, die f\u00fcr alle Objekte dieser Klasse gelten. Klassen beschreiben eine Struktur der Objekte (das sind die sogenannten Objektvariablen ) und ein Verhalten dieser Objekte (das sind die sogenannten Objektmethoden ). Insgesamt sprechen wir bei der Struktur und dem Verhalten von den Eigenschaften einer Klasse. Eine Klasse ist ein Datentyp und jeder \"Wert\" 1 ist ein konkretes Objekt von diesem Typ. Von einer Klasse k\u00f6nnen wir beliebig viele Objekte erzeugen. Objekte werden aus Klassen erzeugt. Eine Klasse beschreibt die Art und Weise, den Aufbau von Objekten. Objekte sind die speziellen Instanzen einer allgemeinen Klasse. Ein typisches Beispiel ist Auto . Ein Auto kann fahren, hat eine Farbe, ist von einer bestimmten Marke, hat einen bestimmten Motor, eine bestimmte Anzahl von T\u00fcren und so weiter. Das sind alles Eigenschaften eines Autos. Diese Eigenschaften werden in einer Klasse definiert und beschreiben ein Auto im Allgemeinen. Davon gibt es dann konkrete Objekte: ein roter VW Golf mit 5 T\u00fcren, ein blauer Toyota mit 3 T\u00fcren usw. Ein erstes Beispiel mit BlueJ \u00b6 Wir \u00f6ffnen BlueJ dann im Men\u00fc auf Project --> Open Project . Im examples -Ordner von BlueJ finden wir den Ordner shapes . Wir w\u00e4hlen den Ordner und klicken auf Open . Es erscheint: Klicken Sie den Button Compile . Objekt erzeugen \u00b6 Klicken Sie dann mit der rechten Maustaste auf das orangene K\u00e4stchen Circle und w\u00e4hlen aus dem Kontextmen\u00fc new Circle () Den Namen circle1 k\u00f6nnen Sie einfach mit Ok best\u00e4tigen. Sie haben soben Ihr erstes Objekt erzeugt! Das orangene K\u00e4stchen, auf das Sie mit der rechten Maus geklickt haben, repr\u00e4sentiert die Klasse Circle . Das rote K\u00e4stchen links unten mit dem Namen circle1 repr\u00e4sentiert ein Objekt dieser Klasse. Konvention: Klassennamen beginnen immer mit Gro\u00dfbuchstaben und Objektnamen immer mit einem kleinen Buchstaben. Methoden aufrufen \u00b6 Klicken Sie nun mit der rechten Maustaste auf das rote K\u00e4stchen circle1 (also auf das Objekt) und w\u00e4hlen dann void makeVisible () aus. Es erscheint: makeVisible() ist eine Methode . Genauer gesagt, handelt es sich um eine Objektmethode . Als wir darauf geklickt haben, haben wir diese Methode aufgerufen . \u00dcbung Methoden aufrufen Rufen Sie (auch mehrmals) die Methoden makeLeft() , makeRight() , makeUp und makeDown() auf. Rufen Sie auch makeInvisible() und dann wieder makeVisible() auf. Methoden erkennen wir an den runden Klammern () hinter dem Namen. In diesen Klammern kann auch ein Wert stehen. Dazu kommen wir jetzt, zu den sogenannten Parametern . Parameter \u00b6 Nun rufen wir die Methode moveHorizontal(int distance) auf. Es erscheint ein Dialog: geben Sie in das Eingabefeld eine Zahl ein, z.B. 50 und klicken OK . Der Kreis bewegt sich horizontal um 50 Bildschirmpunkte nach rechts. Wir \u00fcbergeben dem Methodenaufruf einen Wert (hier: der Wert 50 ). Klicken Sie mit der rechten Maustaste auf das orangene K\u00e4stchen Circle1 (also auf die Klasse Circle ) und w\u00e4hlen Sie Open Editor . Es erscheint: Das Fenster, das sich \u00f6ffnet, ist der sogenannte Editor . Darin sehen wir die Implementierung der Klasse Circle . So sieht ein Java-Programm aus. Wir kommen zu den Details sp\u00e4ter. Zun\u00e4chst suchen wir den folgenden gelb hinterlegten Block (ab Zeile 81 2 ): /** * Move the circle horizontally by 'distance' pixels. */ public void moveHorizontal ( int distance ) { erase (); xPosition += distance ; draw (); } Bei den ersten drei Zeilen /** * Move the circle horizontally by 'distance' pixels. */ handelt es sich um einen Kommentar (genauer gesagt, um einen JavaDoc-Kommentar). Wir kommen bald zu Kommentaren. Jetzt geht es uns zun\u00e4chst nur um diese Zeile: public void moveHorizontal ( int distance ) Dies ist die sogenannte Signatur der Methode moveHorizontal . moveHorizontal ist der Name der Methode und distance ist der Name des Parameters der Methode. Vor dem Namen des Parameters steht ein Datentyp . In diesem Fall ist es der Datentyp int . Datentypen \u00b6 int steht f\u00fcr Integer und bedeutet ganze Zahl (also auch negative Zahlen). Wir werden uns ausgiebig mit Datentypen besch\u00e4ftigen. In dem Beispiel int distance steht der Datentyp int daf\u00fcr, dass wir der Methode moveHorizontal bei dem Aufruf einen ganzzahligen Wert \u00fcbergeben m\u00fcssen. Rufen Sie die Methode moveHorizontal auf und \u00fcbergeben Ihr einen negativen Zahlenwert! Wenn wir uns die Java-Implementierung der Klasse Circle nochmal genauer anschauen, dann sehen wir, dass die Methoden entweder keinen Parameter haben: public Circle () public void makeVisible () public void makeInvisible () public void moveRight () public void moveLeft () public void moveUp () public void moveDown () private void draw () private void erase () , dann muss dem Aufruf der Methode kein Wert \u00fcbergeben werden. Oder die Methode erwartet einen Parameterwert und dieser Wert muss einer ganzen Zahl entsprechen: public void moveHorizontal ( int distance ) public void moveVertical ( int distance ) public void slowMoveHorizontal ( int distance ) public void slowMoveVertical ( int distance ) public void changeSize ( int newDiameter ) Au\u00dferdem gibt es noch eine Methode, die als Parameterwert einen String erwartet. String ist ebenfalls ein Datentyp. Dieser Datentyp steht aber nicht f\u00fcr ganze Zahlen, sondern f\u00fcr Zeichenketten . public void changeColor ( String newColor ) Zeichenketten ( String ) schreiben wir in Java in doppelten Anf\u00fchrungszeichen \"Zeichenkette\" . Rufen Sie die Methode changeColor auf und \u00fcbergeben Sie als Parameterwert \"red\" . Probieren Sie auch die Werte \"yellow\" , \"green\" , \"magenta\" und \"black\" aus. Fragen Was passiert, wenn Sie nur red schreiben? Was passiert, wenn Sie \"pink\" schreiben? Was passiert, wenn Sie \"blau\" schreiben? Was passiert, wenn Sie \"hallo\" schreiben? Mehrere Objekte \u00b6 Von unserer Klasse Circle haben wir bereits ein Objekt circle1 erzeugt. Von einer Klasse lassen sich beliebig viele Objekte erzeugen! Alle diese Objekte haben dieselben Eigenschaften! Das bedeutet, dass all diesen Objekten, die Sie erzeugen, die gleichen Objektmethoden zur Verf\u00fcgung stehen (und auch die gleichen Objektvariablen). Aufgabe Erzeugen Sie f\u00fcnf Objekte von der Klasse Circle . Weisen Sie allen Objekten unterschiedliche Farben zu! Sorgen Sie daf\u00fcr, dass sich die Objekte in der Darstellung nicht \u00fcberdecken! Wie Sie sehen, haben zwar alle Objekte dieselben Eigenschaften (dieselben Objektmethoden und dieselben Objektvariablen). Aber wir k\u00f6nnen ihnen jeweils unterschiedliche Werte zuweisen, so dass einige Circle -Objekte z.B. rot oder blau oder schwarz sind und auch jeweils andere Positionen haben. Wir schauen uns im Folgenden an, dass jedes Objekt einen eigenen Zustand hat. Der Zustand eines Objektes \u00b6 Klicken Sie mit der rechten Maustaste auf ein Objekt und w\u00e4hlen Sie Inspect . Es \u00f6ffnet sich das folgende Fenster: Lassen Sie dieses Inspektionsfenster ge\u00f6ffnet und \u00e4ndern Sie die Farbe des Objektes. Was beobachten Sie im Inspektionsfenster? Das Inspektionsfenster zeigt den Zustand eines Objektes. Der Zustand wird durch die Werte der Objektvariablen beschrieben. Schauen wir uns die Java-Implementierung der Klasse Circle an, dann finden wir in den Zeilen 13-17 folgende Anweisungen: private int diameter ; private int xPosition ; private int yPosition ; private String color ; private boolean isVisible ; Das sind die Objektvariablen der Klasse Circle . Jedes Objekt der Klasse Circle besitzt seine eigenen Objektvariablen. Jede Variable hat einen Wert . Die Variablen diameter , xPosition und yPosition haben als Wert eine ganze Zahl. Diese Zahl gibt z.B. f\u00fcr diameter die Gr\u00f6\u00dfe des Umfanges des Kreises an. Der Wert f\u00fcr xPosition beschreibt den Wert auf der x-Koordinate und der Wert von yPosition beschreibt den Wert auf der y-Koordinate zur Darstellung des Kreises. Der Wert der Objektvariablen color beschreibt die Farbe des Kreises als Zeichenkette ( String ). Die Objektvariable isVisible ist von einem Datentyp, den wir noch nicht kennen: boolean . Diese Variable kann nur zwei verschiedene Werte annehmen: true (sichtbar) oder false (nicht sichtbar). Die Werte der Variablen k\u00f6nnen mithilfe der Objektmethoden ge\u00e4ndert werden. Fragen Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen color zu \u00e4ndern? Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen diameter zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen isVisible zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen xPosition zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen yPosition zu \u00e4ndern? Die Kombination der Werte aller Objektvariablen beschreibt den Zustand eines Objektes. Aufgabe Erzeugen Sie mehrere Objekte der Klasse Circle ! \u00d6ffnen Sie f\u00fcr alle Objekte jeweils das Inspektionsfenster. \u00c4ndern Sie f\u00fcr unterschiedliche Objekte die Werte von Objektvariablen durch Methodenaufrufe und beobachten Sie die jeweiligen Zustands\u00e4nderungen. Zusammenfassung \u00b6 Wir haben viele neue Begriffe kennengelernt: Klassen und Objekte , Methoden , Methodenaufrufe , Parameter , Datentypen ( int , String , boolean ), Objektvariablen , Zustand eines Objektes. Das ist ganz sch\u00f6n viel auf einmal! Diese Begriffe werden wir in den kommenden Wochen verwenden und vertiefen. Zun\u00e4chst zum Abschluss noch eine \"kleine\" Aufgabe zum Entspannen. Zeichnen Sie dieses Bild: Success Wir kennen schon Klassen, Objekte, Objektvariablen, Objektmethoden, Parameter, einige Datentypen, k\u00f6nnen Objekte erzeugen und Objektmethoden aufrufen. Super! In der objektorientierten Programmierung unterscheiden wir sehr genau zwischen Objekten und Werten. Werte sind soetwas wie 4 , true , 5.5 usw. Solche Werte haben kein Verhalten. Objekte haben aber ein Verhalten (die Objektmethoden - siehe z.B. f\u00fcr String die Methoden charAt() , length() , substring() ). Wir werden sehr detailliert auf die Unterschiede zwischen Werten und Objekten eingehen. Die Datentypen, die wir erstellen, sind sogenannte Referenztypen . Eine Variable von so einem Referenztyp zeigt auf (referenziert) ein Objekt. \u21a9 Um sich die Zeilennummern anzeigen zu lassen, \u00f6ffnen Sie das BlueJ -Men\u00fc und w\u00e4hlen Preferences . Unter dem Reiter Editor finden Sie Display line numbers . Setzen Sie dort das H\u00e4kchen. \u21a9","title":"BlueJ"},{"location":"bluej/#bluej","text":"Wir lernen unsere Entwicklungsumgebung kennen, die wir in den ersten Wochen f\u00fcr das Programmieren nutzen werden. Es handelt sich um BlueJ . BlueJ wurde extra f\u00fcr Studierende entwickelt, die Programmieren lernen. Das J in BlueJ steht f\u00fcr Java . Mit BlueJ wird also das Programmieren mit Java gelernt. Eine wesentliche Idee hinter der Entwicklung von BlueJ bestand darin, gleich am Anfang mit der objektorientierten Programmierung zu beginnen, d.h. sich gleich mit Klassen und Objekten zu besch\u00e4ftigen. Das passiert h\u00e4ufig erst recht sp\u00e4t in der Programmierausbildung. Wir geben zun\u00e4chst einen groben \u00dcberblick und lernen dabei in kurzer Zeit viele neue Konzepte und Begriffe kennen. Aber keine Sorge, mit all diesen Konzepten besch\u00e4ftigen wir uns jeweils noch ganz ausf\u00fchrlich.","title":"BlueJ"},{"location":"bluej/#objekte-und-klassen","text":"Wenn wir uns die Welt betrachten, dann besteht diese aus lauter Objekten , die miteinander in Beziehung stehen. Man ganz konkret \u00fcber bestimmte Objekte sprechen: \u201edas ist ein sch\u00f6ner Stuhl\u201c \u201edas ist ein teurer Tisch\u201c \u201edas Auto ist blau\u201c oder ganz allgemein \u00fcber eine Klasse von Objekten: \u201eInformatikerInnen sind Nerds\u201c \u201eComputer machen immer, was sie wollen\u201c \u201edie Bahnen kommen immer zu sp\u00e4t\u201c In der Welt des objektorientierten Programmierens sind die Klassen die \"Muster\" oder die \"Bauanleitungen\" f\u00fcr konkrete Objekte . Mit Klassen beschreiben wir die allgemeinen Eigenschaften, die f\u00fcr alle Objekte dieser Klasse gelten. Klassen beschreiben eine Struktur der Objekte (das sind die sogenannten Objektvariablen ) und ein Verhalten dieser Objekte (das sind die sogenannten Objektmethoden ). Insgesamt sprechen wir bei der Struktur und dem Verhalten von den Eigenschaften einer Klasse. Eine Klasse ist ein Datentyp und jeder \"Wert\" 1 ist ein konkretes Objekt von diesem Typ. Von einer Klasse k\u00f6nnen wir beliebig viele Objekte erzeugen. Objekte werden aus Klassen erzeugt. Eine Klasse beschreibt die Art und Weise, den Aufbau von Objekten. Objekte sind die speziellen Instanzen einer allgemeinen Klasse. Ein typisches Beispiel ist Auto . Ein Auto kann fahren, hat eine Farbe, ist von einer bestimmten Marke, hat einen bestimmten Motor, eine bestimmte Anzahl von T\u00fcren und so weiter. Das sind alles Eigenschaften eines Autos. Diese Eigenschaften werden in einer Klasse definiert und beschreiben ein Auto im Allgemeinen. Davon gibt es dann konkrete Objekte: ein roter VW Golf mit 5 T\u00fcren, ein blauer Toyota mit 3 T\u00fcren usw.","title":"Objekte und Klassen"},{"location":"bluej/#ein-erstes-beispiel-mit-bluej","text":"Wir \u00f6ffnen BlueJ dann im Men\u00fc auf Project --> Open Project . Im examples -Ordner von BlueJ finden wir den Ordner shapes . Wir w\u00e4hlen den Ordner und klicken auf Open . Es erscheint: Klicken Sie den Button Compile .","title":"Ein erstes Beispiel mit BlueJ"},{"location":"bluej/#objekt-erzeugen","text":"Klicken Sie dann mit der rechten Maustaste auf das orangene K\u00e4stchen Circle und w\u00e4hlen aus dem Kontextmen\u00fc new Circle () Den Namen circle1 k\u00f6nnen Sie einfach mit Ok best\u00e4tigen. Sie haben soben Ihr erstes Objekt erzeugt! Das orangene K\u00e4stchen, auf das Sie mit der rechten Maus geklickt haben, repr\u00e4sentiert die Klasse Circle . Das rote K\u00e4stchen links unten mit dem Namen circle1 repr\u00e4sentiert ein Objekt dieser Klasse. Konvention: Klassennamen beginnen immer mit Gro\u00dfbuchstaben und Objektnamen immer mit einem kleinen Buchstaben.","title":"Objekt erzeugen"},{"location":"bluej/#methoden-aufrufen","text":"Klicken Sie nun mit der rechten Maustaste auf das rote K\u00e4stchen circle1 (also auf das Objekt) und w\u00e4hlen dann void makeVisible () aus. Es erscheint: makeVisible() ist eine Methode . Genauer gesagt, handelt es sich um eine Objektmethode . Als wir darauf geklickt haben, haben wir diese Methode aufgerufen . \u00dcbung Methoden aufrufen Rufen Sie (auch mehrmals) die Methoden makeLeft() , makeRight() , makeUp und makeDown() auf. Rufen Sie auch makeInvisible() und dann wieder makeVisible() auf. Methoden erkennen wir an den runden Klammern () hinter dem Namen. In diesen Klammern kann auch ein Wert stehen. Dazu kommen wir jetzt, zu den sogenannten Parametern .","title":"Methoden aufrufen"},{"location":"bluej/#parameter","text":"Nun rufen wir die Methode moveHorizontal(int distance) auf. Es erscheint ein Dialog: geben Sie in das Eingabefeld eine Zahl ein, z.B. 50 und klicken OK . Der Kreis bewegt sich horizontal um 50 Bildschirmpunkte nach rechts. Wir \u00fcbergeben dem Methodenaufruf einen Wert (hier: der Wert 50 ). Klicken Sie mit der rechten Maustaste auf das orangene K\u00e4stchen Circle1 (also auf die Klasse Circle ) und w\u00e4hlen Sie Open Editor . Es erscheint: Das Fenster, das sich \u00f6ffnet, ist der sogenannte Editor . Darin sehen wir die Implementierung der Klasse Circle . So sieht ein Java-Programm aus. Wir kommen zu den Details sp\u00e4ter. Zun\u00e4chst suchen wir den folgenden gelb hinterlegten Block (ab Zeile 81 2 ): /** * Move the circle horizontally by 'distance' pixels. */ public void moveHorizontal ( int distance ) { erase (); xPosition += distance ; draw (); } Bei den ersten drei Zeilen /** * Move the circle horizontally by 'distance' pixels. */ handelt es sich um einen Kommentar (genauer gesagt, um einen JavaDoc-Kommentar). Wir kommen bald zu Kommentaren. Jetzt geht es uns zun\u00e4chst nur um diese Zeile: public void moveHorizontal ( int distance ) Dies ist die sogenannte Signatur der Methode moveHorizontal . moveHorizontal ist der Name der Methode und distance ist der Name des Parameters der Methode. Vor dem Namen des Parameters steht ein Datentyp . In diesem Fall ist es der Datentyp int .","title":"Parameter"},{"location":"bluej/#datentypen","text":"int steht f\u00fcr Integer und bedeutet ganze Zahl (also auch negative Zahlen). Wir werden uns ausgiebig mit Datentypen besch\u00e4ftigen. In dem Beispiel int distance steht der Datentyp int daf\u00fcr, dass wir der Methode moveHorizontal bei dem Aufruf einen ganzzahligen Wert \u00fcbergeben m\u00fcssen. Rufen Sie die Methode moveHorizontal auf und \u00fcbergeben Ihr einen negativen Zahlenwert! Wenn wir uns die Java-Implementierung der Klasse Circle nochmal genauer anschauen, dann sehen wir, dass die Methoden entweder keinen Parameter haben: public Circle () public void makeVisible () public void makeInvisible () public void moveRight () public void moveLeft () public void moveUp () public void moveDown () private void draw () private void erase () , dann muss dem Aufruf der Methode kein Wert \u00fcbergeben werden. Oder die Methode erwartet einen Parameterwert und dieser Wert muss einer ganzen Zahl entsprechen: public void moveHorizontal ( int distance ) public void moveVertical ( int distance ) public void slowMoveHorizontal ( int distance ) public void slowMoveVertical ( int distance ) public void changeSize ( int newDiameter ) Au\u00dferdem gibt es noch eine Methode, die als Parameterwert einen String erwartet. String ist ebenfalls ein Datentyp. Dieser Datentyp steht aber nicht f\u00fcr ganze Zahlen, sondern f\u00fcr Zeichenketten . public void changeColor ( String newColor ) Zeichenketten ( String ) schreiben wir in Java in doppelten Anf\u00fchrungszeichen \"Zeichenkette\" . Rufen Sie die Methode changeColor auf und \u00fcbergeben Sie als Parameterwert \"red\" . Probieren Sie auch die Werte \"yellow\" , \"green\" , \"magenta\" und \"black\" aus. Fragen Was passiert, wenn Sie nur red schreiben? Was passiert, wenn Sie \"pink\" schreiben? Was passiert, wenn Sie \"blau\" schreiben? Was passiert, wenn Sie \"hallo\" schreiben?","title":"Datentypen"},{"location":"bluej/#mehrere-objekte","text":"Von unserer Klasse Circle haben wir bereits ein Objekt circle1 erzeugt. Von einer Klasse lassen sich beliebig viele Objekte erzeugen! Alle diese Objekte haben dieselben Eigenschaften! Das bedeutet, dass all diesen Objekten, die Sie erzeugen, die gleichen Objektmethoden zur Verf\u00fcgung stehen (und auch die gleichen Objektvariablen). Aufgabe Erzeugen Sie f\u00fcnf Objekte von der Klasse Circle . Weisen Sie allen Objekten unterschiedliche Farben zu! Sorgen Sie daf\u00fcr, dass sich die Objekte in der Darstellung nicht \u00fcberdecken! Wie Sie sehen, haben zwar alle Objekte dieselben Eigenschaften (dieselben Objektmethoden und dieselben Objektvariablen). Aber wir k\u00f6nnen ihnen jeweils unterschiedliche Werte zuweisen, so dass einige Circle -Objekte z.B. rot oder blau oder schwarz sind und auch jeweils andere Positionen haben. Wir schauen uns im Folgenden an, dass jedes Objekt einen eigenen Zustand hat.","title":"Mehrere Objekte"},{"location":"bluej/#der-zustand-eines-objektes","text":"Klicken Sie mit der rechten Maustaste auf ein Objekt und w\u00e4hlen Sie Inspect . Es \u00f6ffnet sich das folgende Fenster: Lassen Sie dieses Inspektionsfenster ge\u00f6ffnet und \u00e4ndern Sie die Farbe des Objektes. Was beobachten Sie im Inspektionsfenster? Das Inspektionsfenster zeigt den Zustand eines Objektes. Der Zustand wird durch die Werte der Objektvariablen beschrieben. Schauen wir uns die Java-Implementierung der Klasse Circle an, dann finden wir in den Zeilen 13-17 folgende Anweisungen: private int diameter ; private int xPosition ; private int yPosition ; private String color ; private boolean isVisible ; Das sind die Objektvariablen der Klasse Circle . Jedes Objekt der Klasse Circle besitzt seine eigenen Objektvariablen. Jede Variable hat einen Wert . Die Variablen diameter , xPosition und yPosition haben als Wert eine ganze Zahl. Diese Zahl gibt z.B. f\u00fcr diameter die Gr\u00f6\u00dfe des Umfanges des Kreises an. Der Wert f\u00fcr xPosition beschreibt den Wert auf der x-Koordinate und der Wert von yPosition beschreibt den Wert auf der y-Koordinate zur Darstellung des Kreises. Der Wert der Objektvariablen color beschreibt die Farbe des Kreises als Zeichenkette ( String ). Die Objektvariable isVisible ist von einem Datentyp, den wir noch nicht kennen: boolean . Diese Variable kann nur zwei verschiedene Werte annehmen: true (sichtbar) oder false (nicht sichtbar). Die Werte der Variablen k\u00f6nnen mithilfe der Objektmethoden ge\u00e4ndert werden. Fragen Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen color zu \u00e4ndern? Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen diameter zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen isVisible zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen xPosition zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen yPosition zu \u00e4ndern? Die Kombination der Werte aller Objektvariablen beschreibt den Zustand eines Objektes. Aufgabe Erzeugen Sie mehrere Objekte der Klasse Circle ! \u00d6ffnen Sie f\u00fcr alle Objekte jeweils das Inspektionsfenster. \u00c4ndern Sie f\u00fcr unterschiedliche Objekte die Werte von Objektvariablen durch Methodenaufrufe und beobachten Sie die jeweiligen Zustands\u00e4nderungen.","title":"Der Zustand eines Objektes"},{"location":"bluej/#zusammenfassung","text":"Wir haben viele neue Begriffe kennengelernt: Klassen und Objekte , Methoden , Methodenaufrufe , Parameter , Datentypen ( int , String , boolean ), Objektvariablen , Zustand eines Objektes. Das ist ganz sch\u00f6n viel auf einmal! Diese Begriffe werden wir in den kommenden Wochen verwenden und vertiefen. Zun\u00e4chst zum Abschluss noch eine \"kleine\" Aufgabe zum Entspannen. Zeichnen Sie dieses Bild: Success Wir kennen schon Klassen, Objekte, Objektvariablen, Objektmethoden, Parameter, einige Datentypen, k\u00f6nnen Objekte erzeugen und Objektmethoden aufrufen. Super! In der objektorientierten Programmierung unterscheiden wir sehr genau zwischen Objekten und Werten. Werte sind soetwas wie 4 , true , 5.5 usw. Solche Werte haben kein Verhalten. Objekte haben aber ein Verhalten (die Objektmethoden - siehe z.B. f\u00fcr String die Methoden charAt() , length() , substring() ). Wir werden sehr detailliert auf die Unterschiede zwischen Werten und Objekten eingehen. Die Datentypen, die wir erstellen, sind sogenannte Referenztypen . Eine Variable von so einem Referenztyp zeigt auf (referenziert) ein Objekt. \u21a9 Um sich die Zeilennummern anzeigen zu lassen, \u00f6ffnen Sie das BlueJ -Men\u00fc und w\u00e4hlen Preferences . Unter dem Reiter Editor finden Sie Display line numbers . Setzen Sie dort das H\u00e4kchen. \u21a9","title":"Zusammenfassung"},{"location":"start/","text":"Was ist Programmieren? \u00b6 Zun\u00e4chst ein bisschen Motivation: 10 Gr\u00fcnde, Programmieren zu lernen und Bericht einer ehemaligen FIW-Studentin . Ehe wir uns weiter mit Java und Programmierkonzepten besch\u00e4ftigen, wollen wir uns bewusst werden, was Programmieren \u00fcberhaupt ist. Prinzipiell l\u00f6sen wir beim Programmieren ein Problem mithilfe einer Programmiersprache. Dabei stellt sich die Frage, welche Probleme mithilfe eines Computers l\u00f6sbar sind und welche nicht. Dazu gibt es umfangreiche theoretische Untersuchungen - viele davon werden Sie in den \"Grundlegenden Konzepten der Informatik\" diskutieren. Ein wesentlicher Begriff dabei ist Algorithmus . Ein Algorithmus ist eine eindeutige Handlungsvorschrift, die aus endlich vielen einzelnen Schritten besteht und ein Problem l\u00f6st. Algorithmen sind also auch Kochrezepte oder Bauanleitungen, wenn sie denn \"eindeutig\" sind. Wir kennen alle das Problem, dass Handlungsanweisungen nicht immer eindeutig sind - man kann es manchmal so oder so machen. In der Programmierung darf eine solche Mehrdeutigkeit nat\u00fcrlich nicht vorkommen. Der Algorithmusbegriff wurde deshalb detailliert und folgende Eigenschaften m\u00fcssen f\u00fcr eine Handlungsanweisung f\u00fcr einen Computer gelten, um ein Algorithmus zu sein: Finitheit Das Verfahren muss in einem endlichen Text (Programm) eindeutig beschreibbar sein. Ausf\u00fchrbarkeit Jeder einzelne Schritt des Verfahrens muss auch tats\u00e4chlich ausf\u00fchrbar sein. Dynamische Finitheit Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz ben\u00f6tigen. Terminierung Das Verfahren muss irgendwann enden, d.h. darf nur endlich viele Ausf\u00fchrungsschritte ben\u00f6tigen. Determiniertheit Das Verfahren muss bei denselben Voraussetzungen das gleiche Ergebnis liefern. Determinismus Die n\u00e4chste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt (in jedem Zustand) eindeutig definiert. Beispiel: Euklidischer Algorithmus \u00b6 Mit dem euklidischen Algorithmus 1 kann der gr\u00f6\u00dfte gemeinsame Teiler (ggT) zweier Zahlen berechnet werden. In seinen Elementen hat Euklid diesen Algorithmus ungef\u00e4hr so formuliert: Euklidischer Algorithmus Wenn CD aber AB nicht misst, und man nimmt bei AB, CD abwechselnd immer das kleinere vom gr\u00f6\u00dferen weg, dann muss (schlie\u00dflich) eine Zahl \u00fcbrig bleiben, die die vorangehende misst. Hm, das ist recht schwierig zu verstehen. Euklid betrachtet die beiden Zahlen, von denen der gr\u00f6\u00dfte gemeinsame Teiler ermittelt werden soll, als Strecken ( AB und CD ). Er zieht wiederholt die kleinere der beiden Strecken von der gr\u00f6\u00dferen ab. Er wiederholt dies solange, bis die beiden Strecken gleich lang sind - genauer: er wiederholt dies solange, solange die beiden Strecken nicht gleich lang sind ( ... CD aber AB nicht misst... ). Beispiel: ggT von 24 und 40 AB: 40, CD: 24, AB gr\u00f6\u00dfer als CD \u2192 40 - 24 = 16 AB: 16, CD: 24, CD gr\u00f6\u00dfer als AB \u2192 24 - 16 = 8 AB: 16, CD: 8, AB gr\u00f6\u00dfer als CD \u2192 16 - 8 = 8 AB: 8, CD: 8, AB gleich CD \u2192 Ende \u2192 ggT ist 8 Wir versuchen, den Algorithmus in eine verst\u00e4ndlichere und genauere Sprache zu \u00fcberf\u00fchren, ohne bereits eine Programmiersprache zu verwenden. Wir benutzen sogenannten Pseudocode : Angenommen, die beiden Zahlen, von denen wir den ggT berechnen wollen, sind a und b : 1 2 3 4 5 6 7 solange a ungleich b ist, wiederhole wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu wenn a gleich b ist, dann: a ( oder auch b ) ist der gesuchte ggT Wichtig ist, dass das Einr\u00fccken hier eine Bedeutung hat (eine Semantik ). In Zeile 1 formulieren wir, dass sich etwas wiederholen soll, solange eine bestimmte Bedingung gilt. Das, was sich wiederholen soll, ist in den Zeilen 2 bis 5 formuliert. Zeile 1 formuliert eine Schleife und in den Zeilen 2 - 5 befindet sich der Schleifeninhalt . Die Zeilen 2 - 5 formulieren ein eigenes Konstrukt, n\u00e4mlich eine Auswahl zwischen Alternativen, abh\u00e4ngig von einer Bedingung. Die Bedingung ist, ob a gr\u00f6\u00dfer ist als b . Wenn das der Fall ist, dann wird die Alternative ziehe b von a ab und weise das Ergebnis a zu ausgef\u00fchrt (In der Programmierung werden das sp\u00e4ter als a = a - b schreiben - das sieht f\u00fcr uns jetzt noch sehr \"falsch\" aus). Ist jedoch a nicht gr\u00f6\u00dfer als b , dann wird die Alternative ziehe a von b ab und weise das Ergebnis b zu ( b = b - a ) ausgef\u00fchrt. Ein solches Konstrukt wird Selektion (oder auch bedingte Alternative ) genannt. Nachdem entweder Zeile 3 oder Zeile 5 ausgef\u00fchrt wurde (es wird genau eins von beiden ausgef\u00fchrt), wird erneut in Zeile 1 gepr\u00fcft, ob a ungleich b ist. Wenn ja, wird die Selektion wiederholt. Wenn nicht, dann ist die Schleife beendet und Zeile 6 wird ausgef\u00fchrt. Die in Zeile 6 formulierte Bedingung wenn a gleich b ist , ist eigentlich unn\u00f6tig. Frage Warum ist die Bedingung wenn a gleich b ist in Zeile 6 unn\u00f6tig? Wir betrachten nochmals die im obigen Algorithmus betrachteten Konstrukte (wir sprechen vom Kontrollfluss von Anweisungen ): Iteration : die Schleife, die in Zeile 1 formuliert wird und die als Schleifeninhalt die Zeilen 2 - 5 hat, beschreibt einen iterativen (sich wiederholenden) Kontrollfluss . Selektion : die bedingte Alternative , die eine Bedingung pr\u00fcft (Zeile 2 ) und dann, je nachdem, ob die Bedingung richtig oder falsch ist, jeweils eine alternative Anweisung ausf\u00fchrt (entweder Zeile 3 oder Zeile 4 ), wird Selektion genannt (siehe Zeilen 2 - 5 ). Sequenz : die Anweisungen werden hintereinander ausgef\u00fchrt, erst Zeile 1 , dann Zeile 2 , dann entweder Zeile 3 oder Zeile 4 usw. Das Hintereinanderausf\u00fchren von Anweisungen wird Sequenz genannt. Schauen wir uns f\u00fcr unseren Algorithmus nochmal die Eigenschaften eines Algorithmus an: Finitheit unsere Beschreibung des Algorithmus ist endlich (siehe oben). Ausf\u00fchrbarkeit jeder einzelne Schritt kann ausgef\u00fchrt werden. Dynamische Finitheit \u00fcber den Speicherplatz k\u00f6nnen wir noch nicht viel sagen, aber wir m\u00fcssen nur einige wenige Zahlen speichern. Das sollte klappen. Terminierung Wann endet unser Algorithmus? Was muss gelten? Wissen wir, ob der Algorithmus irgendwann stoppt? Determiniertheit Es ist sicherlich nicht so leicht zu sehen, ob bei gleicher Eingabe (die Zahlen a und b ) auch stets der gleiche gr\u00f6\u00dfte gemneinsame Teiler berechnet wird. Dazu m\u00fcssten wir uns erstmal \u00fcberlegen, wie wir das pr\u00fcfen k\u00f6nnen. Determinismus Wir werden unseren Algorithmus nochmal an einem Beispiel durchspielen , um ein Gef\u00fchl daf\u00fcr zu bekommen, dass wir stets wissen, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Beispielzahlen f\u00fcr den euklidischen Algorithmus \u00b6 Wir nehmen die Zahlen a=40 und b=24 und spielen damit unseren Algorithmus durch: Zeile 1 : a (40) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von a-b ist 16. Der neue Wert von a ist 16. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist nicht gr\u00f6\u00dfer als b , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von b-a ist 8. Der neue Wert von b ist 8. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (8) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeile 5 ) Zeile 3 : das Ergebnis von a-b ist 8. Der neue Wert von a ist 8. Zeile 1 : wegen wiederhole (Iteration): a (8) ist nicht ungleich b (8) , also wird der Schleifeninhalt nicht ausgef\u00fchrt Zeile 6 : a (8) ist gleich b (8) Zeile 7 : der gesuchte ggT ist 8 Ende F\u00fcr dieses Beispiel war stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe a=40 und b=24 stets 8 ist. Fragen Was \u00e4ndert sich, wenn am Anfang a=24 und b=40 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=0 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=24 und b=24 sind? Beispiel: (3n+1)-Vermutung (Collatz-Problem) \u00b6 Wir betrachten noch einen weiteren Algorithmus: Als Eingabe bekommen wir eine positive nat\u00fcrliche Zahl, z.B. 5 . Der Algorithmus berechnet eine Folge von Zahlen und zwar nach folgender Vorschrift: ist die Zahl ungerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl mit 3 multipliziert und dann 1 addiert wird. Ist die Zahl gerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl durch 2 geteilt wird. Der Algorithmus stoppt, wenn der Nachfolger 1 ist. Angenommen, die eingegebene positive nat\u00fcrliche Zahl ist n : 1 2 3 4 5 solange n ungleich 1 ist, wiederhole wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Wir begeben uns also in eine Schleife und berechnen so lange einen Nachfolger f\u00fcr die Zahl bis der NAchfolger 1 ist. Betrachten wir den Algorithmus f\u00fcr die EIngabe von n=5 : Zeile 1 : n (5) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist ungerade , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von 3*5+1 ist 16 . Der neue Wert von n ist 16. Zeile 1 : wegen wiederhole (Iteration): n (16) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 16/2 ist 8 . Der neue Wert von n ist 8. Zeile 1 : wegen wiederhole (Iteration): n (8) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 8/2 ist 4 . Der neue Wert von n ist 4. Zeile 1 : wegen wiederhole (Iteration): n (4) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 4/2 ist 2 . Der neue Wert von n ist 2. Zeile 1 : wegen wiederhole (Iteration): n (2) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 2/2 ist 1 . Der neue Wert von n ist 1. Zeile 1 : wegen wiederhole (Iteration): n (1) ist nicht ungleich 1 , also wird der Schleifeninhalt nicht ausgef\u00fchrt Ende Auch f\u00fcr dieses Beispiel war erneut stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die Eingabe n=5 stets 1 ist. Fragen Spielen Sie den Algorithmus ruhig einmal f\u00fcr n=7 durch oder auch f\u00fcr andere n Denken Sie, dass der Algorithmus f\u00fcr jede beliebige positive nat\u00fcrliche Zahl n terminiert? Wenn ein Algorithmus f\u00fcr eine konkrete Eingabe stets ein eindeutiges Ergebnis (und zwar immer das gleiche) liefert, wie k\u00f6nnen dann Zufallszahlen berechnet werden? Success Wir haben ein Verst\u00e4ndnis \u00fcber den Algorithmus -Begriff erlangt und wissen, was Finitheit , Determiniertheit , Determinismus und Terminierung bedeuten. Programmablaufstrukturen \u00b6 Interessanterweise gibt es nur drei verschiedene Ablaufstrukturen in Programmen bzw. Algorithmen. Alle drei haben wir bereits verwendet. Mit Ablaufstrukturen meinen wir die Abarbeitungsreihenfolge von Anweisungen. Man sagt auch Kontrollfluss dazu. Die drei Ablaufstrukturen, die es gibt, sind: die Sequenz : die Anweisungen werden in sequenzieller Abfolge, d.h. hintereinander ausgef\u00fchrt die Iteration : die Abl\u00e4ufe werden wiederholt ausgef\u00fchrt, also in einer Schleife die Selektion : die Abl\u00e4ufe werden selektiv , d.h. unter einer bestimmten Bedingung ausgef\u00fchrt. Man nennt diese Struktur auch Verzweigung oder bedingte Alternative Wir schauen uns alle drei Kontrollstrukturen einmal genauer an. Die Sequenz \u00b6 Bei der Sequenz handelt es sich einfach um hintereinander ausgef\u00fchrte Anweisungen. Es wird stets erst die eine Anweisung vollst\u00e4ndig abgearbeitet, ehe die andere begonnen wird. Sequenz von 3 Anweisungen Anweisung1 Anweisung2 Anweisung3 Ein Beispiel (mit 2 Anweisungen) w\u00e4re: berechne 3 *n und weise das Ergebnis n zu berechne n+1 und weise das Ergebnis n zu Zur Visualisierung von Kontrollstrukturen werden auch sogannnte Programmablaufdiagramme oder Programmablaufpl\u00e4ne verwendet. F\u00fcr eine Sequenz s\u00e4he ein solches Ablaufdiagramm so aus: So ein Diagramm wird von oben nach unten gelesen. Es wird also erst Anweisung1 ausgef\u00fchrt, dann Anweisung2 und zuletzt Anweisung3 . Innerhalb einer Sequenz gilt immer single entry / single exit , d.h. keine der Anweisungen innerhalb einer Sequenz kann mehrere Ausg\u00e4nge oder mehrere Eing\u00e4nge haben. Es w\u00e4re ansonsten nicht-deterministisch und somit ein Versto\u00df gegen unseren Algorithmusbegriff. Die Iteration \u00b6 Bei der Iteration handelt es sich um eine wiederholte Ausf\u00fchrung einer Anweisung bzw. einer Sequenz von Anweisungen. Wie oft eine Iteration ausgef\u00fchrt wird, h\u00e4ngt von einer Bedingung ab. In der Programmierung sprechen wir bei der Iteration auch von einer Schleife . Bedingungen f\u00fcr eine solche Schleife haben wir bereits kennengelernt: solange a ungleich b ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt bzw. solange n ungleich 1 ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt Wichtig ist, dass es auch hier eine strikte Reihenfolge der Abarbeitung der Anweisungen gibt: es wird zun\u00e4chst gepr\u00fcft, ob die Bedingung erf\u00fcllt (wahr) ist, also ob z.B. a ungleich b ist oder ob n ungleich 1 . Wenn diese Bedingung erf\u00fcllt (also wahr) ist, dann werden die Anweisung(en) innerhalb der Schleife nacheinander (sequenziell) abgearbeitet. Erst wenn alle Anweisungen innerhalb der Schleife abgearbeitet wurden, wird die Schleifenbedingung erneut gepr\u00fcft. Ist sie wieder wahr, werden die Anweisungen innerhalb der Schleife erneut abgearbeitet usw. Ist sie nicht wahr, also wenn z.B. a gleich b ist oder n gleich 1 ist , dann wird die Schleife beendet und die Anweisungen innerhalb der Schleife nicht (erneut) abgearbeitet. Das Ablaufdiagramm einer Schleife (Iteration) sieht so aus: Die eigentliche Iteration ist gr\u00fcn dargestellt. Wir kommen von einer anderen Anweisung und pr\u00fcfen die Bedingung. Ist sie wahr, wird Anweisung1 ausgef\u00fchrt. Beachte Anweisung1 muss nicht zwingend nur genau eine Anweisung sein. Bei Anweisung1 kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder sogar selbst um eine Iteration (Schleife in der Schleife - verschachtelte Schleife) handeln! Nach jeder Ausf\u00fchrung von Anweisung1 wird die Bedingung erneut gepr\u00fcft. Ist sie (immernoch) wahr, wird Anweisung1 erneut ausgef\u00fchrt. Ist die Bedingung jedoch falsch, dann wird Anweisung1 nicht (mehr) ausgef\u00fchrt, sondern die Schleife wird verlassen und die Anweisung, die der Schleife folgt, wird ausgef\u00fchrt ( Anweisung2 ) oder das Programm ist dann zu Ende. Beachte Es kann sein, dass Anweisung1 gar nicht ausgef\u00fchrt wird, weil die Bedingung bereits bei der ersten Pr\u00fcfung falsch ist. Es ist also nicht gesagt, dass sich eine Iteration wirklich wiederholt . Es kann sein, dass Anweisung1 gar nicht oder nur genau ein Mal ausgef\u00fchrt wird (wenn die Bedingung nach der ersten Ausf\u00fchrung falsch ist). Das ist kein Problem! Ein Problem ist es jedoch, wenn die Bedingung niemals falsch wird und die Schleife unendlich oft hintereinander ausgef\u00fchrt wird. Das ist ein Versto\u00df gegen die Terminierung eines Algorithmus. In einem solchen Fall werden wir irgendwann einen Fehler bei der Programmausf\u00fchrung erhalten (aber erst zur Ausf\u00fchrungszeit, nicht bereits beim Compilieren). Wir werden uns ausf\u00fchrlich mit Schleifen auseinandersetzen, da sie logisch recht anspruchsvoll und dadurch h\u00e4ufig fehleranf\u00e4llig sein k\u00f6nnen. Die Selektion \u00b6 Bei der Selektion handelt es sich, im Gegensatz zur Iteration, um eine einmalige Ausf\u00fchrung einer (oder mehrerer) Anweisung(en). Jedoch ist diese Ausf\u00fchrung, im Gegensatz zur Sequenz, von einer Bedingung abh\u00e4ngig. Wir hatten eine solche Selektion jeweils in obigen Beispielalgorithmen. Selektion aus dem euklidischen Algorithmus: wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu Selektion aus der (3n+1)-Vermutung (dem Collatz-Problem): wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Es gibt also immer eine Bedingung (z.B. wenn a gr\u00f6\u00dfer ist als b ) und abh\u00e4ngig vom Wert dieser Bedingung (wahr oder falsch), wird entweder die eine Anweisung (z.B. ziehe b von a ab und weise das Ergebnis a zu ) oder die andere (z.B. ziehe a von b ab und weise das Ergebnis b zu ) ausgef\u00fchrt. Das Ablaufdiagramm einer Selektion sieht so aus: Beachte Anweisung1 und auch Anweisung2 m\u00fcssen nicht zwingend jeweils nur genau eine Anweisung sein. Bei beiden kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder um eine Iteration handeln! Verschachteln von Kontrollstrukturen \u00b6 Mehr als diese drei genannten Kontrollstrukturen gibt es nicht. Aber diese Kontrollstrukturen k\u00f6nnen beliebig ineinander verschachtelt werden. \u00dcberall dort, wo eine Anweisung steht (z.B. Anweisung1 ) kann auch eine komplette Kontrollstruktur eingesetzt werden, also eine Sequenz von Anweisungen oder eine Iteration oder eine Selektion. Die kann dann beliebig fortgef\u00fchrt werden. So entstehen komplexe Strukturen - und somit komplexe Programme. Ein (immernoch recht einfaches) Beispiel f\u00fcr eine etwas komplexere Struktur: \u00dcbung Programmablaufpl\u00e4ne Erstellen Sie sowohl f\u00fcr den euklidischen Algorithmus als auch f\u00fcr die (3n+1)-Vermutung einen Programmablaufplan! \u00dcbung Algorithmus und Programmablaufplan Ein Jahr ist ein Schaltjahr, wenn es sich durch 4 teilen l\u00e4sst. Au\u00dfer, es l\u00e4sst sich durch 100 teilen. Dann ist es doch kein Schaltjahr. Au\u00dfer, es l\u00e4sst sich durch 400 teilen. Dann ist es doch ein Schaltjahr. Beschreiben Sie diese Vorschrift als einen Algorithmus in der Form, in der auch der euklidische Algorithmus und die (3n+1)-Vermutung beschrieben wurden. Erstellen Sie dann den dazugeh\u00f6rigen Programmablaufplan. Success Wir wissen nun, dass es nur drei verschiedene Programmablaufstrukturen gibt: die Sequenz, die Iteration und die Selektion. Wir haben ein Verst\u00e4ndnis davon, was die drei Programmablaufstrukturen ausmacht, welchen Zweck sie haben und was sie voneinander unterscheidet. Wir wissen, dass sich diese Strukturen beliebig ineinander verschachteln lassen. Benannt nach Euklid von Alexandria, einem Mathematiker aus dem 3. Jahrhundert, Autor der Elemente - einem Kompendium des Wissens der Mathematik seiner Zeit. \u21a9","title":"Start"},{"location":"start/#was-ist-programmieren","text":"Zun\u00e4chst ein bisschen Motivation: 10 Gr\u00fcnde, Programmieren zu lernen und Bericht einer ehemaligen FIW-Studentin . Ehe wir uns weiter mit Java und Programmierkonzepten besch\u00e4ftigen, wollen wir uns bewusst werden, was Programmieren \u00fcberhaupt ist. Prinzipiell l\u00f6sen wir beim Programmieren ein Problem mithilfe einer Programmiersprache. Dabei stellt sich die Frage, welche Probleme mithilfe eines Computers l\u00f6sbar sind und welche nicht. Dazu gibt es umfangreiche theoretische Untersuchungen - viele davon werden Sie in den \"Grundlegenden Konzepten der Informatik\" diskutieren. Ein wesentlicher Begriff dabei ist Algorithmus . Ein Algorithmus ist eine eindeutige Handlungsvorschrift, die aus endlich vielen einzelnen Schritten besteht und ein Problem l\u00f6st. Algorithmen sind also auch Kochrezepte oder Bauanleitungen, wenn sie denn \"eindeutig\" sind. Wir kennen alle das Problem, dass Handlungsanweisungen nicht immer eindeutig sind - man kann es manchmal so oder so machen. In der Programmierung darf eine solche Mehrdeutigkeit nat\u00fcrlich nicht vorkommen. Der Algorithmusbegriff wurde deshalb detailliert und folgende Eigenschaften m\u00fcssen f\u00fcr eine Handlungsanweisung f\u00fcr einen Computer gelten, um ein Algorithmus zu sein: Finitheit Das Verfahren muss in einem endlichen Text (Programm) eindeutig beschreibbar sein. Ausf\u00fchrbarkeit Jeder einzelne Schritt des Verfahrens muss auch tats\u00e4chlich ausf\u00fchrbar sein. Dynamische Finitheit Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz ben\u00f6tigen. Terminierung Das Verfahren muss irgendwann enden, d.h. darf nur endlich viele Ausf\u00fchrungsschritte ben\u00f6tigen. Determiniertheit Das Verfahren muss bei denselben Voraussetzungen das gleiche Ergebnis liefern. Determinismus Die n\u00e4chste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt (in jedem Zustand) eindeutig definiert.","title":"Was ist Programmieren?"},{"location":"start/#beispiel-euklidischer-algorithmus","text":"Mit dem euklidischen Algorithmus 1 kann der gr\u00f6\u00dfte gemeinsame Teiler (ggT) zweier Zahlen berechnet werden. In seinen Elementen hat Euklid diesen Algorithmus ungef\u00e4hr so formuliert: Euklidischer Algorithmus Wenn CD aber AB nicht misst, und man nimmt bei AB, CD abwechselnd immer das kleinere vom gr\u00f6\u00dferen weg, dann muss (schlie\u00dflich) eine Zahl \u00fcbrig bleiben, die die vorangehende misst. Hm, das ist recht schwierig zu verstehen. Euklid betrachtet die beiden Zahlen, von denen der gr\u00f6\u00dfte gemeinsame Teiler ermittelt werden soll, als Strecken ( AB und CD ). Er zieht wiederholt die kleinere der beiden Strecken von der gr\u00f6\u00dferen ab. Er wiederholt dies solange, bis die beiden Strecken gleich lang sind - genauer: er wiederholt dies solange, solange die beiden Strecken nicht gleich lang sind ( ... CD aber AB nicht misst... ). Beispiel: ggT von 24 und 40 AB: 40, CD: 24, AB gr\u00f6\u00dfer als CD \u2192 40 - 24 = 16 AB: 16, CD: 24, CD gr\u00f6\u00dfer als AB \u2192 24 - 16 = 8 AB: 16, CD: 8, AB gr\u00f6\u00dfer als CD \u2192 16 - 8 = 8 AB: 8, CD: 8, AB gleich CD \u2192 Ende \u2192 ggT ist 8 Wir versuchen, den Algorithmus in eine verst\u00e4ndlichere und genauere Sprache zu \u00fcberf\u00fchren, ohne bereits eine Programmiersprache zu verwenden. Wir benutzen sogenannten Pseudocode : Angenommen, die beiden Zahlen, von denen wir den ggT berechnen wollen, sind a und b : 1 2 3 4 5 6 7 solange a ungleich b ist, wiederhole wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu wenn a gleich b ist, dann: a ( oder auch b ) ist der gesuchte ggT Wichtig ist, dass das Einr\u00fccken hier eine Bedeutung hat (eine Semantik ). In Zeile 1 formulieren wir, dass sich etwas wiederholen soll, solange eine bestimmte Bedingung gilt. Das, was sich wiederholen soll, ist in den Zeilen 2 bis 5 formuliert. Zeile 1 formuliert eine Schleife und in den Zeilen 2 - 5 befindet sich der Schleifeninhalt . Die Zeilen 2 - 5 formulieren ein eigenes Konstrukt, n\u00e4mlich eine Auswahl zwischen Alternativen, abh\u00e4ngig von einer Bedingung. Die Bedingung ist, ob a gr\u00f6\u00dfer ist als b . Wenn das der Fall ist, dann wird die Alternative ziehe b von a ab und weise das Ergebnis a zu ausgef\u00fchrt (In der Programmierung werden das sp\u00e4ter als a = a - b schreiben - das sieht f\u00fcr uns jetzt noch sehr \"falsch\" aus). Ist jedoch a nicht gr\u00f6\u00dfer als b , dann wird die Alternative ziehe a von b ab und weise das Ergebnis b zu ( b = b - a ) ausgef\u00fchrt. Ein solches Konstrukt wird Selektion (oder auch bedingte Alternative ) genannt. Nachdem entweder Zeile 3 oder Zeile 5 ausgef\u00fchrt wurde (es wird genau eins von beiden ausgef\u00fchrt), wird erneut in Zeile 1 gepr\u00fcft, ob a ungleich b ist. Wenn ja, wird die Selektion wiederholt. Wenn nicht, dann ist die Schleife beendet und Zeile 6 wird ausgef\u00fchrt. Die in Zeile 6 formulierte Bedingung wenn a gleich b ist , ist eigentlich unn\u00f6tig. Frage Warum ist die Bedingung wenn a gleich b ist in Zeile 6 unn\u00f6tig? Wir betrachten nochmals die im obigen Algorithmus betrachteten Konstrukte (wir sprechen vom Kontrollfluss von Anweisungen ): Iteration : die Schleife, die in Zeile 1 formuliert wird und die als Schleifeninhalt die Zeilen 2 - 5 hat, beschreibt einen iterativen (sich wiederholenden) Kontrollfluss . Selektion : die bedingte Alternative , die eine Bedingung pr\u00fcft (Zeile 2 ) und dann, je nachdem, ob die Bedingung richtig oder falsch ist, jeweils eine alternative Anweisung ausf\u00fchrt (entweder Zeile 3 oder Zeile 4 ), wird Selektion genannt (siehe Zeilen 2 - 5 ). Sequenz : die Anweisungen werden hintereinander ausgef\u00fchrt, erst Zeile 1 , dann Zeile 2 , dann entweder Zeile 3 oder Zeile 4 usw. Das Hintereinanderausf\u00fchren von Anweisungen wird Sequenz genannt. Schauen wir uns f\u00fcr unseren Algorithmus nochmal die Eigenschaften eines Algorithmus an: Finitheit unsere Beschreibung des Algorithmus ist endlich (siehe oben). Ausf\u00fchrbarkeit jeder einzelne Schritt kann ausgef\u00fchrt werden. Dynamische Finitheit \u00fcber den Speicherplatz k\u00f6nnen wir noch nicht viel sagen, aber wir m\u00fcssen nur einige wenige Zahlen speichern. Das sollte klappen. Terminierung Wann endet unser Algorithmus? Was muss gelten? Wissen wir, ob der Algorithmus irgendwann stoppt? Determiniertheit Es ist sicherlich nicht so leicht zu sehen, ob bei gleicher Eingabe (die Zahlen a und b ) auch stets der gleiche gr\u00f6\u00dfte gemneinsame Teiler berechnet wird. Dazu m\u00fcssten wir uns erstmal \u00fcberlegen, wie wir das pr\u00fcfen k\u00f6nnen. Determinismus Wir werden unseren Algorithmus nochmal an einem Beispiel durchspielen , um ein Gef\u00fchl daf\u00fcr zu bekommen, dass wir stets wissen, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird.","title":"Beispiel: Euklidischer Algorithmus"},{"location":"start/#beispielzahlen-fur-den-euklidischen-algorithmus","text":"Wir nehmen die Zahlen a=40 und b=24 und spielen damit unseren Algorithmus durch: Zeile 1 : a (40) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von a-b ist 16. Der neue Wert von a ist 16. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist nicht gr\u00f6\u00dfer als b , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von b-a ist 8. Der neue Wert von b ist 8. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (8) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeile 5 ) Zeile 3 : das Ergebnis von a-b ist 8. Der neue Wert von a ist 8. Zeile 1 : wegen wiederhole (Iteration): a (8) ist nicht ungleich b (8) , also wird der Schleifeninhalt nicht ausgef\u00fchrt Zeile 6 : a (8) ist gleich b (8) Zeile 7 : der gesuchte ggT ist 8 Ende F\u00fcr dieses Beispiel war stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe a=40 und b=24 stets 8 ist. Fragen Was \u00e4ndert sich, wenn am Anfang a=24 und b=40 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=0 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=24 und b=24 sind?","title":"Beispielzahlen f\u00fcr den euklidischen Algorithmus"},{"location":"start/#beispiel-3n1-vermutung-collatz-problem","text":"Wir betrachten noch einen weiteren Algorithmus: Als Eingabe bekommen wir eine positive nat\u00fcrliche Zahl, z.B. 5 . Der Algorithmus berechnet eine Folge von Zahlen und zwar nach folgender Vorschrift: ist die Zahl ungerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl mit 3 multipliziert und dann 1 addiert wird. Ist die Zahl gerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl durch 2 geteilt wird. Der Algorithmus stoppt, wenn der Nachfolger 1 ist. Angenommen, die eingegebene positive nat\u00fcrliche Zahl ist n : 1 2 3 4 5 solange n ungleich 1 ist, wiederhole wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Wir begeben uns also in eine Schleife und berechnen so lange einen Nachfolger f\u00fcr die Zahl bis der NAchfolger 1 ist. Betrachten wir den Algorithmus f\u00fcr die EIngabe von n=5 : Zeile 1 : n (5) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist ungerade , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von 3*5+1 ist 16 . Der neue Wert von n ist 16. Zeile 1 : wegen wiederhole (Iteration): n (16) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 16/2 ist 8 . Der neue Wert von n ist 8. Zeile 1 : wegen wiederhole (Iteration): n (8) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 8/2 ist 4 . Der neue Wert von n ist 4. Zeile 1 : wegen wiederhole (Iteration): n (4) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 4/2 ist 2 . Der neue Wert von n ist 2. Zeile 1 : wegen wiederhole (Iteration): n (2) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 2/2 ist 1 . Der neue Wert von n ist 1. Zeile 1 : wegen wiederhole (Iteration): n (1) ist nicht ungleich 1 , also wird der Schleifeninhalt nicht ausgef\u00fchrt Ende Auch f\u00fcr dieses Beispiel war erneut stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die Eingabe n=5 stets 1 ist. Fragen Spielen Sie den Algorithmus ruhig einmal f\u00fcr n=7 durch oder auch f\u00fcr andere n Denken Sie, dass der Algorithmus f\u00fcr jede beliebige positive nat\u00fcrliche Zahl n terminiert? Wenn ein Algorithmus f\u00fcr eine konkrete Eingabe stets ein eindeutiges Ergebnis (und zwar immer das gleiche) liefert, wie k\u00f6nnen dann Zufallszahlen berechnet werden? Success Wir haben ein Verst\u00e4ndnis \u00fcber den Algorithmus -Begriff erlangt und wissen, was Finitheit , Determiniertheit , Determinismus und Terminierung bedeuten.","title":"Beispiel: (3n+1)-Vermutung (Collatz-Problem)"},{"location":"start/#programmablaufstrukturen","text":"Interessanterweise gibt es nur drei verschiedene Ablaufstrukturen in Programmen bzw. Algorithmen. Alle drei haben wir bereits verwendet. Mit Ablaufstrukturen meinen wir die Abarbeitungsreihenfolge von Anweisungen. Man sagt auch Kontrollfluss dazu. Die drei Ablaufstrukturen, die es gibt, sind: die Sequenz : die Anweisungen werden in sequenzieller Abfolge, d.h. hintereinander ausgef\u00fchrt die Iteration : die Abl\u00e4ufe werden wiederholt ausgef\u00fchrt, also in einer Schleife die Selektion : die Abl\u00e4ufe werden selektiv , d.h. unter einer bestimmten Bedingung ausgef\u00fchrt. Man nennt diese Struktur auch Verzweigung oder bedingte Alternative Wir schauen uns alle drei Kontrollstrukturen einmal genauer an.","title":"Programmablaufstrukturen"},{"location":"start/#die-sequenz","text":"Bei der Sequenz handelt es sich einfach um hintereinander ausgef\u00fchrte Anweisungen. Es wird stets erst die eine Anweisung vollst\u00e4ndig abgearbeitet, ehe die andere begonnen wird. Sequenz von 3 Anweisungen Anweisung1 Anweisung2 Anweisung3 Ein Beispiel (mit 2 Anweisungen) w\u00e4re: berechne 3 *n und weise das Ergebnis n zu berechne n+1 und weise das Ergebnis n zu Zur Visualisierung von Kontrollstrukturen werden auch sogannnte Programmablaufdiagramme oder Programmablaufpl\u00e4ne verwendet. F\u00fcr eine Sequenz s\u00e4he ein solches Ablaufdiagramm so aus: So ein Diagramm wird von oben nach unten gelesen. Es wird also erst Anweisung1 ausgef\u00fchrt, dann Anweisung2 und zuletzt Anweisung3 . Innerhalb einer Sequenz gilt immer single entry / single exit , d.h. keine der Anweisungen innerhalb einer Sequenz kann mehrere Ausg\u00e4nge oder mehrere Eing\u00e4nge haben. Es w\u00e4re ansonsten nicht-deterministisch und somit ein Versto\u00df gegen unseren Algorithmusbegriff.","title":"Die Sequenz"},{"location":"start/#die-iteration","text":"Bei der Iteration handelt es sich um eine wiederholte Ausf\u00fchrung einer Anweisung bzw. einer Sequenz von Anweisungen. Wie oft eine Iteration ausgef\u00fchrt wird, h\u00e4ngt von einer Bedingung ab. In der Programmierung sprechen wir bei der Iteration auch von einer Schleife . Bedingungen f\u00fcr eine solche Schleife haben wir bereits kennengelernt: solange a ungleich b ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt bzw. solange n ungleich 1 ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt Wichtig ist, dass es auch hier eine strikte Reihenfolge der Abarbeitung der Anweisungen gibt: es wird zun\u00e4chst gepr\u00fcft, ob die Bedingung erf\u00fcllt (wahr) ist, also ob z.B. a ungleich b ist oder ob n ungleich 1 . Wenn diese Bedingung erf\u00fcllt (also wahr) ist, dann werden die Anweisung(en) innerhalb der Schleife nacheinander (sequenziell) abgearbeitet. Erst wenn alle Anweisungen innerhalb der Schleife abgearbeitet wurden, wird die Schleifenbedingung erneut gepr\u00fcft. Ist sie wieder wahr, werden die Anweisungen innerhalb der Schleife erneut abgearbeitet usw. Ist sie nicht wahr, also wenn z.B. a gleich b ist oder n gleich 1 ist , dann wird die Schleife beendet und die Anweisungen innerhalb der Schleife nicht (erneut) abgearbeitet. Das Ablaufdiagramm einer Schleife (Iteration) sieht so aus: Die eigentliche Iteration ist gr\u00fcn dargestellt. Wir kommen von einer anderen Anweisung und pr\u00fcfen die Bedingung. Ist sie wahr, wird Anweisung1 ausgef\u00fchrt. Beachte Anweisung1 muss nicht zwingend nur genau eine Anweisung sein. Bei Anweisung1 kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder sogar selbst um eine Iteration (Schleife in der Schleife - verschachtelte Schleife) handeln! Nach jeder Ausf\u00fchrung von Anweisung1 wird die Bedingung erneut gepr\u00fcft. Ist sie (immernoch) wahr, wird Anweisung1 erneut ausgef\u00fchrt. Ist die Bedingung jedoch falsch, dann wird Anweisung1 nicht (mehr) ausgef\u00fchrt, sondern die Schleife wird verlassen und die Anweisung, die der Schleife folgt, wird ausgef\u00fchrt ( Anweisung2 ) oder das Programm ist dann zu Ende. Beachte Es kann sein, dass Anweisung1 gar nicht ausgef\u00fchrt wird, weil die Bedingung bereits bei der ersten Pr\u00fcfung falsch ist. Es ist also nicht gesagt, dass sich eine Iteration wirklich wiederholt . Es kann sein, dass Anweisung1 gar nicht oder nur genau ein Mal ausgef\u00fchrt wird (wenn die Bedingung nach der ersten Ausf\u00fchrung falsch ist). Das ist kein Problem! Ein Problem ist es jedoch, wenn die Bedingung niemals falsch wird und die Schleife unendlich oft hintereinander ausgef\u00fchrt wird. Das ist ein Versto\u00df gegen die Terminierung eines Algorithmus. In einem solchen Fall werden wir irgendwann einen Fehler bei der Programmausf\u00fchrung erhalten (aber erst zur Ausf\u00fchrungszeit, nicht bereits beim Compilieren). Wir werden uns ausf\u00fchrlich mit Schleifen auseinandersetzen, da sie logisch recht anspruchsvoll und dadurch h\u00e4ufig fehleranf\u00e4llig sein k\u00f6nnen.","title":"Die Iteration"},{"location":"start/#die-selektion","text":"Bei der Selektion handelt es sich, im Gegensatz zur Iteration, um eine einmalige Ausf\u00fchrung einer (oder mehrerer) Anweisung(en). Jedoch ist diese Ausf\u00fchrung, im Gegensatz zur Sequenz, von einer Bedingung abh\u00e4ngig. Wir hatten eine solche Selektion jeweils in obigen Beispielalgorithmen. Selektion aus dem euklidischen Algorithmus: wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu Selektion aus der (3n+1)-Vermutung (dem Collatz-Problem): wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Es gibt also immer eine Bedingung (z.B. wenn a gr\u00f6\u00dfer ist als b ) und abh\u00e4ngig vom Wert dieser Bedingung (wahr oder falsch), wird entweder die eine Anweisung (z.B. ziehe b von a ab und weise das Ergebnis a zu ) oder die andere (z.B. ziehe a von b ab und weise das Ergebnis b zu ) ausgef\u00fchrt. Das Ablaufdiagramm einer Selektion sieht so aus: Beachte Anweisung1 und auch Anweisung2 m\u00fcssen nicht zwingend jeweils nur genau eine Anweisung sein. Bei beiden kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder um eine Iteration handeln!","title":"Die Selektion"},{"location":"start/#verschachteln-von-kontrollstrukturen","text":"Mehr als diese drei genannten Kontrollstrukturen gibt es nicht. Aber diese Kontrollstrukturen k\u00f6nnen beliebig ineinander verschachtelt werden. \u00dcberall dort, wo eine Anweisung steht (z.B. Anweisung1 ) kann auch eine komplette Kontrollstruktur eingesetzt werden, also eine Sequenz von Anweisungen oder eine Iteration oder eine Selektion. Die kann dann beliebig fortgef\u00fchrt werden. So entstehen komplexe Strukturen - und somit komplexe Programme. Ein (immernoch recht einfaches) Beispiel f\u00fcr eine etwas komplexere Struktur: \u00dcbung Programmablaufpl\u00e4ne Erstellen Sie sowohl f\u00fcr den euklidischen Algorithmus als auch f\u00fcr die (3n+1)-Vermutung einen Programmablaufplan! \u00dcbung Algorithmus und Programmablaufplan Ein Jahr ist ein Schaltjahr, wenn es sich durch 4 teilen l\u00e4sst. Au\u00dfer, es l\u00e4sst sich durch 100 teilen. Dann ist es doch kein Schaltjahr. Au\u00dfer, es l\u00e4sst sich durch 400 teilen. Dann ist es doch ein Schaltjahr. Beschreiben Sie diese Vorschrift als einen Algorithmus in der Form, in der auch der euklidische Algorithmus und die (3n+1)-Vermutung beschrieben wurden. Erstellen Sie dann den dazugeh\u00f6rigen Programmablaufplan. Success Wir wissen nun, dass es nur drei verschiedene Programmablaufstrukturen gibt: die Sequenz, die Iteration und die Selektion. Wir haben ein Verst\u00e4ndnis davon, was die drei Programmablaufstrukturen ausmacht, welchen Zweck sie haben und was sie voneinander unterscheidet. Wir wissen, dass sich diese Strukturen beliebig ineinander verschachteln lassen. Benannt nach Euklid von Alexandria, einem Mathematiker aus dem 3. Jahrhundert, Autor der Elemente - einem Kompendium des Wissens der Mathematik seiner Zeit. \u21a9","title":"Verschachteln von Kontrollstrukturen"},{"location":"tools/","text":"Werkzeuge \u00b6 Literaturempfehlungen \u00b6 Joachim Goll, Cornelia Heinisch: \"Java als erste Programmiersprache. Ein professioneller Einstieg in die Objektorientierung mit Java\" , Springer Vieweg Sebastian D\u00f6rn: \"Java lernen in abgeschlossenen Lerneinheiten\" , Springer Vieweg Dietmar Ratz, Jens Scheffler, Detlef Seese, Jan Wiesenberger: \"Grundkurs Programmieren in Java x\" , Hanser Verlag Kathy Sierra, Bert Bates: \"Java von Kopf bis Fu\u00df\" , O'Reilly Verlag Joshua Bloch: \"Effective Java. Best practices for the Java platform\" , Pearson Education Inc. Robin C. Martin: \"Clean Code: A Handbook of Agile Software Craftmanship\" , Prentice Hall und alle B\u00fccher f\u00fcr Einsteigerinnen, die Sie ansprechen... Java \u00b6 Wir verwenden die Programmiersprache Java , um die Programmierkonzepte, die wir lernen und anwenden wollen, zu implementieren. Java besteht aus 2 Teilen: der Java Run Time Environment (Java RTE) (Java-Laufzeitumgebung) dem Java Development Kit (JDK) (die Java-Entwicklungsumgebung) Die Java-Laufzeitumgebung ist \u00fcblicherweise bereits auf allen Rechnern installiert. Sie ist selbst ein Programm. Innerhalb dieses Programms werden Java-Programme ausgef\u00fchrt. Das JDK m\u00fcssen Sie installieren. Verwenden Sie dazu diesen Link und gehen wie f\u00fcr Ihr Betriebssystem angegeben vor (pr\u00fcfen Sie aber zun\u00e4chst, ob Sie nicht eventuell bereits Beides haben - java -version und javac -version - siehe folgend). Testen Sie am besten auf Ihrer Konsole (Terminal), ob Ihr Java korrekt funktioniert. Zum Testen Ihrer Laufzeitumgebung geben Sie dazu java -version ein. Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): java version \"15.0.1\" 2020 -10-20 Java ( TM ) SE Runtime Environment ( build 15 .0.1+9-18 ) Java HotSpot ( TM ) 64 -Bit Server VM ( build 15 .0.1+9-18, mixed mode, sharing ) Somit wissen Sie, dass die Laufzeitumgebung funktioniert. Zum Testen des JDK rufen wir am besten den Compiler ( javac ) auf: javac -version Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): javac 15 .0.1 Success Sie haben nun die Java-Laufzeitumgebung installiert, in der unsere Java-Programme ausgef\u00fchrt werden und Sie haben das Java Development Kit installiert. Teil des JDK ist z.B. der Compiler , der unsere Java-Programme in Byte-Code \u00fcbersetzt. Dieser Bytecode wird in unserer Java-Laufzeitumgebung ausgef\u00fchrt. IDE \u00b6 Um unsere Programme \"zu schreiben\", verwenden wir eine sogenannte Integrated Development Environment (IDE) , eine integrierte Entwicklungsumgebung, die uns beim Programmieren unterst\u00fctzt. Wir k\u00f6nnten unsere Programme auch mit einfachen Texteditoren schreiben, aber eine IDE unterst\u00fctzt uns, indem der Programmcode geeignet hervorgehoben wird ( Syntx-Highlighting ) und uns Vorschl\u00e4ge f\u00fcr die Verwendung von Methoden und Variablen gemacht werden ( Intelligent Code Completion ). BlueJ \u00b6 Am Anfang verwenden wir BlueJ . BlueJ wird an der University of Kent (UK) entwickelt und richtet sich speziell an Programmieranf\u00e4ngerinnen. Das Tolle an BlueJ ist, dass die Funktionsbl\u00f6cke , die zusammengeh\u00f6ren, farbig hervorgehoben werden. Die Download-Seite von BlueJ befindet sich hier . Laden Sie BlueJ herunter, entpacken Sie das zip-File und bewegen Sie den Ordner BlueJ in Ihren Programme-Ordner. Derzeit hei\u00dft der Ordner BlueJ 5 .0.2 In dem Ordner befindet sich die ausf\u00fchrbare BlueJ -Datei ( BlueJ.app oder BlueJ.exe ) und ein examples -Ordner. \u00d6ffnen Sie BlueJ durch Doppelklick auf die ausf\u00fchrbare BlueJ -Datei. W\u00e4hlen Sie im Men\u00fc Project --> Open Project... . Klicken Sie zum examples -Ordner und w\u00e4hlen Sie das Projekt hello und \u00f6ffnen Sie es. BlueJ sieht dann so aus: Klicken Sie mit der rechten Maustaste auf das gelbe Rechteck Hello und w\u00e4hlen Sie im Men\u00fc Open editor aus. Es erscheint folgendes Fenster: Klicken Sie in diesem Fenster auf den Button Compile . Es sollte folgendes Fenster erscheinen: Success Sie haben BlueJ erfolgreich installiert und die Java-Programme werden \u00fcbersetzt (compiliert). Eclipse \u00b6 Nachdem wir anfangs alle BlueJ verwenden, sind Sie danach in der Wahl Ihrer IDE frei. Wir verwenden Eclipse . Eclipse ist in Java geschrieben und Open-Source. Den Download-Link f\u00fcr Eclipse finden Sie hier . Es gibt verschiedene Versionen von Eclipse, wir verwenden die Eclipse IDE for Java Developers . Installieren Sie Eclipse am besten in ihren Applications oder Programme Ordner. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 oder Uebung1 oder Aufgabe2 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie einen Paketnamen ein (Paketnamen werden kleingeschrieben), z.B. themen.start . Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes (z.B. themen.start ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe eines beliebigen Namens, der gleichzeitig der Klassen- und Dateiname ist (z.B. HelloFIW ). Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . Klicken auf den Button Finish . Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die Bedeutung der einzelnen Fenster in Eclipse: IntelliJ \u00b6 Diejenigen von Ihnen, die nicht Eclipse verwenden, werden sich stattdessen wahrscheinlich f\u00fcr IntelliJ entscheiden. Das ist v\u00f6llig in Ordnung. IntelliJ ist von JetBrains, einem tschechischen Unternehmen, und derzeit die wohl modernste IDE auf dem Markt, nicht nur f\u00fcr Java- sondern auch f\u00fcr Web-Entwicklungen. IntelliJ ist nicht Open-Source und ist kostenpflichtig. Mit einer Hochschullizenz erhalten Sie jedoch kostenlosen Zugriff auf alle Enterprise-Versionen. Sie m\u00fcssen sich dazu bei JetBrains mit Ihrer HTW-Adresse registrieren. Visual Studio Code \u00b6 Wer gerne mit Microsoft-Produkten arbeitet, kann auch gerne Visual Studio Code ( VS Code ) arbeiten. Das ist auch eine sehr gute IDE und ebenfalls nicht nur zur Nutzung f\u00fcr die Java-Entwicklung, sondern auch f\u00fcr Web- und App-Entwicklungen geeignet. Sp\u00e4testens im dritten Semster in WebTech werden die meisten von Ihnen entweder auf IntelliJ oder VS Code wechseln. Weitere n\u00fctzliche Werkzeuge \u00b6 Windows: gitBash \u00b6 Das Terminal ( cmd ) in Windows ist nicht so gut. Installieren Sie sich lieber die GitBash f\u00fcr Windows . Unter Downloads \u00f6ffnet sich das GitHub-Repository f\u00fcr Git. Aktuell w\u00e4hlen Sie dort Git-2.29.2-64-bit.exe und folgen dann den Installationsanweisungen. Online-Kurse \u00b6 SoloLearn https://www.sololearn.com/Course/Java/ JetBrains Academy https://hyperskill.org/tracks/1","title":"Werkzeuge"},{"location":"tools/#werkzeuge","text":"","title":"Werkzeuge"},{"location":"tools/#literaturempfehlungen","text":"Joachim Goll, Cornelia Heinisch: \"Java als erste Programmiersprache. Ein professioneller Einstieg in die Objektorientierung mit Java\" , Springer Vieweg Sebastian D\u00f6rn: \"Java lernen in abgeschlossenen Lerneinheiten\" , Springer Vieweg Dietmar Ratz, Jens Scheffler, Detlef Seese, Jan Wiesenberger: \"Grundkurs Programmieren in Java x\" , Hanser Verlag Kathy Sierra, Bert Bates: \"Java von Kopf bis Fu\u00df\" , O'Reilly Verlag Joshua Bloch: \"Effective Java. Best practices for the Java platform\" , Pearson Education Inc. Robin C. Martin: \"Clean Code: A Handbook of Agile Software Craftmanship\" , Prentice Hall und alle B\u00fccher f\u00fcr Einsteigerinnen, die Sie ansprechen...","title":"Literaturempfehlungen"},{"location":"tools/#java","text":"Wir verwenden die Programmiersprache Java , um die Programmierkonzepte, die wir lernen und anwenden wollen, zu implementieren. Java besteht aus 2 Teilen: der Java Run Time Environment (Java RTE) (Java-Laufzeitumgebung) dem Java Development Kit (JDK) (die Java-Entwicklungsumgebung) Die Java-Laufzeitumgebung ist \u00fcblicherweise bereits auf allen Rechnern installiert. Sie ist selbst ein Programm. Innerhalb dieses Programms werden Java-Programme ausgef\u00fchrt. Das JDK m\u00fcssen Sie installieren. Verwenden Sie dazu diesen Link und gehen wie f\u00fcr Ihr Betriebssystem angegeben vor (pr\u00fcfen Sie aber zun\u00e4chst, ob Sie nicht eventuell bereits Beides haben - java -version und javac -version - siehe folgend). Testen Sie am besten auf Ihrer Konsole (Terminal), ob Ihr Java korrekt funktioniert. Zum Testen Ihrer Laufzeitumgebung geben Sie dazu java -version ein. Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): java version \"15.0.1\" 2020 -10-20 Java ( TM ) SE Runtime Environment ( build 15 .0.1+9-18 ) Java HotSpot ( TM ) 64 -Bit Server VM ( build 15 .0.1+9-18, mixed mode, sharing ) Somit wissen Sie, dass die Laufzeitumgebung funktioniert. Zum Testen des JDK rufen wir am besten den Compiler ( javac ) auf: javac -version Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): javac 15 .0.1 Success Sie haben nun die Java-Laufzeitumgebung installiert, in der unsere Java-Programme ausgef\u00fchrt werden und Sie haben das Java Development Kit installiert. Teil des JDK ist z.B. der Compiler , der unsere Java-Programme in Byte-Code \u00fcbersetzt. Dieser Bytecode wird in unserer Java-Laufzeitumgebung ausgef\u00fchrt.","title":"Java"},{"location":"tools/#ide","text":"Um unsere Programme \"zu schreiben\", verwenden wir eine sogenannte Integrated Development Environment (IDE) , eine integrierte Entwicklungsumgebung, die uns beim Programmieren unterst\u00fctzt. Wir k\u00f6nnten unsere Programme auch mit einfachen Texteditoren schreiben, aber eine IDE unterst\u00fctzt uns, indem der Programmcode geeignet hervorgehoben wird ( Syntx-Highlighting ) und uns Vorschl\u00e4ge f\u00fcr die Verwendung von Methoden und Variablen gemacht werden ( Intelligent Code Completion ).","title":"IDE"},{"location":"tools/#bluej","text":"Am Anfang verwenden wir BlueJ . BlueJ wird an der University of Kent (UK) entwickelt und richtet sich speziell an Programmieranf\u00e4ngerinnen. Das Tolle an BlueJ ist, dass die Funktionsbl\u00f6cke , die zusammengeh\u00f6ren, farbig hervorgehoben werden. Die Download-Seite von BlueJ befindet sich hier . Laden Sie BlueJ herunter, entpacken Sie das zip-File und bewegen Sie den Ordner BlueJ in Ihren Programme-Ordner. Derzeit hei\u00dft der Ordner BlueJ 5 .0.2 In dem Ordner befindet sich die ausf\u00fchrbare BlueJ -Datei ( BlueJ.app oder BlueJ.exe ) und ein examples -Ordner. \u00d6ffnen Sie BlueJ durch Doppelklick auf die ausf\u00fchrbare BlueJ -Datei. W\u00e4hlen Sie im Men\u00fc Project --> Open Project... . Klicken Sie zum examples -Ordner und w\u00e4hlen Sie das Projekt hello und \u00f6ffnen Sie es. BlueJ sieht dann so aus: Klicken Sie mit der rechten Maustaste auf das gelbe Rechteck Hello und w\u00e4hlen Sie im Men\u00fc Open editor aus. Es erscheint folgendes Fenster: Klicken Sie in diesem Fenster auf den Button Compile . Es sollte folgendes Fenster erscheinen: Success Sie haben BlueJ erfolgreich installiert und die Java-Programme werden \u00fcbersetzt (compiliert).","title":"BlueJ"},{"location":"tools/#eclipse","text":"Nachdem wir anfangs alle BlueJ verwenden, sind Sie danach in der Wahl Ihrer IDE frei. Wir verwenden Eclipse . Eclipse ist in Java geschrieben und Open-Source. Den Download-Link f\u00fcr Eclipse finden Sie hier . Es gibt verschiedene Versionen von Eclipse, wir verwenden die Eclipse IDE for Java Developers . Installieren Sie Eclipse am besten in ihren Applications oder Programme Ordner. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 oder Uebung1 oder Aufgabe2 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie einen Paketnamen ein (Paketnamen werden kleingeschrieben), z.B. themen.start . Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes (z.B. themen.start ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe eines beliebigen Namens, der gleichzeitig der Klassen- und Dateiname ist (z.B. HelloFIW ). Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . Klicken auf den Button Finish . Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die Bedeutung der einzelnen Fenster in Eclipse:","title":"Eclipse"},{"location":"tools/#intellij","text":"Diejenigen von Ihnen, die nicht Eclipse verwenden, werden sich stattdessen wahrscheinlich f\u00fcr IntelliJ entscheiden. Das ist v\u00f6llig in Ordnung. IntelliJ ist von JetBrains, einem tschechischen Unternehmen, und derzeit die wohl modernste IDE auf dem Markt, nicht nur f\u00fcr Java- sondern auch f\u00fcr Web-Entwicklungen. IntelliJ ist nicht Open-Source und ist kostenpflichtig. Mit einer Hochschullizenz erhalten Sie jedoch kostenlosen Zugriff auf alle Enterprise-Versionen. Sie m\u00fcssen sich dazu bei JetBrains mit Ihrer HTW-Adresse registrieren.","title":"IntelliJ"},{"location":"tools/#visual-studio-code","text":"Wer gerne mit Microsoft-Produkten arbeitet, kann auch gerne Visual Studio Code ( VS Code ) arbeiten. Das ist auch eine sehr gute IDE und ebenfalls nicht nur zur Nutzung f\u00fcr die Java-Entwicklung, sondern auch f\u00fcr Web- und App-Entwicklungen geeignet. Sp\u00e4testens im dritten Semster in WebTech werden die meisten von Ihnen entweder auf IntelliJ oder VS Code wechseln.","title":"Visual Studio Code"},{"location":"tools/#weitere-nutzliche-werkzeuge","text":"","title":"Weitere n\u00fctzliche Werkzeuge"},{"location":"tools/#windows-gitbash","text":"Das Terminal ( cmd ) in Windows ist nicht so gut. Installieren Sie sich lieber die GitBash f\u00fcr Windows . Unter Downloads \u00f6ffnet sich das GitHub-Repository f\u00fcr Git. Aktuell w\u00e4hlen Sie dort Git-2.29.2-64-bit.exe und folgen dann den Installationsanweisungen.","title":"Windows: gitBash"},{"location":"tools/#online-kurse","text":"SoloLearn https://www.sololearn.com/Course/Java/ JetBrains Academy https://hyperskill.org/tracks/1","title":"Online-Kurse"},{"location":"uebungen/","text":"\u00dcbungen \u00b6 \u00dcbungsbl\u00e4tter (wochenweise) \u00b6 \u00dcbung 1 Vorbereitung Installieren Sie - falls noch nicht geschehen - das Java Davelopment Kit (JDK) (siehe Java ). Installieren Sie BlueJ (siehe IDE ). Starten Sie BlueJ und \u00f6ffnen Sie ( Project --> Open Project... ) das Projekt picture (im BlueJ-Ordner unter examples ). Klicken Sie dann den Compile -Button. Klicken Sie mit der rechten Maustaste auf die Klasse Picture (das orangene K\u00e4stchen mit der Beschriftung Picture ) und erzeugen Sie davon ein Objekt picture1 . Klicken Sie mit der rechten Maustaste auf das Objekt picture1 und rufen Sie die Methode draw() auf. Klicken Sie erneut mit der echten Maustaste auf die Klasse Picture und \u00f6ffnen Sie den Editor mit Open Editor . Es erscheint das Java-Programm (der Quellcode ) der Klasse Picture : Picture.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /** * This class represents a simple picture. You can draw the picture using * the draw method. But wait, there's more: being an electronic picture, it * can be changed. You can set it to black-and-white display and back to * colors (only after it's been drawn, of course). * * This class was written as an early example for teaching Java with BlueJ. * * @author Michael K\u00f6lling and David J. Barnes * @version 1.1 (24 May 2001) */ public class Picture { private Square wall ; private Square window ; private Triangle roof ; private Circle sun ; /** * Constructor for objects of class Picture */ public Picture () { // nothing to do... instance variables are automatically set to null } /** * Draw this picture. */ public void draw () { wall = new Square (); wall . moveVertical ( 80 ); wall . changeSize ( 100 ); wall . makeVisible (); window = new Square (); window . changeColor ( \"black\" ); window . moveHorizontal ( 20 ); window . moveVertical ( 100 ); window . makeVisible (); roof = new Triangle (); roof . changeSize ( 50 , 140 ); roof . moveHorizontal ( 60 ); roof . moveVertical ( 70 ); roof . makeVisible (); sun = new Circle (); sun . changeColor ( \"yellow\" ); sun . moveHorizontal ( 180 ); sun . moveVertical ( - 10 ); sun . changeSize ( 60 ); sun . makeVisible (); } /** * Change this picture to black/white display */ public void setBlackAndWhite () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"black\" ); window . changeColor ( \"white\" ); roof . changeColor ( \"black\" ); sun . changeColor ( \"black\" ); } } /** * Change this picture to use color display */ public void setColor () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"red\" ); window . changeColor ( \"black\" ); roof . changeColor ( \"green\" ); sun . changeColor ( \"yellow\" ); } } } Wir schauen uns diese Klasse ein wenig genauer an und diskutieren einige Details (Objektvariablen, Objektmethoden, Kommentare, ...). Durchf\u00fchrung F\u00fcr diese \u00dcbung interessiert uns nur die Methode draw() . Die Methodenaufrufe, die wir bis jetzt immer einzeln vorgenommen haben, werden nun \"aufgeschrieben\" - wir programmieren ! \u00c4ndern Sie Farben und Positionen der einzelnen Objekte! Wenn Sie Ihre \u00c4nderungen ausprobieren wollen, m\u00fcssen Sie die Klasse neu compilieren . Durch das Compilieren gehen die erzeugten Objekte verloren. Warum ist das wohl so? Lassen Sie die Sonne langsam untergehen. Welche Objektmethode kommt daf\u00fcr infrage? F\u00fcr welches Objekt muss diese Objektmethode aufgerufen werden? Tipp: Derzeit ist es recht m\u00fchsam, die \u00c4nderungen zu testen. Wir m\u00fcssen die Klasse Picture compilieren, dann ein Objekt dieser Klasse erzeugen und dann f\u00fcr dieses Objekt die Methode draw() aufrufen. Wir wollen diesen Vorgang etwas vereinfachen und erstellen uns dazu eine Testklasse . Klicken Sie mit der rechten Maustaste auf die Klasse Picture und w\u00e4hlen Sie Create Test Class aus. Klicken Sie mit der rechten Maustaste auf diese neue Testklasse PictureTest und w\u00e4hlen Sie Create Test Method ... aus. Geben Sie als Namen f\u00fcr diese Testmethode drawTest an und best\u00e4tigen Sie die Eingabe mit OK . Nun wird ein Test \"aufgenommen\". Klicken Sie mit der rechten Maustaste auf die Klasse Picture und erzeugen Sie von dieser Klasse eine Objekt picture1 . F\u00fcr dieses Objekt rufen Sie die draw() -Methode auf. Klicken Sie dann im Hauptfenster auf der linken Seite unter recording den Button End . Sie haben nun einen Test erzeugt, den Sie leicht aufrufen k\u00f6nnen. \u00c4ndern Sie Ihre draw() -Methode, compilieren Sie die Klasse Picture und w\u00e4hlen Sie nun mit der rechten Maustaste f\u00fcr die Klasse PictureTest die Methode drawTest() aus und rufen diese auf.","title":"\u00dcbungen"},{"location":"uebungen/#ubungen","text":"","title":"\u00dcbungen"},{"location":"uebungen/#ubungsblatter-wochenweise","text":"\u00dcbung 1 Vorbereitung Installieren Sie - falls noch nicht geschehen - das Java Davelopment Kit (JDK) (siehe Java ). Installieren Sie BlueJ (siehe IDE ). Starten Sie BlueJ und \u00f6ffnen Sie ( Project --> Open Project... ) das Projekt picture (im BlueJ-Ordner unter examples ). Klicken Sie dann den Compile -Button. Klicken Sie mit der rechten Maustaste auf die Klasse Picture (das orangene K\u00e4stchen mit der Beschriftung Picture ) und erzeugen Sie davon ein Objekt picture1 . Klicken Sie mit der rechten Maustaste auf das Objekt picture1 und rufen Sie die Methode draw() auf. Klicken Sie erneut mit der echten Maustaste auf die Klasse Picture und \u00f6ffnen Sie den Editor mit Open Editor . Es erscheint das Java-Programm (der Quellcode ) der Klasse Picture : Picture.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /** * This class represents a simple picture. You can draw the picture using * the draw method. But wait, there's more: being an electronic picture, it * can be changed. You can set it to black-and-white display and back to * colors (only after it's been drawn, of course). * * This class was written as an early example for teaching Java with BlueJ. * * @author Michael K\u00f6lling and David J. Barnes * @version 1.1 (24 May 2001) */ public class Picture { private Square wall ; private Square window ; private Triangle roof ; private Circle sun ; /** * Constructor for objects of class Picture */ public Picture () { // nothing to do... instance variables are automatically set to null } /** * Draw this picture. */ public void draw () { wall = new Square (); wall . moveVertical ( 80 ); wall . changeSize ( 100 ); wall . makeVisible (); window = new Square (); window . changeColor ( \"black\" ); window . moveHorizontal ( 20 ); window . moveVertical ( 100 ); window . makeVisible (); roof = new Triangle (); roof . changeSize ( 50 , 140 ); roof . moveHorizontal ( 60 ); roof . moveVertical ( 70 ); roof . makeVisible (); sun = new Circle (); sun . changeColor ( \"yellow\" ); sun . moveHorizontal ( 180 ); sun . moveVertical ( - 10 ); sun . changeSize ( 60 ); sun . makeVisible (); } /** * Change this picture to black/white display */ public void setBlackAndWhite () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"black\" ); window . changeColor ( \"white\" ); roof . changeColor ( \"black\" ); sun . changeColor ( \"black\" ); } } /** * Change this picture to use color display */ public void setColor () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"red\" ); window . changeColor ( \"black\" ); roof . changeColor ( \"green\" ); sun . changeColor ( \"yellow\" ); } } } Wir schauen uns diese Klasse ein wenig genauer an und diskutieren einige Details (Objektvariablen, Objektmethoden, Kommentare, ...). Durchf\u00fchrung F\u00fcr diese \u00dcbung interessiert uns nur die Methode draw() . Die Methodenaufrufe, die wir bis jetzt immer einzeln vorgenommen haben, werden nun \"aufgeschrieben\" - wir programmieren ! \u00c4ndern Sie Farben und Positionen der einzelnen Objekte! Wenn Sie Ihre \u00c4nderungen ausprobieren wollen, m\u00fcssen Sie die Klasse neu compilieren . Durch das Compilieren gehen die erzeugten Objekte verloren. Warum ist das wohl so? Lassen Sie die Sonne langsam untergehen. Welche Objektmethode kommt daf\u00fcr infrage? F\u00fcr welches Objekt muss diese Objektmethode aufgerufen werden? Tipp: Derzeit ist es recht m\u00fchsam, die \u00c4nderungen zu testen. Wir m\u00fcssen die Klasse Picture compilieren, dann ein Objekt dieser Klasse erzeugen und dann f\u00fcr dieses Objekt die Methode draw() aufrufen. Wir wollen diesen Vorgang etwas vereinfachen und erstellen uns dazu eine Testklasse . Klicken Sie mit der rechten Maustaste auf die Klasse Picture und w\u00e4hlen Sie Create Test Class aus. Klicken Sie mit der rechten Maustaste auf diese neue Testklasse PictureTest und w\u00e4hlen Sie Create Test Method ... aus. Geben Sie als Namen f\u00fcr diese Testmethode drawTest an und best\u00e4tigen Sie die Eingabe mit OK . Nun wird ein Test \"aufgenommen\". Klicken Sie mit der rechten Maustaste auf die Klasse Picture und erzeugen Sie von dieser Klasse eine Objekt picture1 . F\u00fcr dieses Objekt rufen Sie die draw() -Methode auf. Klicken Sie dann im Hauptfenster auf der linken Seite unter recording den Button End . Sie haben nun einen Test erzeugt, den Sie leicht aufrufen k\u00f6nnen. \u00c4ndern Sie Ihre draw() -Methode, compilieren Sie die Klasse Picture und w\u00e4hlen Sie nun mit der rechten Maustaste f\u00fcr die Klasse PictureTest die Methode drawTest() aus und rufen diese auf.","title":"\u00dcbungsbl\u00e4tter (wochenweise)"}]}