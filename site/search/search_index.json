{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programmieren I \u00b6 Herzlich willkommen zur Programmieren I Veranstaltung! Wir werden unter Verwendung der Programmiersprache Java die wesentlichen Konzepte lernen, die f\u00fcr das Verst\u00e4ndnis modernen Programmierens notwendig sind. Es sind keinerlei Vorkenntnisse erforderlich. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung! Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren! Sie m\u00fcssen es tun . Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler! Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df! Organisatorisches \u00b6 Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in der Vorlesung vorgestellt und in diesem Skript beschrieben. Es ist geplant, die neuen Themen stets vorab in diesem Skript hier zu ver\u00f6ffentlichen. Sie k\u00f6nnen sich also bereits vorab mit dem jeweiligen neuen Thema besch\u00e4ftigen. Zusammen mit dem Skript (das neue Thema) werden sowohl die dazugeh\u00f6rige \u00dcbung als auch die dazugeh\u00f6rige Aufgabe hochgeladen. Die beiden \u00dcbungen am Mittwoch sind jeweils gleich (d.h. dort werden die gleichen \u00dcbungsaufgaben gel\u00f6st). Die \u00dcbungen behandeln den Stoff, der am Mittwoch in der Vorwoche und am Dienstag in der gleichen Woche besprochen wird. Das bedeutet: das neue Thema wird am Mittwoch und am darauffolgenden Dienstag in der Vorlesung vermittelt und an dem Mittwoch darauf in der \u00dcbung angewendet. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Sie k\u00f6nnen auch beliebig w\u00f6chentlich wechseln. Es wird ein Tutorium angeboten (Termin wird noch bekanntgegeben). Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu. Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie die Aufgaben (Hausaufgaben) l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 12 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr \"Programmieren 1\". Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht meistens jeweils einem Wochenthema. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, dass Sie sich diese gegenseitig beantworten. Damit w\u00e4re allen geholfen und wir k\u00f6nnen besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Bei Bedarf beantworten die Lehrenden die Fragen nat\u00fcrlich. Es wird ein Programmier-Tutorium angeboten. Dieses findet montags um 16:00 Uhr in C 639 statt - Start ist am 25.10.2021. Unsere Tutorin ist Lisanne Delfs . Planung (vorl\u00e4ufig - kann sich noch \u00e4ndern) \u00b6 Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) Aufgabe Abgabe Aufgabe bis 1. 11.-15.10.2021 Einf\u00fchrung und Organisatorisches , Klassen und Objekte - BlueJ - - 2. 18.-22.10.2021 Variablen und Datentypen und Operatoren und Ausdr\u00fccke Aufgabe 1 25.10.2021 3. 25.-29.10.2021 Methoden Aufgabe 2 01.11.2021 4. 01.-05.11.2021 Sequenzen, Iterationen und Selektion Aufgabe 3 08.11.2021 5. 08.-12.11.2021 N\u00fctzliche Klassen, Einf\u00fchrung Arrays Aufgabe 4 15.11.2021 6. 15.-19.11.2021 Sortieren von Arrays Aufgabe 5 22.11.2021 7. 22.-26.11.2021 Konstruktoren, this, eigene Datentypen, R\u00fcckgabe von Objekten Aufgabe 6 29.11.2021 8. 29.-03.12.2021 Klassen- und Objekt-Variablen und -Methoden Aufgabe 7 06.12.2021 9. 06.-10.12.2021 Vererbung Aufgabe 8 13.12.2021 10. 13.-17.12.2021 Object und Polymorphie Aufgabe 9 20.12.2021 11. 20.-24.12.2021 return Aufgabe 10 03.01.2022 12. 03.-07.01.2022 Enumerations Aufgabe 11 10.01.2022 13. 10.-14.01.2022 Exceptions Aufgabe 12 17.01.2022 14. 17.-21.01.2022 JavaDoc - - 15. 24.-28.01.2021 Neuerungen ab Java 8 - - 16. 31.-03.02.2022 Wiederholung, Klausurvorbereitung Fragen - 17. 07.-11.02.2021 Wiederholung, Klausurvorbereitung Fragen -","title":"Home"},{"location":"#programmieren-i","text":"Herzlich willkommen zur Programmieren I Veranstaltung! Wir werden unter Verwendung der Programmiersprache Java die wesentlichen Konzepte lernen, die f\u00fcr das Verst\u00e4ndnis modernen Programmierens notwendig sind. Es sind keinerlei Vorkenntnisse erforderlich. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung! Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren! Sie m\u00fcssen es tun . Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler! Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df!","title":"Programmieren I"},{"location":"#organisatorisches","text":"Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in der Vorlesung vorgestellt und in diesem Skript beschrieben. Es ist geplant, die neuen Themen stets vorab in diesem Skript hier zu ver\u00f6ffentlichen. Sie k\u00f6nnen sich also bereits vorab mit dem jeweiligen neuen Thema besch\u00e4ftigen. Zusammen mit dem Skript (das neue Thema) werden sowohl die dazugeh\u00f6rige \u00dcbung als auch die dazugeh\u00f6rige Aufgabe hochgeladen. Die beiden \u00dcbungen am Mittwoch sind jeweils gleich (d.h. dort werden die gleichen \u00dcbungsaufgaben gel\u00f6st). Die \u00dcbungen behandeln den Stoff, der am Mittwoch in der Vorwoche und am Dienstag in der gleichen Woche besprochen wird. Das bedeutet: das neue Thema wird am Mittwoch und am darauffolgenden Dienstag in der Vorlesung vermittelt und an dem Mittwoch darauf in der \u00dcbung angewendet. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Sie k\u00f6nnen auch beliebig w\u00f6chentlich wechseln. Es wird ein Tutorium angeboten (Termin wird noch bekanntgegeben). Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu. Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie die Aufgaben (Hausaufgaben) l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 12 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr \"Programmieren 1\". Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht meistens jeweils einem Wochenthema. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, dass Sie sich diese gegenseitig beantworten. Damit w\u00e4re allen geholfen und wir k\u00f6nnen besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Bei Bedarf beantworten die Lehrenden die Fragen nat\u00fcrlich. Es wird ein Programmier-Tutorium angeboten. Dieses findet montags um 16:00 Uhr in C 639 statt - Start ist am 25.10.2021. Unsere Tutorin ist Lisanne Delfs .","title":"Organisatorisches"},{"location":"#planung-vorlaufig-kann-sich-noch-andern","text":"Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) Aufgabe Abgabe Aufgabe bis 1. 11.-15.10.2021 Einf\u00fchrung und Organisatorisches , Klassen und Objekte - BlueJ - - 2. 18.-22.10.2021 Variablen und Datentypen und Operatoren und Ausdr\u00fccke Aufgabe 1 25.10.2021 3. 25.-29.10.2021 Methoden Aufgabe 2 01.11.2021 4. 01.-05.11.2021 Sequenzen, Iterationen und Selektion Aufgabe 3 08.11.2021 5. 08.-12.11.2021 N\u00fctzliche Klassen, Einf\u00fchrung Arrays Aufgabe 4 15.11.2021 6. 15.-19.11.2021 Sortieren von Arrays Aufgabe 5 22.11.2021 7. 22.-26.11.2021 Konstruktoren, this, eigene Datentypen, R\u00fcckgabe von Objekten Aufgabe 6 29.11.2021 8. 29.-03.12.2021 Klassen- und Objekt-Variablen und -Methoden Aufgabe 7 06.12.2021 9. 06.-10.12.2021 Vererbung Aufgabe 8 13.12.2021 10. 13.-17.12.2021 Object und Polymorphie Aufgabe 9 20.12.2021 11. 20.-24.12.2021 return Aufgabe 10 03.01.2022 12. 03.-07.01.2022 Enumerations Aufgabe 11 10.01.2022 13. 10.-14.01.2022 Exceptions Aufgabe 12 17.01.2022 14. 17.-21.01.2022 JavaDoc - - 15. 24.-28.01.2021 Neuerungen ab Java 8 - - 16. 31.-03.02.2022 Wiederholung, Klausurvorbereitung Fragen - 17. 07.-11.02.2021 Wiederholung, Klausurvorbereitung Fragen -","title":"Planung (vorl\u00e4ufig - kann sich noch \u00e4ndern)"},{"location":"aufgaben/","text":"Aufgaben \u00b6 Hier finden Sie die Aufgaben. Die Abgabefristen der einzelnen Aufgaben stehen hier . Beachten Sie die nachfolgenden Hinweise zum Hochladen der Aufgaben. Hinweise zur Abgabe der Aufgaben \u00b6 Die Aufgaben laden Sie in Moodle unter dem Reiter \"Aufgaben\" hoch. Dort ist f\u00fcr jede Aufgabe eine Moodle-Aufgabe erstellt. Beachten Sie, dass ein Hochladen nach Ablauf der Abgabefrist nicht mehr m\u00f6glich ist. BlueJ vs. Eclipse \u00b6 Die ersten Wochen verwenden wir als Entwicklungsumgebung BlueJ. F\u00fcr die Aufgaben, die wir mit BlueJ l\u00f6sen, werde ich Ihnen jeweils Hinweise zur Abgabe f\u00fcr jede Aufgabe einzeln geben. Sobald wir Eclipse verwenden, gelten die folgenden Hinweise: Achten Sie darauf, dass Sie die Quelldateien (also die .java -Dateien aus dem src -Verzeichnis) hochladen. Ihre Klassen erstellen Sie immer in einem package aufgaben.aufgabeX . Das hei\u00dft, Aufgabe1 ist im package aufgaben.aufgabe1 , Aufgabe2 im package aufgaben.aufgabe2 usw. In Ihrem workspace gibt es dann einen Ordner f\u00fcr Ihr Java-Projekt, z.B. WS21 (je nachdem, wie Sie Ihr Java-Projekt genannt haben) und darin befindet sich ein bin - und ein src -Ordner. In dem src -Ordner befindet sich dann ein Ordner aufgaben und darin ein Ordner aufgaben1 (f\u00fcr Aufgabe1). Darin befindet sich Ihre .java -Datei, die Sie hochladen sollen. Angenommen, Sie haben Ihre Klasse Aufgabe1 genannt, dann hei\u00dft die Klasse also Aufgabe1.java . Sie folgen also dem Pfad workspace \u2192 Java-Projekt (z.B. WS21 ) \u2192 src \u2192 aufgaben \u2192 aufgabe X . Wenn Ihre L\u00f6sung aus mehreren Klassen (mehreren .java -Dateien) besteht, k\u00f6nnen Sie entweder die Dateien einzeln hochladen oder Sie zippen Ihre Dateien (am besten dann den aufgabeX -Ordner und laden das .zip -File hoch. In Ihrer L\u00f6sung (Ihrer/n Klasse/n) f\u00fcgen Sie direkt oberhalb Ihrer Klassendefinition einen JavaDoc-Kommentar ein ( /** ... */ ). Dieser enth\u00e4lt ein @author -Tag. dahinter schreiben Sie Ihren Namen. Das sieht dann z.B. so aus: package aufgaben.aufgabe1 ; /** * * @author J\u00f6rn Freiheit * * Diese Klasse gibt auf die Konsole ein Rhombus (eine Raute) aus. * Der Rhombus ist entweder gefuellt oder ungefuellt. * */ public class Aufgabe1 { // hier Ihre Implementierung } Sie k\u00f6nnen Ihre Aufgaben zu zweit l\u00f6sen. Tragen Sie dann hinter das @author -Tag beide Namen ein und laden Sie bitte beide die L\u00f6sung in Moodle hoch! Code Review \u00b6 F\u00fcr jede abgegebene Aufgabe wird Ihnen die L\u00f6sung einer Kommilitonin zum Review zugewiesen. Analysieren Sie den Code Ihrer Kommilitonin und geben Sie ihr dazu eine R\u00fcckmeldung! Es gen\u00fcgen 2 bis 3 Review-Kommentare. Zur offiziellen Abgabe einer Aufgabe geh\u00f6ren also das Hochladen der eigenen L\u00f6sung, das Analysieren/Kommentieren einer fremden L\u00f6sung. Hinweise zum Review: \u00b6 Es geht nicht darum, das Programm zu \u00fcberarbeiten, sondern darum es nachzuvollziehen und Ihrer Kommilitonin eine R\u00fcckmeldung und eventuell Anregungen zu geben. Weisen Sie sowohl auf St\u00e4rken als auch auf Schw\u00e4chen des Quelltexts hin. Worauf Sie u.a. achten k\u00f6nnen: Ist der Quelltext gut strukturiert und verst\u00e4ndlich? Haben Variablen und Methoden passende Namen? Werden die Namen konsistent verwendet? Werden Konventionen eingehalten? Beispiel: Klassennamen starten immer mit Gro\u00dfbuchstaben, Objektnamen immer mit Kleinbuchstaben Ist das Programm \u00fcbersichtlich formatiert? Beispiel: kein horizontales Scrolling n\u00f6tig Machen Sie ggf. Vorschl\u00e4ge f\u00fcr (alternative) L\u00f6sungen. Gehen Sie respektvoll miteinander um, es gibt keinen Grund, unh\u00f6flich zu sein. Lesen Sie Ihre Kommentare noch einmal durch, bevor Sie sie an Ihre Kommilitonin weitergeben. Aufgaben \u00b6 Aufgabe 1 (Abgabe bis 25.10.2021 24:00 Uhr) \u00b6 Aufgabe1 - Square mit Circles Verwenden Sie BlueJ und \u00f6ffnen Sie das Projekt picture aus dem examples -Ordner von BlueJ. Speichern Sie das Projekt als Projekt aufgabe1 ab. Die Klasse Picture k\u00f6nnen Sie wie folgt anpassen: /** * Aufgabe 1 * */ public class Picture { /** * Constructor for objects of class Picture */ public Picture () { // nothing to do... instance variables are automatically set to null } /** * Draw this picture. */ public void draw () { Square s1 = new Square (); Circle c1 = new Circle (); Circle c2 = new Circle (); Circle c3 = new Circle (); Circle c4 = new Circle (); // hier die Implementierung } } Programmieren Sie die draw() -Methode so, dass folgendes Bild gezeichnet wird: Die Gr\u00f6\u00dfen bleiben Ihnen \u00fcberlassen, aber die vier Kreise sollen das gelbe Quadrat vollst\u00e4ndig ausf\u00fcllen. Den Titel des Fensters m\u00fcssen Sie nicht \u00e4ndern (geht aber in der Klasse Canvas ). Erstellen Sie sich eine Testklasse PictureTest , in der es eine Testmethode testDraw() gibt, die die draw() -Methode f\u00fcr ein Picture -Objekt ausf\u00fchrt. Zippen Sie Ihr Projekt aufgabe1 und laden es in Moodle hoch.","title":"Aufgaben"},{"location":"aufgaben/#aufgaben","text":"Hier finden Sie die Aufgaben. Die Abgabefristen der einzelnen Aufgaben stehen hier . Beachten Sie die nachfolgenden Hinweise zum Hochladen der Aufgaben.","title":"Aufgaben"},{"location":"aufgaben/#hinweise-zur-abgabe-der-aufgaben","text":"Die Aufgaben laden Sie in Moodle unter dem Reiter \"Aufgaben\" hoch. Dort ist f\u00fcr jede Aufgabe eine Moodle-Aufgabe erstellt. Beachten Sie, dass ein Hochladen nach Ablauf der Abgabefrist nicht mehr m\u00f6glich ist.","title":"Hinweise zur Abgabe der Aufgaben"},{"location":"aufgaben/#bluej-vs-eclipse","text":"Die ersten Wochen verwenden wir als Entwicklungsumgebung BlueJ. F\u00fcr die Aufgaben, die wir mit BlueJ l\u00f6sen, werde ich Ihnen jeweils Hinweise zur Abgabe f\u00fcr jede Aufgabe einzeln geben. Sobald wir Eclipse verwenden, gelten die folgenden Hinweise: Achten Sie darauf, dass Sie die Quelldateien (also die .java -Dateien aus dem src -Verzeichnis) hochladen. Ihre Klassen erstellen Sie immer in einem package aufgaben.aufgabeX . Das hei\u00dft, Aufgabe1 ist im package aufgaben.aufgabe1 , Aufgabe2 im package aufgaben.aufgabe2 usw. In Ihrem workspace gibt es dann einen Ordner f\u00fcr Ihr Java-Projekt, z.B. WS21 (je nachdem, wie Sie Ihr Java-Projekt genannt haben) und darin befindet sich ein bin - und ein src -Ordner. In dem src -Ordner befindet sich dann ein Ordner aufgaben und darin ein Ordner aufgaben1 (f\u00fcr Aufgabe1). Darin befindet sich Ihre .java -Datei, die Sie hochladen sollen. Angenommen, Sie haben Ihre Klasse Aufgabe1 genannt, dann hei\u00dft die Klasse also Aufgabe1.java . Sie folgen also dem Pfad workspace \u2192 Java-Projekt (z.B. WS21 ) \u2192 src \u2192 aufgaben \u2192 aufgabe X . Wenn Ihre L\u00f6sung aus mehreren Klassen (mehreren .java -Dateien) besteht, k\u00f6nnen Sie entweder die Dateien einzeln hochladen oder Sie zippen Ihre Dateien (am besten dann den aufgabeX -Ordner und laden das .zip -File hoch. In Ihrer L\u00f6sung (Ihrer/n Klasse/n) f\u00fcgen Sie direkt oberhalb Ihrer Klassendefinition einen JavaDoc-Kommentar ein ( /** ... */ ). Dieser enth\u00e4lt ein @author -Tag. dahinter schreiben Sie Ihren Namen. Das sieht dann z.B. so aus: package aufgaben.aufgabe1 ; /** * * @author J\u00f6rn Freiheit * * Diese Klasse gibt auf die Konsole ein Rhombus (eine Raute) aus. * Der Rhombus ist entweder gefuellt oder ungefuellt. * */ public class Aufgabe1 { // hier Ihre Implementierung } Sie k\u00f6nnen Ihre Aufgaben zu zweit l\u00f6sen. Tragen Sie dann hinter das @author -Tag beide Namen ein und laden Sie bitte beide die L\u00f6sung in Moodle hoch!","title":"BlueJ vs. Eclipse"},{"location":"aufgaben/#code-review","text":"F\u00fcr jede abgegebene Aufgabe wird Ihnen die L\u00f6sung einer Kommilitonin zum Review zugewiesen. Analysieren Sie den Code Ihrer Kommilitonin und geben Sie ihr dazu eine R\u00fcckmeldung! Es gen\u00fcgen 2 bis 3 Review-Kommentare. Zur offiziellen Abgabe einer Aufgabe geh\u00f6ren also das Hochladen der eigenen L\u00f6sung, das Analysieren/Kommentieren einer fremden L\u00f6sung.","title":"Code Review"},{"location":"aufgaben/#hinweise-zum-review","text":"Es geht nicht darum, das Programm zu \u00fcberarbeiten, sondern darum es nachzuvollziehen und Ihrer Kommilitonin eine R\u00fcckmeldung und eventuell Anregungen zu geben. Weisen Sie sowohl auf St\u00e4rken als auch auf Schw\u00e4chen des Quelltexts hin. Worauf Sie u.a. achten k\u00f6nnen: Ist der Quelltext gut strukturiert und verst\u00e4ndlich? Haben Variablen und Methoden passende Namen? Werden die Namen konsistent verwendet? Werden Konventionen eingehalten? Beispiel: Klassennamen starten immer mit Gro\u00dfbuchstaben, Objektnamen immer mit Kleinbuchstaben Ist das Programm \u00fcbersichtlich formatiert? Beispiel: kein horizontales Scrolling n\u00f6tig Machen Sie ggf. Vorschl\u00e4ge f\u00fcr (alternative) L\u00f6sungen. Gehen Sie respektvoll miteinander um, es gibt keinen Grund, unh\u00f6flich zu sein. Lesen Sie Ihre Kommentare noch einmal durch, bevor Sie sie an Ihre Kommilitonin weitergeben.","title":"Hinweise zum Review:"},{"location":"aufgaben/#aufgaben_1","text":"","title":"Aufgaben"},{"location":"aufgaben/#aufgabe-1-abgabe-bis-25102021-2400-uhr","text":"Aufgabe1 - Square mit Circles Verwenden Sie BlueJ und \u00f6ffnen Sie das Projekt picture aus dem examples -Ordner von BlueJ. Speichern Sie das Projekt als Projekt aufgabe1 ab. Die Klasse Picture k\u00f6nnen Sie wie folgt anpassen: /** * Aufgabe 1 * */ public class Picture { /** * Constructor for objects of class Picture */ public Picture () { // nothing to do... instance variables are automatically set to null } /** * Draw this picture. */ public void draw () { Square s1 = new Square (); Circle c1 = new Circle (); Circle c2 = new Circle (); Circle c3 = new Circle (); Circle c4 = new Circle (); // hier die Implementierung } } Programmieren Sie die draw() -Methode so, dass folgendes Bild gezeichnet wird: Die Gr\u00f6\u00dfen bleiben Ihnen \u00fcberlassen, aber die vier Kreise sollen das gelbe Quadrat vollst\u00e4ndig ausf\u00fcllen. Den Titel des Fensters m\u00fcssen Sie nicht \u00e4ndern (geht aber in der Klasse Canvas ). Erstellen Sie sich eine Testklasse PictureTest , in der es eine Testmethode testDraw() gibt, die die draw() -Methode f\u00fcr ein Picture -Objekt ausf\u00fchrt. Zippen Sie Ihr Projekt aufgabe1 und laden es in Moodle hoch.","title":"Aufgabe 1 (Abgabe bis 25.10.2021 24:00 Uhr)"},{"location":"ausdruecke/","text":"Operatoren und Ausdr\u00fccke \u00b6 Im vorherigen Abschnitt haben wir Variablen und Datentypen kennengelernt. Wir k\u00f6nnen Variablen deklarieren und initialisieren und ihnen neue Werte zuweisen. Nun f\u00fchren wir Operationen ein, die wir in den jeweiligen Datentypen verwenden k\u00f6nnen, um neue Werte zu erzeugen. Wir beginnen bei den arithmetischen Operatoren, d.h. mit den Operatoren, die wir f\u00fcr die ganzzahligen Datentypen und die Gleitkomma-Datentypen verwenden k\u00f6nnen. Arithmetische Operatoren \u00b6 Arithmetische Operationen kennen wir nat\u00fcrlich schon. Die einfachsten arithmetischen Operatoren sind die un\u00e4ren Operatoren, auch Vorzeichenoperatoren genannt. Ansonsten gibt es die Addition + , die Subtraktion - , die Multiplikation * und die Division / . Au\u00dferdem gibt es auch einen Restwertoperator (auch modulo genannt), der bei der ganzzahligen Division den verbleibenden Rest als Ergebnis ermittelt ( % ). Ganz wichtig ist, dass das Divisionssymbol / eine unterschiedliche Bedeutung hat, je nachdem, ob wir ganze Zahlen dividieren oder Gleitkommazahlen. Bei der Division von ganzen Zahlen ist das Ergebnis der Division der ganzzahlige Wert (also z.B. 5 / 4 ergibt 1 ), aber bei der Division von Gleitkommazahlen ein Gleitkommawert (also z.B. 5.0 / 4.0 ergibt 1.25 ). Der Restwertoperator wird wirklich sinnvoll eigentlich nur f\u00fcr ganze Zahlen verwendet (also z.B. 7 % 4 ergibt 3 - der verbleibende Rest der ganzzahligen Divsion ist 3 ). Trotzdem kann der Restwertoperator auch auf Gleitkommazahlen angewendet werden (obwohl dort ja eigentlich kein Rest bleibt). So ergibt 7.0 % 4.0 auch 3.0 und/aber 7.5 % 4.0 ergibt 3.5 . Operatorsymbol(e) Bedeutung Beispiel Un\u00e4re Operatoren + Wird als Vorzeichen vor ganzen Zahlen (z.B. +5 ) oder vor Gleikommazahlen (z.B. +5.5 ) verwendet. + \u00e4ndert nichts und kann immer weggelassen werden. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = +x; Wert von x ist -5 - Wird als Vorzeichen vor ganzen Zahlen (z.B. -5 ) oder vor Gleikommazahlen (z.B. -5.5 ) verwendet. -x dreht das Vorzeichen von x um. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = -x; Wert von x ist +5 double y = -5.5; y = -y; Wert von y ist +5.5 Bin\u00e4re Operatoren + Addition von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 + 6; Wert von x: +1 double y = -5.5 + 6.5; Wert von y: +1.0 - Subtraktion von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 - 6; Wert von x ist -11 double y = -5.5 - 6.5; Wert von y: -12.0 * Multiplikation von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 * 6; Wert von x: -30 double y = -5.0 * 6.0; Wert von y: -30.0 / Division von Zahlen. Achtung! Sie m\u00fcssen unterscheiden, ob Sie ganze Zahlen dividieren oder Gleitkommazahlen! Bei ganzen Zahlen handelt es sich um die ganzzahlige Division! int x = 5 / 4; Wert von x: +1 double y = 5.0 / 4.0; Wert von y: +1.25 % Restwertoperator. Ergebnis ist der Rest, der bei ganzzahliger Division \u00fcbrig bleibt. Wirklich sinnvoll nur bei ganzzahligen Werten, geht aber auch bei Gleitkommazahlen. int x = 7 % 4; Wert von x ist 3 double y = 6.5 % 5.0; Wert von y ist 1.5 Pr\u00e4- und Postfix-Operatoren \u00b6 Dar\u00fcber hinaus gibt es noch besondere Operatoren, die eingef\u00fchrt wurden, weil sie eine h\u00e4ufig vorkommende Operation in der Schreibweise verk\u00fcrzen. Angenommen, wir haben eine Variable int x = 5; . Da es (insbesondere sp\u00e4ter in Schleifen) h\u00e4ufig vorkommt, dass der Wert dieser Variablen um 1 erh\u00f6ht werden soll, hat man daf\u00fcr einen eigenen Operator eingef\u00fchrt: ++ . Dieser Operator steht f\u00fcr die Erh\u00f6hung des Wertes um den Summanden 1 . Er kann sowohl als Pr\u00e4fix-Operator ( ++x ) als auch als Postfix-Operator eingesetzt werden. Man spricht hier von Pr\u00e4- und Postfix- Inkrement -Operatoren. 1 2 3 4 5 int x = 5 ; System . out . println ( x ++ ); // 5 System . out . println ( x ); // 6 System . out . println ( ++ x ); // 7 System . out . println ( x ); // 7 Der Unterschied zwischen den beiden wird im obigen Beispiel deutlich. x hat nach der Initialisierung den Wert 5 . In Zeile 2 geben wir den Wert aus und erh\u00f6hen x danach um 1 . Ausgegeben wird also der Wert 5 , aber nach der Ausgabe ist der Wert um 1 erh\u00f6ht auf 6 (siehe Zeile 3 ). Bei dem Prefix-Operator (Zeile 4 ) wird der Wert erst erh\u00f6ht und dann ausgelesen. Es wird also bereits der neue Wert 7 ausgegeben. Im Prinzip entsprechen beide Operatoren aber der Anweisung x = x + 1; . Den \u00e4quivalenten Operator gibt es auch f\u00fcr die Subtraktion minus 1 . Dies wird mit dem Prefix-Operator --x; sowie mit dem Postfix-Operator x--; erreicht. Diese hei\u00dfen Pr\u00e4- und Postfix- Dekrement -Operatoren. Verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren \u00b6 Aus dieser Verwendung haben sich weitere Schreibweisen etabliert: Operatoren (Beispiele) Bedeutung x+=7; x = x + 7; x-=7; x = x - 7; x*=7; x = x * 7; x/=7; x = x / 7; x%=7; x = x % 7; Vergleichsoperatoren \u00b6 Werden die oben genannten Operatoren auf arithmetische Datentypen angewendet, so ist das Ergebnis selbst wieder von einem arithmetischen Datentyp ( int oder double ). Bei den folgenden Vergleichsoperatoren ist das anders. Die Operanden sind zwar auch wieder von arithmetischen Datentypen, aber das Ergebnis ist ein boolean , das hei\u00dft, der Vergleich resultiert in einem Wert true oder in einem Wert false . Vergleichsoperator Beispiel Bedeutung == x == y Vergleich auf Gleichheit. Ergibt true , wenn x den gleichen Wert hat wie y , sonst false < x < y Kleiner als. Ergibt true , wenn x einen echt kleineren Wert hat als y , sonst false > x > y Gr\u00f6\u00dfer als. Ergibt true , wenn x einen echt gr\u00f6\u00dferen Wert hat als y , sonst false < = x < = y Kleiner gleich. Ergibt true , wenn x einen kleineren als oder den gleichen Wert wie y hat, sonst false >= x >= y Gr\u00f6\u00dfer gleich. Ergibt true , wenn x einen gr\u00f6\u00dferen als oder den gleichen Wert wie y hat, sonst false != x != y Ungleich. Ergibt true , wenn x einen anderen Wert hat als y , sonst false Wertzuweisungsoperator \u00b6 Einen weiteren Operator kennen wir bereits, den Wertzuweisungsoperator = . Auf der linken Seite der Zuweisung steht immer eine Variable und auf der rechten Seite ein Wert, der sich auch aus einem Ausdruck ergeben kann, z.B. int x = 5 + 6; . Dann wird x der Wert 11 zugeweisen. Beachte Der Zuweisungsoperator ist zun\u00e4chst gew\u00f6hnungsbed\u00fcrftig, denn eine Zuweisung der Form x = x+1; sieht ja aus mathematischer Sicht komisch aus, da in der Mathematik das Symbol = f\u00fcr die Gleichheit verwendet wird. In der (Java-)Programmierung hat dieses Symbol aber eine andere Bedeutung, n\u00e4mlich die Zuweisung des Wertes auf der rechten Seite zur Variablen auf der linken Seite. In der Zuweisung x = x+1; wird also erst der Wert x+1 berechnet und dieser Wert dann der Variablen x zugeordnet (die dann einen um 1 h\u00f6heren Wert hat als zuvor). Der Operator f\u00fcr die Gleichheit ist \u00fcbrigens == , wie wir gleich sehen werden. Logische Operatoren \u00b6 Die arithmetischen Operatoren werden auf Operanden angewendet, die von einem ganzzahligen Datentyp oder von einem Gleitkomma-Datentyp sind. Jetzt lernen wir Operatoren kennen, die auf Operanden vom Typ boolean angewendet werden. Nehmen wir in der folgenden Tabelle an, dass die Variablen a und b jeweils vom Typ boolean sind. Sie wurden also wie folgt deklariert: boolean a; und boolean b; . Logischer Operator Beispiel Bedeutung && a && b UND-Operator. Ergibt true , wenn a den Wert true hat UND b auch den Wert true , sonst false || a || b ODER-Operator. Ergibt true , wenn a den Wert true hat ODER b den Wert true (oder beide), sonst false ^ a ^ b EXCLUSIVES ODER. Ergibt true , wenn ENTWEDER a den Wert true hat ODER b den Wert true (aber NICHT beide), sonst false ! !a NEGATION (un\u00e4rer Operator). Ergibt true , wenn a den Wert false hat, ergibt false , wenn a den Wert true hat Es sein angemerkt, dass es f\u00fcr die Operatoren && und || jeweils auch die Operatoren & und | gibt. Das logische Prinzip ist das gleiche (also UND und ODER). Es gibt nur jeweils eine Unterscheidung und diese ist im folgenden Beispiel dargestellt: false && a // a wird nicht mehr gepr\u00fcft, Ausdruck ist false false & a // a wird gepr\u00fcft, Ausdruck ist false true || b // b wird nicht mehr gepr\u00fcft, Ausdruck ist true true | b // b wird gepr\u00fcft, Ausdruck ist true Ist beim logischen UND bereits der erste Operand false , dann kann das Ergebnis nicht mehr true sein, sondern ist false . Egal, welchen Wert der zweite Operand hat. Bei dem Operator && wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator & aber doch. && ist somit effizienter. Ist beim logischen ODER bereits der erste Operand true , dann ist das Ergebnis bereits true , egal, welchen Wert der zweite Operand hat. Bei dem Operator || wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator | aber doch. || ist somit effizienter. Wir verwenden deshalb immer && und || anstatt & und | . Wahrheitstabellen \u00b6 Hier nochmal eine Veranschaulichung der obigen logischen Operatoren in einer Wahrheitstabelle. Wir nehmen wieder an, dass die Variablen a und b jeweils vom Typ boolean sind. a b a && b a || b a ^ b !a true true true true false false true false false true true false false true false true true true false false false false false true \u00dcbung Exclusives Oder Angenommen, es g\u00e4be den Operator ^ f\u00fcr das Exclusive Oder nicht und Sie h\u00e4tten nur die Operatoren && , || und ! . Wie k\u00f6nnen Sie mit && , || und ! das exclusive Oder \"nachbauen\"? Ausdr\u00fccke und Anweisungen \u00b6 Anweisungen haben wir bereits kennengelernt. Zum Beispiel sind Deklarationen Anweisungen und Initialisierungen auch. Neben Anweisungen gibt es im Programmcode auch Ausdr\u00fccke . Ausdr\u00fccke unterscheiden sich von Anweisungen dahingehened, dass sie einen Wert (genauer einen R\u00fcckgabewert ) haben. Jeder Wert in Java hat einen Typ. Wir schauen uns zun\u00e4chst die einfachsten Ausdr\u00fccke an, die es gibt, n\u00e4mlich sogenannte Literale . Literale \u00b6 Ein Literal ist ein konstanter Wert im Java-Quellcode. Literale sind z.B. ganze Zahlen (z.B. 123 oder -123 ), Gleikommazahlen (z.B 5.5 oder -6.0 ), Wahrheitswerte ( true oder false ), ein Character (z.B. 'a' oder 'A' ) Wir werden sp\u00e4ter noch andere Literale kennenlernen: Zeichenketten (Datentyp String ), z.B. \"Hallo FIW!\" die leere Referenz null Jedes Literal ist ein Ausdruck. Der R\u00fcckgabewert des Literals ist der Wert des Literals. Jedes Literal ist von einem konkreten Datentyp. Die folgenden Anweisungen werden auch Ausdrucksanweisung genannt, da in der Anweisung ein Ausdruck verwendet wird und der Wert dieses Ausdrucks als Nebeneffekt zum Tragen kommt (nur die ersten beiden sind Ausdrucksanweisungen - die folgenden drei sind Fehler ): int x = 123 ; // auf der rechten Seite des Zuweisungsoperators steht ein Ausdruck; // der Wert des Ausdrucks wird der Wert der Variablen x x ++ ; // x++ ist ein Ausdruck - durch das Semikolon wird der Ausdruck hier zu einer Ausdrucksanweisung x ++ // der Ausdruck selbst kann so nicht stehen (Compilerfehler) // da steht nur ein Wert mit dem nichts gemacht wird 5 + 6 // gleicher Fehler wie oben; nur ein Ausdruck, kann so nicht alleine stehen 5 + 6 ; // geht auch nicht; hier gibt es keinen Nebeneffekt (keine Zuweisung) // keine g\u00fcltige Ausdrucksanweisung Ausdr\u00fccke sind Literale Literale, die mit (passenden) Operatoren verkn\u00fcpft sind Ausdr\u00fccke, die mit passenden Operatoren verkn\u00fcpft sind Ausdr\u00fccke mit Operatoren \u00b6 Verbinden wir Literale mit Operatoren, entstehen dadurch Ausdr\u00fccke. Ausdr\u00fccke k\u00f6nnen wiederum mithilfe von Operatoren mit weiteren Literalen oder auch mit weiteren Ausdr\u00fccken verbunden werden. Beachten Sie, dass Ausdr\u00fccke immer einen Wert haben, der Wert ermittelt wird, indem der Ausdruck aufgel\u00f6st wird, d.h. die Operatoren angewendet werden. Dies erfolgt in folgender Reihenfolge: wenn runde Klammern um einen Ausdruck gesetzt sind, wird zun\u00e4chst der geklammerte Ausdruck aufgerufen, un\u00e4re (also einelementige) Operatoren binden st\u00e4rker als bin\u00e4re (also zweielementige) Operatoren, d.h. es werden zun\u00e4chst die einelementigen Operatoren angewendet, bei arithmetischen Operatoren gilt \"Punkt vor Strich-Rechnung\", bei logischen Operatoren gilt folgende Reihenfolge (st\u00e4rkere Bindung von links nach rechts) == , != -> & \u2192 ^ \u2192 | \u2192 && \u2192 || (lernen Sie das aber keinesfalls auswendig und verlassen sich dann auf Ihr Ged\u00e4chtnis, sondern verwenden Sie Klammern!) der Zuweisungsoperator ( = ) sowie += , -= , /= , *= , %= binden am schw\u00e4chsten dann erfolgt die Aufl\u00f6sung von links nach rechts Achten Sie darauf, dass Ausdr\u00fccke einen anderen Typ haben k\u00f6nnen als die Literale (bzw. Ausdr\u00fccke), die man im Ausdruck mithilfe von Operatoren miteinander verbindet, z.B. 3 == 4 ist vom Typ boolean , aber 3 und 4 sind jeweils vom Typ int . Beispiele f\u00fcr Ausdr\u00fccke sind: 5 + 6 - 8 // Ergebnis (Wert) ist ein int true && false // Ergebnis (Wert) ist ein boolean 5 < 6 // Ergebnis (Wert) ist ein boolean 7 >= 7 // Ergebnis (Wert) ist ein boolean 6 == 6 // Ergebnis (Wert) ist ein boolean 6 != 6 // Ergebnis (Wert) ist ein boolean 5.5 * 2.0 // Ergebnis (Wert) ist ein double 7.0 / 4.0 // Ergebnis (Wert) ist ein double ( 7.0 / 4.0 ) > 1.0 // Ergebnis (Wert) ist ein boolean \u00dcbung Ausdruck Angenommen, a , b und c seien vom Typ int . Was ist an diesem Ausdruck falsch: a < b < c ? Wie w\u00e4re es richtig? \u00dcbung Durchschnitt berechnen Angenommen, Sie sollen die Durchschnittsnote von folgenden Noten berechnen: 1 , 1 , 1 , 1 , 2 , 2 , 3 , 4 . Sie \u00fcberlegen sich folgendes Programm daf\u00fcr: int summe = 1 + 1 + 1 + 1 + 2 + 2 + 3 + 4 ; int anzahl = 8 ; System . out . println ( summe / anzahl ); Vom Ergebnis sind Sie aber entt\u00e4uscht. Welches Ergebnis wird ausgegeben? Welches w\u00e4re richtig gewesen? Was ist an Ihrem Programm falsch? Wie geht es besser? Bei der Verwendung des Zuweisungsoperators gibt es auf der linken Seite immer eine Variable und auf der rechten Seite immer einen Ausdruck. Bevor die Zuweisung erfolgt, wird der Wert des Ausdrucks auf der rechten Seite ausgewertet. Beispiele: int x = 0 ; // Wert von x ist 0 x = 7 + 4 / 2 ; // Wert von x ist 9 int y = 7 % 4 ; // Wert von y ist 3 x = y ++ ; // Achtung Wert von x ist 3 (Postfix); Wert von y ist 4 x = y ; // Wert von x ist 4 boolean a = ( 7 > 4 ); // Wert von a ist true a = ! a ; // Wert von a ist false a = ( a || true ); // Wert von a ist true a = !! a && true ; // Wert von a ist true Beachte Generell gilt bei der Zuweisung immer , dass der Ausdruck auf der rechten Seite erst vollst\u00e4ndig ausgerechnet wird und der berechnete Wert dann der Variablen auf der linken Seite zugewiesen wird. \"Leider\" macht der Postfix-Operator dabei eine Ausnahme . Bei diesem Operator erfolgt erst die Zuweisung und dann die Berechnung: int x = 3 ; // x hat den Wert 3 int y = x ++ ; // y hat den Wert 3 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = a -- ; // b hat den Wert 3 und a den Wert 2 Das gilt nicht f\u00fcr den Pr\u00e4fix-Operator: int x = 3 ; // x hat den Wert 3 int y = ++ x ; // y hat den Wert 4 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = -- a ; // b hat den Wert 2 und a den Wert 2","title":"Ausdr\u00fccke"},{"location":"ausdruecke/#operatoren-und-ausdrucke","text":"Im vorherigen Abschnitt haben wir Variablen und Datentypen kennengelernt. Wir k\u00f6nnen Variablen deklarieren und initialisieren und ihnen neue Werte zuweisen. Nun f\u00fchren wir Operationen ein, die wir in den jeweiligen Datentypen verwenden k\u00f6nnen, um neue Werte zu erzeugen. Wir beginnen bei den arithmetischen Operatoren, d.h. mit den Operatoren, die wir f\u00fcr die ganzzahligen Datentypen und die Gleitkomma-Datentypen verwenden k\u00f6nnen.","title":"Operatoren und Ausdr\u00fccke"},{"location":"ausdruecke/#arithmetische-operatoren","text":"Arithmetische Operationen kennen wir nat\u00fcrlich schon. Die einfachsten arithmetischen Operatoren sind die un\u00e4ren Operatoren, auch Vorzeichenoperatoren genannt. Ansonsten gibt es die Addition + , die Subtraktion - , die Multiplikation * und die Division / . Au\u00dferdem gibt es auch einen Restwertoperator (auch modulo genannt), der bei der ganzzahligen Division den verbleibenden Rest als Ergebnis ermittelt ( % ). Ganz wichtig ist, dass das Divisionssymbol / eine unterschiedliche Bedeutung hat, je nachdem, ob wir ganze Zahlen dividieren oder Gleitkommazahlen. Bei der Division von ganzen Zahlen ist das Ergebnis der Division der ganzzahlige Wert (also z.B. 5 / 4 ergibt 1 ), aber bei der Division von Gleitkommazahlen ein Gleitkommawert (also z.B. 5.0 / 4.0 ergibt 1.25 ). Der Restwertoperator wird wirklich sinnvoll eigentlich nur f\u00fcr ganze Zahlen verwendet (also z.B. 7 % 4 ergibt 3 - der verbleibende Rest der ganzzahligen Divsion ist 3 ). Trotzdem kann der Restwertoperator auch auf Gleitkommazahlen angewendet werden (obwohl dort ja eigentlich kein Rest bleibt). So ergibt 7.0 % 4.0 auch 3.0 und/aber 7.5 % 4.0 ergibt 3.5 . Operatorsymbol(e) Bedeutung Beispiel Un\u00e4re Operatoren + Wird als Vorzeichen vor ganzen Zahlen (z.B. +5 ) oder vor Gleikommazahlen (z.B. +5.5 ) verwendet. + \u00e4ndert nichts und kann immer weggelassen werden. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = +x; Wert von x ist -5 - Wird als Vorzeichen vor ganzen Zahlen (z.B. -5 ) oder vor Gleikommazahlen (z.B. -5.5 ) verwendet. -x dreht das Vorzeichen von x um. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = -x; Wert von x ist +5 double y = -5.5; y = -y; Wert von y ist +5.5 Bin\u00e4re Operatoren + Addition von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 + 6; Wert von x: +1 double y = -5.5 + 6.5; Wert von y: +1.0 - Subtraktion von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 - 6; Wert von x ist -11 double y = -5.5 - 6.5; Wert von y: -12.0 * Multiplikation von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 * 6; Wert von x: -30 double y = -5.0 * 6.0; Wert von y: -30.0 / Division von Zahlen. Achtung! Sie m\u00fcssen unterscheiden, ob Sie ganze Zahlen dividieren oder Gleitkommazahlen! Bei ganzen Zahlen handelt es sich um die ganzzahlige Division! int x = 5 / 4; Wert von x: +1 double y = 5.0 / 4.0; Wert von y: +1.25 % Restwertoperator. Ergebnis ist der Rest, der bei ganzzahliger Division \u00fcbrig bleibt. Wirklich sinnvoll nur bei ganzzahligen Werten, geht aber auch bei Gleitkommazahlen. int x = 7 % 4; Wert von x ist 3 double y = 6.5 % 5.0; Wert von y ist 1.5","title":"Arithmetische Operatoren"},{"location":"ausdruecke/#pra-und-postfix-operatoren","text":"Dar\u00fcber hinaus gibt es noch besondere Operatoren, die eingef\u00fchrt wurden, weil sie eine h\u00e4ufig vorkommende Operation in der Schreibweise verk\u00fcrzen. Angenommen, wir haben eine Variable int x = 5; . Da es (insbesondere sp\u00e4ter in Schleifen) h\u00e4ufig vorkommt, dass der Wert dieser Variablen um 1 erh\u00f6ht werden soll, hat man daf\u00fcr einen eigenen Operator eingef\u00fchrt: ++ . Dieser Operator steht f\u00fcr die Erh\u00f6hung des Wertes um den Summanden 1 . Er kann sowohl als Pr\u00e4fix-Operator ( ++x ) als auch als Postfix-Operator eingesetzt werden. Man spricht hier von Pr\u00e4- und Postfix- Inkrement -Operatoren. 1 2 3 4 5 int x = 5 ; System . out . println ( x ++ ); // 5 System . out . println ( x ); // 6 System . out . println ( ++ x ); // 7 System . out . println ( x ); // 7 Der Unterschied zwischen den beiden wird im obigen Beispiel deutlich. x hat nach der Initialisierung den Wert 5 . In Zeile 2 geben wir den Wert aus und erh\u00f6hen x danach um 1 . Ausgegeben wird also der Wert 5 , aber nach der Ausgabe ist der Wert um 1 erh\u00f6ht auf 6 (siehe Zeile 3 ). Bei dem Prefix-Operator (Zeile 4 ) wird der Wert erst erh\u00f6ht und dann ausgelesen. Es wird also bereits der neue Wert 7 ausgegeben. Im Prinzip entsprechen beide Operatoren aber der Anweisung x = x + 1; . Den \u00e4quivalenten Operator gibt es auch f\u00fcr die Subtraktion minus 1 . Dies wird mit dem Prefix-Operator --x; sowie mit dem Postfix-Operator x--; erreicht. Diese hei\u00dfen Pr\u00e4- und Postfix- Dekrement -Operatoren.","title":"Pr\u00e4- und Postfix-Operatoren"},{"location":"ausdruecke/#verkurzte-schreibweisen-fur-arithmetische-operatoren","text":"Aus dieser Verwendung haben sich weitere Schreibweisen etabliert: Operatoren (Beispiele) Bedeutung x+=7; x = x + 7; x-=7; x = x - 7; x*=7; x = x * 7; x/=7; x = x / 7; x%=7; x = x % 7;","title":"Verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren"},{"location":"ausdruecke/#vergleichsoperatoren","text":"Werden die oben genannten Operatoren auf arithmetische Datentypen angewendet, so ist das Ergebnis selbst wieder von einem arithmetischen Datentyp ( int oder double ). Bei den folgenden Vergleichsoperatoren ist das anders. Die Operanden sind zwar auch wieder von arithmetischen Datentypen, aber das Ergebnis ist ein boolean , das hei\u00dft, der Vergleich resultiert in einem Wert true oder in einem Wert false . Vergleichsoperator Beispiel Bedeutung == x == y Vergleich auf Gleichheit. Ergibt true , wenn x den gleichen Wert hat wie y , sonst false < x < y Kleiner als. Ergibt true , wenn x einen echt kleineren Wert hat als y , sonst false > x > y Gr\u00f6\u00dfer als. Ergibt true , wenn x einen echt gr\u00f6\u00dferen Wert hat als y , sonst false < = x < = y Kleiner gleich. Ergibt true , wenn x einen kleineren als oder den gleichen Wert wie y hat, sonst false >= x >= y Gr\u00f6\u00dfer gleich. Ergibt true , wenn x einen gr\u00f6\u00dferen als oder den gleichen Wert wie y hat, sonst false != x != y Ungleich. Ergibt true , wenn x einen anderen Wert hat als y , sonst false","title":"Vergleichsoperatoren"},{"location":"ausdruecke/#wertzuweisungsoperator","text":"Einen weiteren Operator kennen wir bereits, den Wertzuweisungsoperator = . Auf der linken Seite der Zuweisung steht immer eine Variable und auf der rechten Seite ein Wert, der sich auch aus einem Ausdruck ergeben kann, z.B. int x = 5 + 6; . Dann wird x der Wert 11 zugeweisen. Beachte Der Zuweisungsoperator ist zun\u00e4chst gew\u00f6hnungsbed\u00fcrftig, denn eine Zuweisung der Form x = x+1; sieht ja aus mathematischer Sicht komisch aus, da in der Mathematik das Symbol = f\u00fcr die Gleichheit verwendet wird. In der (Java-)Programmierung hat dieses Symbol aber eine andere Bedeutung, n\u00e4mlich die Zuweisung des Wertes auf der rechten Seite zur Variablen auf der linken Seite. In der Zuweisung x = x+1; wird also erst der Wert x+1 berechnet und dieser Wert dann der Variablen x zugeordnet (die dann einen um 1 h\u00f6heren Wert hat als zuvor). Der Operator f\u00fcr die Gleichheit ist \u00fcbrigens == , wie wir gleich sehen werden.","title":"Wertzuweisungsoperator"},{"location":"ausdruecke/#logische-operatoren","text":"Die arithmetischen Operatoren werden auf Operanden angewendet, die von einem ganzzahligen Datentyp oder von einem Gleitkomma-Datentyp sind. Jetzt lernen wir Operatoren kennen, die auf Operanden vom Typ boolean angewendet werden. Nehmen wir in der folgenden Tabelle an, dass die Variablen a und b jeweils vom Typ boolean sind. Sie wurden also wie folgt deklariert: boolean a; und boolean b; . Logischer Operator Beispiel Bedeutung && a && b UND-Operator. Ergibt true , wenn a den Wert true hat UND b auch den Wert true , sonst false || a || b ODER-Operator. Ergibt true , wenn a den Wert true hat ODER b den Wert true (oder beide), sonst false ^ a ^ b EXCLUSIVES ODER. Ergibt true , wenn ENTWEDER a den Wert true hat ODER b den Wert true (aber NICHT beide), sonst false ! !a NEGATION (un\u00e4rer Operator). Ergibt true , wenn a den Wert false hat, ergibt false , wenn a den Wert true hat Es sein angemerkt, dass es f\u00fcr die Operatoren && und || jeweils auch die Operatoren & und | gibt. Das logische Prinzip ist das gleiche (also UND und ODER). Es gibt nur jeweils eine Unterscheidung und diese ist im folgenden Beispiel dargestellt: false && a // a wird nicht mehr gepr\u00fcft, Ausdruck ist false false & a // a wird gepr\u00fcft, Ausdruck ist false true || b // b wird nicht mehr gepr\u00fcft, Ausdruck ist true true | b // b wird gepr\u00fcft, Ausdruck ist true Ist beim logischen UND bereits der erste Operand false , dann kann das Ergebnis nicht mehr true sein, sondern ist false . Egal, welchen Wert der zweite Operand hat. Bei dem Operator && wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator & aber doch. && ist somit effizienter. Ist beim logischen ODER bereits der erste Operand true , dann ist das Ergebnis bereits true , egal, welchen Wert der zweite Operand hat. Bei dem Operator || wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator | aber doch. || ist somit effizienter. Wir verwenden deshalb immer && und || anstatt & und | .","title":"Logische Operatoren"},{"location":"ausdruecke/#wahrheitstabellen","text":"Hier nochmal eine Veranschaulichung der obigen logischen Operatoren in einer Wahrheitstabelle. Wir nehmen wieder an, dass die Variablen a und b jeweils vom Typ boolean sind. a b a && b a || b a ^ b !a true true true true false false true false false true true false false true false true true true false false false false false true \u00dcbung Exclusives Oder Angenommen, es g\u00e4be den Operator ^ f\u00fcr das Exclusive Oder nicht und Sie h\u00e4tten nur die Operatoren && , || und ! . Wie k\u00f6nnen Sie mit && , || und ! das exclusive Oder \"nachbauen\"?","title":"Wahrheitstabellen"},{"location":"ausdruecke/#ausdrucke-und-anweisungen","text":"Anweisungen haben wir bereits kennengelernt. Zum Beispiel sind Deklarationen Anweisungen und Initialisierungen auch. Neben Anweisungen gibt es im Programmcode auch Ausdr\u00fccke . Ausdr\u00fccke unterscheiden sich von Anweisungen dahingehened, dass sie einen Wert (genauer einen R\u00fcckgabewert ) haben. Jeder Wert in Java hat einen Typ. Wir schauen uns zun\u00e4chst die einfachsten Ausdr\u00fccke an, die es gibt, n\u00e4mlich sogenannte Literale .","title":"Ausdr\u00fccke und Anweisungen"},{"location":"ausdruecke/#literale","text":"Ein Literal ist ein konstanter Wert im Java-Quellcode. Literale sind z.B. ganze Zahlen (z.B. 123 oder -123 ), Gleikommazahlen (z.B 5.5 oder -6.0 ), Wahrheitswerte ( true oder false ), ein Character (z.B. 'a' oder 'A' ) Wir werden sp\u00e4ter noch andere Literale kennenlernen: Zeichenketten (Datentyp String ), z.B. \"Hallo FIW!\" die leere Referenz null Jedes Literal ist ein Ausdruck. Der R\u00fcckgabewert des Literals ist der Wert des Literals. Jedes Literal ist von einem konkreten Datentyp. Die folgenden Anweisungen werden auch Ausdrucksanweisung genannt, da in der Anweisung ein Ausdruck verwendet wird und der Wert dieses Ausdrucks als Nebeneffekt zum Tragen kommt (nur die ersten beiden sind Ausdrucksanweisungen - die folgenden drei sind Fehler ): int x = 123 ; // auf der rechten Seite des Zuweisungsoperators steht ein Ausdruck; // der Wert des Ausdrucks wird der Wert der Variablen x x ++ ; // x++ ist ein Ausdruck - durch das Semikolon wird der Ausdruck hier zu einer Ausdrucksanweisung x ++ // der Ausdruck selbst kann so nicht stehen (Compilerfehler) // da steht nur ein Wert mit dem nichts gemacht wird 5 + 6 // gleicher Fehler wie oben; nur ein Ausdruck, kann so nicht alleine stehen 5 + 6 ; // geht auch nicht; hier gibt es keinen Nebeneffekt (keine Zuweisung) // keine g\u00fcltige Ausdrucksanweisung Ausdr\u00fccke sind Literale Literale, die mit (passenden) Operatoren verkn\u00fcpft sind Ausdr\u00fccke, die mit passenden Operatoren verkn\u00fcpft sind","title":"Literale"},{"location":"ausdruecke/#ausdrucke-mit-operatoren","text":"Verbinden wir Literale mit Operatoren, entstehen dadurch Ausdr\u00fccke. Ausdr\u00fccke k\u00f6nnen wiederum mithilfe von Operatoren mit weiteren Literalen oder auch mit weiteren Ausdr\u00fccken verbunden werden. Beachten Sie, dass Ausdr\u00fccke immer einen Wert haben, der Wert ermittelt wird, indem der Ausdruck aufgel\u00f6st wird, d.h. die Operatoren angewendet werden. Dies erfolgt in folgender Reihenfolge: wenn runde Klammern um einen Ausdruck gesetzt sind, wird zun\u00e4chst der geklammerte Ausdruck aufgerufen, un\u00e4re (also einelementige) Operatoren binden st\u00e4rker als bin\u00e4re (also zweielementige) Operatoren, d.h. es werden zun\u00e4chst die einelementigen Operatoren angewendet, bei arithmetischen Operatoren gilt \"Punkt vor Strich-Rechnung\", bei logischen Operatoren gilt folgende Reihenfolge (st\u00e4rkere Bindung von links nach rechts) == , != -> & \u2192 ^ \u2192 | \u2192 && \u2192 || (lernen Sie das aber keinesfalls auswendig und verlassen sich dann auf Ihr Ged\u00e4chtnis, sondern verwenden Sie Klammern!) der Zuweisungsoperator ( = ) sowie += , -= , /= , *= , %= binden am schw\u00e4chsten dann erfolgt die Aufl\u00f6sung von links nach rechts Achten Sie darauf, dass Ausdr\u00fccke einen anderen Typ haben k\u00f6nnen als die Literale (bzw. Ausdr\u00fccke), die man im Ausdruck mithilfe von Operatoren miteinander verbindet, z.B. 3 == 4 ist vom Typ boolean , aber 3 und 4 sind jeweils vom Typ int . Beispiele f\u00fcr Ausdr\u00fccke sind: 5 + 6 - 8 // Ergebnis (Wert) ist ein int true && false // Ergebnis (Wert) ist ein boolean 5 < 6 // Ergebnis (Wert) ist ein boolean 7 >= 7 // Ergebnis (Wert) ist ein boolean 6 == 6 // Ergebnis (Wert) ist ein boolean 6 != 6 // Ergebnis (Wert) ist ein boolean 5.5 * 2.0 // Ergebnis (Wert) ist ein double 7.0 / 4.0 // Ergebnis (Wert) ist ein double ( 7.0 / 4.0 ) > 1.0 // Ergebnis (Wert) ist ein boolean \u00dcbung Ausdruck Angenommen, a , b und c seien vom Typ int . Was ist an diesem Ausdruck falsch: a < b < c ? Wie w\u00e4re es richtig? \u00dcbung Durchschnitt berechnen Angenommen, Sie sollen die Durchschnittsnote von folgenden Noten berechnen: 1 , 1 , 1 , 1 , 2 , 2 , 3 , 4 . Sie \u00fcberlegen sich folgendes Programm daf\u00fcr: int summe = 1 + 1 + 1 + 1 + 2 + 2 + 3 + 4 ; int anzahl = 8 ; System . out . println ( summe / anzahl ); Vom Ergebnis sind Sie aber entt\u00e4uscht. Welches Ergebnis wird ausgegeben? Welches w\u00e4re richtig gewesen? Was ist an Ihrem Programm falsch? Wie geht es besser? Bei der Verwendung des Zuweisungsoperators gibt es auf der linken Seite immer eine Variable und auf der rechten Seite immer einen Ausdruck. Bevor die Zuweisung erfolgt, wird der Wert des Ausdrucks auf der rechten Seite ausgewertet. Beispiele: int x = 0 ; // Wert von x ist 0 x = 7 + 4 / 2 ; // Wert von x ist 9 int y = 7 % 4 ; // Wert von y ist 3 x = y ++ ; // Achtung Wert von x ist 3 (Postfix); Wert von y ist 4 x = y ; // Wert von x ist 4 boolean a = ( 7 > 4 ); // Wert von a ist true a = ! a ; // Wert von a ist false a = ( a || true ); // Wert von a ist true a = !! a && true ; // Wert von a ist true Beachte Generell gilt bei der Zuweisung immer , dass der Ausdruck auf der rechten Seite erst vollst\u00e4ndig ausgerechnet wird und der berechnete Wert dann der Variablen auf der linken Seite zugewiesen wird. \"Leider\" macht der Postfix-Operator dabei eine Ausnahme . Bei diesem Operator erfolgt erst die Zuweisung und dann die Berechnung: int x = 3 ; // x hat den Wert 3 int y = x ++ ; // y hat den Wert 3 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = a -- ; // b hat den Wert 3 und a den Wert 2 Das gilt nicht f\u00fcr den Pr\u00e4fix-Operator: int x = 3 ; // x hat den Wert 3 int y = ++ x ; // y hat den Wert 4 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = -- a ; // b hat den Wert 2 und a den Wert 2","title":"Ausdr\u00fccke mit Operatoren"},{"location":"bluej/","text":"BlueJ \u00b6 Wir lernen unsere Entwicklungsumgebung kennen, die wir in den ersten Wochen f\u00fcr das Programmieren nutzen werden. Es handelt sich um BlueJ . BlueJ wurde extra f\u00fcr Studierende entwickelt, die Programmieren lernen. Das J in BlueJ steht f\u00fcr Java . Mit BlueJ wird also das Programmieren mit Java gelernt. Eine wesentliche Idee hinter der Entwicklung von BlueJ bestand darin, gleich am Anfang mit der objektorientierten Programmierung zu beginnen, d.h. sich gleich mit Klassen und Objekten zu besch\u00e4ftigen. Das passiert h\u00e4ufig erst recht sp\u00e4t in der Programmierausbildung. Wir geben zun\u00e4chst einen groben \u00dcberblick und lernen dabei in kurzer Zeit viele neue Konzepte und Begriffe kennen. Aber keine Sorge, mit all diesen Konzepten besch\u00e4ftigen wir uns jeweils noch ganz ausf\u00fchrlich. Objekte und Klassen \u00b6 Wenn wir uns die Welt betrachten, dann besteht diese aus lauter Objekten , die miteinander in Beziehung stehen. Man ganz konkret \u00fcber bestimmte Objekte sprechen: \u201edas ist ein sch\u00f6ner Stuhl\u201c \u201edas ist ein teurer Tisch\u201c \u201edas Auto ist blau\u201c oder ganz allgemein \u00fcber eine Klasse von Objekten: \u201eInformatikerInnen sind Nerds\u201c \u201eComputer machen immer, was sie wollen\u201c \u201edie Bahnen kommen immer zu sp\u00e4t\u201c In der Welt des objektorientierten Programmierens sind die Klassen die \"Muster\" oder die \"Bauanleitungen\" f\u00fcr konkrete Objekte . Mit Klassen beschreiben wir die allgemeinen Eigenschaften, die f\u00fcr alle Objekte dieser Klasse gelten. Klassen beschreiben eine Struktur der Objekte (das sind die sogenannten Objektvariablen ) und ein Verhalten dieser Objekte (das sind die sogenannten Objektmethoden ). Insgesamt sprechen wir bei der Struktur und dem Verhalten von den Eigenschaften einer Klasse. Eine Klasse ist ein Datentyp und jeder \"Wert\" 1 ist ein konkretes Objekt von diesem Typ. Von einer Klasse k\u00f6nnen wir beliebig viele Objekte erzeugen. Objekte werden aus Klassen erzeugt. Eine Klasse beschreibt die Art und Weise, den Aufbau von Objekten. Objekte sind die speziellen Instanzen einer allgemeinen Klasse. Ein typisches Beispiel ist Auto . Ein Auto kann fahren, hat eine Farbe, ist von einer bestimmten Marke, hat einen bestimmten Motor, eine bestimmte Anzahl von T\u00fcren und so weiter. Das sind alles Eigenschaften eines Autos. Diese Eigenschaften werden in einer Klasse definiert und beschreiben ein Auto im Allgemeinen. Davon gibt es dann konkrete Objekte: ein roter VW Golf mit 5 T\u00fcren, ein blauer Toyota mit 3 T\u00fcren usw. Eine Klasse beschreibt also alle m\u00f6glichen Objekte, die von dieser Klasse erstellt werden k\u00f6nnen. Die Eigenschaften der Objekte werden in Objektvariablen und Objektmethoden beschrieben. Beispiele daf\u00fcr zeigen zun\u00e4chst die folgenden Abbildungen: Objektvariablen \u00b6 In der Klasse Stuhl ist beschrieben, dass jeder Stuhl (jedes Stuhl -Objekt) eine Inventarnummer hat, in einem Raum steht, eine bestimmt Anzahl Beine hat und einen Status , der beschreibt, ob er frei oder besetzt ist. Diese Eigenschaften werden als Objektvariablen definiert. Jedes Objekt der Klasse Stuhl hat seinen eigenen Objektvariablen , n\u00e4mlich genau die vier. Das bedeutet, alle Objekte der Klasse Stuhl haben die gleichen Eigenschaften, aber die konkreten Werte dieser Objektvariablen sind von Stuhl(-Objekt) zu Stuhl(-Objekt) unterschiedlich. Vier konkrete Stuhl-Objekte stuhl1 , stuhl2 , stuhl3 und stuhl4 sind in der Abbildung dargestellt. Objektmethoden \u00b6 Jedes Objekt der Klasse Stuhl hat jeweils konkrete Werte f\u00fcr die Objektvariablen. Zum Beispiel hat das Objekt stuhl1 den Wert 1 f\u00fcr die Inventarnummer , den Wert 123 f\u00fcr den Raum , den Wert 4 f\u00fcr Anzahl Beine und den Wert frei f\u00fcr Status . Wie k\u00f6nnen diese Werte ge\u00e4ndert werden? Die Antwort ist: durch Objektmethoden . Objektmethoden beschreiben das Verhalten eines Objektes. Z.B. kann der Status dadurch ge\u00e4ndert werden, dass man sich auf den Stuhl setzt oder wieder aufsteht. Solche T\u00e4tigkeiten bzw. so ein Verhalten lassen sich durch Obejktmethoden beschreiben. Darin wird etwas getan und zwar haupts\u00e4chlich die Werte von Objektvariablen ge\u00e4ndert oder einfach ausgelesen. M\u00f6gliche Objektmethoden w\u00e4ren also aufstehen (den Status in frei \u00e4ndern), hinsetzen (den Status in besetzt \u00e4ndern), umziehen (den Raum \u00e4ndern), inventarisieren (die Inventarnummer auslesen), zusammenkrachen (die Anzahl Beine \u00e4ndern) usw. Ein erstes Beispiel mit BlueJ \u00b6 Wir \u00f6ffnen BlueJ dann im Men\u00fc auf Project --> Open Project . Im examples -Ordner von BlueJ finden wir den Ordner shapes . Wir w\u00e4hlen den Ordner und klicken auf Open . Es erscheint: Klicken Sie den Button Compile . Objekt erzeugen \u00b6 Klicken Sie dann mit der rechten Maustaste auf das orangene K\u00e4stchen Circle und w\u00e4hlen aus dem Kontextmen\u00fc new Circle () Den Namen circle1 k\u00f6nnen Sie einfach mit Ok best\u00e4tigen. Sie haben soben Ihr erstes Objekt erzeugt! Das orangene K\u00e4stchen, auf das Sie mit der rechten Maus geklickt haben, repr\u00e4sentiert die Klasse Circle . Das rote K\u00e4stchen links unten mit dem Namen circle1 repr\u00e4sentiert ein Objekt dieser Klasse. Konvention: Klassennamen beginnen immer mit Gro\u00dfbuchstaben und Objektnamen immer mit einem kleinen Buchstaben. Methoden aufrufen \u00b6 Klicken Sie nun mit der rechten Maustaste auf das rote K\u00e4stchen circle1 (also auf das Objekt) und w\u00e4hlen dann void makeVisible () aus. Es erscheint: makeVisible() ist eine Methode . Genauer gesagt, handelt es sich um eine Objektmethode . Als wir darauf geklickt haben, haben wir diese Methode aufgerufen . \u00dcbung Methoden aufrufen Rufen Sie (auch mehrmals) die Methoden makeLeft() , makeRight() , makeUp und makeDown() auf. Rufen Sie auch makeInvisible() und dann wieder makeVisible() auf. Methoden erkennen wir an den runden Klammern () hinter dem Namen. In diesen Klammern kann auch ein Wert stehen. Dazu kommen wir jetzt, zu den sogenannten Parametern . Parameter \u00b6 Nun rufen wir die Methode moveHorizontal(int distance) auf. Es erscheint ein Dialog: geben Sie in das Eingabefeld eine Zahl ein, z.B. 50 und klicken OK . Der Kreis bewegt sich horizontal um 50 Bildschirmpunkte nach rechts. Wir \u00fcbergeben dem Methodenaufruf einen Wert (hier: der Wert 50 ). Klicken Sie mit der rechten Maustaste auf das orangene K\u00e4stchen Circle1 (also auf die Klasse Circle ) und w\u00e4hlen Sie Open Editor . Es erscheint: Das Fenster, das sich \u00f6ffnet, ist der sogenannte Editor . Darin sehen wir die Implementierung der Klasse Circle . So sieht ein Java-Programm aus. Wir kommen zu den Details sp\u00e4ter. Zun\u00e4chst suchen wir den folgenden gelb hinterlegten Block (ab Zeile 81 2 ): /** * Move the circle horizontally by 'distance' pixels. */ public void moveHorizontal ( int distance ) { erase (); xPosition += distance ; draw (); } Bei den ersten drei Zeilen /** * Move the circle horizontally by 'distance' pixels. */ handelt es sich um einen Kommentar (genauer gesagt, um einen JavaDoc-Kommentar). Wir kommen bald zu Kommentaren. Jetzt geht es uns zun\u00e4chst nur um diese Zeile: public void moveHorizontal ( int distance ) Dies ist die sogenannte Signatur der Methode moveHorizontal . moveHorizontal ist der Name der Methode und distance ist der Name des Parameters der Methode. Vor dem Namen des Parameters steht ein Datentyp . In diesem Fall ist es der Datentyp int . Datentypen \u00b6 int steht f\u00fcr Integer und bedeutet ganze Zahl (also auch negative Zahlen). Wir werden uns ausgiebig mit Datentypen besch\u00e4ftigen. In dem Beispiel int distance steht der Datentyp int daf\u00fcr, dass wir der Methode moveHorizontal bei dem Aufruf einen ganzzahligen Wert \u00fcbergeben m\u00fcssen. Rufen Sie die Methode moveHorizontal auf und \u00fcbergeben Ihr einen negativen Zahlenwert! Wenn wir uns die Java-Implementierung der Klasse Circle nochmal genauer anschauen, dann sehen wir, dass die Methoden entweder keinen Parameter haben: public Circle () public void makeVisible () public void makeInvisible () public void moveRight () public void moveLeft () public void moveUp () public void moveDown () private void draw () private void erase () , dann muss dem Aufruf der Methode kein Wert \u00fcbergeben werden. Oder die Methode erwartet einen Parameterwert und dieser Wert muss einer ganzen Zahl entsprechen: public void moveHorizontal ( int distance ) public void moveVertical ( int distance ) public void slowMoveHorizontal ( int distance ) public void slowMoveVertical ( int distance ) public void changeSize ( int newDiameter ) Au\u00dferdem gibt es noch eine Methode, die als Parameterwert einen String erwartet. String ist ebenfalls ein Datentyp. Dieser Datentyp steht aber nicht f\u00fcr ganze Zahlen, sondern f\u00fcr Zeichenketten . public void changeColor ( String newColor ) Zeichenketten ( String ) schreiben wir in Java in doppelten Anf\u00fchrungszeichen \"Zeichenkette\" . Rufen Sie die Methode changeColor auf und \u00fcbergeben Sie als Parameterwert \"red\" . Probieren Sie auch die Werte \"yellow\" , \"green\" , \"magenta\" und \"black\" aus. Fragen Was passiert, wenn Sie nur red schreiben? Was passiert, wenn Sie \"pink\" schreiben? Was passiert, wenn Sie \"blau\" schreiben? Was passiert, wenn Sie \"hallo\" schreiben? Mehrere Objekte \u00b6 Von unserer Klasse Circle haben wir bereits ein Objekt circle1 erzeugt. Von einer Klasse lassen sich beliebig viele Objekte erzeugen! Alle diese Objekte haben dieselben Eigenschaften! Das bedeutet, dass all diesen Objekten, die Sie erzeugen, die gleichen Objektmethoden zur Verf\u00fcgung stehen (und auch die gleichen Objektvariablen). Aufgabe Erzeugen Sie f\u00fcnf Objekte von der Klasse Circle . Weisen Sie allen Objekten unterschiedliche Farben zu! Sorgen Sie daf\u00fcr, dass sich die Objekte in der Darstellung nicht \u00fcberdecken! Wie Sie sehen, haben zwar alle Objekte dieselben Eigenschaften (dieselben Objektmethoden und dieselben Objektvariablen). Aber wir k\u00f6nnen ihnen jeweils unterschiedliche Werte zuweisen, so dass einige Circle -Objekte z.B. rot oder blau oder schwarz sind und auch jeweils andere Positionen haben. Wir schauen uns im Folgenden an, dass jedes Objekt einen eigenen Zustand hat. Der Zustand eines Objektes \u00b6 Klicken Sie mit der rechten Maustaste auf ein Objekt und w\u00e4hlen Sie Inspect . Es \u00f6ffnet sich das folgende Fenster: Lassen Sie dieses Inspektionsfenster ge\u00f6ffnet und \u00e4ndern Sie die Farbe des Objektes. Was beobachten Sie im Inspektionsfenster? Das Inspektionsfenster zeigt den Zustand eines Objektes. Der Zustand wird durch die Werte der Objektvariablen beschrieben. Schauen wir uns die Java-Implementierung der Klasse Circle an, dann finden wir in den Zeilen 13-17 folgende Anweisungen: private int diameter ; private int xPosition ; private int yPosition ; private String color ; private boolean isVisible ; Das sind die Objektvariablen der Klasse Circle . Jedes Objekt der Klasse Circle besitzt seine eigenen Objektvariablen. Jede Variable hat einen Wert . Die Variablen diameter , xPosition und yPosition haben als Wert eine ganze Zahl. Diese Zahl gibt z.B. f\u00fcr diameter die Gr\u00f6\u00dfe des Umfanges des Kreises an. Der Wert f\u00fcr xPosition beschreibt den Wert auf der x-Koordinate und der Wert von yPosition beschreibt den Wert auf der y-Koordinate zur Darstellung des Kreises. Der Wert der Objektvariablen color beschreibt die Farbe des Kreises als Zeichenkette ( String ). Die Objektvariable isVisible ist von einem Datentyp, den wir noch nicht kennen: boolean . Diese Variable kann nur zwei verschiedene Werte annehmen: true (sichtbar) oder false (nicht sichtbar). Die Werte der Variablen k\u00f6nnen mithilfe der Objektmethoden ge\u00e4ndert werden. Fragen Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen color zu \u00e4ndern? Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen diameter zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen isVisible zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen xPosition zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen yPosition zu \u00e4ndern? Die Kombination der Werte aller Objektvariablen beschreibt den Zustand eines Objektes. Aufgabe Erzeugen Sie mehrere Objekte der Klasse Circle ! \u00d6ffnen Sie f\u00fcr alle Objekte jeweils das Inspektionsfenster. \u00c4ndern Sie f\u00fcr unterschiedliche Objekte die Werte von Objektvariablen durch Methodenaufrufe und beobachten Sie die jeweiligen Zustands\u00e4nderungen. Zusammenfassung \u00b6 Wir haben viele neue Begriffe kennengelernt: Klassen und Objekte , Methoden , Methodenaufrufe , Parameter , Datentypen ( int , String , boolean ), Objektvariablen , Objektmethoden , Zustand eines Objektes. Das ist ganz sch\u00f6n viel auf einmal! Diese Begriffe werden wir in den kommenden Wochen verwenden und vertiefen. Zun\u00e4chst zum Abschluss noch eine \"kleine\" Aufgabe zum Entspannen. Zeichnen Sie dieses Bild: Success Wir kennen schon Klassen, Objekte, Objektvariablen, Objektmethoden, Parameter, einige Datentypen, k\u00f6nnen Objekte erzeugen und Objektmethoden aufrufen. Super! In der objektorientierten Programmierung unterscheiden wir sehr genau zwischen Objekten und Werten. Werte sind soetwas wie 4 , true , 5.5 usw. Solche Werte haben kein Verhalten. Objekte haben aber ein Verhalten (die Objektmethoden - siehe z.B. f\u00fcr String die Methoden charAt() , length() , substring() ). Wir werden sehr detailliert auf die Unterschiede zwischen Werten und Objekten eingehen. Die Datentypen, die wir erstellen, sind sogenannte Referenztypen . Eine Variable von so einem Referenztyp zeigt auf (referenziert) ein Objekt. \u21a9 Um sich die Zeilennummern anzeigen zu lassen, \u00f6ffnen Sie das BlueJ -Men\u00fc und w\u00e4hlen Preferences . Unter dem Reiter Editor finden Sie Display line numbers . Setzen Sie dort das H\u00e4kchen. \u21a9","title":"BlueJ"},{"location":"bluej/#bluej","text":"Wir lernen unsere Entwicklungsumgebung kennen, die wir in den ersten Wochen f\u00fcr das Programmieren nutzen werden. Es handelt sich um BlueJ . BlueJ wurde extra f\u00fcr Studierende entwickelt, die Programmieren lernen. Das J in BlueJ steht f\u00fcr Java . Mit BlueJ wird also das Programmieren mit Java gelernt. Eine wesentliche Idee hinter der Entwicklung von BlueJ bestand darin, gleich am Anfang mit der objektorientierten Programmierung zu beginnen, d.h. sich gleich mit Klassen und Objekten zu besch\u00e4ftigen. Das passiert h\u00e4ufig erst recht sp\u00e4t in der Programmierausbildung. Wir geben zun\u00e4chst einen groben \u00dcberblick und lernen dabei in kurzer Zeit viele neue Konzepte und Begriffe kennen. Aber keine Sorge, mit all diesen Konzepten besch\u00e4ftigen wir uns jeweils noch ganz ausf\u00fchrlich.","title":"BlueJ"},{"location":"bluej/#objekte-und-klassen","text":"Wenn wir uns die Welt betrachten, dann besteht diese aus lauter Objekten , die miteinander in Beziehung stehen. Man ganz konkret \u00fcber bestimmte Objekte sprechen: \u201edas ist ein sch\u00f6ner Stuhl\u201c \u201edas ist ein teurer Tisch\u201c \u201edas Auto ist blau\u201c oder ganz allgemein \u00fcber eine Klasse von Objekten: \u201eInformatikerInnen sind Nerds\u201c \u201eComputer machen immer, was sie wollen\u201c \u201edie Bahnen kommen immer zu sp\u00e4t\u201c In der Welt des objektorientierten Programmierens sind die Klassen die \"Muster\" oder die \"Bauanleitungen\" f\u00fcr konkrete Objekte . Mit Klassen beschreiben wir die allgemeinen Eigenschaften, die f\u00fcr alle Objekte dieser Klasse gelten. Klassen beschreiben eine Struktur der Objekte (das sind die sogenannten Objektvariablen ) und ein Verhalten dieser Objekte (das sind die sogenannten Objektmethoden ). Insgesamt sprechen wir bei der Struktur und dem Verhalten von den Eigenschaften einer Klasse. Eine Klasse ist ein Datentyp und jeder \"Wert\" 1 ist ein konkretes Objekt von diesem Typ. Von einer Klasse k\u00f6nnen wir beliebig viele Objekte erzeugen. Objekte werden aus Klassen erzeugt. Eine Klasse beschreibt die Art und Weise, den Aufbau von Objekten. Objekte sind die speziellen Instanzen einer allgemeinen Klasse. Ein typisches Beispiel ist Auto . Ein Auto kann fahren, hat eine Farbe, ist von einer bestimmten Marke, hat einen bestimmten Motor, eine bestimmte Anzahl von T\u00fcren und so weiter. Das sind alles Eigenschaften eines Autos. Diese Eigenschaften werden in einer Klasse definiert und beschreiben ein Auto im Allgemeinen. Davon gibt es dann konkrete Objekte: ein roter VW Golf mit 5 T\u00fcren, ein blauer Toyota mit 3 T\u00fcren usw. Eine Klasse beschreibt also alle m\u00f6glichen Objekte, die von dieser Klasse erstellt werden k\u00f6nnen. Die Eigenschaften der Objekte werden in Objektvariablen und Objektmethoden beschrieben. Beispiele daf\u00fcr zeigen zun\u00e4chst die folgenden Abbildungen:","title":"Objekte und Klassen"},{"location":"bluej/#objektvariablen","text":"In der Klasse Stuhl ist beschrieben, dass jeder Stuhl (jedes Stuhl -Objekt) eine Inventarnummer hat, in einem Raum steht, eine bestimmt Anzahl Beine hat und einen Status , der beschreibt, ob er frei oder besetzt ist. Diese Eigenschaften werden als Objektvariablen definiert. Jedes Objekt der Klasse Stuhl hat seinen eigenen Objektvariablen , n\u00e4mlich genau die vier. Das bedeutet, alle Objekte der Klasse Stuhl haben die gleichen Eigenschaften, aber die konkreten Werte dieser Objektvariablen sind von Stuhl(-Objekt) zu Stuhl(-Objekt) unterschiedlich. Vier konkrete Stuhl-Objekte stuhl1 , stuhl2 , stuhl3 und stuhl4 sind in der Abbildung dargestellt.","title":"Objektvariablen"},{"location":"bluej/#objektmethoden","text":"Jedes Objekt der Klasse Stuhl hat jeweils konkrete Werte f\u00fcr die Objektvariablen. Zum Beispiel hat das Objekt stuhl1 den Wert 1 f\u00fcr die Inventarnummer , den Wert 123 f\u00fcr den Raum , den Wert 4 f\u00fcr Anzahl Beine und den Wert frei f\u00fcr Status . Wie k\u00f6nnen diese Werte ge\u00e4ndert werden? Die Antwort ist: durch Objektmethoden . Objektmethoden beschreiben das Verhalten eines Objektes. Z.B. kann der Status dadurch ge\u00e4ndert werden, dass man sich auf den Stuhl setzt oder wieder aufsteht. Solche T\u00e4tigkeiten bzw. so ein Verhalten lassen sich durch Obejktmethoden beschreiben. Darin wird etwas getan und zwar haupts\u00e4chlich die Werte von Objektvariablen ge\u00e4ndert oder einfach ausgelesen. M\u00f6gliche Objektmethoden w\u00e4ren also aufstehen (den Status in frei \u00e4ndern), hinsetzen (den Status in besetzt \u00e4ndern), umziehen (den Raum \u00e4ndern), inventarisieren (die Inventarnummer auslesen), zusammenkrachen (die Anzahl Beine \u00e4ndern) usw.","title":"Objektmethoden"},{"location":"bluej/#ein-erstes-beispiel-mit-bluej","text":"Wir \u00f6ffnen BlueJ dann im Men\u00fc auf Project --> Open Project . Im examples -Ordner von BlueJ finden wir den Ordner shapes . Wir w\u00e4hlen den Ordner und klicken auf Open . Es erscheint: Klicken Sie den Button Compile .","title":"Ein erstes Beispiel mit BlueJ"},{"location":"bluej/#objekt-erzeugen","text":"Klicken Sie dann mit der rechten Maustaste auf das orangene K\u00e4stchen Circle und w\u00e4hlen aus dem Kontextmen\u00fc new Circle () Den Namen circle1 k\u00f6nnen Sie einfach mit Ok best\u00e4tigen. Sie haben soben Ihr erstes Objekt erzeugt! Das orangene K\u00e4stchen, auf das Sie mit der rechten Maus geklickt haben, repr\u00e4sentiert die Klasse Circle . Das rote K\u00e4stchen links unten mit dem Namen circle1 repr\u00e4sentiert ein Objekt dieser Klasse. Konvention: Klassennamen beginnen immer mit Gro\u00dfbuchstaben und Objektnamen immer mit einem kleinen Buchstaben.","title":"Objekt erzeugen"},{"location":"bluej/#methoden-aufrufen","text":"Klicken Sie nun mit der rechten Maustaste auf das rote K\u00e4stchen circle1 (also auf das Objekt) und w\u00e4hlen dann void makeVisible () aus. Es erscheint: makeVisible() ist eine Methode . Genauer gesagt, handelt es sich um eine Objektmethode . Als wir darauf geklickt haben, haben wir diese Methode aufgerufen . \u00dcbung Methoden aufrufen Rufen Sie (auch mehrmals) die Methoden makeLeft() , makeRight() , makeUp und makeDown() auf. Rufen Sie auch makeInvisible() und dann wieder makeVisible() auf. Methoden erkennen wir an den runden Klammern () hinter dem Namen. In diesen Klammern kann auch ein Wert stehen. Dazu kommen wir jetzt, zu den sogenannten Parametern .","title":"Methoden aufrufen"},{"location":"bluej/#parameter","text":"Nun rufen wir die Methode moveHorizontal(int distance) auf. Es erscheint ein Dialog: geben Sie in das Eingabefeld eine Zahl ein, z.B. 50 und klicken OK . Der Kreis bewegt sich horizontal um 50 Bildschirmpunkte nach rechts. Wir \u00fcbergeben dem Methodenaufruf einen Wert (hier: der Wert 50 ). Klicken Sie mit der rechten Maustaste auf das orangene K\u00e4stchen Circle1 (also auf die Klasse Circle ) und w\u00e4hlen Sie Open Editor . Es erscheint: Das Fenster, das sich \u00f6ffnet, ist der sogenannte Editor . Darin sehen wir die Implementierung der Klasse Circle . So sieht ein Java-Programm aus. Wir kommen zu den Details sp\u00e4ter. Zun\u00e4chst suchen wir den folgenden gelb hinterlegten Block (ab Zeile 81 2 ): /** * Move the circle horizontally by 'distance' pixels. */ public void moveHorizontal ( int distance ) { erase (); xPosition += distance ; draw (); } Bei den ersten drei Zeilen /** * Move the circle horizontally by 'distance' pixels. */ handelt es sich um einen Kommentar (genauer gesagt, um einen JavaDoc-Kommentar). Wir kommen bald zu Kommentaren. Jetzt geht es uns zun\u00e4chst nur um diese Zeile: public void moveHorizontal ( int distance ) Dies ist die sogenannte Signatur der Methode moveHorizontal . moveHorizontal ist der Name der Methode und distance ist der Name des Parameters der Methode. Vor dem Namen des Parameters steht ein Datentyp . In diesem Fall ist es der Datentyp int .","title":"Parameter"},{"location":"bluej/#datentypen","text":"int steht f\u00fcr Integer und bedeutet ganze Zahl (also auch negative Zahlen). Wir werden uns ausgiebig mit Datentypen besch\u00e4ftigen. In dem Beispiel int distance steht der Datentyp int daf\u00fcr, dass wir der Methode moveHorizontal bei dem Aufruf einen ganzzahligen Wert \u00fcbergeben m\u00fcssen. Rufen Sie die Methode moveHorizontal auf und \u00fcbergeben Ihr einen negativen Zahlenwert! Wenn wir uns die Java-Implementierung der Klasse Circle nochmal genauer anschauen, dann sehen wir, dass die Methoden entweder keinen Parameter haben: public Circle () public void makeVisible () public void makeInvisible () public void moveRight () public void moveLeft () public void moveUp () public void moveDown () private void draw () private void erase () , dann muss dem Aufruf der Methode kein Wert \u00fcbergeben werden. Oder die Methode erwartet einen Parameterwert und dieser Wert muss einer ganzen Zahl entsprechen: public void moveHorizontal ( int distance ) public void moveVertical ( int distance ) public void slowMoveHorizontal ( int distance ) public void slowMoveVertical ( int distance ) public void changeSize ( int newDiameter ) Au\u00dferdem gibt es noch eine Methode, die als Parameterwert einen String erwartet. String ist ebenfalls ein Datentyp. Dieser Datentyp steht aber nicht f\u00fcr ganze Zahlen, sondern f\u00fcr Zeichenketten . public void changeColor ( String newColor ) Zeichenketten ( String ) schreiben wir in Java in doppelten Anf\u00fchrungszeichen \"Zeichenkette\" . Rufen Sie die Methode changeColor auf und \u00fcbergeben Sie als Parameterwert \"red\" . Probieren Sie auch die Werte \"yellow\" , \"green\" , \"magenta\" und \"black\" aus. Fragen Was passiert, wenn Sie nur red schreiben? Was passiert, wenn Sie \"pink\" schreiben? Was passiert, wenn Sie \"blau\" schreiben? Was passiert, wenn Sie \"hallo\" schreiben?","title":"Datentypen"},{"location":"bluej/#mehrere-objekte","text":"Von unserer Klasse Circle haben wir bereits ein Objekt circle1 erzeugt. Von einer Klasse lassen sich beliebig viele Objekte erzeugen! Alle diese Objekte haben dieselben Eigenschaften! Das bedeutet, dass all diesen Objekten, die Sie erzeugen, die gleichen Objektmethoden zur Verf\u00fcgung stehen (und auch die gleichen Objektvariablen). Aufgabe Erzeugen Sie f\u00fcnf Objekte von der Klasse Circle . Weisen Sie allen Objekten unterschiedliche Farben zu! Sorgen Sie daf\u00fcr, dass sich die Objekte in der Darstellung nicht \u00fcberdecken! Wie Sie sehen, haben zwar alle Objekte dieselben Eigenschaften (dieselben Objektmethoden und dieselben Objektvariablen). Aber wir k\u00f6nnen ihnen jeweils unterschiedliche Werte zuweisen, so dass einige Circle -Objekte z.B. rot oder blau oder schwarz sind und auch jeweils andere Positionen haben. Wir schauen uns im Folgenden an, dass jedes Objekt einen eigenen Zustand hat.","title":"Mehrere Objekte"},{"location":"bluej/#der-zustand-eines-objektes","text":"Klicken Sie mit der rechten Maustaste auf ein Objekt und w\u00e4hlen Sie Inspect . Es \u00f6ffnet sich das folgende Fenster: Lassen Sie dieses Inspektionsfenster ge\u00f6ffnet und \u00e4ndern Sie die Farbe des Objektes. Was beobachten Sie im Inspektionsfenster? Das Inspektionsfenster zeigt den Zustand eines Objektes. Der Zustand wird durch die Werte der Objektvariablen beschrieben. Schauen wir uns die Java-Implementierung der Klasse Circle an, dann finden wir in den Zeilen 13-17 folgende Anweisungen: private int diameter ; private int xPosition ; private int yPosition ; private String color ; private boolean isVisible ; Das sind die Objektvariablen der Klasse Circle . Jedes Objekt der Klasse Circle besitzt seine eigenen Objektvariablen. Jede Variable hat einen Wert . Die Variablen diameter , xPosition und yPosition haben als Wert eine ganze Zahl. Diese Zahl gibt z.B. f\u00fcr diameter die Gr\u00f6\u00dfe des Umfanges des Kreises an. Der Wert f\u00fcr xPosition beschreibt den Wert auf der x-Koordinate und der Wert von yPosition beschreibt den Wert auf der y-Koordinate zur Darstellung des Kreises. Der Wert der Objektvariablen color beschreibt die Farbe des Kreises als Zeichenkette ( String ). Die Objektvariable isVisible ist von einem Datentyp, den wir noch nicht kennen: boolean . Diese Variable kann nur zwei verschiedene Werte annehmen: true (sichtbar) oder false (nicht sichtbar). Die Werte der Variablen k\u00f6nnen mithilfe der Objektmethoden ge\u00e4ndert werden. Fragen Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen color zu \u00e4ndern? Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen diameter zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen isVisible zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen xPosition zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen yPosition zu \u00e4ndern? Die Kombination der Werte aller Objektvariablen beschreibt den Zustand eines Objektes. Aufgabe Erzeugen Sie mehrere Objekte der Klasse Circle ! \u00d6ffnen Sie f\u00fcr alle Objekte jeweils das Inspektionsfenster. \u00c4ndern Sie f\u00fcr unterschiedliche Objekte die Werte von Objektvariablen durch Methodenaufrufe und beobachten Sie die jeweiligen Zustands\u00e4nderungen.","title":"Der Zustand eines Objektes"},{"location":"bluej/#zusammenfassung","text":"Wir haben viele neue Begriffe kennengelernt: Klassen und Objekte , Methoden , Methodenaufrufe , Parameter , Datentypen ( int , String , boolean ), Objektvariablen , Objektmethoden , Zustand eines Objektes. Das ist ganz sch\u00f6n viel auf einmal! Diese Begriffe werden wir in den kommenden Wochen verwenden und vertiefen. Zun\u00e4chst zum Abschluss noch eine \"kleine\" Aufgabe zum Entspannen. Zeichnen Sie dieses Bild: Success Wir kennen schon Klassen, Objekte, Objektvariablen, Objektmethoden, Parameter, einige Datentypen, k\u00f6nnen Objekte erzeugen und Objektmethoden aufrufen. Super! In der objektorientierten Programmierung unterscheiden wir sehr genau zwischen Objekten und Werten. Werte sind soetwas wie 4 , true , 5.5 usw. Solche Werte haben kein Verhalten. Objekte haben aber ein Verhalten (die Objektmethoden - siehe z.B. f\u00fcr String die Methoden charAt() , length() , substring() ). Wir werden sehr detailliert auf die Unterschiede zwischen Werten und Objekten eingehen. Die Datentypen, die wir erstellen, sind sogenannte Referenztypen . Eine Variable von so einem Referenztyp zeigt auf (referenziert) ein Objekt. \u21a9 Um sich die Zeilennummern anzeigen zu lassen, \u00f6ffnen Sie das BlueJ -Men\u00fc und w\u00e4hlen Preferences . Unter dem Reiter Editor finden Sie Display line numbers . Setzen Sie dort das H\u00e4kchen. \u21a9","title":"Zusammenfassung"},{"location":"methoden/","text":"Methoden \u00b6 Bis jetzt haben wir unseren Programmcode stets in die main() -Methode geschrieben. Das wird auf Dauer viel zu un\u00fcbersichtlich. Au\u00dferdem versto\u00dfen wir so gegen zwei wichtige Prinzipien der Programmierung: dem Single Responsibility Principle (SRP) und Don't repeat yourself (DRY) . Die urspr\u00fcngliche Formulierung des SRP stammt von Robert C. Martin , der es als ein Prinzip der Objektorientierung einf\u00fchrte und es ein wenig anders meinte, als wir es hier verwenden. Dazu kommen wir, wenn wir uns mit Objektorientierung besch\u00e4ftigen. Wir k\u00f6nnen uns aber als wesentliche Prinzipien schonmal merken, dass eine Variable genau eine Bedeutung haben soll und niemals f\u00fcr verschiedene Bedeutungen benutzt werden sollte (zwei Bedeutungen == zwei Variablen) und eine Methode genau eine Sache erledigen sollte. Zun\u00e4chst schauen wir uns an, was eine Methode \u00fcberhaupt ist und wie wir sie definieren und verwenden. Angenommen, wir haben ein Programm in der folgenden Form: public class Methods { public static void main ( String [] args ) { int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 summand1 = 5 ; summand2 = 9 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 5 + 9 = 14 summand1 = - 115 ; summand2 = 999 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // -115 + 999 = 884 } } In dieser main() -Methode machen wir drei Mal das Gleiche, wir addieren 2 Summanden und geben das Ergebnis der Berechnung aus. Wir sehen insbesondere doppelten (sogar dreifachen) Code, d.h. wir wiederholen uns. Au\u00dferdem geben die vergebenen Namen nur an, wof\u00fcr die Variablen da sind, aber es gibt keine namentliche Beschreibung von dem, WAS wir tun. Methodendefinition \u00b6 Das wollen wir \u00e4ndern und laden den sich wiederholenden Code in eine Methode aus. Diese Methode nennen wir add() : 1 2 3 4 5 public static void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } Betrachten wir diese Definition einer Methode genauer: In Zeile 1 sehen wir den Methodenkopf : Das Schl\u00fcsselwort public besagt, dass diese Methode von allen anderen Klassen (die wir noch nicht haben) aufgerufen werden kann. Es handelt sich um eine \u00f6ffentliche Methode. Wir gehen darauf genauer ein, wenn wir uns mit Sichtbarkeitsmodifizierern besch\u00e4ftigen. Das Schl\u00fcsselwort static besagt, dass wir diese Methode verwenden (aufrufen) k\u00f6nnen, ohne eine Objekt der Klasse Methods erzeugen zu m\u00fcssen. Wir k\u00f6nnen derzeit eh noch keine Objekte erzeugen, also definieren wir zun\u00e4chst alle unsere Methoden als static ( statisch , Klassenmethode ). Das Schl\u00fcsselwort void steht daf\u00fcr, dass der Aufruf unserer Methode keinen Wert hat, d.h. der Aufruf dieser Methode ist eine Anweisung ohne Nebeneffekt. Wenn die Methode einen Wert haben soll, dann wird hier ein Datentyp eingetragen (sehen wir im n\u00e4chsten Beispiel). add ist der Methodenname. Hier gelten die Bedingungen, die wir an Bezeichner in Java haben. Methodennamen beginnen stets mit einem Kleinbuchstaben. Nach dem Methodennamen kommen runde Klammern und darin sogenannte Parameter . Parameter sind Variablen. Parameter werden in der Methodendefinition deklariert, aber nicht initialisiert. Parameter werden beim Aufruf der Methode initialisiert. In den Zeilen 2-5 steht der Methodenk\u00f6rper : Der Methodenk\u00f6rper ist ein Anweisungsblock. Er beginnt mit einer \u00f6ffnenden geschweiften Klammer { (Zeile 2 ) und endet mit einer schlie\u00dfenden geschweiften Klammer } (Zeile 5 ). Innerhalb dieses Anweisungsblocks k\u00f6nnen beliebig viele Anweisungen stehen. In Zeile 3 wird unter Verwendung der Werte der Variablen (Parameter) summand1 und summand2 eine Summe gebildet und in der Variablen summe vom Typ int gespeichert. Die Werte der Parameter und der Summe werden in Zeile 4 geeignet auf die Konsole ausgegeben. Die Definition einer Methode erfolgt immer innerhalb einer Klasse und au\u00dferhalb jeder anderen Methode. Methodenaufruf \u00b6 In der main() -Methode wird unsere Methode nun aufgerufen. Wichtig ist es zu beachten, dass wir exakt den gleichen Namen f\u00fcr die Methode verwenden, wie in der Methodendefinition angegeben (Gro\u00df- und Kleinschreibung beachten!) und dass der Methode in den runden Klammern Werte f\u00fcr die Parameter \u00fcbergeben werden. Dabei m\u00fcssen die Anzahl der Parameter und der jeweilige Typ der Parameter mit dem Aufruf \u00fcbereinstimmen. Hier nochmal die gesamte Klasse Methods mit den Aufrufen der add() -Methode in main() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Methods { public static void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } public static void main ( String [] args ) { add ( 3 , 4 ); add ( 5 , 9 ); add ( - 115 , 999 ); } } In der main() -Methode wird nun drei Mal unsere neue add() -Methode aufgerufen. Bei jedem Aufruf werden Werte f\u00fcr die Parameter \u00fcbergeben. Der Aufruf der Methode entspricht einer Anweisung (Semikolon am Ende). Der Aufruf der add() -Methode entspricht keinem Ausdruck, da der Aufruf dieser Methode ohne Wert ist. Dies liegt daran, dass in der Methodendefinition angegeben wurde, dass der Wert der Methode void ist - also kein Wert, kein Typ. Beachten Sie, dass in der Klasse Methods nun zwei Methoden definiert sind, main() und add() . Die main() -Methode ist die Programmmethode , die automatisch ausgef\u00fchrt wird, sobald wir das Programm starten. Damit die add() -Methode ausgef\u00fchrt wird, muss sie aufgerufen werden. Beachte Es werden nur alle Anweisungen ausgef\u00fchrt, die in der main() -Methode enthalten sind! Wird add() nie in main() aufgerufen, wird add() auch niemals ausgef\u00fchrt. Die Definition der Methode allein sorgt noch nicht f\u00fcr dessen Ausf\u00fchrung! Ausf\u00fchrung des Programms im Detail \u00b6 Wir schauen uns die Ausf\u00fchrung des obigen Programms nochmal im Detail an, um die Aufrufe genauer zu analysieren: durch das Starten des Programms wird die main() -Methode aufgerufen (Zeile 9 ) die erste Anweisung in der main() -Methode ist add(3,4); (Zeile 11 ) dadurch wird die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 3 und int summand2 = 4 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 7 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ergibt sich aus: summand1 + \" + \" ist ein Konkatenation; das Ergebnis ist \"3 + \" . \"3 + \" + summand2 ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4\" . \"3 + 4\" + \" = \" ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = \" . \"3 + 4 = \" + summe ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = 7\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. die n\u00e4chste Anweisung in der main() -Methode ist add(5,9); (Zeile 12 ) dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 5 und int summand2 = 9 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 14 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"5 + 9 = 14\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. die n\u00e4chste Anweisung in der main() -Methode ist add(-115,999); (Zeile 13 ) dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = -115 und int summand2 = 999 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 884 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"-115 + 999 = 884\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. in der main() -Methode gibt es keine weitere Anweisung mehr. Das Programm ist beendet. Methode gibt einen Wert zur\u00fcck \u00b6 Unsere Methode add() hat keinen Wert zur\u00fcckgegeben. Das wurde im Methodenkopf festgelegt, wo wir mit void definiert haben, dass der Aufruf der Methode keinem Wert entspricht. Dies ist typisch f\u00fcr Methoden, die etwas auf die Konsole ausgeben. Alle Methoden, deren Aufgabe es ist, etwas auszugeben, sind (sollten sein) vom R\u00fcckgabetyp 1 void . Jetzt erstellen wir eine Methode computeSum() , die das gleiche macht wie add() , aber mit dem Unterschied, dass diese Methode nichts auf die Konsole ausgibt, sondern die Summe der beiden Parameter an den Aufrufer der Methode zur\u00fcckgibt . Die Definition dieser Methode sieht dann so aus: 1 2 3 4 5 public static int computeSum ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; return summe ; } Zwei ganz wesentliche Unterschiede zur Definition von add() fallen auf: Diese Methode hat einen R\u00fcckgabetyp ( int ). Dort, wo bei add() noch void stand, steht bei computeSum() im Methodenkopf int . Damit wird festgelegt, dass der Aufruf der Methode einem Wert entspricht, welcher vom Typ int ist. Der Aufruf dieser Methode ist somit ein Ausdruck! Die letzte Anweisung der Methode computeSum() ist eine Anweisung, die mit dem Schl\u00fcsselwort return beginnt. Jede Methode, die einen R\u00fcckgabetyp hat (also genau nicht void ), muss ein solches return enthalten. Dieses return muss die letzte Anweisung in der Methode sein und es muss einen Wert zur\u00fcckgeben, der von dem Typ ist, der f\u00fcr die Methode als R\u00fcckgabetyp definiert wurde. Hier ist es der Wert von summe . summe ist vom Typ int und somit ist return summe; korrekt, da die Methode ja ein int zur\u00fcckgeben soll. Aufruf einer Methode, die einen Wert zur\u00fcckgibt \u00b6 Unsere Methode computeSum() k\u00f6nnte nun in der main() -Methode wie folgt aufgerufen werden: computeSum ( 3 , 4 ); // korrekt, aber sinnlos Ein solcher Aufruf macht aber gar keinen Sinn, weil die Methode selbst ja z.B. nichts ausgibt und somit hat diese Methode gar keinen Effekt. Sinnvoll eingesetzt werden kann eine solche Methode nur als Ausdruck, z.B.: int sum = computeSum ( 3 , 4 ); // sum wird mit dem Wert 7 initialisiert System . out . println ( computeSum ( 5 , 9 )); // es wird 14 ausgegeben Der Aufruf der Methode ist somit ein arithmetischer Ausdruck und kann auch als solcher behandelt werden, z.B. mit anderen arithmetischen Ausdr\u00fccken mittels arithmetischer Operatoren zu einem weiteren arithmetischen Ausdruck verkn\u00fcpft werden. Hier noch weitere Beispiele f\u00fcr Methoden mit R\u00fcckgabe (hier R\u00fcckgabe vom Typ boolean ): public static boolean areEqual ( int nr1 , int nr2 ) { return ( nr1 == nr2 ); } public static boolean isDivider ( int nr1 , int nr2 ) { return ( nr1 % nr2 == 0 ); } Sie k\u00f6nnen auch Methoden in Methoden aufrufen. Nehmen wir die beiden Methoden areEqual(int, int) und isDivider(int, int) und angenommen, wir wollen f\u00fcr 2 int -Zahlen pr\u00fcfen, ob die eine Teiler der anderen ist, aber beide sollen nicht gleich sein, dann k\u00f6nnen wir folgende Methode schreiben: public static boolean isDividerButNotEqual ( int nr1 , int nr2 ) { return ( isDivider ( nr1 , nr2 ) && ! areEqual ( nr1 , nr2 )); } Das schauen wir uns einmal genauer an: wir definieren wieder eine Methode wie gehabt: wir vergeben einen Namen ( isDividerButNotEqual ) und wir legen fest, dass bei Aufruf der Methode zwei int -Werte \u00fcbergeben werden m\u00fcssen ( (int nr1, int nr2) ). als R\u00fcckgabetyp definieren wir boolean , denn wir wollen ja pr\u00fcfen, ob sich die beiden ganzzahlig teilen, aber nicht gleich sind innerhalb der Methode rufen wir die Methode isDivider(nr1, nr2) auf und \u00fcbergeben dabei unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht einem boole schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr2 Teiler von nr1 ist und false` sonst - also, wenn nicht) au\u00dferdem rufen wir die Methode areEqual(nr1, nr2) auf und \u00fcbergeben dabei ebenfalls unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht ebenfalls einem boole schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr1 und nr2 gleich sind und false` sonst - also, wenn nicht) wir wollen aber pr\u00fcfen, ob sie nicht gleich sind, also schreiben wir !areEqual(nr1, nr2) - also die Negation dieses Ausdrucks wir wollen pr\u00fcfen, ob isDivider(nr1, nr2) UND NICHT areEqual(nr1, nr2) , also isDivider(nr1, nr2) UND !areEqual(nr1, nr2) , also isDivider(nr1, nr2) && !areEqual(nr1, nr2) diesen Wert geben wir zur\u00fcck 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isEven(int number) , die ein true zur\u00fcckgibt, wenn number gerade ist und sonst false . 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isOdd(int number) , die ein true zur\u00fcckgibt, wenn number ungerade ist und sonst false . Dieses Mal verwenden Sie aber die Methode isEven() , um den richtigen Wert zu ermitteln. Success Wir k\u00f6nnen uns nun Methoden selber definieren. Die Definition von Methoden erfolgt innerhalb der Klasse, aber au\u00dferhalb jeder anderen Methode. Eine Methode kann entweder keinen Wert zur\u00fcckgeben. Dann ist der \"R\u00fcckgabetyp\" 1 void . Eine solche void -Methode gibt typischerweise etwas auf die Konsole aus. Oder die Methode gibt einen Wert zur\u00fcck. Dann wird der Datentyp dieses Wertes im Methodenkopf der Methodendefinition angegeben. Die R\u00fcckgabe des Wertes erfolgt durch return . Die return -Anweisung muss die letzte Anweisung in der Methode sein. Der Aufruf einer solchen Methode entspricht dann einem Ausdruck. Einer Methode k\u00f6nnen beliebig viele Parameter \u00fcbergeben werden. Diese lokalen Variablen werden im Methodenkopf in den runden Klammern durch Komma getrennt deklariert. Bei Aufruf der Methode m\u00fcssen diesen Variablen Werte \u00fcbergeben werden (Anzahl und Datentypen m\u00fcssen bei Methodenaufruf passen). void ist kein Datentyp! Man sagt aber, dass Methoden, die keinen Wert zur\u00fcckliefern, vom R\u00fcckgabetyp void sind. Ganz korrekt ist das also nicht, aber es fehlt ein besserer Ausdruck daf\u00fcr. \u21a9 \u21a9","title":"Methoden"},{"location":"methoden/#methoden","text":"Bis jetzt haben wir unseren Programmcode stets in die main() -Methode geschrieben. Das wird auf Dauer viel zu un\u00fcbersichtlich. Au\u00dferdem versto\u00dfen wir so gegen zwei wichtige Prinzipien der Programmierung: dem Single Responsibility Principle (SRP) und Don't repeat yourself (DRY) . Die urspr\u00fcngliche Formulierung des SRP stammt von Robert C. Martin , der es als ein Prinzip der Objektorientierung einf\u00fchrte und es ein wenig anders meinte, als wir es hier verwenden. Dazu kommen wir, wenn wir uns mit Objektorientierung besch\u00e4ftigen. Wir k\u00f6nnen uns aber als wesentliche Prinzipien schonmal merken, dass eine Variable genau eine Bedeutung haben soll und niemals f\u00fcr verschiedene Bedeutungen benutzt werden sollte (zwei Bedeutungen == zwei Variablen) und eine Methode genau eine Sache erledigen sollte. Zun\u00e4chst schauen wir uns an, was eine Methode \u00fcberhaupt ist und wie wir sie definieren und verwenden. Angenommen, wir haben ein Programm in der folgenden Form: public class Methods { public static void main ( String [] args ) { int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 summand1 = 5 ; summand2 = 9 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 5 + 9 = 14 summand1 = - 115 ; summand2 = 999 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // -115 + 999 = 884 } } In dieser main() -Methode machen wir drei Mal das Gleiche, wir addieren 2 Summanden und geben das Ergebnis der Berechnung aus. Wir sehen insbesondere doppelten (sogar dreifachen) Code, d.h. wir wiederholen uns. Au\u00dferdem geben die vergebenen Namen nur an, wof\u00fcr die Variablen da sind, aber es gibt keine namentliche Beschreibung von dem, WAS wir tun.","title":"Methoden"},{"location":"methoden/#methodendefinition","text":"Das wollen wir \u00e4ndern und laden den sich wiederholenden Code in eine Methode aus. Diese Methode nennen wir add() : 1 2 3 4 5 public static void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } Betrachten wir diese Definition einer Methode genauer: In Zeile 1 sehen wir den Methodenkopf : Das Schl\u00fcsselwort public besagt, dass diese Methode von allen anderen Klassen (die wir noch nicht haben) aufgerufen werden kann. Es handelt sich um eine \u00f6ffentliche Methode. Wir gehen darauf genauer ein, wenn wir uns mit Sichtbarkeitsmodifizierern besch\u00e4ftigen. Das Schl\u00fcsselwort static besagt, dass wir diese Methode verwenden (aufrufen) k\u00f6nnen, ohne eine Objekt der Klasse Methods erzeugen zu m\u00fcssen. Wir k\u00f6nnen derzeit eh noch keine Objekte erzeugen, also definieren wir zun\u00e4chst alle unsere Methoden als static ( statisch , Klassenmethode ). Das Schl\u00fcsselwort void steht daf\u00fcr, dass der Aufruf unserer Methode keinen Wert hat, d.h. der Aufruf dieser Methode ist eine Anweisung ohne Nebeneffekt. Wenn die Methode einen Wert haben soll, dann wird hier ein Datentyp eingetragen (sehen wir im n\u00e4chsten Beispiel). add ist der Methodenname. Hier gelten die Bedingungen, die wir an Bezeichner in Java haben. Methodennamen beginnen stets mit einem Kleinbuchstaben. Nach dem Methodennamen kommen runde Klammern und darin sogenannte Parameter . Parameter sind Variablen. Parameter werden in der Methodendefinition deklariert, aber nicht initialisiert. Parameter werden beim Aufruf der Methode initialisiert. In den Zeilen 2-5 steht der Methodenk\u00f6rper : Der Methodenk\u00f6rper ist ein Anweisungsblock. Er beginnt mit einer \u00f6ffnenden geschweiften Klammer { (Zeile 2 ) und endet mit einer schlie\u00dfenden geschweiften Klammer } (Zeile 5 ). Innerhalb dieses Anweisungsblocks k\u00f6nnen beliebig viele Anweisungen stehen. In Zeile 3 wird unter Verwendung der Werte der Variablen (Parameter) summand1 und summand2 eine Summe gebildet und in der Variablen summe vom Typ int gespeichert. Die Werte der Parameter und der Summe werden in Zeile 4 geeignet auf die Konsole ausgegeben. Die Definition einer Methode erfolgt immer innerhalb einer Klasse und au\u00dferhalb jeder anderen Methode.","title":"Methodendefinition"},{"location":"methoden/#methodenaufruf","text":"In der main() -Methode wird unsere Methode nun aufgerufen. Wichtig ist es zu beachten, dass wir exakt den gleichen Namen f\u00fcr die Methode verwenden, wie in der Methodendefinition angegeben (Gro\u00df- und Kleinschreibung beachten!) und dass der Methode in den runden Klammern Werte f\u00fcr die Parameter \u00fcbergeben werden. Dabei m\u00fcssen die Anzahl der Parameter und der jeweilige Typ der Parameter mit dem Aufruf \u00fcbereinstimmen. Hier nochmal die gesamte Klasse Methods mit den Aufrufen der add() -Methode in main() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Methods { public static void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } public static void main ( String [] args ) { add ( 3 , 4 ); add ( 5 , 9 ); add ( - 115 , 999 ); } } In der main() -Methode wird nun drei Mal unsere neue add() -Methode aufgerufen. Bei jedem Aufruf werden Werte f\u00fcr die Parameter \u00fcbergeben. Der Aufruf der Methode entspricht einer Anweisung (Semikolon am Ende). Der Aufruf der add() -Methode entspricht keinem Ausdruck, da der Aufruf dieser Methode ohne Wert ist. Dies liegt daran, dass in der Methodendefinition angegeben wurde, dass der Wert der Methode void ist - also kein Wert, kein Typ. Beachten Sie, dass in der Klasse Methods nun zwei Methoden definiert sind, main() und add() . Die main() -Methode ist die Programmmethode , die automatisch ausgef\u00fchrt wird, sobald wir das Programm starten. Damit die add() -Methode ausgef\u00fchrt wird, muss sie aufgerufen werden. Beachte Es werden nur alle Anweisungen ausgef\u00fchrt, die in der main() -Methode enthalten sind! Wird add() nie in main() aufgerufen, wird add() auch niemals ausgef\u00fchrt. Die Definition der Methode allein sorgt noch nicht f\u00fcr dessen Ausf\u00fchrung!","title":"Methodenaufruf"},{"location":"methoden/#ausfuhrung-des-programms-im-detail","text":"Wir schauen uns die Ausf\u00fchrung des obigen Programms nochmal im Detail an, um die Aufrufe genauer zu analysieren: durch das Starten des Programms wird die main() -Methode aufgerufen (Zeile 9 ) die erste Anweisung in der main() -Methode ist add(3,4); (Zeile 11 ) dadurch wird die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 3 und int summand2 = 4 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 7 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ergibt sich aus: summand1 + \" + \" ist ein Konkatenation; das Ergebnis ist \"3 + \" . \"3 + \" + summand2 ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4\" . \"3 + 4\" + \" = \" ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = \" . \"3 + 4 = \" + summe ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = 7\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. die n\u00e4chste Anweisung in der main() -Methode ist add(5,9); (Zeile 12 ) dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 5 und int summand2 = 9 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 14 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"5 + 9 = 14\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. die n\u00e4chste Anweisung in der main() -Methode ist add(-115,999); (Zeile 13 ) dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = -115 und int summand2 = 999 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 884 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"-115 + 999 = 884\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. in der main() -Methode gibt es keine weitere Anweisung mehr. Das Programm ist beendet.","title":"Ausf\u00fchrung des Programms im Detail"},{"location":"methoden/#methode-gibt-einen-wert-zuruck","text":"Unsere Methode add() hat keinen Wert zur\u00fcckgegeben. Das wurde im Methodenkopf festgelegt, wo wir mit void definiert haben, dass der Aufruf der Methode keinem Wert entspricht. Dies ist typisch f\u00fcr Methoden, die etwas auf die Konsole ausgeben. Alle Methoden, deren Aufgabe es ist, etwas auszugeben, sind (sollten sein) vom R\u00fcckgabetyp 1 void . Jetzt erstellen wir eine Methode computeSum() , die das gleiche macht wie add() , aber mit dem Unterschied, dass diese Methode nichts auf die Konsole ausgibt, sondern die Summe der beiden Parameter an den Aufrufer der Methode zur\u00fcckgibt . Die Definition dieser Methode sieht dann so aus: 1 2 3 4 5 public static int computeSum ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; return summe ; } Zwei ganz wesentliche Unterschiede zur Definition von add() fallen auf: Diese Methode hat einen R\u00fcckgabetyp ( int ). Dort, wo bei add() noch void stand, steht bei computeSum() im Methodenkopf int . Damit wird festgelegt, dass der Aufruf der Methode einem Wert entspricht, welcher vom Typ int ist. Der Aufruf dieser Methode ist somit ein Ausdruck! Die letzte Anweisung der Methode computeSum() ist eine Anweisung, die mit dem Schl\u00fcsselwort return beginnt. Jede Methode, die einen R\u00fcckgabetyp hat (also genau nicht void ), muss ein solches return enthalten. Dieses return muss die letzte Anweisung in der Methode sein und es muss einen Wert zur\u00fcckgeben, der von dem Typ ist, der f\u00fcr die Methode als R\u00fcckgabetyp definiert wurde. Hier ist es der Wert von summe . summe ist vom Typ int und somit ist return summe; korrekt, da die Methode ja ein int zur\u00fcckgeben soll.","title":"Methode gibt einen Wert zur\u00fcck"},{"location":"methoden/#aufruf-einer-methode-die-einen-wert-zuruckgibt","text":"Unsere Methode computeSum() k\u00f6nnte nun in der main() -Methode wie folgt aufgerufen werden: computeSum ( 3 , 4 ); // korrekt, aber sinnlos Ein solcher Aufruf macht aber gar keinen Sinn, weil die Methode selbst ja z.B. nichts ausgibt und somit hat diese Methode gar keinen Effekt. Sinnvoll eingesetzt werden kann eine solche Methode nur als Ausdruck, z.B.: int sum = computeSum ( 3 , 4 ); // sum wird mit dem Wert 7 initialisiert System . out . println ( computeSum ( 5 , 9 )); // es wird 14 ausgegeben Der Aufruf der Methode ist somit ein arithmetischer Ausdruck und kann auch als solcher behandelt werden, z.B. mit anderen arithmetischen Ausdr\u00fccken mittels arithmetischer Operatoren zu einem weiteren arithmetischen Ausdruck verkn\u00fcpft werden. Hier noch weitere Beispiele f\u00fcr Methoden mit R\u00fcckgabe (hier R\u00fcckgabe vom Typ boolean ): public static boolean areEqual ( int nr1 , int nr2 ) { return ( nr1 == nr2 ); } public static boolean isDivider ( int nr1 , int nr2 ) { return ( nr1 % nr2 == 0 ); } Sie k\u00f6nnen auch Methoden in Methoden aufrufen. Nehmen wir die beiden Methoden areEqual(int, int) und isDivider(int, int) und angenommen, wir wollen f\u00fcr 2 int -Zahlen pr\u00fcfen, ob die eine Teiler der anderen ist, aber beide sollen nicht gleich sein, dann k\u00f6nnen wir folgende Methode schreiben: public static boolean isDividerButNotEqual ( int nr1 , int nr2 ) { return ( isDivider ( nr1 , nr2 ) && ! areEqual ( nr1 , nr2 )); } Das schauen wir uns einmal genauer an: wir definieren wieder eine Methode wie gehabt: wir vergeben einen Namen ( isDividerButNotEqual ) und wir legen fest, dass bei Aufruf der Methode zwei int -Werte \u00fcbergeben werden m\u00fcssen ( (int nr1, int nr2) ). als R\u00fcckgabetyp definieren wir boolean , denn wir wollen ja pr\u00fcfen, ob sich die beiden ganzzahlig teilen, aber nicht gleich sind innerhalb der Methode rufen wir die Methode isDivider(nr1, nr2) auf und \u00fcbergeben dabei unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht einem boole schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr2 Teiler von nr1 ist und false` sonst - also, wenn nicht) au\u00dferdem rufen wir die Methode areEqual(nr1, nr2) auf und \u00fcbergeben dabei ebenfalls unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht ebenfalls einem boole schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr1 und nr2 gleich sind und false` sonst - also, wenn nicht) wir wollen aber pr\u00fcfen, ob sie nicht gleich sind, also schreiben wir !areEqual(nr1, nr2) - also die Negation dieses Ausdrucks wir wollen pr\u00fcfen, ob isDivider(nr1, nr2) UND NICHT areEqual(nr1, nr2) , also isDivider(nr1, nr2) UND !areEqual(nr1, nr2) , also isDivider(nr1, nr2) && !areEqual(nr1, nr2) diesen Wert geben wir zur\u00fcck 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isEven(int number) , die ein true zur\u00fcckgibt, wenn number gerade ist und sonst false . 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isOdd(int number) , die ein true zur\u00fcckgibt, wenn number ungerade ist und sonst false . Dieses Mal verwenden Sie aber die Methode isEven() , um den richtigen Wert zu ermitteln. Success Wir k\u00f6nnen uns nun Methoden selber definieren. Die Definition von Methoden erfolgt innerhalb der Klasse, aber au\u00dferhalb jeder anderen Methode. Eine Methode kann entweder keinen Wert zur\u00fcckgeben. Dann ist der \"R\u00fcckgabetyp\" 1 void . Eine solche void -Methode gibt typischerweise etwas auf die Konsole aus. Oder die Methode gibt einen Wert zur\u00fcck. Dann wird der Datentyp dieses Wertes im Methodenkopf der Methodendefinition angegeben. Die R\u00fcckgabe des Wertes erfolgt durch return . Die return -Anweisung muss die letzte Anweisung in der Methode sein. Der Aufruf einer solchen Methode entspricht dann einem Ausdruck. Einer Methode k\u00f6nnen beliebig viele Parameter \u00fcbergeben werden. Diese lokalen Variablen werden im Methodenkopf in den runden Klammern durch Komma getrennt deklariert. Bei Aufruf der Methode m\u00fcssen diesen Variablen Werte \u00fcbergeben werden (Anzahl und Datentypen m\u00fcssen bei Methodenaufruf passen). void ist kein Datentyp! Man sagt aber, dass Methoden, die keinen Wert zur\u00fcckliefern, vom R\u00fcckgabetyp void sind. Ganz korrekt ist das also nicht, aber es fehlt ein besserer Ausdruck daf\u00fcr. \u21a9 \u21a9","title":"Aufruf einer Methode, die einen Wert zur\u00fcckgibt"},{"location":"start/","text":"Was ist Programmieren? \u00b6 Zun\u00e4chst ein bisschen Motivation: 10 Gr\u00fcnde, Programmieren zu lernen und Bericht einer ehemaligen FIW-Studentin . Ehe wir uns weiter mit Java und Programmierkonzepten besch\u00e4ftigen, wollen wir uns bewusst werden, was Programmieren \u00fcberhaupt ist. Prinzipiell l\u00f6sen wir beim Programmieren ein Problem mithilfe einer Programmiersprache. Dabei stellt sich die Frage, welche Probleme mithilfe eines Computers l\u00f6sbar sind und welche nicht. Dazu gibt es umfangreiche theoretische Untersuchungen - viele davon werden Sie in den \"Grundlegenden Konzepten der Informatik\" diskutieren. Ein wesentlicher Begriff dabei ist Algorithmus . Ein Algorithmus ist eine eindeutige Handlungsvorschrift, die aus endlich vielen einzelnen Schritten besteht und ein Problem l\u00f6st. Algorithmen sind also auch Kochrezepte oder Bauanleitungen, wenn sie denn \"eindeutig\" sind. Wir kennen alle das Problem, dass Handlungsanweisungen nicht immer eindeutig sind - man kann es manchmal so oder so machen. In der Programmierung darf eine solche Mehrdeutigkeit nat\u00fcrlich nicht vorkommen. Der Algorithmusbegriff wurde deshalb detailliert und folgende Eigenschaften m\u00fcssen f\u00fcr eine Handlungsanweisung f\u00fcr einen Computer gelten, um ein Algorithmus zu sein: Finitheit Das Verfahren muss in einem endlichen Text (Programm) eindeutig beschreibbar sein. Ausf\u00fchrbarkeit Jeder einzelne Schritt des Verfahrens muss auch tats\u00e4chlich ausf\u00fchrbar sein. Dynamische Finitheit Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz ben\u00f6tigen. Terminierung Das Verfahren muss irgendwann enden, d.h. darf nur endlich viele Ausf\u00fchrungsschritte ben\u00f6tigen. Determiniertheit Das Verfahren muss bei denselben Voraussetzungen das gleiche Ergebnis liefern. Determinismus Die n\u00e4chste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt (in jedem Zustand) eindeutig definiert. Beispiel: Euklidischer Algorithmus \u00b6 Mit dem euklidischen Algorithmus 1 kann der gr\u00f6\u00dfte gemeinsame Teiler (ggT) zweier Zahlen berechnet werden. In seinen Elementen hat Euklid diesen Algorithmus ungef\u00e4hr so formuliert: Euklidischer Algorithmus Wenn CD aber AB nicht misst, und man nimmt bei AB, CD abwechselnd immer das kleinere vom gr\u00f6\u00dferen weg, dann muss (schlie\u00dflich) eine Zahl \u00fcbrig bleiben, die die vorangehende misst. Hm, das ist recht schwierig zu verstehen. Euklid betrachtet die beiden Zahlen, von denen der gr\u00f6\u00dfte gemeinsame Teiler ermittelt werden soll, als Strecken ( AB und CD ). Er zieht wiederholt die kleinere der beiden Strecken von der gr\u00f6\u00dferen ab. Er wiederholt dies solange, bis die beiden Strecken gleich lang sind - genauer: er wiederholt dies solange, solange die beiden Strecken nicht gleich lang sind ( ... CD aber AB nicht misst... ). Beispiel: ggT von 24 und 40 AB: 40, CD: 24, AB gr\u00f6\u00dfer als CD \u2192 40 - 24 = 16 AB: 16, CD: 24, CD gr\u00f6\u00dfer als AB \u2192 24 - 16 = 8 AB: 16, CD: 8, AB gr\u00f6\u00dfer als CD \u2192 16 - 8 = 8 AB: 8, CD: 8, AB gleich CD \u2192 Ende \u2192 ggT ist 8 Wir versuchen, den Algorithmus in eine verst\u00e4ndlichere und genauere Sprache zu \u00fcberf\u00fchren, ohne bereits eine Programmiersprache zu verwenden. Wir benutzen sogenannten Pseudocode : Angenommen, die beiden Zahlen, von denen wir den ggT berechnen wollen, sind a und b : 1 2 3 4 5 6 7 solange a ungleich b ist, wiederhole wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu wenn a gleich b ist, dann: a ( oder auch b ) ist der gesuchte ggT Wichtig ist, dass das Einr\u00fccken hier eine Bedeutung hat (eine Semantik ). In Zeile 1 formulieren wir, dass sich etwas wiederholen soll, solange eine bestimmte Bedingung gilt. Das, was sich wiederholen soll, ist in den Zeilen 2 bis 5 formuliert. Zeile 1 formuliert eine Schleife und in den Zeilen 2 - 5 befindet sich der Schleifeninhalt . Die Zeilen 2 - 5 formulieren ein eigenes Konstrukt, n\u00e4mlich eine Auswahl zwischen Alternativen, abh\u00e4ngig von einer Bedingung. Die Bedingung ist, ob a gr\u00f6\u00dfer ist als b . Wenn das der Fall ist, dann wird die Alternative ziehe b von a ab und weise das Ergebnis a zu ausgef\u00fchrt (In der Programmierung werden das sp\u00e4ter als a = a - b schreiben - das sieht f\u00fcr uns jetzt noch sehr \"falsch\" aus). Ist jedoch a nicht gr\u00f6\u00dfer als b , dann wird die Alternative ziehe a von b ab und weise das Ergebnis b zu ( b = b - a ) ausgef\u00fchrt. Ein solches Konstrukt wird Selektion (oder auch bedingte Alternative ) genannt. Nachdem entweder Zeile 3 oder Zeile 5 ausgef\u00fchrt wurde (es wird genau eins von beiden ausgef\u00fchrt), wird erneut in Zeile 1 gepr\u00fcft, ob a ungleich b ist. Wenn ja, wird die Selektion wiederholt. Wenn nicht, dann ist die Schleife beendet und Zeile 6 wird ausgef\u00fchrt. Die in Zeile 6 formulierte Bedingung wenn a gleich b ist , ist eigentlich unn\u00f6tig. Frage Warum ist die Bedingung wenn a gleich b ist in Zeile 6 unn\u00f6tig? Wir betrachten nochmals die im obigen Algorithmus betrachteten Konstrukte (wir sprechen vom Kontrollfluss von Anweisungen ): Iteration : die Schleife, die in Zeile 1 formuliert wird und die als Schleifeninhalt die Zeilen 2 - 5 hat, beschreibt einen iterativen (sich wiederholenden) Kontrollfluss . Selektion : die bedingte Alternative , die eine Bedingung pr\u00fcft (Zeile 2 ) und dann, je nachdem, ob die Bedingung richtig oder falsch ist, jeweils eine alternative Anweisung ausf\u00fchrt (entweder Zeile 3 oder Zeile 4 ), wird Selektion genannt (siehe Zeilen 2 - 5 ). Sequenz : die Anweisungen werden hintereinander ausgef\u00fchrt, erst Zeile 1 , dann Zeile 2 , dann entweder Zeile 3 oder Zeile 4 usw. Das Hintereinanderausf\u00fchren von Anweisungen wird Sequenz genannt. Schauen wir uns f\u00fcr unseren Algorithmus nochmal die Eigenschaften eines Algorithmus an: Finitheit unsere Beschreibung des Algorithmus ist endlich (siehe oben). Ausf\u00fchrbarkeit jeder einzelne Schritt kann ausgef\u00fchrt werden. Dynamische Finitheit \u00fcber den Speicherplatz k\u00f6nnen wir noch nicht viel sagen, aber wir m\u00fcssen nur einige wenige Zahlen speichern. Das sollte klappen. Terminierung Wann endet unser Algorithmus? Was muss gelten? Wissen wir, ob der Algorithmus irgendwann stoppt? Determiniertheit Es ist sicherlich nicht so leicht zu sehen, ob bei gleicher Eingabe (die Zahlen a und b ) auch stets der gleiche gr\u00f6\u00dfte gemneinsame Teiler berechnet wird. Dazu m\u00fcssten wir uns erstmal \u00fcberlegen, wie wir das pr\u00fcfen k\u00f6nnen. Determinismus Wir werden unseren Algorithmus nochmal an einem Beispiel durchspielen , um ein Gef\u00fchl daf\u00fcr zu bekommen, dass wir stets wissen, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Beispielzahlen f\u00fcr den euklidischen Algorithmus \u00b6 Wir nehmen die Zahlen a=40 und b=24 und spielen damit unseren Algorithmus durch: Zeile 1 : a (40) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von a-b ist 16. Der neue Wert von a ist 16. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist nicht gr\u00f6\u00dfer als b , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von b-a ist 8. Der neue Wert von b ist 8. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (8) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeile 5 ) Zeile 3 : das Ergebnis von a-b ist 8. Der neue Wert von a ist 8. Zeile 1 : wegen wiederhole (Iteration): a (8) ist nicht ungleich b (8) , also wird der Schleifeninhalt nicht ausgef\u00fchrt Zeile 6 : a (8) ist gleich b (8) Zeile 7 : der gesuchte ggT ist 8 Ende F\u00fcr dieses Beispiel war stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe a=40 und b=24 stets 8 ist. Fragen Was \u00e4ndert sich, wenn am Anfang a=24 und b=40 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=0 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=24 und b=24 sind? Beispiel: (3n+1)-Vermutung (Collatz-Problem) \u00b6 Wir betrachten noch einen weiteren Algorithmus: Als Eingabe bekommen wir eine positive nat\u00fcrliche Zahl, z.B. 5 . Der Algorithmus berechnet eine Folge von Zahlen und zwar nach folgender Vorschrift: ist die Zahl ungerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl mit 3 multipliziert und dann 1 addiert wird. Ist die Zahl gerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl durch 2 geteilt wird. Der Algorithmus stoppt, wenn der Nachfolger 1 ist. Angenommen, die eingegebene positive nat\u00fcrliche Zahl ist n : 1 2 3 4 5 solange n ungleich 1 ist, wiederhole wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Wir begeben uns also in eine Schleife und berechnen so lange einen Nachfolger f\u00fcr die Zahl bis der NAchfolger 1 ist. Betrachten wir den Algorithmus f\u00fcr die EIngabe von n=5 : Zeile 1 : n (5) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist ungerade , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von 3*5+1 ist 16 . Der neue Wert von n ist 16. Zeile 1 : wegen wiederhole (Iteration): n (16) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 16/2 ist 8 . Der neue Wert von n ist 8. Zeile 1 : wegen wiederhole (Iteration): n (8) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 8/2 ist 4 . Der neue Wert von n ist 4. Zeile 1 : wegen wiederhole (Iteration): n (4) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 4/2 ist 2 . Der neue Wert von n ist 2. Zeile 1 : wegen wiederhole (Iteration): n (2) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 2/2 ist 1 . Der neue Wert von n ist 1. Zeile 1 : wegen wiederhole (Iteration): n (1) ist nicht ungleich 1 , also wird der Schleifeninhalt nicht ausgef\u00fchrt Ende Auch f\u00fcr dieses Beispiel war erneut stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die Eingabe n=5 stets 1 ist. Fragen Spielen Sie den Algorithmus ruhig einmal f\u00fcr n=7 durch oder auch f\u00fcr andere n Denken Sie, dass der Algorithmus f\u00fcr jede beliebige positive nat\u00fcrliche Zahl n terminiert? Wenn ein Algorithmus f\u00fcr eine konkrete Eingabe stets ein eindeutiges Ergebnis (und zwar immer das gleiche) liefert, wie k\u00f6nnen dann Zufallszahlen berechnet werden? Success Wir haben ein Verst\u00e4ndnis \u00fcber den Algorithmus -Begriff erlangt und wissen, was Finitheit , Determiniertheit , Determinismus und Terminierung bedeuten. Programmablaufstrukturen \u00b6 Interessanterweise gibt es nur drei verschiedene Ablaufstrukturen in Programmen bzw. Algorithmen. Alle drei haben wir bereits verwendet. Mit Ablaufstrukturen meinen wir die Abarbeitungsreihenfolge von Anweisungen. Man sagt auch Kontrollfluss dazu. Die drei Ablaufstrukturen, die es gibt, sind: die Sequenz : die Anweisungen werden in sequenzieller Abfolge, d.h. hintereinander ausgef\u00fchrt die Iteration : die Abl\u00e4ufe werden wiederholt ausgef\u00fchrt, also in einer Schleife die Selektion : die Abl\u00e4ufe werden selektiv , d.h. unter einer bestimmten Bedingung ausgef\u00fchrt. Man nennt diese Struktur auch Verzweigung oder bedingte Alternative Wir schauen uns alle drei Kontrollstrukturen einmal genauer an. Die Sequenz \u00b6 Bei der Sequenz handelt es sich einfach um hintereinander ausgef\u00fchrte Anweisungen. Es wird stets erst die eine Anweisung vollst\u00e4ndig abgearbeitet, ehe die andere begonnen wird. Sequenz von 3 Anweisungen Anweisung1 Anweisung2 Anweisung3 Ein Beispiel (mit 2 Anweisungen) w\u00e4re: berechne 3 *n und weise das Ergebnis n zu berechne n+1 und weise das Ergebnis n zu Zur Visualisierung von Kontrollstrukturen werden auch sogannnte Programmablaufdiagramme oder Programmablaufpl\u00e4ne verwendet. F\u00fcr eine Sequenz s\u00e4he ein solches Ablaufdiagramm so aus: So ein Diagramm wird von oben nach unten gelesen. Es wird also erst Anweisung1 ausgef\u00fchrt, dann Anweisung2 und zuletzt Anweisung3 . Innerhalb einer Sequenz gilt immer single entry / single exit , d.h. keine der Anweisungen innerhalb einer Sequenz kann mehrere Ausg\u00e4nge oder mehrere Eing\u00e4nge haben. Es w\u00e4re ansonsten nicht-deterministisch und somit ein Versto\u00df gegen unseren Algorithmusbegriff. Die Iteration \u00b6 Bei der Iteration handelt es sich um eine wiederholte Ausf\u00fchrung einer Anweisung bzw. einer Sequenz von Anweisungen. Wie oft eine Iteration ausgef\u00fchrt wird, h\u00e4ngt von einer Bedingung ab. In der Programmierung sprechen wir bei der Iteration auch von einer Schleife . Bedingungen f\u00fcr eine solche Schleife haben wir bereits kennengelernt: solange a ungleich b ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt bzw. solange n ungleich 1 ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt Wichtig ist, dass es auch hier eine strikte Reihenfolge der Abarbeitung der Anweisungen gibt: es wird zun\u00e4chst gepr\u00fcft, ob die Bedingung erf\u00fcllt (wahr) ist, also ob z.B. a ungleich b ist oder ob n ungleich 1 . Wenn diese Bedingung erf\u00fcllt (also wahr) ist, dann werden die Anweisung(en) innerhalb der Schleife nacheinander (sequenziell) abgearbeitet. Erst wenn alle Anweisungen innerhalb der Schleife abgearbeitet wurden, wird die Schleifenbedingung erneut gepr\u00fcft. Ist sie wieder wahr, werden die Anweisungen innerhalb der Schleife erneut abgearbeitet usw. Ist sie nicht wahr, also wenn z.B. a gleich b ist oder n gleich 1 ist , dann wird die Schleife beendet und die Anweisungen innerhalb der Schleife nicht (erneut) abgearbeitet. Das Ablaufdiagramm einer Schleife (Iteration) sieht so aus: Die eigentliche Iteration ist gr\u00fcn dargestellt. Wir kommen von einer anderen Anweisung und pr\u00fcfen die Bedingung. Ist sie wahr, wird Anweisung1 ausgef\u00fchrt. Beachte Anweisung1 muss nicht zwingend nur genau eine Anweisung sein. Bei Anweisung1 kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder sogar selbst um eine Iteration (Schleife in der Schleife - verschachtelte Schleife) handeln! Nach jeder Ausf\u00fchrung von Anweisung1 wird die Bedingung erneut gepr\u00fcft. Ist sie (immernoch) wahr, wird Anweisung1 erneut ausgef\u00fchrt. Ist die Bedingung jedoch falsch, dann wird Anweisung1 nicht (mehr) ausgef\u00fchrt, sondern die Schleife wird verlassen und die Anweisung, die der Schleife folgt, wird ausgef\u00fchrt ( Anweisung2 ) oder das Programm ist dann zu Ende. Beachte Es kann sein, dass Anweisung1 gar nicht ausgef\u00fchrt wird, weil die Bedingung bereits bei der ersten Pr\u00fcfung falsch ist. Es ist also nicht gesagt, dass sich eine Iteration wirklich wiederholt . Es kann sein, dass Anweisung1 gar nicht oder nur genau ein Mal ausgef\u00fchrt wird (wenn die Bedingung nach der ersten Ausf\u00fchrung falsch ist). Das ist kein Problem! Ein Problem ist es jedoch, wenn die Bedingung niemals falsch wird und die Schleife unendlich oft hintereinander ausgef\u00fchrt wird. Das ist ein Versto\u00df gegen die Terminierung eines Algorithmus. In einem solchen Fall werden wir irgendwann einen Fehler bei der Programmausf\u00fchrung erhalten (aber erst zur Ausf\u00fchrungszeit, nicht bereits beim Compilieren). Wir werden uns ausf\u00fchrlich mit Schleifen auseinandersetzen, da sie logisch recht anspruchsvoll und dadurch h\u00e4ufig fehleranf\u00e4llig sein k\u00f6nnen. Die Selektion \u00b6 Bei der Selektion handelt es sich, im Gegensatz zur Iteration, um eine einmalige Ausf\u00fchrung einer (oder mehrerer) Anweisung(en). Jedoch ist diese Ausf\u00fchrung, im Gegensatz zur Sequenz, von einer Bedingung abh\u00e4ngig. Wir hatten eine solche Selektion jeweils in obigen Beispielalgorithmen. Selektion aus dem euklidischen Algorithmus: wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu Selektion aus der (3n+1)-Vermutung (dem Collatz-Problem): wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Es gibt also immer eine Bedingung (z.B. wenn a gr\u00f6\u00dfer ist als b ) und abh\u00e4ngig vom Wert dieser Bedingung (wahr oder falsch), wird entweder die eine Anweisung (z.B. ziehe b von a ab und weise das Ergebnis a zu ) oder die andere (z.B. ziehe a von b ab und weise das Ergebnis b zu ) ausgef\u00fchrt. Das Ablaufdiagramm einer Selektion sieht so aus: Beachte Anweisung1 und auch Anweisung2 m\u00fcssen nicht zwingend jeweils nur genau eine Anweisung sein. Bei beiden kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder um eine Iteration handeln! Verschachteln von Kontrollstrukturen \u00b6 Mehr als diese drei genannten Kontrollstrukturen gibt es nicht. Aber diese Kontrollstrukturen k\u00f6nnen beliebig ineinander verschachtelt werden. \u00dcberall dort, wo eine Anweisung steht (z.B. Anweisung1 ) kann auch eine komplette Kontrollstruktur eingesetzt werden, also eine Sequenz von Anweisungen oder eine Iteration oder eine Selektion. Die kann dann beliebig fortgef\u00fchrt werden. So entstehen komplexe Strukturen - und somit komplexe Programme. Ein (immernoch recht einfaches) Beispiel f\u00fcr eine etwas komplexere Struktur: \u00dcbung Programmablaufpl\u00e4ne Erstellen Sie sowohl f\u00fcr den euklidischen Algorithmus als auch f\u00fcr die (3n+1)-Vermutung einen Programmablaufplan! \u00dcbung Algorithmus und Programmablaufplan Ein Jahr ist ein Schaltjahr, wenn es sich durch 4 teilen l\u00e4sst. Au\u00dfer, es l\u00e4sst sich durch 100 teilen. Dann ist es doch kein Schaltjahr. Au\u00dfer, es l\u00e4sst sich durch 400 teilen. Dann ist es doch ein Schaltjahr. Beschreiben Sie diese Vorschrift als einen Algorithmus in der Form, in der auch der euklidische Algorithmus und die (3n+1)-Vermutung beschrieben wurden. Erstellen Sie dann den dazugeh\u00f6rigen Programmablaufplan. Success Wir wissen nun, dass es nur drei verschiedene Programmablaufstrukturen gibt: die Sequenz, die Iteration und die Selektion. Wir haben ein Verst\u00e4ndnis davon, was die drei Programmablaufstrukturen ausmacht, welchen Zweck sie haben und was sie voneinander unterscheidet. Wir wissen, dass sich diese Strukturen beliebig ineinander verschachteln lassen. Benannt nach Euklid von Alexandria, einem Mathematiker aus dem 3. Jahrhundert, Autor der Elemente - einem Kompendium des Wissens der Mathematik seiner Zeit. \u21a9","title":"Start"},{"location":"start/#was-ist-programmieren","text":"Zun\u00e4chst ein bisschen Motivation: 10 Gr\u00fcnde, Programmieren zu lernen und Bericht einer ehemaligen FIW-Studentin . Ehe wir uns weiter mit Java und Programmierkonzepten besch\u00e4ftigen, wollen wir uns bewusst werden, was Programmieren \u00fcberhaupt ist. Prinzipiell l\u00f6sen wir beim Programmieren ein Problem mithilfe einer Programmiersprache. Dabei stellt sich die Frage, welche Probleme mithilfe eines Computers l\u00f6sbar sind und welche nicht. Dazu gibt es umfangreiche theoretische Untersuchungen - viele davon werden Sie in den \"Grundlegenden Konzepten der Informatik\" diskutieren. Ein wesentlicher Begriff dabei ist Algorithmus . Ein Algorithmus ist eine eindeutige Handlungsvorschrift, die aus endlich vielen einzelnen Schritten besteht und ein Problem l\u00f6st. Algorithmen sind also auch Kochrezepte oder Bauanleitungen, wenn sie denn \"eindeutig\" sind. Wir kennen alle das Problem, dass Handlungsanweisungen nicht immer eindeutig sind - man kann es manchmal so oder so machen. In der Programmierung darf eine solche Mehrdeutigkeit nat\u00fcrlich nicht vorkommen. Der Algorithmusbegriff wurde deshalb detailliert und folgende Eigenschaften m\u00fcssen f\u00fcr eine Handlungsanweisung f\u00fcr einen Computer gelten, um ein Algorithmus zu sein: Finitheit Das Verfahren muss in einem endlichen Text (Programm) eindeutig beschreibbar sein. Ausf\u00fchrbarkeit Jeder einzelne Schritt des Verfahrens muss auch tats\u00e4chlich ausf\u00fchrbar sein. Dynamische Finitheit Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz ben\u00f6tigen. Terminierung Das Verfahren muss irgendwann enden, d.h. darf nur endlich viele Ausf\u00fchrungsschritte ben\u00f6tigen. Determiniertheit Das Verfahren muss bei denselben Voraussetzungen das gleiche Ergebnis liefern. Determinismus Die n\u00e4chste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt (in jedem Zustand) eindeutig definiert.","title":"Was ist Programmieren?"},{"location":"start/#beispiel-euklidischer-algorithmus","text":"Mit dem euklidischen Algorithmus 1 kann der gr\u00f6\u00dfte gemeinsame Teiler (ggT) zweier Zahlen berechnet werden. In seinen Elementen hat Euklid diesen Algorithmus ungef\u00e4hr so formuliert: Euklidischer Algorithmus Wenn CD aber AB nicht misst, und man nimmt bei AB, CD abwechselnd immer das kleinere vom gr\u00f6\u00dferen weg, dann muss (schlie\u00dflich) eine Zahl \u00fcbrig bleiben, die die vorangehende misst. Hm, das ist recht schwierig zu verstehen. Euklid betrachtet die beiden Zahlen, von denen der gr\u00f6\u00dfte gemeinsame Teiler ermittelt werden soll, als Strecken ( AB und CD ). Er zieht wiederholt die kleinere der beiden Strecken von der gr\u00f6\u00dferen ab. Er wiederholt dies solange, bis die beiden Strecken gleich lang sind - genauer: er wiederholt dies solange, solange die beiden Strecken nicht gleich lang sind ( ... CD aber AB nicht misst... ). Beispiel: ggT von 24 und 40 AB: 40, CD: 24, AB gr\u00f6\u00dfer als CD \u2192 40 - 24 = 16 AB: 16, CD: 24, CD gr\u00f6\u00dfer als AB \u2192 24 - 16 = 8 AB: 16, CD: 8, AB gr\u00f6\u00dfer als CD \u2192 16 - 8 = 8 AB: 8, CD: 8, AB gleich CD \u2192 Ende \u2192 ggT ist 8 Wir versuchen, den Algorithmus in eine verst\u00e4ndlichere und genauere Sprache zu \u00fcberf\u00fchren, ohne bereits eine Programmiersprache zu verwenden. Wir benutzen sogenannten Pseudocode : Angenommen, die beiden Zahlen, von denen wir den ggT berechnen wollen, sind a und b : 1 2 3 4 5 6 7 solange a ungleich b ist, wiederhole wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu wenn a gleich b ist, dann: a ( oder auch b ) ist der gesuchte ggT Wichtig ist, dass das Einr\u00fccken hier eine Bedeutung hat (eine Semantik ). In Zeile 1 formulieren wir, dass sich etwas wiederholen soll, solange eine bestimmte Bedingung gilt. Das, was sich wiederholen soll, ist in den Zeilen 2 bis 5 formuliert. Zeile 1 formuliert eine Schleife und in den Zeilen 2 - 5 befindet sich der Schleifeninhalt . Die Zeilen 2 - 5 formulieren ein eigenes Konstrukt, n\u00e4mlich eine Auswahl zwischen Alternativen, abh\u00e4ngig von einer Bedingung. Die Bedingung ist, ob a gr\u00f6\u00dfer ist als b . Wenn das der Fall ist, dann wird die Alternative ziehe b von a ab und weise das Ergebnis a zu ausgef\u00fchrt (In der Programmierung werden das sp\u00e4ter als a = a - b schreiben - das sieht f\u00fcr uns jetzt noch sehr \"falsch\" aus). Ist jedoch a nicht gr\u00f6\u00dfer als b , dann wird die Alternative ziehe a von b ab und weise das Ergebnis b zu ( b = b - a ) ausgef\u00fchrt. Ein solches Konstrukt wird Selektion (oder auch bedingte Alternative ) genannt. Nachdem entweder Zeile 3 oder Zeile 5 ausgef\u00fchrt wurde (es wird genau eins von beiden ausgef\u00fchrt), wird erneut in Zeile 1 gepr\u00fcft, ob a ungleich b ist. Wenn ja, wird die Selektion wiederholt. Wenn nicht, dann ist die Schleife beendet und Zeile 6 wird ausgef\u00fchrt. Die in Zeile 6 formulierte Bedingung wenn a gleich b ist , ist eigentlich unn\u00f6tig. Frage Warum ist die Bedingung wenn a gleich b ist in Zeile 6 unn\u00f6tig? Wir betrachten nochmals die im obigen Algorithmus betrachteten Konstrukte (wir sprechen vom Kontrollfluss von Anweisungen ): Iteration : die Schleife, die in Zeile 1 formuliert wird und die als Schleifeninhalt die Zeilen 2 - 5 hat, beschreibt einen iterativen (sich wiederholenden) Kontrollfluss . Selektion : die bedingte Alternative , die eine Bedingung pr\u00fcft (Zeile 2 ) und dann, je nachdem, ob die Bedingung richtig oder falsch ist, jeweils eine alternative Anweisung ausf\u00fchrt (entweder Zeile 3 oder Zeile 4 ), wird Selektion genannt (siehe Zeilen 2 - 5 ). Sequenz : die Anweisungen werden hintereinander ausgef\u00fchrt, erst Zeile 1 , dann Zeile 2 , dann entweder Zeile 3 oder Zeile 4 usw. Das Hintereinanderausf\u00fchren von Anweisungen wird Sequenz genannt. Schauen wir uns f\u00fcr unseren Algorithmus nochmal die Eigenschaften eines Algorithmus an: Finitheit unsere Beschreibung des Algorithmus ist endlich (siehe oben). Ausf\u00fchrbarkeit jeder einzelne Schritt kann ausgef\u00fchrt werden. Dynamische Finitheit \u00fcber den Speicherplatz k\u00f6nnen wir noch nicht viel sagen, aber wir m\u00fcssen nur einige wenige Zahlen speichern. Das sollte klappen. Terminierung Wann endet unser Algorithmus? Was muss gelten? Wissen wir, ob der Algorithmus irgendwann stoppt? Determiniertheit Es ist sicherlich nicht so leicht zu sehen, ob bei gleicher Eingabe (die Zahlen a und b ) auch stets der gleiche gr\u00f6\u00dfte gemneinsame Teiler berechnet wird. Dazu m\u00fcssten wir uns erstmal \u00fcberlegen, wie wir das pr\u00fcfen k\u00f6nnen. Determinismus Wir werden unseren Algorithmus nochmal an einem Beispiel durchspielen , um ein Gef\u00fchl daf\u00fcr zu bekommen, dass wir stets wissen, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird.","title":"Beispiel: Euklidischer Algorithmus"},{"location":"start/#beispielzahlen-fur-den-euklidischen-algorithmus","text":"Wir nehmen die Zahlen a=40 und b=24 und spielen damit unseren Algorithmus durch: Zeile 1 : a (40) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von a-b ist 16. Der neue Wert von a ist 16. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist nicht gr\u00f6\u00dfer als b , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von b-a ist 8. Der neue Wert von b ist 8. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (8) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeile 5 ) Zeile 3 : das Ergebnis von a-b ist 8. Der neue Wert von a ist 8. Zeile 1 : wegen wiederhole (Iteration): a (8) ist nicht ungleich b (8) , also wird der Schleifeninhalt nicht ausgef\u00fchrt Zeile 6 : a (8) ist gleich b (8) Zeile 7 : der gesuchte ggT ist 8 Ende F\u00fcr dieses Beispiel war stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe a=40 und b=24 stets 8 ist. Fragen Was \u00e4ndert sich, wenn am Anfang a=24 und b=40 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=0 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=24 und b=24 sind?","title":"Beispielzahlen f\u00fcr den euklidischen Algorithmus"},{"location":"start/#beispiel-3n1-vermutung-collatz-problem","text":"Wir betrachten noch einen weiteren Algorithmus: Als Eingabe bekommen wir eine positive nat\u00fcrliche Zahl, z.B. 5 . Der Algorithmus berechnet eine Folge von Zahlen und zwar nach folgender Vorschrift: ist die Zahl ungerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl mit 3 multipliziert und dann 1 addiert wird. Ist die Zahl gerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl durch 2 geteilt wird. Der Algorithmus stoppt, wenn der Nachfolger 1 ist. Angenommen, die eingegebene positive nat\u00fcrliche Zahl ist n : 1 2 3 4 5 solange n ungleich 1 ist, wiederhole wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Wir begeben uns also in eine Schleife und berechnen so lange einen Nachfolger f\u00fcr die Zahl bis der NAchfolger 1 ist. Betrachten wir den Algorithmus f\u00fcr die EIngabe von n=5 : Zeile 1 : n (5) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist ungerade , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von 3*5+1 ist 16 . Der neue Wert von n ist 16. Zeile 1 : wegen wiederhole (Iteration): n (16) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 16/2 ist 8 . Der neue Wert von n ist 8. Zeile 1 : wegen wiederhole (Iteration): n (8) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 8/2 ist 4 . Der neue Wert von n ist 4. Zeile 1 : wegen wiederhole (Iteration): n (4) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 4/2 ist 2 . Der neue Wert von n ist 2. Zeile 1 : wegen wiederhole (Iteration): n (2) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 2/2 ist 1 . Der neue Wert von n ist 1. Zeile 1 : wegen wiederhole (Iteration): n (1) ist nicht ungleich 1 , also wird der Schleifeninhalt nicht ausgef\u00fchrt Ende Auch f\u00fcr dieses Beispiel war erneut stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die Eingabe n=5 stets 1 ist. Fragen Spielen Sie den Algorithmus ruhig einmal f\u00fcr n=7 durch oder auch f\u00fcr andere n Denken Sie, dass der Algorithmus f\u00fcr jede beliebige positive nat\u00fcrliche Zahl n terminiert? Wenn ein Algorithmus f\u00fcr eine konkrete Eingabe stets ein eindeutiges Ergebnis (und zwar immer das gleiche) liefert, wie k\u00f6nnen dann Zufallszahlen berechnet werden? Success Wir haben ein Verst\u00e4ndnis \u00fcber den Algorithmus -Begriff erlangt und wissen, was Finitheit , Determiniertheit , Determinismus und Terminierung bedeuten.","title":"Beispiel: (3n+1)-Vermutung (Collatz-Problem)"},{"location":"start/#programmablaufstrukturen","text":"Interessanterweise gibt es nur drei verschiedene Ablaufstrukturen in Programmen bzw. Algorithmen. Alle drei haben wir bereits verwendet. Mit Ablaufstrukturen meinen wir die Abarbeitungsreihenfolge von Anweisungen. Man sagt auch Kontrollfluss dazu. Die drei Ablaufstrukturen, die es gibt, sind: die Sequenz : die Anweisungen werden in sequenzieller Abfolge, d.h. hintereinander ausgef\u00fchrt die Iteration : die Abl\u00e4ufe werden wiederholt ausgef\u00fchrt, also in einer Schleife die Selektion : die Abl\u00e4ufe werden selektiv , d.h. unter einer bestimmten Bedingung ausgef\u00fchrt. Man nennt diese Struktur auch Verzweigung oder bedingte Alternative Wir schauen uns alle drei Kontrollstrukturen einmal genauer an.","title":"Programmablaufstrukturen"},{"location":"start/#die-sequenz","text":"Bei der Sequenz handelt es sich einfach um hintereinander ausgef\u00fchrte Anweisungen. Es wird stets erst die eine Anweisung vollst\u00e4ndig abgearbeitet, ehe die andere begonnen wird. Sequenz von 3 Anweisungen Anweisung1 Anweisung2 Anweisung3 Ein Beispiel (mit 2 Anweisungen) w\u00e4re: berechne 3 *n und weise das Ergebnis n zu berechne n+1 und weise das Ergebnis n zu Zur Visualisierung von Kontrollstrukturen werden auch sogannnte Programmablaufdiagramme oder Programmablaufpl\u00e4ne verwendet. F\u00fcr eine Sequenz s\u00e4he ein solches Ablaufdiagramm so aus: So ein Diagramm wird von oben nach unten gelesen. Es wird also erst Anweisung1 ausgef\u00fchrt, dann Anweisung2 und zuletzt Anweisung3 . Innerhalb einer Sequenz gilt immer single entry / single exit , d.h. keine der Anweisungen innerhalb einer Sequenz kann mehrere Ausg\u00e4nge oder mehrere Eing\u00e4nge haben. Es w\u00e4re ansonsten nicht-deterministisch und somit ein Versto\u00df gegen unseren Algorithmusbegriff.","title":"Die Sequenz"},{"location":"start/#die-iteration","text":"Bei der Iteration handelt es sich um eine wiederholte Ausf\u00fchrung einer Anweisung bzw. einer Sequenz von Anweisungen. Wie oft eine Iteration ausgef\u00fchrt wird, h\u00e4ngt von einer Bedingung ab. In der Programmierung sprechen wir bei der Iteration auch von einer Schleife . Bedingungen f\u00fcr eine solche Schleife haben wir bereits kennengelernt: solange a ungleich b ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt bzw. solange n ungleich 1 ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt Wichtig ist, dass es auch hier eine strikte Reihenfolge der Abarbeitung der Anweisungen gibt: es wird zun\u00e4chst gepr\u00fcft, ob die Bedingung erf\u00fcllt (wahr) ist, also ob z.B. a ungleich b ist oder ob n ungleich 1 . Wenn diese Bedingung erf\u00fcllt (also wahr) ist, dann werden die Anweisung(en) innerhalb der Schleife nacheinander (sequenziell) abgearbeitet. Erst wenn alle Anweisungen innerhalb der Schleife abgearbeitet wurden, wird die Schleifenbedingung erneut gepr\u00fcft. Ist sie wieder wahr, werden die Anweisungen innerhalb der Schleife erneut abgearbeitet usw. Ist sie nicht wahr, also wenn z.B. a gleich b ist oder n gleich 1 ist , dann wird die Schleife beendet und die Anweisungen innerhalb der Schleife nicht (erneut) abgearbeitet. Das Ablaufdiagramm einer Schleife (Iteration) sieht so aus: Die eigentliche Iteration ist gr\u00fcn dargestellt. Wir kommen von einer anderen Anweisung und pr\u00fcfen die Bedingung. Ist sie wahr, wird Anweisung1 ausgef\u00fchrt. Beachte Anweisung1 muss nicht zwingend nur genau eine Anweisung sein. Bei Anweisung1 kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder sogar selbst um eine Iteration (Schleife in der Schleife - verschachtelte Schleife) handeln! Nach jeder Ausf\u00fchrung von Anweisung1 wird die Bedingung erneut gepr\u00fcft. Ist sie (immernoch) wahr, wird Anweisung1 erneut ausgef\u00fchrt. Ist die Bedingung jedoch falsch, dann wird Anweisung1 nicht (mehr) ausgef\u00fchrt, sondern die Schleife wird verlassen und die Anweisung, die der Schleife folgt, wird ausgef\u00fchrt ( Anweisung2 ) oder das Programm ist dann zu Ende. Beachte Es kann sein, dass Anweisung1 gar nicht ausgef\u00fchrt wird, weil die Bedingung bereits bei der ersten Pr\u00fcfung falsch ist. Es ist also nicht gesagt, dass sich eine Iteration wirklich wiederholt . Es kann sein, dass Anweisung1 gar nicht oder nur genau ein Mal ausgef\u00fchrt wird (wenn die Bedingung nach der ersten Ausf\u00fchrung falsch ist). Das ist kein Problem! Ein Problem ist es jedoch, wenn die Bedingung niemals falsch wird und die Schleife unendlich oft hintereinander ausgef\u00fchrt wird. Das ist ein Versto\u00df gegen die Terminierung eines Algorithmus. In einem solchen Fall werden wir irgendwann einen Fehler bei der Programmausf\u00fchrung erhalten (aber erst zur Ausf\u00fchrungszeit, nicht bereits beim Compilieren). Wir werden uns ausf\u00fchrlich mit Schleifen auseinandersetzen, da sie logisch recht anspruchsvoll und dadurch h\u00e4ufig fehleranf\u00e4llig sein k\u00f6nnen.","title":"Die Iteration"},{"location":"start/#die-selektion","text":"Bei der Selektion handelt es sich, im Gegensatz zur Iteration, um eine einmalige Ausf\u00fchrung einer (oder mehrerer) Anweisung(en). Jedoch ist diese Ausf\u00fchrung, im Gegensatz zur Sequenz, von einer Bedingung abh\u00e4ngig. Wir hatten eine solche Selektion jeweils in obigen Beispielalgorithmen. Selektion aus dem euklidischen Algorithmus: wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu Selektion aus der (3n+1)-Vermutung (dem Collatz-Problem): wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Es gibt also immer eine Bedingung (z.B. wenn a gr\u00f6\u00dfer ist als b ) und abh\u00e4ngig vom Wert dieser Bedingung (wahr oder falsch), wird entweder die eine Anweisung (z.B. ziehe b von a ab und weise das Ergebnis a zu ) oder die andere (z.B. ziehe a von b ab und weise das Ergebnis b zu ) ausgef\u00fchrt. Das Ablaufdiagramm einer Selektion sieht so aus: Beachte Anweisung1 und auch Anweisung2 m\u00fcssen nicht zwingend jeweils nur genau eine Anweisung sein. Bei beiden kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder um eine Iteration handeln!","title":"Die Selektion"},{"location":"start/#verschachteln-von-kontrollstrukturen","text":"Mehr als diese drei genannten Kontrollstrukturen gibt es nicht. Aber diese Kontrollstrukturen k\u00f6nnen beliebig ineinander verschachtelt werden. \u00dcberall dort, wo eine Anweisung steht (z.B. Anweisung1 ) kann auch eine komplette Kontrollstruktur eingesetzt werden, also eine Sequenz von Anweisungen oder eine Iteration oder eine Selektion. Die kann dann beliebig fortgef\u00fchrt werden. So entstehen komplexe Strukturen - und somit komplexe Programme. Ein (immernoch recht einfaches) Beispiel f\u00fcr eine etwas komplexere Struktur: \u00dcbung Programmablaufpl\u00e4ne Erstellen Sie sowohl f\u00fcr den euklidischen Algorithmus als auch f\u00fcr die (3n+1)-Vermutung einen Programmablaufplan! \u00dcbung Algorithmus und Programmablaufplan Ein Jahr ist ein Schaltjahr, wenn es sich durch 4 teilen l\u00e4sst. Au\u00dfer, es l\u00e4sst sich durch 100 teilen. Dann ist es doch kein Schaltjahr. Au\u00dfer, es l\u00e4sst sich durch 400 teilen. Dann ist es doch ein Schaltjahr. Beschreiben Sie diese Vorschrift als einen Algorithmus in der Form, in der auch der euklidische Algorithmus und die (3n+1)-Vermutung beschrieben wurden. Erstellen Sie dann den dazugeh\u00f6rigen Programmablaufplan. Success Wir wissen nun, dass es nur drei verschiedene Programmablaufstrukturen gibt: die Sequenz, die Iteration und die Selektion. Wir haben ein Verst\u00e4ndnis davon, was die drei Programmablaufstrukturen ausmacht, welchen Zweck sie haben und was sie voneinander unterscheidet. Wir wissen, dass sich diese Strukturen beliebig ineinander verschachteln lassen. Benannt nach Euklid von Alexandria, einem Mathematiker aus dem 3. Jahrhundert, Autor der Elemente - einem Kompendium des Wissens der Mathematik seiner Zeit. \u21a9","title":"Verschachteln von Kontrollstrukturen"},{"location":"tools/","text":"Werkzeuge \u00b6 Literaturempfehlungen \u00b6 Joachim Goll, Cornelia Heinisch: \"Java als erste Programmiersprache. Ein professioneller Einstieg in die Objektorientierung mit Java\" , Springer Vieweg Sebastian D\u00f6rn: \"Java lernen in abgeschlossenen Lerneinheiten\" , Springer Vieweg Dietmar Ratz, Jens Scheffler, Detlef Seese, Jan Wiesenberger: \"Grundkurs Programmieren in Java x\" , Hanser Verlag Kathy Sierra, Bert Bates: \"Java von Kopf bis Fu\u00df\" , O'Reilly Verlag Joshua Bloch: \"Effective Java. Best practices for the Java platform\" , Pearson Education Inc. Robin C. Martin: \"Clean Code: A Handbook of Agile Software Craftmanship\" , Prentice Hall und alle B\u00fccher f\u00fcr Einsteigerinnen, die Sie ansprechen... Java \u00b6 Wir verwenden die Programmiersprache Java , um die Programmierkonzepte, die wir lernen und anwenden wollen, zu implementieren. Java besteht aus 2 Teilen: der Java Run Time Environment (Java RTE) (Java-Laufzeitumgebung) dem Java Development Kit (JDK) (die Java-Entwicklungsumgebung) Die Java-Laufzeitumgebung ist \u00fcblicherweise bereits auf allen Rechnern installiert. Sie ist selbst ein Programm. Innerhalb dieses Programms werden Java-Programme ausgef\u00fchrt. Das JDK m\u00fcssen Sie installieren. Verwenden Sie dazu diesen Link und gehen wie f\u00fcr Ihr Betriebssystem angegeben vor (pr\u00fcfen Sie aber zun\u00e4chst, ob Sie nicht eventuell bereits Beides haben - java -version und javac -version - siehe folgend). Testen Sie am besten auf Ihrer Konsole (Terminal), ob Ihr Java korrekt funktioniert. Zum Testen Ihrer Laufzeitumgebung geben Sie dazu java -version ein. Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): java version \"15.0.1\" 2020 -10-20 Java ( TM ) SE Runtime Environment ( build 15 .0.1+9-18 ) Java HotSpot ( TM ) 64 -Bit Server VM ( build 15 .0.1+9-18, mixed mode, sharing ) Somit wissen Sie, dass die Laufzeitumgebung funktioniert. Zum Testen des JDK rufen wir am besten den Compiler ( javac ) auf: javac -version Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): javac 15 .0.1 Success Sie haben nun die Java-Laufzeitumgebung installiert, in der unsere Java-Programme ausgef\u00fchrt werden und Sie haben das Java Development Kit installiert. Teil des JDK ist z.B. der Compiler , der unsere Java-Programme in Byte-Code \u00fcbersetzt. Dieser Bytecode wird in unserer Java-Laufzeitumgebung ausgef\u00fchrt. IDE \u00b6 Um unsere Programme \"zu schreiben\", verwenden wir eine sogenannte Integrated Development Environment (IDE) , eine integrierte Entwicklungsumgebung, die uns beim Programmieren unterst\u00fctzt. Wir k\u00f6nnten unsere Programme auch mit einfachen Texteditoren schreiben, aber eine IDE unterst\u00fctzt uns, indem der Programmcode geeignet hervorgehoben wird ( Syntx-Highlighting ) und uns Vorschl\u00e4ge f\u00fcr die Verwendung von Methoden und Variablen gemacht werden ( Intelligent Code Completion ). BlueJ \u00b6 Am Anfang verwenden wir BlueJ . BlueJ wird an der University of Kent (UK) entwickelt und richtet sich speziell an Programmieranf\u00e4ngerinnen. Das Tolle an BlueJ ist, dass die Funktionsbl\u00f6cke , die zusammengeh\u00f6ren, farbig hervorgehoben werden. Die Download-Seite von BlueJ befindet sich hier . Laden Sie BlueJ herunter, entpacken Sie das zip-File und bewegen Sie den Ordner BlueJ in Ihren Programme-Ordner. Derzeit hei\u00dft der Ordner BlueJ 5 .0.2 In dem Ordner befindet sich die ausf\u00fchrbare BlueJ -Datei ( BlueJ.app oder BlueJ.exe ) und ein examples -Ordner. \u00d6ffnen Sie BlueJ durch Doppelklick auf die ausf\u00fchrbare BlueJ -Datei. W\u00e4hlen Sie im Men\u00fc Project --> Open Project... . Klicken Sie zum examples -Ordner und w\u00e4hlen Sie das Projekt hello und \u00f6ffnen Sie es. BlueJ sieht dann so aus: Klicken Sie mit der rechten Maustaste auf das gelbe Rechteck Hello und w\u00e4hlen Sie im Men\u00fc Open editor aus. Es erscheint folgendes Fenster: Klicken Sie in diesem Fenster auf den Button Compile . Es sollte folgendes Fenster erscheinen: Success Sie haben BlueJ erfolgreich installiert und die Java-Programme werden \u00fcbersetzt (compiliert). Eclipse \u00b6 Nachdem wir anfangs alle BlueJ verwenden, sind Sie danach in der Wahl Ihrer IDE frei. Wir verwenden Eclipse . Eclipse ist in Java geschrieben und Open-Source. Den Download-Link f\u00fcr Eclipse finden Sie hier . Es gibt verschiedene Versionen von Eclipse, wir verwenden die Eclipse IDE for Java Developers . Installieren Sie Eclipse am besten in ihren Applications oder Programme Ordner. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 oder Uebung1 oder Aufgabe2 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie einen Paketnamen ein (Paketnamen werden kleingeschrieben), z.B. themen.start . Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes (z.B. themen.start ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe eines beliebigen Namens, der gleichzeitig der Klassen- und Dateiname ist (z.B. HelloFIW ). Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . Klicken auf den Button Finish . Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die Bedeutung der einzelnen Fenster in Eclipse: IntelliJ \u00b6 Diejenigen von Ihnen, die nicht Eclipse verwenden, werden sich stattdessen wahrscheinlich f\u00fcr IntelliJ entscheiden. Das ist v\u00f6llig in Ordnung. IntelliJ ist von JetBrains, einem tschechischen Unternehmen, und derzeit die wohl modernste IDE auf dem Markt, nicht nur f\u00fcr Java- sondern auch f\u00fcr Web-Entwicklungen. IntelliJ ist nicht Open-Source und ist kostenpflichtig. Mit einer Hochschullizenz erhalten Sie jedoch kostenlosen Zugriff auf alle Enterprise-Versionen. Sie m\u00fcssen sich dazu bei JetBrains mit Ihrer HTW-Adresse registrieren. Visual Studio Code \u00b6 Wer gerne mit Microsoft-Produkten arbeitet, kann auch gerne Visual Studio Code ( VS Code ) arbeiten. Das ist auch eine sehr gute IDE und ebenfalls nicht nur zur Nutzung f\u00fcr die Java-Entwicklung, sondern auch f\u00fcr Web- und App-Entwicklungen geeignet. Sp\u00e4testens im dritten Semster in WebTech werden die meisten von Ihnen entweder auf IntelliJ oder VS Code wechseln. Weitere n\u00fctzliche Werkzeuge \u00b6 Windows: gitBash \u00b6 Das Terminal ( cmd ) in Windows ist nicht so gut. Installieren Sie sich lieber die GitBash f\u00fcr Windows . Unter Downloads \u00f6ffnet sich das GitHub-Repository f\u00fcr Git. Aktuell w\u00e4hlen Sie dort Git-2.29.2-64-bit.exe und folgen dann den Installationsanweisungen. Online-Kurse \u00b6 SoloLearn https://www.sololearn.com/Course/Java/ JetBrains Academy https://hyperskill.org/tracks/1","title":"Werkzeuge"},{"location":"tools/#werkzeuge","text":"","title":"Werkzeuge"},{"location":"tools/#literaturempfehlungen","text":"Joachim Goll, Cornelia Heinisch: \"Java als erste Programmiersprache. Ein professioneller Einstieg in die Objektorientierung mit Java\" , Springer Vieweg Sebastian D\u00f6rn: \"Java lernen in abgeschlossenen Lerneinheiten\" , Springer Vieweg Dietmar Ratz, Jens Scheffler, Detlef Seese, Jan Wiesenberger: \"Grundkurs Programmieren in Java x\" , Hanser Verlag Kathy Sierra, Bert Bates: \"Java von Kopf bis Fu\u00df\" , O'Reilly Verlag Joshua Bloch: \"Effective Java. Best practices for the Java platform\" , Pearson Education Inc. Robin C. Martin: \"Clean Code: A Handbook of Agile Software Craftmanship\" , Prentice Hall und alle B\u00fccher f\u00fcr Einsteigerinnen, die Sie ansprechen...","title":"Literaturempfehlungen"},{"location":"tools/#java","text":"Wir verwenden die Programmiersprache Java , um die Programmierkonzepte, die wir lernen und anwenden wollen, zu implementieren. Java besteht aus 2 Teilen: der Java Run Time Environment (Java RTE) (Java-Laufzeitumgebung) dem Java Development Kit (JDK) (die Java-Entwicklungsumgebung) Die Java-Laufzeitumgebung ist \u00fcblicherweise bereits auf allen Rechnern installiert. Sie ist selbst ein Programm. Innerhalb dieses Programms werden Java-Programme ausgef\u00fchrt. Das JDK m\u00fcssen Sie installieren. Verwenden Sie dazu diesen Link und gehen wie f\u00fcr Ihr Betriebssystem angegeben vor (pr\u00fcfen Sie aber zun\u00e4chst, ob Sie nicht eventuell bereits Beides haben - java -version und javac -version - siehe folgend). Testen Sie am besten auf Ihrer Konsole (Terminal), ob Ihr Java korrekt funktioniert. Zum Testen Ihrer Laufzeitumgebung geben Sie dazu java -version ein. Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): java version \"15.0.1\" 2020 -10-20 Java ( TM ) SE Runtime Environment ( build 15 .0.1+9-18 ) Java HotSpot ( TM ) 64 -Bit Server VM ( build 15 .0.1+9-18, mixed mode, sharing ) Somit wissen Sie, dass die Laufzeitumgebung funktioniert. Zum Testen des JDK rufen wir am besten den Compiler ( javac ) auf: javac -version Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): javac 15 .0.1 Success Sie haben nun die Java-Laufzeitumgebung installiert, in der unsere Java-Programme ausgef\u00fchrt werden und Sie haben das Java Development Kit installiert. Teil des JDK ist z.B. der Compiler , der unsere Java-Programme in Byte-Code \u00fcbersetzt. Dieser Bytecode wird in unserer Java-Laufzeitumgebung ausgef\u00fchrt.","title":"Java"},{"location":"tools/#ide","text":"Um unsere Programme \"zu schreiben\", verwenden wir eine sogenannte Integrated Development Environment (IDE) , eine integrierte Entwicklungsumgebung, die uns beim Programmieren unterst\u00fctzt. Wir k\u00f6nnten unsere Programme auch mit einfachen Texteditoren schreiben, aber eine IDE unterst\u00fctzt uns, indem der Programmcode geeignet hervorgehoben wird ( Syntx-Highlighting ) und uns Vorschl\u00e4ge f\u00fcr die Verwendung von Methoden und Variablen gemacht werden ( Intelligent Code Completion ).","title":"IDE"},{"location":"tools/#bluej","text":"Am Anfang verwenden wir BlueJ . BlueJ wird an der University of Kent (UK) entwickelt und richtet sich speziell an Programmieranf\u00e4ngerinnen. Das Tolle an BlueJ ist, dass die Funktionsbl\u00f6cke , die zusammengeh\u00f6ren, farbig hervorgehoben werden. Die Download-Seite von BlueJ befindet sich hier . Laden Sie BlueJ herunter, entpacken Sie das zip-File und bewegen Sie den Ordner BlueJ in Ihren Programme-Ordner. Derzeit hei\u00dft der Ordner BlueJ 5 .0.2 In dem Ordner befindet sich die ausf\u00fchrbare BlueJ -Datei ( BlueJ.app oder BlueJ.exe ) und ein examples -Ordner. \u00d6ffnen Sie BlueJ durch Doppelklick auf die ausf\u00fchrbare BlueJ -Datei. W\u00e4hlen Sie im Men\u00fc Project --> Open Project... . Klicken Sie zum examples -Ordner und w\u00e4hlen Sie das Projekt hello und \u00f6ffnen Sie es. BlueJ sieht dann so aus: Klicken Sie mit der rechten Maustaste auf das gelbe Rechteck Hello und w\u00e4hlen Sie im Men\u00fc Open editor aus. Es erscheint folgendes Fenster: Klicken Sie in diesem Fenster auf den Button Compile . Es sollte folgendes Fenster erscheinen: Success Sie haben BlueJ erfolgreich installiert und die Java-Programme werden \u00fcbersetzt (compiliert).","title":"BlueJ"},{"location":"tools/#eclipse","text":"Nachdem wir anfangs alle BlueJ verwenden, sind Sie danach in der Wahl Ihrer IDE frei. Wir verwenden Eclipse . Eclipse ist in Java geschrieben und Open-Source. Den Download-Link f\u00fcr Eclipse finden Sie hier . Es gibt verschiedene Versionen von Eclipse, wir verwenden die Eclipse IDE for Java Developers . Installieren Sie Eclipse am besten in ihren Applications oder Programme Ordner. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 oder Uebung1 oder Aufgabe2 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie einen Paketnamen ein (Paketnamen werden kleingeschrieben), z.B. themen.start . Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes (z.B. themen.start ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe eines beliebigen Namens, der gleichzeitig der Klassen- und Dateiname ist (z.B. HelloFIW ). Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . Klicken auf den Button Finish . Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die Bedeutung der einzelnen Fenster in Eclipse:","title":"Eclipse"},{"location":"tools/#intellij","text":"Diejenigen von Ihnen, die nicht Eclipse verwenden, werden sich stattdessen wahrscheinlich f\u00fcr IntelliJ entscheiden. Das ist v\u00f6llig in Ordnung. IntelliJ ist von JetBrains, einem tschechischen Unternehmen, und derzeit die wohl modernste IDE auf dem Markt, nicht nur f\u00fcr Java- sondern auch f\u00fcr Web-Entwicklungen. IntelliJ ist nicht Open-Source und ist kostenpflichtig. Mit einer Hochschullizenz erhalten Sie jedoch kostenlosen Zugriff auf alle Enterprise-Versionen. Sie m\u00fcssen sich dazu bei JetBrains mit Ihrer HTW-Adresse registrieren.","title":"IntelliJ"},{"location":"tools/#visual-studio-code","text":"Wer gerne mit Microsoft-Produkten arbeitet, kann auch gerne Visual Studio Code ( VS Code ) arbeiten. Das ist auch eine sehr gute IDE und ebenfalls nicht nur zur Nutzung f\u00fcr die Java-Entwicklung, sondern auch f\u00fcr Web- und App-Entwicklungen geeignet. Sp\u00e4testens im dritten Semster in WebTech werden die meisten von Ihnen entweder auf IntelliJ oder VS Code wechseln.","title":"Visual Studio Code"},{"location":"tools/#weitere-nutzliche-werkzeuge","text":"","title":"Weitere n\u00fctzliche Werkzeuge"},{"location":"tools/#windows-gitbash","text":"Das Terminal ( cmd ) in Windows ist nicht so gut. Installieren Sie sich lieber die GitBash f\u00fcr Windows . Unter Downloads \u00f6ffnet sich das GitHub-Repository f\u00fcr Git. Aktuell w\u00e4hlen Sie dort Git-2.29.2-64-bit.exe und folgen dann den Installationsanweisungen.","title":"Windows: gitBash"},{"location":"tools/#online-kurse","text":"SoloLearn https://www.sololearn.com/Course/Java/ JetBrains Academy https://hyperskill.org/tracks/1","title":"Online-Kurse"},{"location":"uebungen/","text":"\u00dcbungen \u00b6 \u00dcbungsbl\u00e4tter (wochenweise) \u00b6 \u00dcbung 1 (20.10.2021) Vorbereitung Installieren Sie - falls noch nicht geschehen - das Java Davelopment Kit (JDK) (siehe Java ). Installieren Sie BlueJ (siehe IDE ). Starten Sie BlueJ und \u00f6ffnen Sie ( Project --> Open Project... ) das Projekt picture (im BlueJ-Ordner unter examples ). Klicken Sie dann den Compile -Button. Klicken Sie mit der rechten Maustaste auf die Klasse Picture (das orangene K\u00e4stchen mit der Beschriftung Picture ) und erzeugen Sie davon ein Objekt picture1 . Klicken Sie mit der rechten Maustaste auf das Objekt picture1 und rufen Sie die Methode draw() auf. Klicken Sie erneut mit der echten Maustaste auf die Klasse Picture und \u00f6ffnen Sie den Editor mit Open Editor . Es erscheint das Java-Programm (der Quellcode ) der Klasse Picture : Picture.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /** * This class represents a simple picture. You can draw the picture using * the draw method. But wait, there's more: being an electronic picture, it * can be changed. You can set it to black-and-white display and back to * colors (only after it's been drawn, of course). * * This class was written as an early example for teaching Java with BlueJ. * * @author Michael K\u00f6lling and David J. Barnes * @version 1.1 (24 May 2001) */ public class Picture { private Square wall ; private Square window ; private Triangle roof ; private Circle sun ; /** * Constructor for objects of class Picture */ public Picture () { // nothing to do... instance variables are automatically set to null } /** * Draw this picture. */ public void draw () { wall = new Square (); wall . moveVertical ( 80 ); wall . changeSize ( 100 ); wall . makeVisible (); window = new Square (); window . changeColor ( \"black\" ); window . moveHorizontal ( 20 ); window . moveVertical ( 100 ); window . makeVisible (); roof = new Triangle (); roof . changeSize ( 50 , 140 ); roof . moveHorizontal ( 60 ); roof . moveVertical ( 70 ); roof . makeVisible (); sun = new Circle (); sun . changeColor ( \"yellow\" ); sun . moveHorizontal ( 180 ); sun . moveVertical ( - 10 ); sun . changeSize ( 60 ); sun . makeVisible (); } /** * Change this picture to black/white display */ public void setBlackAndWhite () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"black\" ); window . changeColor ( \"white\" ); roof . changeColor ( \"black\" ); sun . changeColor ( \"black\" ); } } /** * Change this picture to use color display */ public void setColor () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"red\" ); window . changeColor ( \"black\" ); roof . changeColor ( \"green\" ); sun . changeColor ( \"yellow\" ); } } } Wir schauen uns diese Klasse ein wenig genauer an und diskutieren einige Details (Objektvariablen, Objektmethoden, Kommentare, ...). Durchf\u00fchrung F\u00fcr diese \u00dcbung interessiert uns nur die Methode draw() . Die Methodenaufrufe, die wir bis jetzt immer einzeln vorgenommen haben, werden nun \"aufgeschrieben\" - wir programmieren ! \u00c4ndern Sie Farben und Positionen der einzelnen Objekte! Wenn Sie Ihre \u00c4nderungen ausprobieren wollen, m\u00fcssen Sie die Klasse neu compilieren . Durch das Compilieren gehen die erzeugten Objekte verloren. Warum ist das wohl so? Lassen Sie die Sonne langsam untergehen. Welche Objektmethode kommt daf\u00fcr infrage? F\u00fcr welches Objekt muss diese Objektmethode aufgerufen werden? Tipp: Derzeit ist es recht m\u00fchsam, die \u00c4nderungen zu testen. Wir m\u00fcssen die Klasse Picture compilieren, dann ein Objekt dieser Klasse erzeugen und dann f\u00fcr dieses Objekt die Methode draw() aufrufen. Wir wollen diesen Vorgang etwas vereinfachen und erstellen uns dazu eine Testklasse . Klicken Sie mit der rechten Maustaste auf die Klasse Picture und w\u00e4hlen Sie Create Test Class aus. Klicken Sie mit der rechten Maustaste auf diese neue Testklasse PictureTest und w\u00e4hlen Sie Create Test Method ... aus. Geben Sie als Namen f\u00fcr diese Testmethode drawTest an und best\u00e4tigen Sie die Eingabe mit OK . Nun wird ein Test \"aufgenommen\". Klicken Sie mit der rechten Maustaste auf die Klasse Picture und erzeugen Sie von dieser Klasse eine Objekt picture1 . F\u00fcr dieses Objekt rufen Sie die draw() -Methode auf. Klicken Sie dann im Hauptfenster auf der linken Seite unter recording den Button End . Sie haben nun einen Test erzeugt, den Sie leicht aufrufen k\u00f6nnen. \u00c4ndern Sie Ihre draw() -Methode, compilieren Sie die Klasse Picture und w\u00e4hlen Sie nun mit der rechten Maustaste f\u00fcr die Klasse PictureTest die Methode drawTest() aus und rufen diese auf. \u00dcbung 2 (27.10.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung2 . Erstellen Sie darin eine Klasse Uebung2 . Ersetzen Sie den gesamten Code der Klasse Uebung2 durch folgenden Code: public class Uebung2 { public Uebung2 () { } public void printLesson2 () { // Schreiben Sie Ihren gesamten Code in diese Methode // und fuehren Sie diese Methode aus } } Deklarieren und initialisieren Sie in der printLesson2() -Methode jeweils eine Variable mit dem Datentyp int , long , char , byte , short , float , double , boolean und String . Geben Sie alle Werte einzeln durch Aufruf der println() -Methode aus. Erzeugen Sie dabei folgende Ausgabe (Werte nur Beispiele): Wert vom Typ int : 123 Wert vom Typ long : 456789 Wert vom Typ char : a Wert vom Typ byte : 127 Wert vom Typ short : 32767 Wert vom Typ float : 4 .23 Wert vom Typ double : 6 .98 Wert vom Typ boolean : true Wert vom Typ String : Hallo! Setzen Sie den Wert Ihrer int -Variablen auf 2147483647 . Geben Sie den Wert auf der Konsole aus, z.B.: Wert von i : 2147483647 Erh\u00f6hen Sie nun den Wert der Variablen um 1 und geben Sie den Wert erneut aus. Was passiert? Warum? Wiederholen Sie das gleiche mit einer `long-Variablen. Weisen Sie Ihrer char -Variablen den Wert 65 zu. Geben Sie den Wert Ihrer char -Variablen aus. Was passiert? Warum? Deklarieren Sie zwei weitere int -Variablen und weisen Sie diesen Variablen Werte zu. Erzeugen Sie unter Verwendung der Werte dieser beiden Variablen folgende Ausgabe (wir nehmen an, die beiden Werte sind 17 und 4 ): 17 geteilt durch 4 ergibt 4 . Es bleibt ein Rest von 1 \u00c4ndern Sie das Programm so, dass bei einer ganzzahligen Division ohne Rest die Ausgabe in der Form ist (z.B. f\u00fcr die Werte 16 und 4 ): 16 geteilt durch 4 ergibt 4 ohne Rest. F\u00fcgen Sie zwei weitere Anweisungen hinzu, sodass mit Hilfe der println() -Methode folgende Ausgaben (f\u00fcr die Beispielwerte 17 und 4 ) erscheinen: 17 /4 = 4 17 mod 4 = 1","title":"\u00dcbungen"},{"location":"uebungen/#ubungen","text":"","title":"\u00dcbungen"},{"location":"uebungen/#ubungsblatter-wochenweise","text":"\u00dcbung 1 (20.10.2021) Vorbereitung Installieren Sie - falls noch nicht geschehen - das Java Davelopment Kit (JDK) (siehe Java ). Installieren Sie BlueJ (siehe IDE ). Starten Sie BlueJ und \u00f6ffnen Sie ( Project --> Open Project... ) das Projekt picture (im BlueJ-Ordner unter examples ). Klicken Sie dann den Compile -Button. Klicken Sie mit der rechten Maustaste auf die Klasse Picture (das orangene K\u00e4stchen mit der Beschriftung Picture ) und erzeugen Sie davon ein Objekt picture1 . Klicken Sie mit der rechten Maustaste auf das Objekt picture1 und rufen Sie die Methode draw() auf. Klicken Sie erneut mit der echten Maustaste auf die Klasse Picture und \u00f6ffnen Sie den Editor mit Open Editor . Es erscheint das Java-Programm (der Quellcode ) der Klasse Picture : Picture.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /** * This class represents a simple picture. You can draw the picture using * the draw method. But wait, there's more: being an electronic picture, it * can be changed. You can set it to black-and-white display and back to * colors (only after it's been drawn, of course). * * This class was written as an early example for teaching Java with BlueJ. * * @author Michael K\u00f6lling and David J. Barnes * @version 1.1 (24 May 2001) */ public class Picture { private Square wall ; private Square window ; private Triangle roof ; private Circle sun ; /** * Constructor for objects of class Picture */ public Picture () { // nothing to do... instance variables are automatically set to null } /** * Draw this picture. */ public void draw () { wall = new Square (); wall . moveVertical ( 80 ); wall . changeSize ( 100 ); wall . makeVisible (); window = new Square (); window . changeColor ( \"black\" ); window . moveHorizontal ( 20 ); window . moveVertical ( 100 ); window . makeVisible (); roof = new Triangle (); roof . changeSize ( 50 , 140 ); roof . moveHorizontal ( 60 ); roof . moveVertical ( 70 ); roof . makeVisible (); sun = new Circle (); sun . changeColor ( \"yellow\" ); sun . moveHorizontal ( 180 ); sun . moveVertical ( - 10 ); sun . changeSize ( 60 ); sun . makeVisible (); } /** * Change this picture to black/white display */ public void setBlackAndWhite () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"black\" ); window . changeColor ( \"white\" ); roof . changeColor ( \"black\" ); sun . changeColor ( \"black\" ); } } /** * Change this picture to use color display */ public void setColor () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"red\" ); window . changeColor ( \"black\" ); roof . changeColor ( \"green\" ); sun . changeColor ( \"yellow\" ); } } } Wir schauen uns diese Klasse ein wenig genauer an und diskutieren einige Details (Objektvariablen, Objektmethoden, Kommentare, ...). Durchf\u00fchrung F\u00fcr diese \u00dcbung interessiert uns nur die Methode draw() . Die Methodenaufrufe, die wir bis jetzt immer einzeln vorgenommen haben, werden nun \"aufgeschrieben\" - wir programmieren ! \u00c4ndern Sie Farben und Positionen der einzelnen Objekte! Wenn Sie Ihre \u00c4nderungen ausprobieren wollen, m\u00fcssen Sie die Klasse neu compilieren . Durch das Compilieren gehen die erzeugten Objekte verloren. Warum ist das wohl so? Lassen Sie die Sonne langsam untergehen. Welche Objektmethode kommt daf\u00fcr infrage? F\u00fcr welches Objekt muss diese Objektmethode aufgerufen werden? Tipp: Derzeit ist es recht m\u00fchsam, die \u00c4nderungen zu testen. Wir m\u00fcssen die Klasse Picture compilieren, dann ein Objekt dieser Klasse erzeugen und dann f\u00fcr dieses Objekt die Methode draw() aufrufen. Wir wollen diesen Vorgang etwas vereinfachen und erstellen uns dazu eine Testklasse . Klicken Sie mit der rechten Maustaste auf die Klasse Picture und w\u00e4hlen Sie Create Test Class aus. Klicken Sie mit der rechten Maustaste auf diese neue Testklasse PictureTest und w\u00e4hlen Sie Create Test Method ... aus. Geben Sie als Namen f\u00fcr diese Testmethode drawTest an und best\u00e4tigen Sie die Eingabe mit OK . Nun wird ein Test \"aufgenommen\". Klicken Sie mit der rechten Maustaste auf die Klasse Picture und erzeugen Sie von dieser Klasse eine Objekt picture1 . F\u00fcr dieses Objekt rufen Sie die draw() -Methode auf. Klicken Sie dann im Hauptfenster auf der linken Seite unter recording den Button End . Sie haben nun einen Test erzeugt, den Sie leicht aufrufen k\u00f6nnen. \u00c4ndern Sie Ihre draw() -Methode, compilieren Sie die Klasse Picture und w\u00e4hlen Sie nun mit der rechten Maustaste f\u00fcr die Klasse PictureTest die Methode drawTest() aus und rufen diese auf. \u00dcbung 2 (27.10.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung2 . Erstellen Sie darin eine Klasse Uebung2 . Ersetzen Sie den gesamten Code der Klasse Uebung2 durch folgenden Code: public class Uebung2 { public Uebung2 () { } public void printLesson2 () { // Schreiben Sie Ihren gesamten Code in diese Methode // und fuehren Sie diese Methode aus } } Deklarieren und initialisieren Sie in der printLesson2() -Methode jeweils eine Variable mit dem Datentyp int , long , char , byte , short , float , double , boolean und String . Geben Sie alle Werte einzeln durch Aufruf der println() -Methode aus. Erzeugen Sie dabei folgende Ausgabe (Werte nur Beispiele): Wert vom Typ int : 123 Wert vom Typ long : 456789 Wert vom Typ char : a Wert vom Typ byte : 127 Wert vom Typ short : 32767 Wert vom Typ float : 4 .23 Wert vom Typ double : 6 .98 Wert vom Typ boolean : true Wert vom Typ String : Hallo! Setzen Sie den Wert Ihrer int -Variablen auf 2147483647 . Geben Sie den Wert auf der Konsole aus, z.B.: Wert von i : 2147483647 Erh\u00f6hen Sie nun den Wert der Variablen um 1 und geben Sie den Wert erneut aus. Was passiert? Warum? Wiederholen Sie das gleiche mit einer `long-Variablen. Weisen Sie Ihrer char -Variablen den Wert 65 zu. Geben Sie den Wert Ihrer char -Variablen aus. Was passiert? Warum? Deklarieren Sie zwei weitere int -Variablen und weisen Sie diesen Variablen Werte zu. Erzeugen Sie unter Verwendung der Werte dieser beiden Variablen folgende Ausgabe (wir nehmen an, die beiden Werte sind 17 und 4 ): 17 geteilt durch 4 ergibt 4 . Es bleibt ein Rest von 1 \u00c4ndern Sie das Programm so, dass bei einer ganzzahligen Division ohne Rest die Ausgabe in der Form ist (z.B. f\u00fcr die Werte 16 und 4 ): 16 geteilt durch 4 ergibt 4 ohne Rest. F\u00fcgen Sie zwei weitere Anweisungen hinzu, sodass mit Hilfe der println() -Methode folgende Ausgaben (f\u00fcr die Beispielwerte 17 und 4 ) erscheinen: 17 /4 = 4 17 mod 4 = 1","title":"\u00dcbungsbl\u00e4tter (wochenweise)"},{"location":"variablen/","text":"Variablen und Datentypen \u00b6 Sowohl in dem euklidischen Algorithmus als auch bei der (3n+1)-Vermutung haben wir mit Zahlen gerechnet. Diese haben wir in Variablen gespeichert (z.B. a , b , n ). Wir kennen Variablen bereits aus der Mathematik. Dort \"speichern\" wir Werte in diesen Variablen. Das gleiche passiert auch beim Programmieren. Unsere erste Klasse \u00b6 Damit wir das Thema Variablen und Datentypen auch gleich anwenden k\u00f6nnen, schreiben wir nun endlich unser erstes Programm, d.h. wir implementieren unsere erste Klasse. Dazu \u00f6ffnen wir BlueJ und w\u00e4hlen im Men\u00fc Project --> New Project . Es \u00f6ffnet sich ein Dateiauswahlfenster. Unter Location sollten Sie sich einen Ordner aussuchen, in den Sie zuk\u00fcnftig Ihre BlueJ-Projekte speichern, z.B. unter Ihren Dokumenten/Prog1/BlueJ . Als Projektname k\u00f6nnen Sie z.B. variablen nehmen. Es erscheint Klicken Sie auf den Button New Class... und geben Sie Ihrer Klasse den Namen Variablen . Beachten Sie, dass wir Klassennamen stets mit einem Gro\u00dfbuchstaben beginnen! Klicken Sie den Button Compile , dann verschwinden die Streifen im Klassen-Icon. Doppelklicken Sie auf die Klasse Variablen , es \u00f6ffnet sich das Editor-Fenster: Wir schauen uns den darin enthaltenen Code mal etwas genauer an (die erste leere Zeile habe ich gel\u00f6scht, deshalb ist die Zeilennummerierung um 1 versetzt): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Write a description of class Variablen here. * * @author (your name) * @version (a version number or a date) */ public class Variablen { // instance variables - replace the example below with your own private int x ; /** * Constructor for objects of class Variablen */ public Variablen () { // initialise instance variables x = 0 ; } /** * An example of a method - replace this comment with your own * * @param y a sample parameter for a method * @return the sum of x and y */ public int sampleMethod ( int y ) { // put your code here return x + y ; } } Die Zeilen 1 - 6 enthalten einen Kommentar, einen sogenannten JavaDoc-Kommentar . JavaDoc-Kommentare beginnen mit /** und enden mit */ . Dazwischen kann alles stehen und solche Kommentare gehen meistens \u00fcber mehrere Zeilen. Wir werden JavaDoc noch n\u00e4her kennenlernen. In Zeile 7 steht die Klassensignatur. Es handelt sich um eine \u00f6ffentliche Klasse (deshalb public - lernen wir noch) und nach dem Schl\u00fcsselwort class steht der Klassenname Variablen . In Zeile 8 beginnt die Implementierung der Klasse. Diese Implementierung wird durch eine \u00f6ffnende geschweifte Klammer { begonnen und endet in Zeile 32 mit der schlie\u00dfenden geschweiften Klammer } . In Zeile 9 steht ein sogenannter Zeilenkommentar . Ein Zeilenkommentar beginnt mit // und endet automatisch am Ende der Zeile. Hier dient der Kommentar dazu, \u00fcber die Objektvariable x zu informieren, die in Zeile 10 deklariert wird. In Zeile 10 wird eine Variable deklariert . Der Name der Variable ist x . Sie ist vom Datentyp int . Wir k\u00f6nnen nur innerhalb der Klasse Variablen auf diese Variable zugreifen, da sie als private deklariert wird. Zu Variablen und Datentypen kommen wir gleich ausf\u00fchrlich. In den Zeile 12-14 steht erneut ein JavaDoc-Kommentar - dieses Mal kommentiert er die nachfolgende Methode, den sogenannten Konstruktor . In den Zeilen 15-19 sehen wir die erste Methode der Klasse. Diese Methode ist speziell, denn sie hei\u00dft exakt so, wie die Klasse selbst. Es handelt sich um einen sogenannten Konstruktor . Diese Methode wird aufgerufen, um ein Objekt der Klasse zu erzeugen. Wir werden uns ausf\u00fchrlich mit Konstruktoren besch\u00e4ftigen. Typischerweise werden im Konstruktor alle Objektvariablen initialisiert , d.h. die Objektvariablen bekommen einen initialen Wert. Hier wird der Objektvariablen x der Wert 0 zugewiesen (Zeile 18 ). In den Zeilen 27-31 wird die Methode sampleMethod() implementiert. Dieser Methode wird ein Parameter y vom Typ int \u00fcbergeben. Diese Methode gibt den Wert der Summe von x und y zur\u00fcck. Wir kommen dazu, wenn wir uns ausgiebiger mit Methoden besch\u00e4ftigen. Zun\u00e4chst \u00e4ndern wir dieses Programm, indem wir (fast) alle Kommentare l\u00f6schen und die sampleMethod() -Methode umbenennen und umprogrammieren. Unsere Klasse sieht nun so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); } } Die Implementierung unserer Objektmethode hat sich ge\u00e4ndert: der Name der Methode ist nun printObjectState() , die Methode erwartet keinen Parameter mehr, der R\u00fcckgabetyp (kennen wir noch nicht) der Methode ist nicht mehr int , sondern void und die Implementierung der Methode besteht aus einer einzigen Anweisung System.out.println(x); . Wir klicken auf den Compile -Button, dann erzeugen wir uns ein Objekt von der Klasse Variablen und nennen es variable1 und f\u00fchren f\u00fcr dieses Objekt die Methode printObjectState() aus. Es erscheint Dieses Fenster ist unser Terminal-Fenster (auch Konsole genannt). In diesem Terminal-Fenster wird der Wert der Objektvariablen x ausgegeben. Dieser Wert ist 0 . System.out.println(x); \u00b6 Schauen wir uns System.out.println(x); zun\u00e4chst etwas genauer an. Wir verwenden hier eine Klasse, n\u00e4mlich die Klasse System . Diese Klasse existiert bereits und wurde von den Java-Entwicklern f\u00fcr uns geschrieben. Sie geh\u00f6rt zum Standardpaket von Java, existiert bereits seit der ersten Version von Java und befindet sich im Paket java.lang (zu Paketen kommen wir sp\u00e4ter). Diese Klasse hat eine interessante (Klassen-)Variable, die wir verwenden, n\u00e4mlich out . Diese Variable stellt in unserem (Betriebs-)System die Verbindung zu unserem Standardausgabeger\u00e4t bereit, in unserem Fall die Konsole (das Terminal-Fenster ). Um nun eine Ausgabe auf diese Konsole zu generieren, verwenden wir die Methode println() . Wir sehen hier eine typische Notation in Java, die sogenannte Punktnotation . Mithilfe dieser Punktnotation greifen wir auf Eigenschaften von Klassen und Objekten zu. In unserem Beispiel greifen wir mit System.out auf das Standardausgabeger\u00e4t zu und mit System.out.println() auf die println() -Methode des Ausgabeger\u00e4tes 1 . Die Methode println() erzeugt also eine Ausgabe auf unsere Konsole. Jetzt m\u00fcssen wir nur noch sagen, WAS ausgegeben werden sollen. Dazu \u00fcbergeben wir dieser Methode hier die Variable x . Der Wert dieser Variablen ( 0 ) wird gelesen und ausgegeben. Bei System.out.println(x); handelt es sich um eine Anweisung . Eine Anweisung endet in Java immer mit einem Semikolon ; . Dieses d\u00fcrfen wir nicht vergessen, ansonsten haben wir einen Syntaxfehler und unser Programm kann nicht compiliert und nicht ausgef\u00fchrt werden. println() vs. print() \u00b6 In unserem ersten Programm haben wir die Methode println() verwendet, um etwas auf der Konsole auszugeben. Es gibt noch eine andere M\u00f6glichkeit f\u00fcr die Ausgabe auf die Konsole, n\u00e4mlich die Methode print() , also ohne ln . Das ln steht f\u00fcr Line und gibt an, dass nach der Ausgabe ein Zeilenumbruch erfolgt. Wir \u00e4ndern zun\u00e4chst unser Programm, indem wir die Anweisung System.out.println(x); kopieren und weitere 2x einf\u00fcgen. printObjectState()-Methode mit println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); System . out . println ( x ); System . out . println ( x ); } } Um das \u00dcberpr\u00fcfen unserer \u00c4nderungen zu beschleunigen, klicken wir mit der rechten Maustaste auf die Klasse Variablen und w\u00e4hlen Create Test Class . Es entsteht eine Testklasse VariablenTest (gr\u00fcner Kasten). Wir klicken mit der rechten Maustaste auf diesen gr\u00fcnen Kasten und w\u00e4hlen Create Test Method... . Wir werden nach einem Namen f\u00fcr die testmethode gefragt und w\u00e4hlen testPrintObjectState . Nun wird unser Test \"aufgenommen\". Wir erzeugen ein Objekt der Klasse Variablen , nennen dieses Objekt variable1 und rufen f\u00fcr dieses Objekt die Methode printObjectState() auf. Dann beenden wir die \"Aufnahme\" des Tests, indem wir unter recording auf den Button End klicken. Nun brauchen wir f\u00fcr das Ausf\u00fchren unserer Methode immer nur noch die testPrintObjectState() -Methode der Klasse VariablenTest auszuf\u00fchren (Rechtsklick auf die Klasse und Methode ausw\u00e4hlen). Das ruft die Erzeugung eines Variablen -Objektes auf und f\u00fchrt daf\u00fcr die Methode printObjectState() aus. In unserem Terminal (der Konsole) erscheinen 0 0 0 Eventuell sind bei Ihnen vier 0 untereinander, weil das Terminal noch die 0 vom ersten Test angezeigt hatte. Das k\u00f6nnen Sie verhindern, indem Sie im BlueJ -Men\u00fc Options ausw\u00e4hlen und darin einen Haken bei Clear screen at method call setzen. Das hei\u00dft, dass jede der Ausgaben mithilfe der println() -Methode in einer neuen Zeile erfolgt. Nach jeder Ausgabe erfolgt also ein Zeilenumbruch, der Ausgabecursor wird in die n\u00e4chste Zeile gesetzt. Die n\u00e4chste Ausgabe beginnt am Anfang der neuen Zeile. Wir wollen nun unser Programm \u00e4ndern und verwenden nicht mehr die println() - Methode, sondern print() : printObjectState()-Methode mit print() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . print ( x ); System . out . print ( x ); System . out . print ( x ); } } Wir f\u00fchren den Test erneut aus und erhalten auf der Konsole die Ausgabe: 000 Die print() -Methode gibt also nur den Wert der Variablen x aus, f\u00fchrt aber danach keinen Zeilenumbruch durch. Der Ausgabecursor bleibt hinter dem letzten ausgegebenen Zeichen stehen. Unsere drei Nullen werden in der Konsole deshalb hintereinander ausgegeben. Wir \u00e4ndern nun unser Programm erneut und f\u00fcgen folgende Anweisungen hinzu: System.out.println() . Wir rufen also die println() -Methode auf, ohne eine Zeichenkette zu \u00fcbergeben, die ausgegeben werden soll. Diese Anweisung sorgt einfach daf\u00fcr, dass ein Zeilenumbruch erfolgt. Es wird also nichts ausgegeben, aber der Ausgabecursor an den Beginn der n\u00e4chsten Zeile gesetzt. printObjectState()-Methode mit print() und println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . print ( x ); System . out . println (); System . out . print ( x ); System . out . println (); System . out . print ( x ); System . out . println (); } } Wir f\u00fchren den Test erneut aus und erhalten auf der Konsole die Ausgabe: 0 0 0 \u00dcbung Erzeugen Sie folgende Ausgabe auf der Konsole: 0 0 0 Eine m\u00f6gliche L\u00f6sung 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); System . out . println (); System . out . println ( x ); System . out . println (); System . out . println ( x ); System . out . println (); } } So, jetzt haben wir unser erstes Programm geschrieben und k\u00f6nnen nun Variablen kennenlernen und dieses Konzept auch gleich anwenden. Variablen \u00b6 Eine Variable kann man sich wie eine Kiste vorstellen, in die genau ein Wert passt. Diese Kiste hat einen Namen (den Namen der Variable) und in der Programmierung wird auch noch gesagt, welche Art von Wert dort hineinpasst. Man spricht auch vom Typ der Variablen oder noch besser vom Datentyp . Eine Variable besteht also aus drei Dingen: dem Wert der Variablen (genau einer) dem Datentyp der Variablen (besteimmt den Wertebereich, also die m\u00f6glichen Werte, die die Variable annehmen kann) dem Namen der Variablen (daf\u00fcr gibt es Regeln, wie solche Bezeichner aussehen d\u00fcrfen) Das Erstellen einer Variablen (die Definition einer Variablen ) besteht in der Programmierung aus zwei Schritten: der Variablendeklaration : in der Deklaration wird festgelegt, wie die Variable hei\u00dft und von welchem Datentyp sie ist der Initialisierung : bei der Initialisierung wird der Variablen ihr erster Wert zugewiesen Damit wir einer Variablen ihren Datentyp zuweisen k\u00f6nnen, m\u00fcssen wir die Datentypen zun\u00e4chst kennenlernen, die eine Variable haben kann. Datentypen in Java \u00b6 In Java gibt es acht sogenannte primitive Datentypen . Wir bezeichnen diese primitiven Datentypen als Wertetypen . Eine Variable von einem Wertetyp kann genau einen Wert annehmen. In folgender Tabelle sind diese Datentypen aufgelistet und ihre jeweilige Bedeutung erkl\u00e4rt. Datentyp Bedeutung int eine Variable vom Datentyp int kann ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Die kleinste Zahl vom Typ int ist -2^31 \"klein\" und die gr\u00f6\u00dfte Zahl vom Typ int ist 2^31-1 gro\u00df. int ist der Standard-Typ f\u00fcr ganze Zahlen in Java. int steht f\u00fcr integer . byte eine Variable vom Datentyp byte kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Die kleinste byte -Zahl ist -2^7 klein und die gr\u00f6\u00dfte byte -Zahl ist 2^7-1 gro\u00df. short eine Variable vom Datentyp short kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Im Gegensatz zu byte ist er aber gr\u00f6\u00dfer. Die kleinste short -Zahl ist -2^15 klein und die gr\u00f6\u00dfte short -Zahl ist 2^15-1 gro\u00df. long eine Variable vom Datentyp long kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel gr\u00f6\u00dfer. long wird immer dann verwendet, wenn der Wertebereich von int nicht ausreicht, also entweder f\u00fcr sehr, sehr kleine oder sehr, sehr gro\u00dfe Zahlen. Die kleinste long -Zahl ist -2^63 klein und die gr\u00f6\u00dfte long -Zahl ist 2^63-1 gro\u00df. char Der Datenyp char steht f\u00fcr character . Mit diesem Datentypen werden einzelne Zeichen gespeichert. Der Datentyp char ist ebenfalls ein ganzzahliger Datentyp, nimmt aber nur positive Werte (aus dem Wertebereich 0 bis 65535 an.) Diese Werte sind Zahlenwerte, die der Codierung eines Zeichens entsprechen, z.B. dem Zeichen 'a' . Ein solches Zeichen steht immer in einfachen Hochkommata '' . boolean Der Datentyp boolean kennt nur genau zwei Werte true und false . Eine Variable vom Datentyp boolean kann also entweder genau true sein oder genau false , nichts anderes. double Der Datentyp double ist in Java der Standard-Datentyp f\u00fcr Gleitkommazahlen (also gebrochene Zahlen mit Komma). Die kleinste und gr\u00f6\u00dfte double -Zahl l\u00e4sst sich nicht genau bestimmen, denn das h\u00e4ngt von der Genauigkeit der Angabe hinter dem Komma ab. Es werden aber 64 bit verwendet, um eine double -Zahl zu speichern. float float ist neben double ein weiterer Datentyp f\u00fcr Gleitkommazahlen. Die Genauigkeit der Speicherung als float ist aber nicht so gro\u00df wie bei double , da float nur 32 bit zur Speicherung einer Zahl zur Verf\u00fcgung hat. Deklaration von Variablen \u00b6 Nun, da wir Datentypen kennen, k\u00f6nnen wir Variablen \"erzeugen\". Das \"Erzeugen\" von Variablen besteht aus zwei Schritten: wir vergeben einen Namen f\u00fcr unsere Variable und wir weisen der Variablen einen Datentyp zu. Dieses Erzeugen von Variablen nennt sich Deklaration (oder Variablendeklaration ). Die allgemine Syntax der Variablendeklaration ist wie folgt: datentyp variablenName ; Wir geben also zuerst den Datentyp an, dann kommt ein Leerschritt, dann den Bezeichner f\u00fcr die Variable (den Namen) und dann folgt ein Semikolon, weil es sich um eine Anweisung handelt. Beispiele: int ganzeZahl ; int number ; long bigNumber ; byte smallNumber ; double nr1 ; float nr2 ; boolean condition ; char character ; F\u00fcr eine Variable wird die Deklaration genau einmal durchgef\u00fchrt. Danach existiert sie und sie kann auch (in Java) nicht ihren Datentypen \u00e4ndern. Noch haben unsere Variablen keine Werte. Das erfolgt erst durch die Initialisierung, also die erste Wertzuweisung. Ehe wir uns das anschauen, \u00fcberlegen wir uns zun\u00e4chst, welche m\u00f6glichen Bezeichner wir f\u00fcr unsere Variablennamen verwenden k\u00f6nnen. Bezeichner \u00b6 Wenn es um Namen geht, die wir in Java selbst vergeben wollen, dann sprechen wir von Bezeichnern . Bezeichner sind nicht nur die Namen von Variablen, sondern sp\u00e4ter auch f\u00fcr Methoden, Klassen, Enumerations, Exceptions und Interfaces. Es gibt einige Regeln f\u00fcr Bezeichner, die wir beachten m\u00fcssen: Bezeichner m\u00fcssen mit einem Java-Buchstaben beginnen Bezeichner setzen sich aus Java-Buchstaben und Java-Zahlen zusammen Java-Buchstaben sind mehr als a - z und A - Z z.B. auch \u20ac , \u00a3 , \u00a5 , $ , Umlaute \u00e4 , \u00f6 , \u00fc , \u00df sowie Buchstaben mit Apostrophen Aber: wir verwenden nur die normalen Buchstaben a - z und A - Z !!! Alles andere f\u00fchrt zu Problemen wichtig: keine Leerzeichen, keine reservierten Schl\u00fcsselw\u00f6rter und keine Sonderzeichen, wie z.B. ! , / , * , { , [ , . , ] , } In Java wird Gro\u00df- und Kleinschreibung unterschieden ( case sensitive )! Reservierte Schl\u00fcsselw\u00f6rter sind Begriffe aus dem Java-Sprachumfang (alle kleingeschrieben) 1 . Dazu geh\u00f6ren: abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while \u00dcbung Bezeichner Warum sind das keine g\u00fcltigen Bezeichner in Java? 2und2macht4 class Hose gewaschen Hurtig! null Konventionen \u00b6 Wir wissen jetzt, was g\u00fcltige Bezeichner sind und was ung\u00fcltige. Dar\u00fcber hinaus gibt es aber auch Vereinbarungen, die helfen, einen besser verst\u00e4ndlichen und konsistenteren Code zu schreiben: wir vergeben nur \"sprechende\" Namen, d.h. man erkennt bereits am Bezeichner, wozu die Variable dient, z.B. sum , input , checkIfEmpty usw. Variablennamen beginnen stets mit einem Kleinbuchstaben (einzige Ausnahmen sind Konstanten, diese schreiben wir vollst\u00e4ndig gro\u00df, d.h. aus lauter Gro\u00dfbuchstaben) Methodennamen beginnen ebenfalls mit einem Kleinbuchstaben, Klassen und Interfaces beginnen stets mit einem Gro\u00dfbuchstaben verwenden die sogenannte camelCaseSchreibweise . Da keine Leerzeichen erlaubt sind, wir aber sprechende Namen haben wollen, die aus mehreren W\u00f6rtern bestehen k\u00f6nnen, schreiben wir den Beginn eines neuen Wortes immer gro\u00df (au\u00dfer ganz am Anfang, denn Methoden- und Variablennamen beginnen ja mit einem Kleinbuchstaben.) Initialisierung von Variablen \u00b6 Nach der Deklaration einer Variablen existiert diese zwar, sie hat jedoch noch keinen Wert. Wir wollen sicherstellen, dass Variablen immer einen Wert haben. Du weisen wir den Variablen direkt nach der Deklaration einen Wert zu. Die erstmalige Wertzuweisung einer Variablen wird Initialisierung genannt. Der Wertzuweisungsoperator = \u00b6 Um einer Variablen einen Wert zuzuweisen, wird der Wertzuweisungsoperator verwendet. Dieser ist ein eifaches Gleichheitszeichen = . Die Syntax der Wertzuweisung ist wie folgt: variablenName = wert ; Auf der linken Seite steht also immer die Variable und auf der rechten Seite der Wert. Auch hier muss am Ende wieder zwingend das Seikolon stehen, denn es handelt sich um eine Anweisung. Wichtig ist, dass der Wert dem Datentyp der Variablen entspricht! Wir geben einige Beispiele f\u00fcr Variablen an, die wir oben deklariert hatten: ganzeZahl = 5 ; // int number = - 1234 ; // int bigNumber = 12345678 ; // long nr1 = 6.54321 ; // double condition = true ; // boolean character = 'a' ; // char Nachdem einer Zahl mithilfe des Wertzuweisungsoperators ein Wert zugewiesen wurde, beh\u00e4lt die Variable den Wert so lange bis ihr ein neuer Wert (mithilfe des Wertzuweisungsoperators) zugewiesen wird. Einer Variablen kann beliebig oft ein neuer Wert zugewiesen werden. Deklaration und Initialisierung in einem Schritt \u00b6 Da wir m\u00f6chten, dass eine Variable sofort nach ihrer Deklaration einen Wert zugewiesen bekommt, ist es \u00fcblich, die Deklaration und die Initialisierung in einem Schritt, d.h. durch eine Anweisung durchzuf\u00fchren. Die Syntax der kombinierten Anweisung (Deklaration und INitialisierung) ist wie folgt: datentyp variablenName = wert ; Wir zeigen die Anwendung der kombinierten Deklaration und Initialisierung anhand der bereits verwendeten Beispiele: int ganzeZahl = 5 ; int number = - 1234 ; long bigNumber = 12345678 ; double nr1 = 6.54321 ; boolean condition = true ; char character = 'a' ; Beachte Wie bereits erw\u00e4hnt, kann eine Variable genau ein Mal deklariert, ihr aber beliebig oft ein neuer Wert zugewiesen werden. Angenommen, Sie wollen der Variablen ganzeZahl einen neuen Wert zuweisen, dann schreiben Sie die Anweisung ganzeZahl = 6; . Sie d\u00fcrfen auf keinen Fall int ganzeZahl = 6; schreiben, denn dann w\u00fcrden Sie ja versuchen, die Variable ganzeZahl erneut zu deklarieren. Diese existiert aber bereits. Sie bekommen einen Compilerfehler und k\u00f6nnen ihr Programm gar nicht erst \u00fcbersetzen. Details zu primitiven Datentypen (Wertetypen) \u00b6 Wie wir bereits bei der Vorstellung der primitiven Datentypen erw\u00e4hnt haben, ist f\u00fcr jeden Datentyp eine gewisse Speichergr\u00f6\u00dfe reserviert. Hier noch einmal die Gr\u00f6\u00dfe der primitiven Datentypen: Datentyp Gr\u00f6\u00dfe Wertebereich boolean 1 Byte 2 true / false char 16 bit 0 ... 65.535 (z.B. 'A' ) byte 8 bit -128 ... 127 short 16 bit -32.768 ... 32.767 int 32 bit -2.147.483.648 ... 2.147.483.647 long 64 bit -2^63 ... 2^63-1 float 32 bit +/-1,4E-45 ... +/-3,4E+38 double 64 bit +/-4,9E-324 ... +/-1,7E+308 Wir schauen uns jetzt noch einige interssante Details zu den Datentypen an. Ganzzahlige Datentypen int , long , short , byte \u00b6 Eine ganze Zahl in einem Java-Programm ist vom Typ int . Dieser Datentyp ist der Standard-Datentyp f\u00fcr ganze Zahlen. Ganze Zahlen werden intern im sogenannten Zweierkomplement dargestellt. Wir schauen uns diese Darstellung am Beispiel des Datentyps byte (der 8 bit gro\u00df ist) einmal genauer an. In der folgenden Darstellung steht die Bedeutung der Position der einzelnen bits ganz oben, beginnend mit der 1 ( 2^0 ) auf der rechten Seite (\"kleinstes\" bit) bis hin zu 2^7 auf der linken Seite (\"gr\u00f6\u00dftest\" bit). Beim Zweierkomplement entspricht diese h\u00f6chste Position jedoch nicht der 128 , sondern der -128 . Dies hat drei Vorteile es wird nicht ein ganzes bit daf\u00fcr verwendet, um zu unterscheiden, ob es sich um eine positive oder negative Zahl handelt die 0 kommt nicht 2x vor ( 1000 0000 und 0000 0000 w\u00e4re jeweils 0 , wenn das f\u00fchrende bit dar\u00fcber entscheiden w\u00fcrde, ob die Zahl positiv oder negativ ist) sowohl die Addition als auch die Subtraktion geht einfacher Die Abbildung zeigt in den oberen drei Zeilen die interne Darstellung von -128 , 127 und 0 . In den drei Zeilen darunter ist dargestellt, wie z.B. die Zahlen 85 , -43 und -85 als Zweierkomplement repr\u00e4sentiert werden. Die folgende Abbildung zeigt die Addition (und somit auch die Subtraktion) zweier Zahlen im Zweierkomplement. Dargestellt sidn die Repr\u00e4sentationen von -4 und 3 als Zweierkomplement. Es wird die Addition der beiden Zahlen gezeigt. Da die Werte alle einen begrenzten Wertebereich haben, kann es zu einem Wertebereichs\u00fcberlauf kommen. Ein solcher \u00dcberlauf ist in der folgenden Abbildung dargestellt. Im Datentyp byte ist 127 die gr\u00f6\u00dfte positive Zahl. Die Abbildung verdeutlicht, was passiert, wenn zu dieser gr\u00f6\u00dften Zahl eine 1 hinzuaddiert wird. Beachten Sie, dass ein solcher \u00dcberlauf unbemerkt passiert. Das bedeutet, dass Sie weder einen Fehler noch eine Warnung erhalten. Sie m\u00fcssen sich also immer gut \u00fcberlegen, ob ein solcher \u00dcberlauf bei Ihren Werten passieren kann. Wenn ja, dann sollten Sie zum n\u00e4chstgr\u00f6\u00dferen Datentypen wechseln, also z.B. von int nach long . Datentyp gr\u00f6\u00dfter Wert kleinster Wert byte 127 -128 short 32.767 -32.768 int 2.147.483.647 -2.147.483.648 long 9.223.372.036.854.775.807 -9.223.372.036.854.775.808 \u00dcbung Zweierkomplement Warum ist 1111 1111 als Zweierkomplement im Datentyp byte die Dezimalzahl -1 ? Wie ist die Repr\u00e4sentation der Zahlen -99 und 99 als Zweierkomplement im Datentyp byte ? Was ist das Ergebnis der Rechnung 2.147.483.647 + 1 im Datentyp int und warum? Initialisierung von long -Variablen. \u00b6 Eine ganze Zahl als Literal , also als alleinstehender Wert ist vom Typ int . Wenn wir folgende kombinierte Deklaration und INitialisierung betrachten: long bigNumber = 12345678 ; dann stellen wir fest, dass die Variable bigNumber auf der linken Seite des Wertzuweisungsoperators vom Typ long ist, die Zahl 12345678 aber vom Typ int . Wir werden sp\u00e4ter noch auf solche Typkonvertierung zu sprechen kommen. Es sei hier jedoch bereits angemerkt, dass man eine ganze Zahl auch um das Postfix L erg\u00e4nzen kann 3 - mit der Wirkung, dass die Zahl dann nicht mehr vom Typ int , sondern vom Typ long ist. Die \"richtige\" Initialisierung sieht so aus: long bigNumber = 12345678L ; Es ist nur in wenigen F\u00e4llen wirklich erforderlich, das L an die Zahl zu h\u00e4ngen, wenn wir eine long -Variable initialisieren. Warum das so ist, werden wir kennenlernen, wenn wir uns \u00fcber * Typkonvertierung* Gedanken machen. Trotzdem sei hier schonmal erw\u00e4hnt, dass diese Deklaration und Initailisierung kein Problem ist long bigNumber = 2147483647 ; aber hier bekommen wir einen Fehler und k\u00f6nnen das Programm gar nicht \u00fcbersetzen: long bigNumber = 2147483648 ; Warum k\u00f6nnte das wohl so sein? Wenn wir es \"richtig\" machen, also mit angeh\u00e4ngtem L , dann ist auch wieder alles in Ordnung und das Programm l\u00e4sst sich compilieren: long bigNumber = 2147483648L ; In unseren Programmen werden wir zu 99% den Datentyp int f\u00fcr ganzzahlige Werte verwenden und zu 1% long . Die anderen ganzzahligen Datentypen byte und short braucht man eigentlich gar nicht mehr, da wir keinen Wert mehr darauf legen m\u00fcssen, Arbeitsspeicher zu sparen. char \u00b6 Der Datentyp char ist f\u00fcr das Speichern von Zeichen vorgesehen. Es handelt sich um einen ganzzahligen Datentypen. Mit den ersten Computern stellte sich die Frage, wie Zeichen (also Ziffern und Buchstaben) intern codiert werden k\u00f6nnen. Es hat sich dann zun\u00e4chst die Zeichencodierung des American Standard Code for Information Interchange (ASCII) durchgesetzt, bei der 7 Bit (=128 Zeichen) dazu verwendet wurden, die wichtigsten Zeichen zu kodieren. Neben einigen Steuerzeichen (die ersten 33 \"Zeichen\", z.B. Zeilenvorschub, ESC -Zeichen) wurden z.B. folgende Zeichen wie folgt kodiert: Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 33 ! 47 / 61 = 34 \"\" 48 0 62 > 35 # 49 1 63 ? 36 $ 50 2 64 @ 37 % 51 3 65 A 38 & 52 4 66 B 39 ' 53 5 67 C 40 ( 54 6 68 D 41 ) 55 7 69 E 42 * 56 8 70 F 43 + 57 9 71 G 44 , 58 : 72 H 45 - 59 ; 73 I 46 . 60 < 74 J Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 75 K 89 Y 103 g 76 L 90 Z 104 h 77 M 91 [ 105 i 78 N 92 \\ 106 j 79 O 93 ] 107 k 80 P 94 ^ 108 l 81 Q 95 _ 109 m 82 R 96 ``` 110 n 83 S 97 a 111 o 84 T 98 b 112 p 85 U 99 c 113 q 86 V 100 d 114 r 87 W 101 e 115 s 88 X 102 f 116 t Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 117 u 121 y 125 } 118 v 122 z 126 ~ 119 w 123 { 127 DEL 120 x 124 | Diese Zeichenkodierung erkl\u00e4rt, warum es sich bei char um einen ganzzahligen Typ handelt. Anstelle eines Zeichens, welches immer in einfachen Hochkommata '' angegeben werden muss, kann auch der ASCII-Code als Zahl verwendet werden. Folgende Beispiele zeigen dies: char ganzzahliger Typ char c1 = 'a' ; System . out . println ( c1 ); // a char c2 = 97 ; System . out . println ( c2 ); // a char c3 = '`' ; c3 ++ ; System . out . println ( c3 ); // a Die 128 verschiedenen Zeichen gen\u00fcgten nat\u00fcrlich schnell nicht mehr und es wurden deutlich gr\u00f6\u00dfere Kodierungstabellen entwickelt. Ein de-facto Standard ist UTF-8 , welcher Bytes (also 8 Bit) zur Kodierung der Zeichen verwendet. Die ersten 128 Zeichen sind dabei mit dem ASCII-Code identisch. Im UTF-8 k\u00f6nnen aber mehrere Bytes hintereinander geschrieben werden und erm\u00f6glichen so einen beliebig gro\u00dfen Kodierungsraum. Der Datentyp char ist 16 Bit gro\u00df, kann also 2 Byte gro\u00dfe Kodierungsr\u00e4ume darstellen (65 536 verschiedene Zeichen). Eine UTF-8-Tabelle finden Sie z.B. hier . Die linke Spalte in dieser Tabelle zeigt den Unicode . Dieser kann auch in Java (in leicht abgewandelter Form) verwendet werden. Scrollen Sie in der Tabelle ein wenig bis zur Position U+00A9 herunter. Dort sehen Sie z.B. die Codierung des \u00a9-Copyright-Zeichens. In Java kann dieser Code wie folgt verwendet werden: char UTF-8 Zeichen char u1 = '\\u00a9' ; System . out . println ( u1 ); // copyright-Zeichen char u2 = '\\u00b0' ; System . out . println ( u2 ); // Grad-Zeichen char u3 = '\\u00bd' ; System . out . println ( u3 ); // 1/2-Zeichen Gleitkomma-Datentypen double , float \u00b6 Eine Gleitkomma-Zahl (also eine Zahl mit einem Punkt, z.B. 5.0 oder -1.2345 ) in einem Java-Programm ist vom Typ double . Dieser Datentyp ist der Standard-Datentyp f\u00fcr Gleitkomma-Zahlen. Der Wertebereich der Datentypen double und float l\u00e4sst sich nicht so leicht angeben, denn entweder wird relativ viel \"Speicher\" f\u00fcr die Genauigkeit verwendet (f\u00fcr die Anzahl der Nachkommastellen, z.B. 0.123456789 ) oder f\u00fcr die Vorkommastellen (z.B. 987654321.0 ). Generell ist der Wertebereich (die Genauigkeit) bei double viel h\u00f6her, denn f\u00fcr eine Variable vom Typ double werden 64 bit reserviert, w\u00e4hrend eine Variable vom Typ float nur 32 bit gro\u00df ist. Bei float beschr\u00e4nkt sich die Genauigkeit auf ca. 7 signifikante Stellen (Nachkommastellen), w\u00e4hrend es bei double ca. 17 signifikante Stellen sind. Beispiel float float floatNumber = 1.0f / 3.0f ; System . out . println ( floatNumber ); // 0.33333334 Im obigen Beispiel wird mithilfe von float der Bruch 1/3 ausgerechnet. Zwei Sachen sind zu beachten Wie wir das schon beim Datentyp long gesehen haben, gibt es auch f\u00fcr Gleitkommazahlen ein Postfix, hier f , um zu sagen, dass eine Zahl vom Typ float sein soll. Ohne das f w\u00e4re sie vom Typ double und wir w\u00fcrden sogar einen Compilerfehler erhalten, wenn wir das f am Ende der Zahl nicht angeben w\u00fcrden. Hier ist es also wichtig, bei der Wertzuweisung anzugeben, dass die Zahl vom Typ float sein soll - n\u00e4mlcih durch die Angabe von f ( F ginge auch). Die Genauigkeit bei float ist nicht sehr hoch. 1/3 im float -Wertebereich ergibt 0.33333334 . Schauen wir uns das gleiche Beispiel mit double an: Beispiel float double doubleNumber = 1.0 / 3.0 ; System . out . println ( doubleNumber ); // 0.3333333333333333 Erstens hat der double -Wert deutlich mehr Nachkommastellen (16 statt 8 bei float ) und zweitens ist der Wert somit korrekter. Die Speicherung von Gleikommazahlen erfolgt nach IEEE 754 - Standard . Wir merken uns: wir sollten float eher nicht verwenden, wenn wir Wert auf Genauigkeit legen, wenn wir float verwenden, dann m\u00fcssen wir beim Initialisieren und bei allen Wertezuweisungen darauf achten, dass wir an die Gleikommazahl ein f anh\u00e4ngen, da es sich ansonsten um eine Gleitkommazahl vom Typ double handelt, double ist der Standardtyp f\u00fcr Gleikommazahlen und wenn eine Gleitkommazahl im Programmcode vorkommt, dann handelt es sich um eine Zahl vom Typ double . Datentyp gr\u00f6\u00dfter positiver Wert kleinster positiver Wert float ~3.4028234663852886E+038 ~1.4012984643248171E-045 double ~1.7976931348623157E+308 ~4.9406564584124654E-324 Der Datentyp String \u00b6 Der Datentyp String ist kein primitiver Datentyp (kein Wertetyp), sondern ein sogenannter komplexer Datentyp (oder, wie wir sagen Referenztyp ). Wir erkennen das bereits daran, dass der Datentyp mit einem Gro\u00dfbuchstaben beginnt. Der Unterschied zwischen Variablen von einem Wertetypen und Variablen von Referenztypen ist der, dass die ersten \"nur\" Werte speichern ( 3 , 5 , 'a' , 123.45 , true , ...) und die anderen speichern Objekte (oder richtiger: Referenzen auf Objekte) - darum k\u00fcmmern wir uns sp\u00e4ter sehr ausf\u00fchrlich. Wir k\u00f6nnen uns merken (ist aber derzeit noch nicht wichtig), dass ein String ein Objekt und kein einfacher Wert ist, aber derzeit betrachten wir den Datentyp String wie die primitiven Wertetypen auch. Ein String -Literal erkennt man an den doppelten Anf\u00fchrungsstrichen. Darin kann ein beliebiger Text (bestehend aus allen m\u00f6glichen Zeichen, Buchstaben, Sonderzeichen, Umlauten etc.) stehen, z.B. \"Hallo FIW!\" , \"2und2gleich4 und $ % & 0? | \\ !\" , \" \u00e4 \u00fc \u00f6 \u00df . Die Deklaration und Initialisierung einer String -Variablen sieht also so aus: String s1 = \"Informatik\" ; Auch f\u00fcr den Datentyp String gibt es einen Operator, der zwei Strings miteinander verbindet. Er wird Konkatenation ( String-Konkatenation oder Zeichenkettenverbindungsoperator genannt). Das Operatorsymbol der Konkatenation ist in Java + . String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); Die folgenden drei Ausgaben sind alle gleich: String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); // Informatik und Wirtschaft String s2 = \"Informatik\" ; String s3 = \" und\" ; String s4 = \" Wirtschaft\" ; System . out . println ( s2 + s3 + s4 ); // Informatik und Wirtschaft String s5 = \"Informatik\" ; String s6 = s5 + \" und\" ; String s7 = s6 + \" Wirtschaft\" ; System . out . println ( s7 ); //Informatik und Wirtschaft Doppelte Bedeutung des Operatorzeichens + \u00b6 Das + wird sowohl als arithmetischer Operator f\u00fcr numerische Datentypen als auch als Konkatenation f\u00fcr Strings verwendet. In den obigen Beispielen kommen wir damit nicht durcheinander, da v\u00f6llig klar ist, dass es sich dabei um die Konkatenation handelt. Es gibt aber Beispiele, bei denen in einem Ausdruck beide Bedeutungen vorkommen. Diese diskutieren wir jetzt. Zun\u00e4chst schauen wir uns noch eine Typische Verendung der Konkatenation an: typisches Beispiel f\u00fcr die Konkatenation 1 2 3 4 int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 Die Ausgabe bei dem obigen Beispiel ist 3 + 4 = 7 . Schauen wir uns das Beispiel genauer an: In Zeile 3 wird das + eindeutig als arithmetischer Operator verwendet, denn es steht zwischen zwei numerischen Werten ( summand1 und summand2 sind jeweils vom Typ int ) In Zeile 4 kommt + mehrmals vor. Der Ausdruck in den runden Klammern von println() wird von links nach rechts aufgel\u00f6st: Das Literal \" + \" ist ein String. Hier ist + gar kein Operator, sondern nur ein Zeichen. Das + in summand1 + \" + \" ist die Konkatenation. Das liegt daran, dass einer der beiden Operanden, die das + verbindet, vom Typ String ist. Intern wird der Wert von summand1 ( die 3 ) zu einem String und dieser wird mit \" + \" verbunden. Es entsteht ein String \"3 + \" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + \" + summand2 enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn einer der beiden Operanden (der erste) ist vom Typ String . Intern wird der Wert von summand2 ( die 4 ) zu einem String und dieser wird mit \"3 + \" verbunden. Es entsteht ein String \"3 + 4\" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + 4\" + \" = \" enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn beide Operanden (der erste und der zweite) sind vom Typ String . Es entsteht der String \"3 + 4 = \" . Das letzte + steht also in dem Ausdruck \"3 + 4 = \" + summe . Auch hier handelt es sich wieder um die Konkatenation, da einer der beiden Operanden (der erste) vom Typ String ist. Intern wird der Wert von summe ( die 7 ) zu einem String und dieser wird mit \"3 + 4 = \" verbunden. Es entsteht ein String \"3 + 4 = 7\" . Dieser String wird ausgegegeben. \u00dcbung Doppelte Bedeutung von + Angenommen, in dem obigen Beispiel wollen Sie die Summe der beiden Summanden nicht erst in einer Variablen zwischenspeichern, sondern gleich ausgeben. Sie schreiben deshalb folgendes Programm: int summand1 = 3 ; int summand2 = 4 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summand1 + summand2 ); Sie erhalten jedoch nicht die gew\u00fcnschte Ausgabe. Warum nicht? Wie k\u00f6nnen Sie doch die Summe ausgeben, ohne diese zwischenspeichern zu m\u00fcssen? Success Wir k\u00f6nnen nun Variablen deklarieren und initialisieren. Wir kennen alle acht primitiven Datentypen. Wir nennen diese Datentypen Wertetypen . Wir wissen, dass eine ganze Zahl im Java-Programm vom Typ int ist und eine Gleikommazahl vom Typ double . Wir kennen die interne Darstellung von ganzen Zahlen und wir wissen \u00fcber die Kodierung von Zeichen Bescheid. Der datentyp char ist ein ganzzahliger Typ, obwohl er f\u00fcr das Speichern von Zeichen zust\u00e4ndig ist. Dies liegt an der Kodierung der Zeichen als ganze Zahlen. Der Wertzuweisungsoperator ist = . Wenn einer Variablen ein Wert zugewiesen werden soll, dann muss die Variablen links stehen, der Wertuweisungsoperator in der Mitte und rechts der Wert. Konstanten \u00b6 Wir haben gesagt, dass Variablen beliebig oft einer neuer Wert zugewisen werden kann. Manchmal m\u00f6chte man aber genau das nicht. Sogenannten Konstanten m\u00f6chte man genau einmal einen Wert zuweisen und dann soll dieser Wert nicht mehr \u00fcberschrieben werden k\u00f6nnen. In Java kann man solche Konstanten mithilfe des Schl\u00fcsselwortes final deklarieren: final datentyp KONSTANTE = Wert; Eine Konstante wird zun\u00e4chst wie eine Variable deklariert, d.h. man vergibt einen Namen f\u00fcr die Variable und weist ihr einen Datentyp zu. Au\u00dferdem wird ihr mithilfe des Zuweisungsoperators ein Wert zugewiesen. Um zu verhindern, dass dieser Variablen erneut ein Wert zugewiesen kann, setzt man vor den Datentyp noch das Schl\u00fcsselwort final . Damit ist diese Variable schreibgesch\u00fctzt und es kann ihr nie wieder ein neuer Wert zugewiesen werden. Schauen wir uns ein Beispiel an: final double PI = 3.14159265359 ; Es wird eine Konstante PI deklariert und ihr der Wert 3.14159265359 zugewiesen. Damit wir Konstanten von \"normalen\" Variablen unterscheiden k\u00f6nnen, schreiben wir Konstenten immer gro\u00df . Wenn der Name einer Konstanten aus mehreren W\u00f6rtern besteht, verwendet man typischerweise den Unterstrich _ zum Verbinden der beiden W\u00f6rter, z.B. final int NOT_FOUND = - 1 ; final int MIN_VALUE = - 2147483648 ; final int MAX_VALUE = 2147483647 ; final char DEGREE_SYMBOL = '\\u00b0' ; final char DEGREE_CELSIUS = '\\u2103' ; final char DEGREE_FAHRENHEIT = '\\u2109' ; Ansonsten k\u00f6nnen Sie Konstanten ganz normal verwenden, aber immer nur lesend, also z.B. double area = PI * 25.0 ; System . out . println ( area ); System . out . println ( DEGREE_FAHRENHEIT ); System . out . println ( DEGREE_CELSIUS ); String fahrenheit = DEGREE_SYMBOL + \"F\" ; System . out . println ( fahrenheit ); ergibt folgende Ausgabe: 78 .53981633975 \u2109 \u2103 \u00b0F Wenn Sie in Ihrem Programm versuchen, einer Konstanten einen neuen Wert zuzuweisen, erhalten Sie einen Fehler ( The final variable cannot be assigned ) und Sie k\u00f6nnen das Programm gar nicht erst compilieren. Wann immer Sie in Ihrem Programm ein Literal verwenden, also einen Wert, sollten Sie \u00fcberlegen, ob Sie diesem Wert nicht besser einen Namen geben k\u00f6nnen, n\u00e4mlich daf\u00fcr eine Konstante verwenden, und dann stets die Konstante anstelle des Wertes verwenden. Damit werden sogenannte magic numbers vermieden und das Programm ist lesbarer. Typkonvertierung (type-cast) \u00b6 Java ist statisch typisiert , d.h. dass jede Variable (und jedes Literal) einen Datentyp hat. Dieser wird bei der Deklaration der Variablen festegelgt und ist somit bereits zur Compile-Zeit bekannt. Der Datentyp einer Variablen kann auch nicht mehr ge\u00e4ndert werden 4 . Die Typisierung einer Variablen gibt den Wertebereich vor, aus dem die Variable Werte annehmen kann ( int -Variablen aus dem int -Wertebereich, boolean aus dem Wertebereich {true, false} usw.). Trotzdem ist in Java auch erlaubt, dass Wertezuweisungen nicht nur aus identischen Datentypen m\u00f6glich sind, sondern auch aus kampatiblen Datentypen: 1 2 3 4 5 int a = 5 ; // links ist int und rechts ist int --> identische Datentypen long b = 5 ; // links ist long und rechts ist int --> kompatible Datentypen int c = boolean ; // nicht erlaubt --> Fehler!!! keine kompatiblen Datentypen (int vs. boolean) float d = 5.0f ; // links ist float und rechts ist float --> identische Datentypen double e = d ; // links ist double und rechts ist float --> kompatible Datentypen In den Zeilen 2 und 5 werden die Datentypen bei der Zuweisung automatisch vom Compiler umgewandelt (in Zeile 2 automatisch von int nach long und in Zeile 5 automatisch von float nach double ). Diese Umwandlung von Datentypen nennt sich Typkonvertierung (engl. type cast ). Die beiden Beispiele aus Zeile 2 und Zeile 5 hei\u00dfen implizite Typkonvertierung. Implizite Typkonvertierung \u00b6 Jeder Wert (jedes Literal ) in Java ist von einem bestimmten Typ, z.B. 1 2 3 4 5 4 // Datentyp int 4.0 // Datentyp double true // Datentyp boolean 'a' // Datentyp char \"FIW\" // Datentyp String Was passiert bei double number = 4 ; ? Wir haben links eine Variable vom Typ double und rechts einen Wert vom Typ int . Die Antwort ist, dass der Compiler implizit den Wert 4 in den Wert 4.0 umwandelt und diesen Wert der Variablen number zuweist. Es findet also eine implizite Typkonvertierung statt. Typkonvertierung immer, wenn in einer Zuweisung verschiedene Typen im Spiel sind, erfolgt eine Typkonvertierung der Typ, der rechts vom Zuweisungsoperator steht, muss in den Typ konvertiert werden, der links vom Zuweisungsoperator steht hier: von int nach double Wenn von Typen mit einem kleineren Wertebereich zu Typen mit einem gr\u00f6\u00dferen Wertebereich umgewandelt (konvertiert) werden sollen, kann dies automatisch (implizit) erfolgen \u2192 implizite Typkonvertierung 1 2 3 4 5 6 7 8 // Beispiel Umrechnung Fahrenheit in Celsius --> ohne Typkonvertierung final char DEGREE_SYMBOL = '\\u00b0' ; int celsius = 0 ; for ( int fahrenheit = 0 ; fahrenheit <= 100 ; fahrenheit += 20 ) { celsius = 5 * ( fahrenheit - 32 ) / 9 ; System . out . printf ( \"%3d %cF --> %3d %cC %n\" , fahrenheit , DEGREE_SYMBOL , celsius , DEGREE_SYMBOL ); } In dem Beispiel werden fahrenheit -Werte in celsius -Werte umgerechnet. Die Variablen celsius und fahrenheit und auch die Werte 5 , 32 und 9 sind vom Typ int . Die Berechnungen laufen ohne Typkonvertierung ab, alles bleibt im Wertebereich von int . Deshalb handelt es sich bei (fahrenheit - 32) / 9 um eine ganzzahlige Division . Die Ausgabe ist wie folgt: 0 \u00b0F --> -17 \u00b0C 20 \u00b0F --> -6 \u00b0C 40 \u00b0F --> 4 \u00b0C 60 \u00b0F --> 15 \u00b0C 80 \u00b0F --> 26 \u00b0C 100 \u00b0F --> 37 \u00b0C Wir \u00e4ndern das Beispiel und deklarieren die beiden Variablen fahrenheit und celsius als double : 1 2 3 4 5 6 7 8 // Beispiel Umrechnung Fahrenheit in Celsius --> mit Typkonvertierung final char DEGREE_SYMBOL = '\\u00b0' ; double celsius = 0 ; for ( double fahrenheit = 0 ; fahrenheit <= 100 ; fahrenheit += 20 ) { celsius = 5 * ( fahrenheit - 32 ) / 9 ; System . out . printf ( \"%6.2f %cF --> %7.3f %cC %n\" , fahrenheit , DEGREE_SYMBOL , celsius , DEGREE_SYMBOL ); } Dadurch ergibt sich eine andere Ausgabe (die Platzhalter in printf() mussten auch angepasst werden): 0 ,00 \u00b0F --> -17,778 \u00b0C 20 ,00 \u00b0F --> -6,667 \u00b0C 40 ,00 \u00b0F --> 4 ,444 \u00b0C 60 ,00 \u00b0F --> 15 ,556 \u00b0C 80 ,00 \u00b0F --> 26 ,667 \u00b0C 100 ,00 \u00b0F --> 37 ,778 \u00b0C Was ist passiert? Dadurch, dass in der Wertezuweisung celsius = 5 * (fahrenheit - 32) / 9; auf der linken Seite ein double steht, wird der gesamte Ausdruck auf der rechten Seite in ein double konvertiert . Das w\u00fcrde aber erst nach Ausrechnen des Ausdrucks erfolgen, wenn nicht auch fahrenheit ein double w\u00e4re. Es passiert folgendes: zuerst wird der Ausdruck (fahrenheit - 32) aufgel\u00f6st, da er in Klammern steht. Hier ist die Operation double - int . Sobald einer der beiden Operanden ein double ist, wird der double -Operator - verwendet \u2192 dazu wird die 32 in eine 32.0 konvertiert \u2192 das Ergebnis ist ein double dann wird von links nach rechts aufgel\u00f6st, also zun\u00e4chst 5 * double . Auch hier ist die Operation also int * double , d.h. double -Multiplikation und somit wird aus der 5 eine 5.0 . Das Ergebnis dieser Multiplikation ist double dann erfolgt die Berechnung von double / 9 . Wenn einer der beiden Operanden ein double ist, handelt es sich bei der Division um eine Gleikommadivision . Also gibt es auch Nachkommastellen \u2192 das Ergebnis ist ein double Diese implizite Typkonvertierung macht der Compiler automatisch. Implizite Typkonvertierung kann immer dann erfolgen, wenn von einem schmalen in einen breiten Datentyp konvertiert wird, d.h. wenn alle Werte aus dem \"schmalen\" Wertebereich auch Werte aus dem \"breiten\" Wertebereich sind. Dies ist bei int (schmal) nach double (breit) der Fall, da alle int -Werte auch im double -Wertebereich enthalten sind. Das hier ist also kein Problem: int v1 = 1 ; double v2 = v1 ; // ok System . out . println ( \"Wert von v2: \" + v2 ); // 1.0 aber das geht nicht : double v3 = 1.0 ; int v4 = v3 ; // Fehler! System . out . println ( \"Wert von v4: \" + v4 ); Obwohl ja die 1.0 ein Wert aus int darstellt, pr\u00fcft der Compiler nicht den Wert, sondern den Typ. Da der double -Wertebereich viele Werte umfasst, die nicht Teil des Wertebereichs von int sind (z.B. 1.5 ), kann hier keine implizite Typkonvertierung erfolgen, denn diese w\u00e4re von einem \"breiten\" in einen \"schmalen\" Datentypen. Wenn man sich jedoch ganz sicher ist, dass eine solche Typkonvertierung sinnvoll ist (z.B. kann man ja 1.0 nach 1 und somit int ohne Verlust umwandeln), kann eine solche Typkonvertierung explizit angesto\u00dfen werden. Explizite Typkonvertierung \u00b6 In dem Beispiel von eben double v3 = 1.0 ; int v4 = v3 ; // Fehler! System . out . println ( \"Wert von v4: \" + v4 ); f\u00fchrt der Compiler keine implizite Typkonvertierung durch. Das Programm wird gar nicht compiliert. Wenn wir nun aber wollen, dass diese Typkonvertierung trotzdem durchgef\u00fchrt wird, m\u00fcssen wir den Typkonvertierungsoperator (auch type cast operator ) verwenden. Der Typkonvertierungsoperator enth\u00e4lt in runden Klammern den Zieltyp und steht vor dem Wert der umgewandelt werden soll: typ_A variable = (typ_A)wert; Die variable sei vom typ_A und der Wert von einem Typ, der nicht impliziert nach typ_A konvertiert werden kann. Unter Angabe von (typ_A) direkt vor dem wert wird der Wert explizit in typ_A konvertiert. Obiges Beispiel w\u00fcrde dann so aussehen: double v3 = 1.0 ; int v4 = ( int ) v3 ; // ok System . out . println ( \"Wert von v4: \" + v4 ); // 1 Da wir wissen, dass die 1 (der von uns zugewiesene Wert von v3 ) im Wertebereich von int liegt, k\u00f6nnen wir den Compiler anweisen, von double nach int zu konvertieren \u2192 explizite Typkonvertierung. Aber Achtung! Explizite Typkonvertierung kann zu Informationsverlust f\u00fchren! double v3 = 1.23456 ; int v4 = ( int ) v3 ; // explizite TK System . out . println ( \"Wert von v4: \" + v4 ); // 1 Wird ein double in ein int konvertiert, werden die Nachkommastellen einfach abgeschnitten (kein Runden!). Aber Achtung! Explizite Typkonvertierung kann zu ganz anderen Werten f\u00fchren! long v5 = 2147483648L ; // L mit angeben! int v6 = ( int ) v5 ; // 2 hoch 31 System . out . println ( \"Wert von v6: \" + v6 ); // -2147483648 2147483648 ist zwar ganzzahlig, ist aber nicht mehr Teil des Wertebereiches von int (um 1 zu gro\u00df) \u2192 aufgrund der internen Zahlendarstellung (Zweierkomplement) , bekommt v6 den Wert -2147483648 . Bei expliziter Typkonvertierung muss selbst\u00e4ndig darauf geachtet werden, dass der Wertebereich nicht \u00fcberschritten bzw. nicht verlassen wird! Sinnvolle Anwendungen des Typkonvertierungsoperators \u00b6 Angenommen, wir haben ein int -Array ia und wollen aus den Werten in diesem Array den Mittelwert berechnen. Dann w\u00e4re folgender erster Implementierungsversuch denkbar: int [] ia = { 1 , 2 , 3 , 4 }; int sum = 0 ; for ( int index = 0 ; index < ia . length ; index ++ ) { sum = sum + ia [ index ] ; } double average = sum / ia . length ; System . out . println ( \"Durchschnitt ist \" + average ); // 2.0 Wir bilden also die Summe \u00fcber alle Werte und teilen durch die Anzahl der Werte. Das entspricht der Definition des Durchschnitts. Wir \u00fcberschlagen im Kopf, dass f\u00fcr die vier Werte 1 , 2 , 3 und 4 der Durchschnitt 2.5 ist. Ausgegeben wird aber Durchschnitt ist 2 .0 Das ist falsch und der Grund daf\u00fcr liegt darin, dass es sich bei sum / ia.length um die ganzzahlige Divsion handelt, da beide Operanden vom Typ int sind. Eine M\u00f6glichkeit w\u00e4re, die Variable sum als double zu deklarieren. Dann haben wir bereits das gew\u00fcnschte Ergebnis. Eine andere ist, einen der beiden (oder beide) explizit nach double zu konvertieren: int [] ia = { 1 , 2 , 3 , 4 }; int sum = 0 ; for ( int index = 0 ; index < ia . length ; index ++ ) { sum = sum + ia [ index ] ; } double average = sum / ( double ) ia . length ; System . out . println ( \"Durchschnitt ist \" + average ); // 2.5 Wir haben jetzt die L\u00e4nge explizit nach double konvertiert und somit ist einer der beiden Operanden der Division ein double und somit wird die Gleitkommadivision durchgef\u00fchrt. Nun erhalten wir das richtige Ergebnis: Kopf, dass f\u00fcr die vier Werte 1 , 2 , 3 und 4 der Durchschnitt 2.5 ist. Ausgegeben wird aber Durchschnitt ist 2 .5 Ein anderes sinnvolles Beispiel ist die explizite Konvertierung eines int -Wertes nach char . Beides sind ganzzahlige Datentypen, aber der Wertebereich von char (8 Bit) umfasst viel weniger Werte als der Wertebereich von int (16 Bit). int ist der \"breite\" Datentyp und char der schmale und somit findet keine implizite Typkonvertierung von int nach char statt. Trotzdem m\u00f6chte man h\u00e4ufig int in Bezug auf char nutzen, weil man unter Verwendung der numerischen ASCII-Codes ( int ) gut mit Zeichen \"rechnen\" kann: for ( int ascii = 65 ; ascii < 91 ; ascii ++ ) { char c = ( char ) ascii ; System . out . print ( c + \" \" ); } Wir m\u00fcssen hier explizit konvertieren, da die implizite Typkonvertierung char c = ascii; nicht existiert. Das w\u00e4re also ein Fehler. Mit der expliziten Typkonvertierung klappt aber alles wie gew\u00fcnscht: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Hier nochmal zur Veranschaulichung, zwischen welchen Datentypen eine implizite Typkonvertierung durchgef\u00fchrt wird: Beachten Sie, dass von und nach boolean in Java keine implizite Typkonvertierung durchgef\u00fchrt wird! Hier nochmal zur Veranschaulichung, zwischen welchen Datentypen eine explizite Typkonvertierung durchgef\u00fchrt werden kann ( kompatible Datentypen): Beachten Sie, dass von und nach boolean in Java auch keine explizite Typkonvertierung m\u00f6glich ist! const und goto geh\u00f6ren eigentlich gar nicht zum Sprachumfang von Java und sind aber trotzdem reservierte Schl\u00fcsselw\u00f6rter. \u21a9 \u21a9 Tats\u00e4chlich ist die Gr\u00f6\u00dfe eines boolean gar nicht genau definiert (siehe hier ). man braucht ja eigentlich nur ein bit. Man liest aber sehr h\u00e4ufig davon, dass einer Variablen vom Typ boolean ein ganzes Byte reserviert wird. \u21a9 Man k\u00f6nnte auch nit dem kleinen Buchstaben l erg\u00e4nzen, das macht man aber nicht, weil die Verwechselungsgefahr mit der 1 zu gro\u00df ist. \u21a9 Das ist nicht in Allen Programmiersprachen so. Beispielsweise wird in JavaScript erst zur Laufzeit ermittelt, von welchem Typ die Variable ist, denn das h\u00e4ngt von ihrem Wert ab. Dort kann eine Variable foo=\"String\" vom Typ string sein und dann durch foo=4 vom Typ number . Die Typisierung in solchen Programmiersprachen nennt man dynamisch typisiert . \u21a9","title":"Variablen"},{"location":"variablen/#variablen-und-datentypen","text":"Sowohl in dem euklidischen Algorithmus als auch bei der (3n+1)-Vermutung haben wir mit Zahlen gerechnet. Diese haben wir in Variablen gespeichert (z.B. a , b , n ). Wir kennen Variablen bereits aus der Mathematik. Dort \"speichern\" wir Werte in diesen Variablen. Das gleiche passiert auch beim Programmieren.","title":"Variablen und Datentypen"},{"location":"variablen/#unsere-erste-klasse","text":"Damit wir das Thema Variablen und Datentypen auch gleich anwenden k\u00f6nnen, schreiben wir nun endlich unser erstes Programm, d.h. wir implementieren unsere erste Klasse. Dazu \u00f6ffnen wir BlueJ und w\u00e4hlen im Men\u00fc Project --> New Project . Es \u00f6ffnet sich ein Dateiauswahlfenster. Unter Location sollten Sie sich einen Ordner aussuchen, in den Sie zuk\u00fcnftig Ihre BlueJ-Projekte speichern, z.B. unter Ihren Dokumenten/Prog1/BlueJ . Als Projektname k\u00f6nnen Sie z.B. variablen nehmen. Es erscheint Klicken Sie auf den Button New Class... und geben Sie Ihrer Klasse den Namen Variablen . Beachten Sie, dass wir Klassennamen stets mit einem Gro\u00dfbuchstaben beginnen! Klicken Sie den Button Compile , dann verschwinden die Streifen im Klassen-Icon. Doppelklicken Sie auf die Klasse Variablen , es \u00f6ffnet sich das Editor-Fenster: Wir schauen uns den darin enthaltenen Code mal etwas genauer an (die erste leere Zeile habe ich gel\u00f6scht, deshalb ist die Zeilennummerierung um 1 versetzt): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Write a description of class Variablen here. * * @author (your name) * @version (a version number or a date) */ public class Variablen { // instance variables - replace the example below with your own private int x ; /** * Constructor for objects of class Variablen */ public Variablen () { // initialise instance variables x = 0 ; } /** * An example of a method - replace this comment with your own * * @param y a sample parameter for a method * @return the sum of x and y */ public int sampleMethod ( int y ) { // put your code here return x + y ; } } Die Zeilen 1 - 6 enthalten einen Kommentar, einen sogenannten JavaDoc-Kommentar . JavaDoc-Kommentare beginnen mit /** und enden mit */ . Dazwischen kann alles stehen und solche Kommentare gehen meistens \u00fcber mehrere Zeilen. Wir werden JavaDoc noch n\u00e4her kennenlernen. In Zeile 7 steht die Klassensignatur. Es handelt sich um eine \u00f6ffentliche Klasse (deshalb public - lernen wir noch) und nach dem Schl\u00fcsselwort class steht der Klassenname Variablen . In Zeile 8 beginnt die Implementierung der Klasse. Diese Implementierung wird durch eine \u00f6ffnende geschweifte Klammer { begonnen und endet in Zeile 32 mit der schlie\u00dfenden geschweiften Klammer } . In Zeile 9 steht ein sogenannter Zeilenkommentar . Ein Zeilenkommentar beginnt mit // und endet automatisch am Ende der Zeile. Hier dient der Kommentar dazu, \u00fcber die Objektvariable x zu informieren, die in Zeile 10 deklariert wird. In Zeile 10 wird eine Variable deklariert . Der Name der Variable ist x . Sie ist vom Datentyp int . Wir k\u00f6nnen nur innerhalb der Klasse Variablen auf diese Variable zugreifen, da sie als private deklariert wird. Zu Variablen und Datentypen kommen wir gleich ausf\u00fchrlich. In den Zeile 12-14 steht erneut ein JavaDoc-Kommentar - dieses Mal kommentiert er die nachfolgende Methode, den sogenannten Konstruktor . In den Zeilen 15-19 sehen wir die erste Methode der Klasse. Diese Methode ist speziell, denn sie hei\u00dft exakt so, wie die Klasse selbst. Es handelt sich um einen sogenannten Konstruktor . Diese Methode wird aufgerufen, um ein Objekt der Klasse zu erzeugen. Wir werden uns ausf\u00fchrlich mit Konstruktoren besch\u00e4ftigen. Typischerweise werden im Konstruktor alle Objektvariablen initialisiert , d.h. die Objektvariablen bekommen einen initialen Wert. Hier wird der Objektvariablen x der Wert 0 zugewiesen (Zeile 18 ). In den Zeilen 27-31 wird die Methode sampleMethod() implementiert. Dieser Methode wird ein Parameter y vom Typ int \u00fcbergeben. Diese Methode gibt den Wert der Summe von x und y zur\u00fcck. Wir kommen dazu, wenn wir uns ausgiebiger mit Methoden besch\u00e4ftigen. Zun\u00e4chst \u00e4ndern wir dieses Programm, indem wir (fast) alle Kommentare l\u00f6schen und die sampleMethod() -Methode umbenennen und umprogrammieren. Unsere Klasse sieht nun so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); } } Die Implementierung unserer Objektmethode hat sich ge\u00e4ndert: der Name der Methode ist nun printObjectState() , die Methode erwartet keinen Parameter mehr, der R\u00fcckgabetyp (kennen wir noch nicht) der Methode ist nicht mehr int , sondern void und die Implementierung der Methode besteht aus einer einzigen Anweisung System.out.println(x); . Wir klicken auf den Compile -Button, dann erzeugen wir uns ein Objekt von der Klasse Variablen und nennen es variable1 und f\u00fchren f\u00fcr dieses Objekt die Methode printObjectState() aus. Es erscheint Dieses Fenster ist unser Terminal-Fenster (auch Konsole genannt). In diesem Terminal-Fenster wird der Wert der Objektvariablen x ausgegeben. Dieser Wert ist 0 .","title":"Unsere erste Klasse"},{"location":"variablen/#systemoutprintlnx","text":"Schauen wir uns System.out.println(x); zun\u00e4chst etwas genauer an. Wir verwenden hier eine Klasse, n\u00e4mlich die Klasse System . Diese Klasse existiert bereits und wurde von den Java-Entwicklern f\u00fcr uns geschrieben. Sie geh\u00f6rt zum Standardpaket von Java, existiert bereits seit der ersten Version von Java und befindet sich im Paket java.lang (zu Paketen kommen wir sp\u00e4ter). Diese Klasse hat eine interessante (Klassen-)Variable, die wir verwenden, n\u00e4mlich out . Diese Variable stellt in unserem (Betriebs-)System die Verbindung zu unserem Standardausgabeger\u00e4t bereit, in unserem Fall die Konsole (das Terminal-Fenster ). Um nun eine Ausgabe auf diese Konsole zu generieren, verwenden wir die Methode println() . Wir sehen hier eine typische Notation in Java, die sogenannte Punktnotation . Mithilfe dieser Punktnotation greifen wir auf Eigenschaften von Klassen und Objekten zu. In unserem Beispiel greifen wir mit System.out auf das Standardausgabeger\u00e4t zu und mit System.out.println() auf die println() -Methode des Ausgabeger\u00e4tes 1 . Die Methode println() erzeugt also eine Ausgabe auf unsere Konsole. Jetzt m\u00fcssen wir nur noch sagen, WAS ausgegeben werden sollen. Dazu \u00fcbergeben wir dieser Methode hier die Variable x . Der Wert dieser Variablen ( 0 ) wird gelesen und ausgegeben. Bei System.out.println(x); handelt es sich um eine Anweisung . Eine Anweisung endet in Java immer mit einem Semikolon ; . Dieses d\u00fcrfen wir nicht vergessen, ansonsten haben wir einen Syntaxfehler und unser Programm kann nicht compiliert und nicht ausgef\u00fchrt werden.","title":"System.out.println(x);"},{"location":"variablen/#println-vs-print","text":"In unserem ersten Programm haben wir die Methode println() verwendet, um etwas auf der Konsole auszugeben. Es gibt noch eine andere M\u00f6glichkeit f\u00fcr die Ausgabe auf die Konsole, n\u00e4mlich die Methode print() , also ohne ln . Das ln steht f\u00fcr Line und gibt an, dass nach der Ausgabe ein Zeilenumbruch erfolgt. Wir \u00e4ndern zun\u00e4chst unser Programm, indem wir die Anweisung System.out.println(x); kopieren und weitere 2x einf\u00fcgen. printObjectState()-Methode mit println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); System . out . println ( x ); System . out . println ( x ); } } Um das \u00dcberpr\u00fcfen unserer \u00c4nderungen zu beschleunigen, klicken wir mit der rechten Maustaste auf die Klasse Variablen und w\u00e4hlen Create Test Class . Es entsteht eine Testklasse VariablenTest (gr\u00fcner Kasten). Wir klicken mit der rechten Maustaste auf diesen gr\u00fcnen Kasten und w\u00e4hlen Create Test Method... . Wir werden nach einem Namen f\u00fcr die testmethode gefragt und w\u00e4hlen testPrintObjectState . Nun wird unser Test \"aufgenommen\". Wir erzeugen ein Objekt der Klasse Variablen , nennen dieses Objekt variable1 und rufen f\u00fcr dieses Objekt die Methode printObjectState() auf. Dann beenden wir die \"Aufnahme\" des Tests, indem wir unter recording auf den Button End klicken. Nun brauchen wir f\u00fcr das Ausf\u00fchren unserer Methode immer nur noch die testPrintObjectState() -Methode der Klasse VariablenTest auszuf\u00fchren (Rechtsklick auf die Klasse und Methode ausw\u00e4hlen). Das ruft die Erzeugung eines Variablen -Objektes auf und f\u00fchrt daf\u00fcr die Methode printObjectState() aus. In unserem Terminal (der Konsole) erscheinen 0 0 0 Eventuell sind bei Ihnen vier 0 untereinander, weil das Terminal noch die 0 vom ersten Test angezeigt hatte. Das k\u00f6nnen Sie verhindern, indem Sie im BlueJ -Men\u00fc Options ausw\u00e4hlen und darin einen Haken bei Clear screen at method call setzen. Das hei\u00dft, dass jede der Ausgaben mithilfe der println() -Methode in einer neuen Zeile erfolgt. Nach jeder Ausgabe erfolgt also ein Zeilenumbruch, der Ausgabecursor wird in die n\u00e4chste Zeile gesetzt. Die n\u00e4chste Ausgabe beginnt am Anfang der neuen Zeile. Wir wollen nun unser Programm \u00e4ndern und verwenden nicht mehr die println() - Methode, sondern print() : printObjectState()-Methode mit print() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . print ( x ); System . out . print ( x ); System . out . print ( x ); } } Wir f\u00fchren den Test erneut aus und erhalten auf der Konsole die Ausgabe: 000 Die print() -Methode gibt also nur den Wert der Variablen x aus, f\u00fchrt aber danach keinen Zeilenumbruch durch. Der Ausgabecursor bleibt hinter dem letzten ausgegebenen Zeichen stehen. Unsere drei Nullen werden in der Konsole deshalb hintereinander ausgegeben. Wir \u00e4ndern nun unser Programm erneut und f\u00fcgen folgende Anweisungen hinzu: System.out.println() . Wir rufen also die println() -Methode auf, ohne eine Zeichenkette zu \u00fcbergeben, die ausgegeben werden soll. Diese Anweisung sorgt einfach daf\u00fcr, dass ein Zeilenumbruch erfolgt. Es wird also nichts ausgegeben, aber der Ausgabecursor an den Beginn der n\u00e4chsten Zeile gesetzt. printObjectState()-Methode mit print() und println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . print ( x ); System . out . println (); System . out . print ( x ); System . out . println (); System . out . print ( x ); System . out . println (); } } Wir f\u00fchren den Test erneut aus und erhalten auf der Konsole die Ausgabe: 0 0 0 \u00dcbung Erzeugen Sie folgende Ausgabe auf der Konsole: 0 0 0 Eine m\u00f6gliche L\u00f6sung 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); System . out . println (); System . out . println ( x ); System . out . println (); System . out . println ( x ); System . out . println (); } } So, jetzt haben wir unser erstes Programm geschrieben und k\u00f6nnen nun Variablen kennenlernen und dieses Konzept auch gleich anwenden.","title":"println() vs. print()"},{"location":"variablen/#variablen","text":"Eine Variable kann man sich wie eine Kiste vorstellen, in die genau ein Wert passt. Diese Kiste hat einen Namen (den Namen der Variable) und in der Programmierung wird auch noch gesagt, welche Art von Wert dort hineinpasst. Man spricht auch vom Typ der Variablen oder noch besser vom Datentyp . Eine Variable besteht also aus drei Dingen: dem Wert der Variablen (genau einer) dem Datentyp der Variablen (besteimmt den Wertebereich, also die m\u00f6glichen Werte, die die Variable annehmen kann) dem Namen der Variablen (daf\u00fcr gibt es Regeln, wie solche Bezeichner aussehen d\u00fcrfen) Das Erstellen einer Variablen (die Definition einer Variablen ) besteht in der Programmierung aus zwei Schritten: der Variablendeklaration : in der Deklaration wird festgelegt, wie die Variable hei\u00dft und von welchem Datentyp sie ist der Initialisierung : bei der Initialisierung wird der Variablen ihr erster Wert zugewiesen Damit wir einer Variablen ihren Datentyp zuweisen k\u00f6nnen, m\u00fcssen wir die Datentypen zun\u00e4chst kennenlernen, die eine Variable haben kann.","title":"Variablen"},{"location":"variablen/#datentypen-in-java","text":"In Java gibt es acht sogenannte primitive Datentypen . Wir bezeichnen diese primitiven Datentypen als Wertetypen . Eine Variable von einem Wertetyp kann genau einen Wert annehmen. In folgender Tabelle sind diese Datentypen aufgelistet und ihre jeweilige Bedeutung erkl\u00e4rt. Datentyp Bedeutung int eine Variable vom Datentyp int kann ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Die kleinste Zahl vom Typ int ist -2^31 \"klein\" und die gr\u00f6\u00dfte Zahl vom Typ int ist 2^31-1 gro\u00df. int ist der Standard-Typ f\u00fcr ganze Zahlen in Java. int steht f\u00fcr integer . byte eine Variable vom Datentyp byte kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Die kleinste byte -Zahl ist -2^7 klein und die gr\u00f6\u00dfte byte -Zahl ist 2^7-1 gro\u00df. short eine Variable vom Datentyp short kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Im Gegensatz zu byte ist er aber gr\u00f6\u00dfer. Die kleinste short -Zahl ist -2^15 klein und die gr\u00f6\u00dfte short -Zahl ist 2^15-1 gro\u00df. long eine Variable vom Datentyp long kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel gr\u00f6\u00dfer. long wird immer dann verwendet, wenn der Wertebereich von int nicht ausreicht, also entweder f\u00fcr sehr, sehr kleine oder sehr, sehr gro\u00dfe Zahlen. Die kleinste long -Zahl ist -2^63 klein und die gr\u00f6\u00dfte long -Zahl ist 2^63-1 gro\u00df. char Der Datenyp char steht f\u00fcr character . Mit diesem Datentypen werden einzelne Zeichen gespeichert. Der Datentyp char ist ebenfalls ein ganzzahliger Datentyp, nimmt aber nur positive Werte (aus dem Wertebereich 0 bis 65535 an.) Diese Werte sind Zahlenwerte, die der Codierung eines Zeichens entsprechen, z.B. dem Zeichen 'a' . Ein solches Zeichen steht immer in einfachen Hochkommata '' . boolean Der Datentyp boolean kennt nur genau zwei Werte true und false . Eine Variable vom Datentyp boolean kann also entweder genau true sein oder genau false , nichts anderes. double Der Datentyp double ist in Java der Standard-Datentyp f\u00fcr Gleitkommazahlen (also gebrochene Zahlen mit Komma). Die kleinste und gr\u00f6\u00dfte double -Zahl l\u00e4sst sich nicht genau bestimmen, denn das h\u00e4ngt von der Genauigkeit der Angabe hinter dem Komma ab. Es werden aber 64 bit verwendet, um eine double -Zahl zu speichern. float float ist neben double ein weiterer Datentyp f\u00fcr Gleitkommazahlen. Die Genauigkeit der Speicherung als float ist aber nicht so gro\u00df wie bei double , da float nur 32 bit zur Speicherung einer Zahl zur Verf\u00fcgung hat.","title":"Datentypen in Java"},{"location":"variablen/#deklaration-von-variablen","text":"Nun, da wir Datentypen kennen, k\u00f6nnen wir Variablen \"erzeugen\". Das \"Erzeugen\" von Variablen besteht aus zwei Schritten: wir vergeben einen Namen f\u00fcr unsere Variable und wir weisen der Variablen einen Datentyp zu. Dieses Erzeugen von Variablen nennt sich Deklaration (oder Variablendeklaration ). Die allgemine Syntax der Variablendeklaration ist wie folgt: datentyp variablenName ; Wir geben also zuerst den Datentyp an, dann kommt ein Leerschritt, dann den Bezeichner f\u00fcr die Variable (den Namen) und dann folgt ein Semikolon, weil es sich um eine Anweisung handelt. Beispiele: int ganzeZahl ; int number ; long bigNumber ; byte smallNumber ; double nr1 ; float nr2 ; boolean condition ; char character ; F\u00fcr eine Variable wird die Deklaration genau einmal durchgef\u00fchrt. Danach existiert sie und sie kann auch (in Java) nicht ihren Datentypen \u00e4ndern. Noch haben unsere Variablen keine Werte. Das erfolgt erst durch die Initialisierung, also die erste Wertzuweisung. Ehe wir uns das anschauen, \u00fcberlegen wir uns zun\u00e4chst, welche m\u00f6glichen Bezeichner wir f\u00fcr unsere Variablennamen verwenden k\u00f6nnen.","title":"Deklaration von Variablen"},{"location":"variablen/#bezeichner","text":"Wenn es um Namen geht, die wir in Java selbst vergeben wollen, dann sprechen wir von Bezeichnern . Bezeichner sind nicht nur die Namen von Variablen, sondern sp\u00e4ter auch f\u00fcr Methoden, Klassen, Enumerations, Exceptions und Interfaces. Es gibt einige Regeln f\u00fcr Bezeichner, die wir beachten m\u00fcssen: Bezeichner m\u00fcssen mit einem Java-Buchstaben beginnen Bezeichner setzen sich aus Java-Buchstaben und Java-Zahlen zusammen Java-Buchstaben sind mehr als a - z und A - Z z.B. auch \u20ac , \u00a3 , \u00a5 , $ , Umlaute \u00e4 , \u00f6 , \u00fc , \u00df sowie Buchstaben mit Apostrophen Aber: wir verwenden nur die normalen Buchstaben a - z und A - Z !!! Alles andere f\u00fchrt zu Problemen wichtig: keine Leerzeichen, keine reservierten Schl\u00fcsselw\u00f6rter und keine Sonderzeichen, wie z.B. ! , / , * , { , [ , . , ] , } In Java wird Gro\u00df- und Kleinschreibung unterschieden ( case sensitive )! Reservierte Schl\u00fcsselw\u00f6rter sind Begriffe aus dem Java-Sprachumfang (alle kleingeschrieben) 1 . Dazu geh\u00f6ren: abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while \u00dcbung Bezeichner Warum sind das keine g\u00fcltigen Bezeichner in Java? 2und2macht4 class Hose gewaschen Hurtig! null","title":"Bezeichner"},{"location":"variablen/#konventionen","text":"Wir wissen jetzt, was g\u00fcltige Bezeichner sind und was ung\u00fcltige. Dar\u00fcber hinaus gibt es aber auch Vereinbarungen, die helfen, einen besser verst\u00e4ndlichen und konsistenteren Code zu schreiben: wir vergeben nur \"sprechende\" Namen, d.h. man erkennt bereits am Bezeichner, wozu die Variable dient, z.B. sum , input , checkIfEmpty usw. Variablennamen beginnen stets mit einem Kleinbuchstaben (einzige Ausnahmen sind Konstanten, diese schreiben wir vollst\u00e4ndig gro\u00df, d.h. aus lauter Gro\u00dfbuchstaben) Methodennamen beginnen ebenfalls mit einem Kleinbuchstaben, Klassen und Interfaces beginnen stets mit einem Gro\u00dfbuchstaben verwenden die sogenannte camelCaseSchreibweise . Da keine Leerzeichen erlaubt sind, wir aber sprechende Namen haben wollen, die aus mehreren W\u00f6rtern bestehen k\u00f6nnen, schreiben wir den Beginn eines neuen Wortes immer gro\u00df (au\u00dfer ganz am Anfang, denn Methoden- und Variablennamen beginnen ja mit einem Kleinbuchstaben.)","title":"Konventionen"},{"location":"variablen/#initialisierung-von-variablen","text":"Nach der Deklaration einer Variablen existiert diese zwar, sie hat jedoch noch keinen Wert. Wir wollen sicherstellen, dass Variablen immer einen Wert haben. Du weisen wir den Variablen direkt nach der Deklaration einen Wert zu. Die erstmalige Wertzuweisung einer Variablen wird Initialisierung genannt.","title":"Initialisierung von Variablen"},{"location":"variablen/#der-wertzuweisungsoperator","text":"Um einer Variablen einen Wert zuzuweisen, wird der Wertzuweisungsoperator verwendet. Dieser ist ein eifaches Gleichheitszeichen = . Die Syntax der Wertzuweisung ist wie folgt: variablenName = wert ; Auf der linken Seite steht also immer die Variable und auf der rechten Seite der Wert. Auch hier muss am Ende wieder zwingend das Seikolon stehen, denn es handelt sich um eine Anweisung. Wichtig ist, dass der Wert dem Datentyp der Variablen entspricht! Wir geben einige Beispiele f\u00fcr Variablen an, die wir oben deklariert hatten: ganzeZahl = 5 ; // int number = - 1234 ; // int bigNumber = 12345678 ; // long nr1 = 6.54321 ; // double condition = true ; // boolean character = 'a' ; // char Nachdem einer Zahl mithilfe des Wertzuweisungsoperators ein Wert zugewiesen wurde, beh\u00e4lt die Variable den Wert so lange bis ihr ein neuer Wert (mithilfe des Wertzuweisungsoperators) zugewiesen wird. Einer Variablen kann beliebig oft ein neuer Wert zugewiesen werden.","title":"Der Wertzuweisungsoperator ="},{"location":"variablen/#deklaration-und-initialisierung-in-einem-schritt","text":"Da wir m\u00f6chten, dass eine Variable sofort nach ihrer Deklaration einen Wert zugewiesen bekommt, ist es \u00fcblich, die Deklaration und die Initialisierung in einem Schritt, d.h. durch eine Anweisung durchzuf\u00fchren. Die Syntax der kombinierten Anweisung (Deklaration und INitialisierung) ist wie folgt: datentyp variablenName = wert ; Wir zeigen die Anwendung der kombinierten Deklaration und Initialisierung anhand der bereits verwendeten Beispiele: int ganzeZahl = 5 ; int number = - 1234 ; long bigNumber = 12345678 ; double nr1 = 6.54321 ; boolean condition = true ; char character = 'a' ; Beachte Wie bereits erw\u00e4hnt, kann eine Variable genau ein Mal deklariert, ihr aber beliebig oft ein neuer Wert zugewiesen werden. Angenommen, Sie wollen der Variablen ganzeZahl einen neuen Wert zuweisen, dann schreiben Sie die Anweisung ganzeZahl = 6; . Sie d\u00fcrfen auf keinen Fall int ganzeZahl = 6; schreiben, denn dann w\u00fcrden Sie ja versuchen, die Variable ganzeZahl erneut zu deklarieren. Diese existiert aber bereits. Sie bekommen einen Compilerfehler und k\u00f6nnen ihr Programm gar nicht erst \u00fcbersetzen.","title":"Deklaration und Initialisierung in einem Schritt"},{"location":"variablen/#details-zu-primitiven-datentypen-wertetypen","text":"Wie wir bereits bei der Vorstellung der primitiven Datentypen erw\u00e4hnt haben, ist f\u00fcr jeden Datentyp eine gewisse Speichergr\u00f6\u00dfe reserviert. Hier noch einmal die Gr\u00f6\u00dfe der primitiven Datentypen: Datentyp Gr\u00f6\u00dfe Wertebereich boolean 1 Byte 2 true / false char 16 bit 0 ... 65.535 (z.B. 'A' ) byte 8 bit -128 ... 127 short 16 bit -32.768 ... 32.767 int 32 bit -2.147.483.648 ... 2.147.483.647 long 64 bit -2^63 ... 2^63-1 float 32 bit +/-1,4E-45 ... +/-3,4E+38 double 64 bit +/-4,9E-324 ... +/-1,7E+308 Wir schauen uns jetzt noch einige interssante Details zu den Datentypen an.","title":"Details zu primitiven Datentypen (Wertetypen)"},{"location":"variablen/#ganzzahlige-datentypen-int-long-short-byte","text":"Eine ganze Zahl in einem Java-Programm ist vom Typ int . Dieser Datentyp ist der Standard-Datentyp f\u00fcr ganze Zahlen. Ganze Zahlen werden intern im sogenannten Zweierkomplement dargestellt. Wir schauen uns diese Darstellung am Beispiel des Datentyps byte (der 8 bit gro\u00df ist) einmal genauer an. In der folgenden Darstellung steht die Bedeutung der Position der einzelnen bits ganz oben, beginnend mit der 1 ( 2^0 ) auf der rechten Seite (\"kleinstes\" bit) bis hin zu 2^7 auf der linken Seite (\"gr\u00f6\u00dftest\" bit). Beim Zweierkomplement entspricht diese h\u00f6chste Position jedoch nicht der 128 , sondern der -128 . Dies hat drei Vorteile es wird nicht ein ganzes bit daf\u00fcr verwendet, um zu unterscheiden, ob es sich um eine positive oder negative Zahl handelt die 0 kommt nicht 2x vor ( 1000 0000 und 0000 0000 w\u00e4re jeweils 0 , wenn das f\u00fchrende bit dar\u00fcber entscheiden w\u00fcrde, ob die Zahl positiv oder negativ ist) sowohl die Addition als auch die Subtraktion geht einfacher Die Abbildung zeigt in den oberen drei Zeilen die interne Darstellung von -128 , 127 und 0 . In den drei Zeilen darunter ist dargestellt, wie z.B. die Zahlen 85 , -43 und -85 als Zweierkomplement repr\u00e4sentiert werden. Die folgende Abbildung zeigt die Addition (und somit auch die Subtraktion) zweier Zahlen im Zweierkomplement. Dargestellt sidn die Repr\u00e4sentationen von -4 und 3 als Zweierkomplement. Es wird die Addition der beiden Zahlen gezeigt. Da die Werte alle einen begrenzten Wertebereich haben, kann es zu einem Wertebereichs\u00fcberlauf kommen. Ein solcher \u00dcberlauf ist in der folgenden Abbildung dargestellt. Im Datentyp byte ist 127 die gr\u00f6\u00dfte positive Zahl. Die Abbildung verdeutlicht, was passiert, wenn zu dieser gr\u00f6\u00dften Zahl eine 1 hinzuaddiert wird. Beachten Sie, dass ein solcher \u00dcberlauf unbemerkt passiert. Das bedeutet, dass Sie weder einen Fehler noch eine Warnung erhalten. Sie m\u00fcssen sich also immer gut \u00fcberlegen, ob ein solcher \u00dcberlauf bei Ihren Werten passieren kann. Wenn ja, dann sollten Sie zum n\u00e4chstgr\u00f6\u00dferen Datentypen wechseln, also z.B. von int nach long . Datentyp gr\u00f6\u00dfter Wert kleinster Wert byte 127 -128 short 32.767 -32.768 int 2.147.483.647 -2.147.483.648 long 9.223.372.036.854.775.807 -9.223.372.036.854.775.808 \u00dcbung Zweierkomplement Warum ist 1111 1111 als Zweierkomplement im Datentyp byte die Dezimalzahl -1 ? Wie ist die Repr\u00e4sentation der Zahlen -99 und 99 als Zweierkomplement im Datentyp byte ? Was ist das Ergebnis der Rechnung 2.147.483.647 + 1 im Datentyp int und warum?","title":"Ganzzahlige Datentypen int, long, short, byte"},{"location":"variablen/#initialisierung-von-long-variablen","text":"Eine ganze Zahl als Literal , also als alleinstehender Wert ist vom Typ int . Wenn wir folgende kombinierte Deklaration und INitialisierung betrachten: long bigNumber = 12345678 ; dann stellen wir fest, dass die Variable bigNumber auf der linken Seite des Wertzuweisungsoperators vom Typ long ist, die Zahl 12345678 aber vom Typ int . Wir werden sp\u00e4ter noch auf solche Typkonvertierung zu sprechen kommen. Es sei hier jedoch bereits angemerkt, dass man eine ganze Zahl auch um das Postfix L erg\u00e4nzen kann 3 - mit der Wirkung, dass die Zahl dann nicht mehr vom Typ int , sondern vom Typ long ist. Die \"richtige\" Initialisierung sieht so aus: long bigNumber = 12345678L ; Es ist nur in wenigen F\u00e4llen wirklich erforderlich, das L an die Zahl zu h\u00e4ngen, wenn wir eine long -Variable initialisieren. Warum das so ist, werden wir kennenlernen, wenn wir uns \u00fcber * Typkonvertierung* Gedanken machen. Trotzdem sei hier schonmal erw\u00e4hnt, dass diese Deklaration und Initailisierung kein Problem ist long bigNumber = 2147483647 ; aber hier bekommen wir einen Fehler und k\u00f6nnen das Programm gar nicht \u00fcbersetzen: long bigNumber = 2147483648 ; Warum k\u00f6nnte das wohl so sein? Wenn wir es \"richtig\" machen, also mit angeh\u00e4ngtem L , dann ist auch wieder alles in Ordnung und das Programm l\u00e4sst sich compilieren: long bigNumber = 2147483648L ; In unseren Programmen werden wir zu 99% den Datentyp int f\u00fcr ganzzahlige Werte verwenden und zu 1% long . Die anderen ganzzahligen Datentypen byte und short braucht man eigentlich gar nicht mehr, da wir keinen Wert mehr darauf legen m\u00fcssen, Arbeitsspeicher zu sparen.","title":"Initialisierung von long-Variablen."},{"location":"variablen/#char","text":"Der Datentyp char ist f\u00fcr das Speichern von Zeichen vorgesehen. Es handelt sich um einen ganzzahligen Datentypen. Mit den ersten Computern stellte sich die Frage, wie Zeichen (also Ziffern und Buchstaben) intern codiert werden k\u00f6nnen. Es hat sich dann zun\u00e4chst die Zeichencodierung des American Standard Code for Information Interchange (ASCII) durchgesetzt, bei der 7 Bit (=128 Zeichen) dazu verwendet wurden, die wichtigsten Zeichen zu kodieren. Neben einigen Steuerzeichen (die ersten 33 \"Zeichen\", z.B. Zeilenvorschub, ESC -Zeichen) wurden z.B. folgende Zeichen wie folgt kodiert: Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 33 ! 47 / 61 = 34 \"\" 48 0 62 > 35 # 49 1 63 ? 36 $ 50 2 64 @ 37 % 51 3 65 A 38 & 52 4 66 B 39 ' 53 5 67 C 40 ( 54 6 68 D 41 ) 55 7 69 E 42 * 56 8 70 F 43 + 57 9 71 G 44 , 58 : 72 H 45 - 59 ; 73 I 46 . 60 < 74 J Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 75 K 89 Y 103 g 76 L 90 Z 104 h 77 M 91 [ 105 i 78 N 92 \\ 106 j 79 O 93 ] 107 k 80 P 94 ^ 108 l 81 Q 95 _ 109 m 82 R 96 ``` 110 n 83 S 97 a 111 o 84 T 98 b 112 p 85 U 99 c 113 q 86 V 100 d 114 r 87 W 101 e 115 s 88 X 102 f 116 t Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 117 u 121 y 125 } 118 v 122 z 126 ~ 119 w 123 { 127 DEL 120 x 124 | Diese Zeichenkodierung erkl\u00e4rt, warum es sich bei char um einen ganzzahligen Typ handelt. Anstelle eines Zeichens, welches immer in einfachen Hochkommata '' angegeben werden muss, kann auch der ASCII-Code als Zahl verwendet werden. Folgende Beispiele zeigen dies: char ganzzahliger Typ char c1 = 'a' ; System . out . println ( c1 ); // a char c2 = 97 ; System . out . println ( c2 ); // a char c3 = '`' ; c3 ++ ; System . out . println ( c3 ); // a Die 128 verschiedenen Zeichen gen\u00fcgten nat\u00fcrlich schnell nicht mehr und es wurden deutlich gr\u00f6\u00dfere Kodierungstabellen entwickelt. Ein de-facto Standard ist UTF-8 , welcher Bytes (also 8 Bit) zur Kodierung der Zeichen verwendet. Die ersten 128 Zeichen sind dabei mit dem ASCII-Code identisch. Im UTF-8 k\u00f6nnen aber mehrere Bytes hintereinander geschrieben werden und erm\u00f6glichen so einen beliebig gro\u00dfen Kodierungsraum. Der Datentyp char ist 16 Bit gro\u00df, kann also 2 Byte gro\u00dfe Kodierungsr\u00e4ume darstellen (65 536 verschiedene Zeichen). Eine UTF-8-Tabelle finden Sie z.B. hier . Die linke Spalte in dieser Tabelle zeigt den Unicode . Dieser kann auch in Java (in leicht abgewandelter Form) verwendet werden. Scrollen Sie in der Tabelle ein wenig bis zur Position U+00A9 herunter. Dort sehen Sie z.B. die Codierung des \u00a9-Copyright-Zeichens. In Java kann dieser Code wie folgt verwendet werden: char UTF-8 Zeichen char u1 = '\\u00a9' ; System . out . println ( u1 ); // copyright-Zeichen char u2 = '\\u00b0' ; System . out . println ( u2 ); // Grad-Zeichen char u3 = '\\u00bd' ; System . out . println ( u3 ); // 1/2-Zeichen","title":"char"},{"location":"variablen/#gleitkomma-datentypen-double-float","text":"Eine Gleitkomma-Zahl (also eine Zahl mit einem Punkt, z.B. 5.0 oder -1.2345 ) in einem Java-Programm ist vom Typ double . Dieser Datentyp ist der Standard-Datentyp f\u00fcr Gleitkomma-Zahlen. Der Wertebereich der Datentypen double und float l\u00e4sst sich nicht so leicht angeben, denn entweder wird relativ viel \"Speicher\" f\u00fcr die Genauigkeit verwendet (f\u00fcr die Anzahl der Nachkommastellen, z.B. 0.123456789 ) oder f\u00fcr die Vorkommastellen (z.B. 987654321.0 ). Generell ist der Wertebereich (die Genauigkeit) bei double viel h\u00f6her, denn f\u00fcr eine Variable vom Typ double werden 64 bit reserviert, w\u00e4hrend eine Variable vom Typ float nur 32 bit gro\u00df ist. Bei float beschr\u00e4nkt sich die Genauigkeit auf ca. 7 signifikante Stellen (Nachkommastellen), w\u00e4hrend es bei double ca. 17 signifikante Stellen sind. Beispiel float float floatNumber = 1.0f / 3.0f ; System . out . println ( floatNumber ); // 0.33333334 Im obigen Beispiel wird mithilfe von float der Bruch 1/3 ausgerechnet. Zwei Sachen sind zu beachten Wie wir das schon beim Datentyp long gesehen haben, gibt es auch f\u00fcr Gleitkommazahlen ein Postfix, hier f , um zu sagen, dass eine Zahl vom Typ float sein soll. Ohne das f w\u00e4re sie vom Typ double und wir w\u00fcrden sogar einen Compilerfehler erhalten, wenn wir das f am Ende der Zahl nicht angeben w\u00fcrden. Hier ist es also wichtig, bei der Wertzuweisung anzugeben, dass die Zahl vom Typ float sein soll - n\u00e4mlcih durch die Angabe von f ( F ginge auch). Die Genauigkeit bei float ist nicht sehr hoch. 1/3 im float -Wertebereich ergibt 0.33333334 . Schauen wir uns das gleiche Beispiel mit double an: Beispiel float double doubleNumber = 1.0 / 3.0 ; System . out . println ( doubleNumber ); // 0.3333333333333333 Erstens hat der double -Wert deutlich mehr Nachkommastellen (16 statt 8 bei float ) und zweitens ist der Wert somit korrekter. Die Speicherung von Gleikommazahlen erfolgt nach IEEE 754 - Standard . Wir merken uns: wir sollten float eher nicht verwenden, wenn wir Wert auf Genauigkeit legen, wenn wir float verwenden, dann m\u00fcssen wir beim Initialisieren und bei allen Wertezuweisungen darauf achten, dass wir an die Gleikommazahl ein f anh\u00e4ngen, da es sich ansonsten um eine Gleitkommazahl vom Typ double handelt, double ist der Standardtyp f\u00fcr Gleikommazahlen und wenn eine Gleitkommazahl im Programmcode vorkommt, dann handelt es sich um eine Zahl vom Typ double . Datentyp gr\u00f6\u00dfter positiver Wert kleinster positiver Wert float ~3.4028234663852886E+038 ~1.4012984643248171E-045 double ~1.7976931348623157E+308 ~4.9406564584124654E-324","title":"Gleitkomma-Datentypen double, float"},{"location":"variablen/#der-datentyp-string","text":"Der Datentyp String ist kein primitiver Datentyp (kein Wertetyp), sondern ein sogenannter komplexer Datentyp (oder, wie wir sagen Referenztyp ). Wir erkennen das bereits daran, dass der Datentyp mit einem Gro\u00dfbuchstaben beginnt. Der Unterschied zwischen Variablen von einem Wertetypen und Variablen von Referenztypen ist der, dass die ersten \"nur\" Werte speichern ( 3 , 5 , 'a' , 123.45 , true , ...) und die anderen speichern Objekte (oder richtiger: Referenzen auf Objekte) - darum k\u00fcmmern wir uns sp\u00e4ter sehr ausf\u00fchrlich. Wir k\u00f6nnen uns merken (ist aber derzeit noch nicht wichtig), dass ein String ein Objekt und kein einfacher Wert ist, aber derzeit betrachten wir den Datentyp String wie die primitiven Wertetypen auch. Ein String -Literal erkennt man an den doppelten Anf\u00fchrungsstrichen. Darin kann ein beliebiger Text (bestehend aus allen m\u00f6glichen Zeichen, Buchstaben, Sonderzeichen, Umlauten etc.) stehen, z.B. \"Hallo FIW!\" , \"2und2gleich4 und $ % & 0? | \\ !\" , \" \u00e4 \u00fc \u00f6 \u00df . Die Deklaration und Initialisierung einer String -Variablen sieht also so aus: String s1 = \"Informatik\" ; Auch f\u00fcr den Datentyp String gibt es einen Operator, der zwei Strings miteinander verbindet. Er wird Konkatenation ( String-Konkatenation oder Zeichenkettenverbindungsoperator genannt). Das Operatorsymbol der Konkatenation ist in Java + . String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); Die folgenden drei Ausgaben sind alle gleich: String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); // Informatik und Wirtschaft String s2 = \"Informatik\" ; String s3 = \" und\" ; String s4 = \" Wirtschaft\" ; System . out . println ( s2 + s3 + s4 ); // Informatik und Wirtschaft String s5 = \"Informatik\" ; String s6 = s5 + \" und\" ; String s7 = s6 + \" Wirtschaft\" ; System . out . println ( s7 ); //Informatik und Wirtschaft","title":"Der Datentyp String"},{"location":"variablen/#doppelte-bedeutung-des-operatorzeichens","text":"Das + wird sowohl als arithmetischer Operator f\u00fcr numerische Datentypen als auch als Konkatenation f\u00fcr Strings verwendet. In den obigen Beispielen kommen wir damit nicht durcheinander, da v\u00f6llig klar ist, dass es sich dabei um die Konkatenation handelt. Es gibt aber Beispiele, bei denen in einem Ausdruck beide Bedeutungen vorkommen. Diese diskutieren wir jetzt. Zun\u00e4chst schauen wir uns noch eine Typische Verendung der Konkatenation an: typisches Beispiel f\u00fcr die Konkatenation 1 2 3 4 int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 Die Ausgabe bei dem obigen Beispiel ist 3 + 4 = 7 . Schauen wir uns das Beispiel genauer an: In Zeile 3 wird das + eindeutig als arithmetischer Operator verwendet, denn es steht zwischen zwei numerischen Werten ( summand1 und summand2 sind jeweils vom Typ int ) In Zeile 4 kommt + mehrmals vor. Der Ausdruck in den runden Klammern von println() wird von links nach rechts aufgel\u00f6st: Das Literal \" + \" ist ein String. Hier ist + gar kein Operator, sondern nur ein Zeichen. Das + in summand1 + \" + \" ist die Konkatenation. Das liegt daran, dass einer der beiden Operanden, die das + verbindet, vom Typ String ist. Intern wird der Wert von summand1 ( die 3 ) zu einem String und dieser wird mit \" + \" verbunden. Es entsteht ein String \"3 + \" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + \" + summand2 enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn einer der beiden Operanden (der erste) ist vom Typ String . Intern wird der Wert von summand2 ( die 4 ) zu einem String und dieser wird mit \"3 + \" verbunden. Es entsteht ein String \"3 + 4\" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + 4\" + \" = \" enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn beide Operanden (der erste und der zweite) sind vom Typ String . Es entsteht der String \"3 + 4 = \" . Das letzte + steht also in dem Ausdruck \"3 + 4 = \" + summe . Auch hier handelt es sich wieder um die Konkatenation, da einer der beiden Operanden (der erste) vom Typ String ist. Intern wird der Wert von summe ( die 7 ) zu einem String und dieser wird mit \"3 + 4 = \" verbunden. Es entsteht ein String \"3 + 4 = 7\" . Dieser String wird ausgegegeben. \u00dcbung Doppelte Bedeutung von + Angenommen, in dem obigen Beispiel wollen Sie die Summe der beiden Summanden nicht erst in einer Variablen zwischenspeichern, sondern gleich ausgeben. Sie schreiben deshalb folgendes Programm: int summand1 = 3 ; int summand2 = 4 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summand1 + summand2 ); Sie erhalten jedoch nicht die gew\u00fcnschte Ausgabe. Warum nicht? Wie k\u00f6nnen Sie doch die Summe ausgeben, ohne diese zwischenspeichern zu m\u00fcssen? Success Wir k\u00f6nnen nun Variablen deklarieren und initialisieren. Wir kennen alle acht primitiven Datentypen. Wir nennen diese Datentypen Wertetypen . Wir wissen, dass eine ganze Zahl im Java-Programm vom Typ int ist und eine Gleikommazahl vom Typ double . Wir kennen die interne Darstellung von ganzen Zahlen und wir wissen \u00fcber die Kodierung von Zeichen Bescheid. Der datentyp char ist ein ganzzahliger Typ, obwohl er f\u00fcr das Speichern von Zeichen zust\u00e4ndig ist. Dies liegt an der Kodierung der Zeichen als ganze Zahlen. Der Wertzuweisungsoperator ist = . Wenn einer Variablen ein Wert zugewiesen werden soll, dann muss die Variablen links stehen, der Wertuweisungsoperator in der Mitte und rechts der Wert.","title":"Doppelte Bedeutung des Operatorzeichens +"},{"location":"variablen/#konstanten","text":"Wir haben gesagt, dass Variablen beliebig oft einer neuer Wert zugewisen werden kann. Manchmal m\u00f6chte man aber genau das nicht. Sogenannten Konstanten m\u00f6chte man genau einmal einen Wert zuweisen und dann soll dieser Wert nicht mehr \u00fcberschrieben werden k\u00f6nnen. In Java kann man solche Konstanten mithilfe des Schl\u00fcsselwortes final deklarieren: final datentyp KONSTANTE = Wert; Eine Konstante wird zun\u00e4chst wie eine Variable deklariert, d.h. man vergibt einen Namen f\u00fcr die Variable und weist ihr einen Datentyp zu. Au\u00dferdem wird ihr mithilfe des Zuweisungsoperators ein Wert zugewiesen. Um zu verhindern, dass dieser Variablen erneut ein Wert zugewiesen kann, setzt man vor den Datentyp noch das Schl\u00fcsselwort final . Damit ist diese Variable schreibgesch\u00fctzt und es kann ihr nie wieder ein neuer Wert zugewiesen werden. Schauen wir uns ein Beispiel an: final double PI = 3.14159265359 ; Es wird eine Konstante PI deklariert und ihr der Wert 3.14159265359 zugewiesen. Damit wir Konstanten von \"normalen\" Variablen unterscheiden k\u00f6nnen, schreiben wir Konstenten immer gro\u00df . Wenn der Name einer Konstanten aus mehreren W\u00f6rtern besteht, verwendet man typischerweise den Unterstrich _ zum Verbinden der beiden W\u00f6rter, z.B. final int NOT_FOUND = - 1 ; final int MIN_VALUE = - 2147483648 ; final int MAX_VALUE = 2147483647 ; final char DEGREE_SYMBOL = '\\u00b0' ; final char DEGREE_CELSIUS = '\\u2103' ; final char DEGREE_FAHRENHEIT = '\\u2109' ; Ansonsten k\u00f6nnen Sie Konstanten ganz normal verwenden, aber immer nur lesend, also z.B. double area = PI * 25.0 ; System . out . println ( area ); System . out . println ( DEGREE_FAHRENHEIT ); System . out . println ( DEGREE_CELSIUS ); String fahrenheit = DEGREE_SYMBOL + \"F\" ; System . out . println ( fahrenheit ); ergibt folgende Ausgabe: 78 .53981633975 \u2109 \u2103 \u00b0F Wenn Sie in Ihrem Programm versuchen, einer Konstanten einen neuen Wert zuzuweisen, erhalten Sie einen Fehler ( The final variable cannot be assigned ) und Sie k\u00f6nnen das Programm gar nicht erst compilieren. Wann immer Sie in Ihrem Programm ein Literal verwenden, also einen Wert, sollten Sie \u00fcberlegen, ob Sie diesem Wert nicht besser einen Namen geben k\u00f6nnen, n\u00e4mlich daf\u00fcr eine Konstante verwenden, und dann stets die Konstante anstelle des Wertes verwenden. Damit werden sogenannte magic numbers vermieden und das Programm ist lesbarer.","title":"Konstanten"},{"location":"variablen/#typkonvertierung-type-cast","text":"Java ist statisch typisiert , d.h. dass jede Variable (und jedes Literal) einen Datentyp hat. Dieser wird bei der Deklaration der Variablen festegelgt und ist somit bereits zur Compile-Zeit bekannt. Der Datentyp einer Variablen kann auch nicht mehr ge\u00e4ndert werden 4 . Die Typisierung einer Variablen gibt den Wertebereich vor, aus dem die Variable Werte annehmen kann ( int -Variablen aus dem int -Wertebereich, boolean aus dem Wertebereich {true, false} usw.). Trotzdem ist in Java auch erlaubt, dass Wertezuweisungen nicht nur aus identischen Datentypen m\u00f6glich sind, sondern auch aus kampatiblen Datentypen: 1 2 3 4 5 int a = 5 ; // links ist int und rechts ist int --> identische Datentypen long b = 5 ; // links ist long und rechts ist int --> kompatible Datentypen int c = boolean ; // nicht erlaubt --> Fehler!!! keine kompatiblen Datentypen (int vs. boolean) float d = 5.0f ; // links ist float und rechts ist float --> identische Datentypen double e = d ; // links ist double und rechts ist float --> kompatible Datentypen In den Zeilen 2 und 5 werden die Datentypen bei der Zuweisung automatisch vom Compiler umgewandelt (in Zeile 2 automatisch von int nach long und in Zeile 5 automatisch von float nach double ). Diese Umwandlung von Datentypen nennt sich Typkonvertierung (engl. type cast ). Die beiden Beispiele aus Zeile 2 und Zeile 5 hei\u00dfen implizite Typkonvertierung.","title":"Typkonvertierung (type-cast)"},{"location":"variablen/#implizite-typkonvertierung","text":"Jeder Wert (jedes Literal ) in Java ist von einem bestimmten Typ, z.B. 1 2 3 4 5 4 // Datentyp int 4.0 // Datentyp double true // Datentyp boolean 'a' // Datentyp char \"FIW\" // Datentyp String Was passiert bei double number = 4 ; ? Wir haben links eine Variable vom Typ double und rechts einen Wert vom Typ int . Die Antwort ist, dass der Compiler implizit den Wert 4 in den Wert 4.0 umwandelt und diesen Wert der Variablen number zuweist. Es findet also eine implizite Typkonvertierung statt. Typkonvertierung immer, wenn in einer Zuweisung verschiedene Typen im Spiel sind, erfolgt eine Typkonvertierung der Typ, der rechts vom Zuweisungsoperator steht, muss in den Typ konvertiert werden, der links vom Zuweisungsoperator steht hier: von int nach double Wenn von Typen mit einem kleineren Wertebereich zu Typen mit einem gr\u00f6\u00dferen Wertebereich umgewandelt (konvertiert) werden sollen, kann dies automatisch (implizit) erfolgen \u2192 implizite Typkonvertierung 1 2 3 4 5 6 7 8 // Beispiel Umrechnung Fahrenheit in Celsius --> ohne Typkonvertierung final char DEGREE_SYMBOL = '\\u00b0' ; int celsius = 0 ; for ( int fahrenheit = 0 ; fahrenheit <= 100 ; fahrenheit += 20 ) { celsius = 5 * ( fahrenheit - 32 ) / 9 ; System . out . printf ( \"%3d %cF --> %3d %cC %n\" , fahrenheit , DEGREE_SYMBOL , celsius , DEGREE_SYMBOL ); } In dem Beispiel werden fahrenheit -Werte in celsius -Werte umgerechnet. Die Variablen celsius und fahrenheit und auch die Werte 5 , 32 und 9 sind vom Typ int . Die Berechnungen laufen ohne Typkonvertierung ab, alles bleibt im Wertebereich von int . Deshalb handelt es sich bei (fahrenheit - 32) / 9 um eine ganzzahlige Division . Die Ausgabe ist wie folgt: 0 \u00b0F --> -17 \u00b0C 20 \u00b0F --> -6 \u00b0C 40 \u00b0F --> 4 \u00b0C 60 \u00b0F --> 15 \u00b0C 80 \u00b0F --> 26 \u00b0C 100 \u00b0F --> 37 \u00b0C Wir \u00e4ndern das Beispiel und deklarieren die beiden Variablen fahrenheit und celsius als double : 1 2 3 4 5 6 7 8 // Beispiel Umrechnung Fahrenheit in Celsius --> mit Typkonvertierung final char DEGREE_SYMBOL = '\\u00b0' ; double celsius = 0 ; for ( double fahrenheit = 0 ; fahrenheit <= 100 ; fahrenheit += 20 ) { celsius = 5 * ( fahrenheit - 32 ) / 9 ; System . out . printf ( \"%6.2f %cF --> %7.3f %cC %n\" , fahrenheit , DEGREE_SYMBOL , celsius , DEGREE_SYMBOL ); } Dadurch ergibt sich eine andere Ausgabe (die Platzhalter in printf() mussten auch angepasst werden): 0 ,00 \u00b0F --> -17,778 \u00b0C 20 ,00 \u00b0F --> -6,667 \u00b0C 40 ,00 \u00b0F --> 4 ,444 \u00b0C 60 ,00 \u00b0F --> 15 ,556 \u00b0C 80 ,00 \u00b0F --> 26 ,667 \u00b0C 100 ,00 \u00b0F --> 37 ,778 \u00b0C Was ist passiert? Dadurch, dass in der Wertezuweisung celsius = 5 * (fahrenheit - 32) / 9; auf der linken Seite ein double steht, wird der gesamte Ausdruck auf der rechten Seite in ein double konvertiert . Das w\u00fcrde aber erst nach Ausrechnen des Ausdrucks erfolgen, wenn nicht auch fahrenheit ein double w\u00e4re. Es passiert folgendes: zuerst wird der Ausdruck (fahrenheit - 32) aufgel\u00f6st, da er in Klammern steht. Hier ist die Operation double - int . Sobald einer der beiden Operanden ein double ist, wird der double -Operator - verwendet \u2192 dazu wird die 32 in eine 32.0 konvertiert \u2192 das Ergebnis ist ein double dann wird von links nach rechts aufgel\u00f6st, also zun\u00e4chst 5 * double . Auch hier ist die Operation also int * double , d.h. double -Multiplikation und somit wird aus der 5 eine 5.0 . Das Ergebnis dieser Multiplikation ist double dann erfolgt die Berechnung von double / 9 . Wenn einer der beiden Operanden ein double ist, handelt es sich bei der Division um eine Gleikommadivision . Also gibt es auch Nachkommastellen \u2192 das Ergebnis ist ein double Diese implizite Typkonvertierung macht der Compiler automatisch. Implizite Typkonvertierung kann immer dann erfolgen, wenn von einem schmalen in einen breiten Datentyp konvertiert wird, d.h. wenn alle Werte aus dem \"schmalen\" Wertebereich auch Werte aus dem \"breiten\" Wertebereich sind. Dies ist bei int (schmal) nach double (breit) der Fall, da alle int -Werte auch im double -Wertebereich enthalten sind. Das hier ist also kein Problem: int v1 = 1 ; double v2 = v1 ; // ok System . out . println ( \"Wert von v2: \" + v2 ); // 1.0 aber das geht nicht : double v3 = 1.0 ; int v4 = v3 ; // Fehler! System . out . println ( \"Wert von v4: \" + v4 ); Obwohl ja die 1.0 ein Wert aus int darstellt, pr\u00fcft der Compiler nicht den Wert, sondern den Typ. Da der double -Wertebereich viele Werte umfasst, die nicht Teil des Wertebereichs von int sind (z.B. 1.5 ), kann hier keine implizite Typkonvertierung erfolgen, denn diese w\u00e4re von einem \"breiten\" in einen \"schmalen\" Datentypen. Wenn man sich jedoch ganz sicher ist, dass eine solche Typkonvertierung sinnvoll ist (z.B. kann man ja 1.0 nach 1 und somit int ohne Verlust umwandeln), kann eine solche Typkonvertierung explizit angesto\u00dfen werden.","title":"Implizite Typkonvertierung"},{"location":"variablen/#explizite-typkonvertierung","text":"In dem Beispiel von eben double v3 = 1.0 ; int v4 = v3 ; // Fehler! System . out . println ( \"Wert von v4: \" + v4 ); f\u00fchrt der Compiler keine implizite Typkonvertierung durch. Das Programm wird gar nicht compiliert. Wenn wir nun aber wollen, dass diese Typkonvertierung trotzdem durchgef\u00fchrt wird, m\u00fcssen wir den Typkonvertierungsoperator (auch type cast operator ) verwenden. Der Typkonvertierungsoperator enth\u00e4lt in runden Klammern den Zieltyp und steht vor dem Wert der umgewandelt werden soll: typ_A variable = (typ_A)wert; Die variable sei vom typ_A und der Wert von einem Typ, der nicht impliziert nach typ_A konvertiert werden kann. Unter Angabe von (typ_A) direkt vor dem wert wird der Wert explizit in typ_A konvertiert. Obiges Beispiel w\u00fcrde dann so aussehen: double v3 = 1.0 ; int v4 = ( int ) v3 ; // ok System . out . println ( \"Wert von v4: \" + v4 ); // 1 Da wir wissen, dass die 1 (der von uns zugewiesene Wert von v3 ) im Wertebereich von int liegt, k\u00f6nnen wir den Compiler anweisen, von double nach int zu konvertieren \u2192 explizite Typkonvertierung. Aber Achtung! Explizite Typkonvertierung kann zu Informationsverlust f\u00fchren! double v3 = 1.23456 ; int v4 = ( int ) v3 ; // explizite TK System . out . println ( \"Wert von v4: \" + v4 ); // 1 Wird ein double in ein int konvertiert, werden die Nachkommastellen einfach abgeschnitten (kein Runden!). Aber Achtung! Explizite Typkonvertierung kann zu ganz anderen Werten f\u00fchren! long v5 = 2147483648L ; // L mit angeben! int v6 = ( int ) v5 ; // 2 hoch 31 System . out . println ( \"Wert von v6: \" + v6 ); // -2147483648 2147483648 ist zwar ganzzahlig, ist aber nicht mehr Teil des Wertebereiches von int (um 1 zu gro\u00df) \u2192 aufgrund der internen Zahlendarstellung (Zweierkomplement) , bekommt v6 den Wert -2147483648 . Bei expliziter Typkonvertierung muss selbst\u00e4ndig darauf geachtet werden, dass der Wertebereich nicht \u00fcberschritten bzw. nicht verlassen wird!","title":"Explizite Typkonvertierung"},{"location":"variablen/#sinnvolle-anwendungen-des-typkonvertierungsoperators","text":"Angenommen, wir haben ein int -Array ia und wollen aus den Werten in diesem Array den Mittelwert berechnen. Dann w\u00e4re folgender erster Implementierungsversuch denkbar: int [] ia = { 1 , 2 , 3 , 4 }; int sum = 0 ; for ( int index = 0 ; index < ia . length ; index ++ ) { sum = sum + ia [ index ] ; } double average = sum / ia . length ; System . out . println ( \"Durchschnitt ist \" + average ); // 2.0 Wir bilden also die Summe \u00fcber alle Werte und teilen durch die Anzahl der Werte. Das entspricht der Definition des Durchschnitts. Wir \u00fcberschlagen im Kopf, dass f\u00fcr die vier Werte 1 , 2 , 3 und 4 der Durchschnitt 2.5 ist. Ausgegeben wird aber Durchschnitt ist 2 .0 Das ist falsch und der Grund daf\u00fcr liegt darin, dass es sich bei sum / ia.length um die ganzzahlige Divsion handelt, da beide Operanden vom Typ int sind. Eine M\u00f6glichkeit w\u00e4re, die Variable sum als double zu deklarieren. Dann haben wir bereits das gew\u00fcnschte Ergebnis. Eine andere ist, einen der beiden (oder beide) explizit nach double zu konvertieren: int [] ia = { 1 , 2 , 3 , 4 }; int sum = 0 ; for ( int index = 0 ; index < ia . length ; index ++ ) { sum = sum + ia [ index ] ; } double average = sum / ( double ) ia . length ; System . out . println ( \"Durchschnitt ist \" + average ); // 2.5 Wir haben jetzt die L\u00e4nge explizit nach double konvertiert und somit ist einer der beiden Operanden der Division ein double und somit wird die Gleitkommadivision durchgef\u00fchrt. Nun erhalten wir das richtige Ergebnis: Kopf, dass f\u00fcr die vier Werte 1 , 2 , 3 und 4 der Durchschnitt 2.5 ist. Ausgegeben wird aber Durchschnitt ist 2 .5 Ein anderes sinnvolles Beispiel ist die explizite Konvertierung eines int -Wertes nach char . Beides sind ganzzahlige Datentypen, aber der Wertebereich von char (8 Bit) umfasst viel weniger Werte als der Wertebereich von int (16 Bit). int ist der \"breite\" Datentyp und char der schmale und somit findet keine implizite Typkonvertierung von int nach char statt. Trotzdem m\u00f6chte man h\u00e4ufig int in Bezug auf char nutzen, weil man unter Verwendung der numerischen ASCII-Codes ( int ) gut mit Zeichen \"rechnen\" kann: for ( int ascii = 65 ; ascii < 91 ; ascii ++ ) { char c = ( char ) ascii ; System . out . print ( c + \" \" ); } Wir m\u00fcssen hier explizit konvertieren, da die implizite Typkonvertierung char c = ascii; nicht existiert. Das w\u00e4re also ein Fehler. Mit der expliziten Typkonvertierung klappt aber alles wie gew\u00fcnscht: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Hier nochmal zur Veranschaulichung, zwischen welchen Datentypen eine implizite Typkonvertierung durchgef\u00fchrt wird: Beachten Sie, dass von und nach boolean in Java keine implizite Typkonvertierung durchgef\u00fchrt wird! Hier nochmal zur Veranschaulichung, zwischen welchen Datentypen eine explizite Typkonvertierung durchgef\u00fchrt werden kann ( kompatible Datentypen): Beachten Sie, dass von und nach boolean in Java auch keine explizite Typkonvertierung m\u00f6glich ist! const und goto geh\u00f6ren eigentlich gar nicht zum Sprachumfang von Java und sind aber trotzdem reservierte Schl\u00fcsselw\u00f6rter. \u21a9 \u21a9 Tats\u00e4chlich ist die Gr\u00f6\u00dfe eines boolean gar nicht genau definiert (siehe hier ). man braucht ja eigentlich nur ein bit. Man liest aber sehr h\u00e4ufig davon, dass einer Variablen vom Typ boolean ein ganzes Byte reserviert wird. \u21a9 Man k\u00f6nnte auch nit dem kleinen Buchstaben l erg\u00e4nzen, das macht man aber nicht, weil die Verwechselungsgefahr mit der 1 zu gro\u00df ist. \u21a9 Das ist nicht in Allen Programmiersprachen so. Beispielsweise wird in JavaScript erst zur Laufzeit ermittelt, von welchem Typ die Variable ist, denn das h\u00e4ngt von ihrem Wert ab. Dort kann eine Variable foo=\"String\" vom Typ string sein und dann durch foo=4 vom Typ number . Die Typisierung in solchen Programmiersprachen nennt man dynamisch typisiert . \u21a9","title":"Sinnvolle Anwendungen des Typkonvertierungsoperators"}]}