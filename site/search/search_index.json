{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programmieren I \u00b6 Herzlich willkommen zur Programmieren I Veranstaltung! Wir werden unter Verwendung der Programmiersprache Java die wesentlichen Konzepte lernen, die f\u00fcr das Verst\u00e4ndnis modernen Programmierens notwendig sind. Es sind keinerlei Vorkenntnisse erforderlich. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung! Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren! Sie m\u00fcssen es tun . Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler! Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df! Organisatorisches \u00b6 Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in der Vorlesung vorgestellt und in diesem Skript beschrieben. Es ist geplant, die neuen Themen stets vorab in diesem Skript hier zu ver\u00f6ffentlichen. Sie k\u00f6nnen sich also bereits vorab mit dem jeweiligen neuen Thema besch\u00e4ftigen. Zusammen mit dem Skript (das neue Thema) werden sowohl die dazugeh\u00f6rige \u00dcbung als auch die dazugeh\u00f6rige Aufgabe hochgeladen. Die beiden \u00dcbungen am Mittwoch sind jeweils gleich (d.h. dort werden die gleichen \u00dcbungsaufgaben gel\u00f6st). Die \u00dcbungen behandeln den Stoff, der am Mittwoch in der Vorwoche und am Dienstag in der gleichen Woche besprochen wird. Das bedeutet: das neue Thema wird am Mittwoch und am darauffolgenden Dienstag in der Vorlesung vermittelt und an dem Mittwoch darauf in der \u00dcbung angewendet. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Sie k\u00f6nnen auch beliebig w\u00f6chentlich wechseln. Es wird ein Tutorium angeboten (Termin wird noch bekanntgegeben). Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu. Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie die Aufgaben (Hausaufgaben) l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 12 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr \"Programmieren 1\". Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht meistens jeweils einem Wochenthema. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, dass Sie sich diese gegenseitig beantworten. Damit w\u00e4re allen geholfen und wir k\u00f6nnen besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Bei Bedarf beantworten die Lehrenden die Fragen nat\u00fcrlich. Es wird ein Programmier-Tutorium angeboten. Dieses findet montags um 16:00 Uhr in C 639 statt - Start ist am 25.10.2021. Unsere Tutorin ist Lisanne Delfs . Planung \u00b6 Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) Aufgabe Abgabe Aufgabe bis 1. 11.-15.10.2021 Einf\u00fchrung und Organisatorisches , Klassen und Objekte - BlueJ - - 2. 18.-22.10.2021 Variablen und Datentypen und Operatoren und Ausdr\u00fccke Aufgabe 1 25.10.2021 3. 25.-29.10.2021 Methoden Aufgabe 2 01.11.2021 4. 01.-05.11.2021 Selektion ( if ) und Iteration ( for ) Aufgabe 3 08.11.2021 5. 08.-12.11.2021 Iteration (while) Aufgabe 4 15.11.2021 6. 15.-19.11.2021 Klassen und Objekte Aufgabe 5 22.11.2021 7. 22.-26.11.2021 Konstruktoren, this, eigene Datentypen, R\u00fcckgabe von Objekten Aufgabe 6 29.11.2021 8. 29.-03.12.2021 Eigene Datentypen in Datentypen verwenden Aufgabe 7 06.12.2021 9. 06.-10.12.2021 Vererbung , Object und Polymorphie Aufgabe 8 13.12.2021 10. 13.-17.12.2021 Arrays Aufgabe 9 03.01.2022 11. 20.-24.12.2021 Algorithmen \u00fcber Arrays Aufgabe 10 10.01.2022 12. 03.-07.01.2022 Sortieren von Arrays Aufgabe 11 17.01.2022 13. 10.-14.01.2022 Suchen in Arrays Aufgabe 12 24.01.2022 14. 17.-21.01.2022 Wiederholung, Klausurvorbereitung - - 15. 24.-28.01.2022 Wiederholung, Klausurvorbereitung - - 16. 02.02.2022 14:00 Uhr Klausur - - Code (und Videos) aus der Vorlesung \u00b6 Vorlesung Variablen -- 19. und 20.10.2021 Variablen.java public class Variablen { // instance variables - replace the example below with your own private int x ; public Variablen () { // initialise instance variables x = 5 ; } public void printObjectState () { System . out . println ( \"endlich programmieren!\" ); System . out . println (); System . out . println ( x ); System . out . println (); System . out . println ( \"endlich programmieren!\" ); System . out . println (); System . out . println ( x ); System . out . println (); int intVariable = 123 ; System . out . println ( intVariable ); intVariable = 5 ; System . out . println ( intVariable ); intVariable = - 1234566 ; System . out . println ( intVariable ); long longVariable = 123456 ; System . out . println ( longVariable ); double doubleVariable ; doubleVariable = 1555.0507897865437654321872 ; System . out . println ( doubleVariable ); double doubleVariable1 ; doubleVariable1 = 15.0507897865437654321872 ; System . out . println ( doubleVariable1 ); float floatVariable ; floatVariable = 0.3f ; char charVariable = 'a' ; System . out . println ( charVariable ); charVariable = 65 ; System . out . println ( charVariable ); charVariable = '\\u00A9' ; System . out . println ( charVariable ); charVariable = '\u00a9' ; System . out . println ( charVariable ); charVariable = 12337 ; System . out . println ( charVariable ); int a = 4 ; int b = 7 ; int summe = a + b ; // 11 int produkt = a * b ; System . out . println ( \"Postfix und Prefix\" ); int a1 = 5 ; System . out . println ( a1 ); a1 ++ ; System . out . println ( a1 ); ++ a1 ; System . out . println ( a1 ); int b1 = a1 ; System . out . println ( b1 ); b1 = a1 ++ ; System . out . println ( b1 ); b1 = ++ a1 ; System . out . println ( b1 ); a1 = 7 ; b1 = 8 ; int c1 = 9 ; boolean result = ( true ^ true ); System . out . println ( result ); String s1 = \"Informatik \" ; String s2 = \"und \" ; String s3 = \"Wirtschaft!\" ; String s4 = s1 + s2 + s3 ; System . out . println ( s1 + s2 + s3 ); int nr1 = 7 ; int nr2 = 4 ; System . out . println ( nr1 + \" + \" + nr2 + \" = \" + ( nr1 + nr2 )); } } Vorlesung Methoden -- 26. und 27.10.2021 Methods.java public class Methods { public Methods () { } public void printSum ( int nr1 , int nr2 ) { System . out . println ( nr1 + \" + \" + nr2 + \" = \" + computeSum ( nr1 , nr2 )); } public int computeSum ( int nr1 , int nr2 ) { int sum = nr1 + nr2 ; return sum ; } public boolean isEven ( int number ) { boolean isEven = (( number % 2 ) == 0 ); return isEven ; } public void start () { System . out . println ( \"Heute Methoden!\" ); printSum ( 3 , 4 ); printSum ( - 7 , 6 ); int sum = computeSum ( computeSum ( 1 , 2 ), 4 ) + computeSum ( - 7 , 6 ); System . out . println ( sum ); } } Vorlesung Selektion if und Iteration for -- 2. und 3.11.2021 SelektionIteration.java public class SelektionIteration { public SelektionIteration () { } public boolean isEven ( int number ) { return ( number % 2 == 0 ); } public void printSumFrom1ToN ( int n ) { int sum = 0 ; String term = \"0\" ; for ( int summand = 1 ; summand <= n ; summand ++ ) { term = term + \" + \" + summand ; sum = sum + summand ; System . out . println ( term + \" = \" + sum ); } } public int computeSumFrom1ToN ( int n ) { int sum = 0 ; for ( int summand = 1 ; summand <= n ; summand ++ ) { sum += summand ; } return sum ; } public void printSomething ( int height , int width ) { for ( int row = height ; row > 0 ; row -- ) { // String output = \"row = \" + row + \" : \"; for ( int col = 0 ; col < row ; col ++ ) { // output += \" col=\" + col; System . out . print ( \"*\" ); } System . out . println (); } } public boolean isOdd ( int number ) { return ! isEven ( number ); } public void start () { boolean result = isEven ( 4 ); int number = 7 ; int a = 3 ; int b = 2 ; if ( isOdd ( number )) { System . out . println ( number + \" ist ungerade\" ); } else { System . out . println ( number + \" ist gerade\" ); } System . out . println ( result ); int i = 0 ; for ( i = 0 ; i > 10 ; i = i + 1 ) { System . out . println ( \"Wert von i \" + ( i + 1 ) ); } System . out . println ( \"Ende der Schleife. Wert von i \" + i ); printSumFrom1ToN ( 7 ); printSomething ( 5 , 4 ); } } Vorlesung Iteration while -- 9.11.2021 IterationWhile.java public class IterationWhile { public IterationWhile () { } public void printCollatz ( int start ) { int number = start ; while ( number > 1 ) { System . out . print ( number + \" \" ); if ( number % 2 == 0 ) { number = number / 2 ; } else { number = 3 * number + 1 ; } } } public void printGGT ( int a , int b ) { int number1 = a ; int number2 = b ; while ( number1 != number2 ) { if ( number1 > number2 ) { number1 = number1 - number2 ; } else { number2 = number2 - number1 ; } } System . out . println ( \"ggT von \" + a + \" und \" + b + \" ist \" + number1 ); } public void start () { printGGT ( 40 , 24 ); printCollatz ( 7 ); } } Vorlesung Schleifen -- 10.11.2021 public class Loops { public Loops () { } public void collatz ( int start ) { int count = 0 ; int number = start ; while ( number > 1 ) { System . out . print ( number + \" \" ); count ++ ; number = successor ( number ); } count ++ ; System . out . println ( number + \" --> \" + count + \" Zahlen\" ); } public int successor ( int nr1 ) { int successor = 0 ; if ( isEven ( nr1 )) { successor = nr1 / 2 ; } else { successor = 3 * nr1 + 1 ; } return successor ; } public boolean isEven ( int nr ) { return ( nr % 2 == 0 ); } public void start () { collatz ( 7 ); } } Vorlesung Klassen und Objekte -- 16.11.2021 Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Adresse { public String street ; public int number ; public int zipcode ; public String city ; public String country ; public String getAddress () { return street + \" \" + number + \" \" + zipcode + \" \" + city ; } public void printAddress () { System . out . println ( getAddress ()); } } AdresseTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; /** * The test class AdresseTest. * * @author (your name) * @version (a version number or a date) */ public class AdresseTest { /** * Default constructor for test class AdresseTest */ public AdresseTest () { } /** * Sets up the test fixture. * * Called before every test case method. */ @BeforeEach public void setUp () { } @Test public void testAdresse () { Adresse adresse1 = new Adresse (); adresse1 . street = \"Wilhelminnenhofstr.\" ; adresse1 . number = 75 ; adresse1 . zipcode = 12459 ; adresse1 . city = \"Berlin\" ; adresse1 . printAddress (); System . out . println ( adresse1 . getAddress ()); Adresse adresse2 = new Adresse (); adresse2 . street = \"Treskowallee\" ; adresse2 . number = 8 ; adresse2 . zipcode = 10318 ; adresse2 . city = \"Berlin\" ; adresse2 . printAddress (); System . out . println ( adresse2 . getAddress ()); } /** * Tears down the test fixture. * * Called after every test case method. */ @AfterEach public void tearDown () { } } Video zur Vorlesung Klassen und Objekte -- 16.11.2021 Vorlesung Klassen und Objekte -- 17.11.2021 Adress.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Address { private String street ; private int number ; private int zipcode ; private String city ; public Address ( String pStreet , int pNumber , int pZipcode , String pCity ) { street = pStreet ; number = pNumber ; zipcode = pZipcode ; city = pCity ; } public void renameStreet ( String newStreetName ) { street = newStreetName ; } public String getAddress () { return street + \" \" + number + \"\\n\" + zipcode + \" \" + city ; } public void printAddress () { System . out . println ( getAddress ()); } } AdressTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; /** * The test class AddressTest. * * @author (your name) * @version (a version number or a date) */ public class AddressTest { /** * Default constructor for test class AddressTest */ public AddressTest () { } /** * Sets up the test fixture. * * Called before every test case method. */ @BeforeEach public void setUp () { } @Test public void testAddress () { Address htwWilh = new Address ( \"Alte Strasse\" , 75 , 1249 , \"Berlin\" ); htwWilh . printAddress (); Address htwTres = new Address ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); htwTres . printAddress (); htwTres . renameStreet ( \"Neue Strasse\" ); htwTres . printAddress (); } /** * Tears down the test fixture. * * Called after every test case method. */ @AfterEach public void tearDown () { } } Video zur Vorlesung Klassen und Objekte -- 17.11.2021 Vorlesung Point und this -- 23.11.2021 Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Point { // Objektvariablen private int x ; private int y ; // Konstruktor public Point ( int x , int y ) { this . x = x ; this . y = y ; } public void print () { System . out . println ( \"[ x=\" + this . x + \", y=\" + this . y + \"]\" ); } public int getX () { return this . x ; } public int getY () { return this . y ; } public void translate ( int deltaX , int deltaY ) { this . x = this . x + deltaX ; this . y = this . y + deltaY ; } public boolean isLeft ( Point p ) { return ( this . x < p . x ); } public boolean isAbove ( Point p ) { return ( this . y > p . y ); } } Programmklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Programmklasse { public void testPoint () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 1 , 2 ); Point p3 = new Point ( - 3 , 6 ); p1 . print (); p2 . print (); p3 . print (); System . out . println ( \"p1 : (\" + p1 . getX () + \", \" + p1 . getY () + \")\" ); System . out . println ( \"p2 : (\" + p2 . getX () + \", \" + p2 . getY () + \")\" ); System . out . println ( \"p3 : (\" + p3 . getX () + \", \" + p3 . getY () + \")\" ); p1 . translate ( 1 , 2 ); System . out . println ( \"p1 : (\" + p1 . getX () + \", \" + p1 . getY () + \")\" ); p1 . print (); p1 . translate ( - 2 , - 4 ); p1 . print (); System . out . println ( \"p1 links von p2 ? \" + p1 . isLeft ( p2 ) ); System . out . println ( \"p2 links von p1 ? \" + p2 . isLeft ( p1 ) ); } } Video zur Vorlesung Point und this -- 23.11.2021 Vorlesung Circle -- 24.11.2021 Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Circle { private double radius ; public Circle ( double radius1 ) { this . radius = radius1 ; } public double getRadius () { return this . radius ; } public double getDiameter () { return 2.0 * this . radius ; } public boolean isSmaller ( Circle otherCircle ) { return this . radius < otherCircle . radius ; } public void print () { System . out . println ( \"Radius : \" + this . radius ); System . out . println ( \"Durchmesser : \" + this . getDiameter () ); } } Programmklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Programmklasse { public void testCircle () { Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 4.0 ); Circle c3 = c1 ; System . out . println ( c1 . getRadius ()); System . out . println ( c2 . getRadius ()); c1 . print (); c2 . print (); c3 . print (); System . out . println ( \"c1 kleiner c2 ? \" + c1 . isSmaller ( c2 )); System . out . println ( \"c2 kleiner c1 ? \" + c2 . isSmaller ( c1 )); } } Video zur Vorlesung Circle -- 24.11.2021 Vorlesung Person, Address, Circle -- 30.11.2021 Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class Circle { private double radius ; public Circle ( double radius ) { this . radius = radius ; } public Circle () { this . radius = 1.0 ; } public double getRadius () { return this . radius ; } public double getDiameter () { return 2.0 * this . radius ; } public double area () { return Math . PI * this . radius * this . radius ; } public boolean isSmaller ( Circle otherCircle ) { return this . radius < otherCircle . radius ; } public void print () { System . out . println ( \"Radius : \" + this . radius ); System . out . println ( \"Durchmesser : \" + this . getDiameter () ); System . out . println ( \"Flaecheninhalt : \" + this . area () ); System . out . println (); } } Address.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Address { private String street ; private int number ; private int zipcode ; private String city ; public Address ( String street , int number , int zipcode , String city ) { this . street = street ; this . number = number ; this . zipcode = zipcode ; this . city = city ; } public void renameStreet ( String newStreetName ) { this . street = newStreetName ; } public String getAddressAsString () { return this . street + \" \" + this . number + \"\\n\" + this . zipcode + \" \" + this . city ; } public void printAddress () { System . out . println ( this . getAddressAsString () ); } } Person.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Person { private String name ; private String forename ; private Address address ; public Person ( String name , String forename , Address address ) { this . name = name ; this . forename = forename ; this . address = address ; } public Address getAddress () { return this . address ; } public void print () { System . out . println ( this . forename + \" \" + this . name ); //this.address.printAddress(); System . out . println ( this . address . getAddressAsString ()); System . out . println (); } } Programmklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 public class Programmklasse { public void testCircle () { Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 4.0 ); Circle c3 = c1 ; Circle c4 = new Circle (); Circle c5 = new Circle ( 6 ); System . out . println ( c1 . getRadius ()); System . out . println ( c2 . getRadius ()); c1 . print (); c2 . print (); c3 . print (); c4 . print (); c5 . print (); System . out . println ( \"c1 kleiner c2 ? \" + c1 . isSmaller ( c2 )); System . out . println ( \"c2 kleiner c1 ? \" + c2 . isSmaller ( c1 )); } public void testPoint () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 1 , 2 ); Point p3 = new Point ( - 3 , 6 ); p1 . print (); p2 . print (); p3 . print (); System . out . println ( \"p1 : (\" + p1 . getX () + \", \" + p1 . getY () + \")\" ); System . out . println ( \"p2 : (\" + p2 . getX () + \", \" + p2 . getY () + \")\" ); System . out . println ( \"p3 : (\" + p3 . getX () + \", \" + p3 . getY () + \")\" ); p1 . translate ( 1 , 2 ); System . out . println ( \"p1 : (\" + p1 . getX () + \", \" + p1 . getY () + \")\" ); p1 . print (); p1 . translate ( - 2 , - 4 ); p1 . print (); System . out . println ( \"p1 links von p2 ? \" + p1 . isLeft ( p2 ) ); System . out . println ( \"p2 links von p1 ? \" + p2 . isLeft ( p1 ) ); } public void testAddress () { Address htwTA = new Address ( \"Treskowallee\" , 8 , 10431 , \"Berlin\" ); Address htwWH = new Address ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); htwTA . printAddress (); htwWH . printAddress (); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , htwTA ); maria . print (); Person max = new Person ( \"Mustermann\" , \"Max\" , new Address ( \"Musterstr.\" , 4 , 11111 , \"Berlin\" )); max . print (); htwTA . renameStreet ( \"Neue Str.\" ); htwTA . printAddress (); //maria.address.renameStreet(\"Teststr.\"); Address mariasAddress = maria . getAddress (); String mariasAddressAsString = mariasAddress . getAddressAsString (); // System.out.println( maria.getAddress().getAddressAsString() ); System . out . println ( mariasAddressAsString ); maria . getAddress (). renameStreet ( \"Teststr. \" ); htwTA . printAddress (); } } Video zur Vorlesung Person, Address, Circle -- 30.11.2021 Vorlesung Methodenstack -- 1.12.2021 Methodenstack.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Methodenstack { public void a ( int vaa ) { int vab = 1 ; System . out . println ( \"+--a() --> vaa = \" + vaa + \" vab = \" + vab ); b ( vaa , vab ); } public void b ( int vba , int vbb ) { System . out . println ( \"+----b() --> vba = \" + vba + \" vbb = \" + vbb ); System . out . println (); } public void start () { for ( int va = 0 ; va < 3 ; va ++ ) { System . out . println ( \"start() --> va = \" + va ); a ( va ); } } } Programclass.java 1 2 3 4 5 6 7 8 public class Programclass { public void main () { Methodenstack ms = new Methodenstack (); ms . start (); } } Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Point { // Objektvariablen private int x ; private int y ; // Konstruktor public Point ( int x , int y ) { this . x = x ; this . y = y ; } public void print () { System . out . println ( \"[ x=\" + this . x + \", y=\" + this . y + \"]\" ); } public int getX () { return this . x ; } public int getY () { return this . y ; } public void translate ( int deltaX , int deltaY ) { this . x = this . x + deltaX ; this . y = this . y + deltaY ; } public boolean isLeft ( Point p ) { return ( this . x < p . x ); } public boolean isAbove ( Point p ) { return ( this . y > p . y ); } } UsePoint.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class UsePoint { public UsePoint () { } public void doSomething ( Point p ) { p . translate ( 2 , 2 ); } public void doSomething ( int a ) { a = 6 ; } public void main () { Point p1 = new Point ( 3 , 4 ); p1 . print (); doSomething ( p1 ); p1 . print (); int a = 5 ; System . out . println ( \"a = \" + a ); doSomething ( a ); System . out . println ( \"a = \" + a ); } } Video zur Vorlesung Methodenstack -- 1.12.2021 Vorlesung Vererbung -- 7.12.2021 Viereck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Viereck { protected int a , b , c , d ; // Seiten des Vierecks public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; // System.out.println(\"Objekt von Viereck erzeugt\"); } public int umfang () { return this . a + this . b + this . c + this . d ; } public String toString () { String s = String . format ( \"[ a=%d, b=%d, c=%d, d=%d ], Umfang des Vierecks : %d %n\" , this . a , this . b , this . c , this . d , this . umfang ()); return s ; } public void print () { System . out . println ( this . toString () ); } } Rechteck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Rechteck extends Viereck // Rechteck erbt von Viereck { // es werden alle Objekteigenschaften der Klasse Viereck geerbt // a, b, c, d, umfang(), toString(), print() public Rechteck ( int laenge , int breite ) { super ( laenge , breite , laenge , breite ); // Aufruf des Konstruktors von Viereck // System.out.println(\"Objekt von Rechteck erzeugt\"); } public int flaecheninhalt () { return this . a * this . b ; } @Override public String toString () { String s = String . format ( \"[ laenge=%d, breite=%d ], Umfang des Rechtecks : %d und Flaecheninhalt : %d %n\" , this . a , this . b , this . umfang (), this . flaecheninhalt ()); return s ; } } Quadrat.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Quadrat extends Rechteck // Quadrat erbt von Rechteck { // es werden alle Objekteigenschaften der Klasse Rechteck geerbt // a, b, c, d, umfang(), toString() (neu), print(), flaecheninhalt() public Quadrat ( int seite ) { super ( seite , seite ); // Aufruf des Konstruktors von Rechteck } @Override public String toString () { String s = String . format ( \"[ seitenlaenge=%d ], Umfang des Quadrats : %d und Flaecheninhalt : %d %n\" , this . a , this . umfang (), this . flaecheninhalt ()); return s ; } } Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Programclass { public void main () { Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 11 , 22 , 33 , 44 ); v2 . print (); // System.out.println(\"Flaecheninhalt des Vierecks : \" + v2.flaecheninhalt()); // Error! Rechteck r1 = new Rechteck ( 15 , 25 ); r1 . print (); System . out . println ( \"Flaecheninhalt des Rechtecks : \" + r1 . flaecheninhalt ()); Quadrat q1 = new Quadrat ( 15 ); q1 . print (); } } ProgramclassTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; public class ProgramclassTest { public ProgramclassTest () { } @Test public void testMain () { Programclass pc = new Programclass (); pc . main (); } } Video zur Vorlesung Vererbung -- 7.12.2021 Vorlesung Object -- 8.12.2021 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class Programclass { public void main () { Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); Viereck v2 = new Viereck ( 11 , 22 , 33 , 44 ); Rechteck r1 = new Rechteck ( 15 , 25 ); Quadrat q1 = new Quadrat ( 15 ); /* v1.print(); v2.print(); r1.print(); q1.print(); */ System . out . println ( v1 . toString ()); System . out . println ( r1 . toString ()); System . out . println ( q1 . toString ()); System . out . println ( v1 . getClass ()); System . out . println ( r1 . getClass ()); System . out . println ( q1 . getClass ()); Viereck vn1 = new Viereck ( 11 , 22 , 33 , 44 ); Viereck vn2 = new Rechteck ( 23 , 34 ); Viereck vn3 = new Quadrat ( 7 ); Rechteck rn1 = ( Rechteck ) vn2 ; // vn2 = new Viereck(1, 2, 3, 4); System . out . println ((( Rechteck ) vn2 ). flaecheninhalt ()); System . out . println ( vn2 . getClass ()); Object o1 = new Quadrat ( 1 ); if ( vn2 instanceof Rechteck ) { System . out . println ( \"bin Rechteck\" ); } if ( vn2 instanceof Viereck ) { System . out . println ( \"bin Viereck\" ); } if ( vn2 instanceof Quadrat ) { System . out . println ( \"bin Quadrat\" ); } System . out . printf ( \"%n%n----------- toString() -----%n%n\" ); System . out . println ( vn1 . toString ()); System . out . println ( vn2 . toString ()); System . out . println ( vn3 . toString ()); System . out . printf ( \"%n%n----------- vn1, n2, vn3 -----%n%n\" ); System . out . println ( vn1 ); System . out . println ( vn2 ); System . out . println ( vn3 ); } } Video zur Vorlesung Object -- 8.12.2021 Teil1 (bis zum Absturz :-( ) Teil2 (nach dem Absturz ;-) ) Vorlesung Object (equals())-- 14.12.2021 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class Programclass { public void main () { Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); Rechteck r1 = new Rechteck ( 15 , 25 ); Quadrat q1 = new Quadrat ( 15 ); Viereck vn1 = new Viereck ( 11 , 22 , 33 , 44 ); Viereck vn2 = new Rechteck ( 23 , 34 ); Viereck vn3 = new Quadrat ( 7 ); vn1 . umfang (); //vn2.flaecheninhalt(); Object o1 = new Viereck ( 11 , 22 , 33 , 44 ); Object o2 = new Rechteck ( 23 , 34 ); Object o3 = new Quadrat ( 7 ); // o1.umfang(); if ( vn3 instanceof Quadrat ) { // true } // if(v instanceof Object) {} // IMMER true // Polymorphie!! System . out . println ( vn1 . toString ()); System . out . println ( vn2 . toString ()); System . out . println ( vn3 . toString ()); // exakt gleich zu Zeilen 20-31 System . out . println ( vn1 ); System . out . println ( vn2 ); System . out . println ( vn3 ); Viereck v2 = new Viereck ( 10 , 20 , 30 , 40 ); Viereck v3 = v1 ; v1 . equals ( v1 ); v1 . equals ( v3 ); Viereck v4 ; // \"Wert\" von v4 ist null // v4.equals(v1) // null.equals() System . out . println ( \"v1 gleich v2 ? \" + ( v1 == v2 )); // Referenzvergleich!!! System . out . println ( \"v1 gleich v3 ? \" + ( v1 == v3 )); // Referenzvergleich!!! System . out . println ( \"v1 gleich v2 ? \" + ( v1 . equals ( v2 ))); // Objektvergleich!!! System . out . println ( \"v1 gleich v3 ? \" + ( v1 . equals ( v3 ))); // Objektvergleich!!! } } Viereck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class Viereck { protected int a , b , c , d ; // Seiten des Vierecks public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; // System.out.println(\"Objekt von Viereck erzeugt\"); } public int umfang () { return this . a + this . b + this . c + this . d ; } @Override public String toString () { String s = String . format ( \"[ a=%d, b=%d, c=%d, d=%d ], Umfang des Vierecks : %d %n\" , this . a , this . b , this . c , this . d , this . umfang ()); return s ; } public void print () { System . out . println ( this . toString () ); } @Override public boolean equals ( Object other ) { if ( this == null ) return false ; if ( this == other ) return true ; if ( other . getClass () != this . getClass ()) return false ; Viereck otherV = ( Viereck ) other ; return ( this . a == otherV . a && this . b == otherV . b && this . c == otherV . c && this . d == otherV . d ); } } Video zur Vorlesung Object (equals())-- 14.12.2021 Vorlesung Arrays -- 15.12.2021 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 public class Programclass { public void main () { System . out . printf ( \"-------- Arrays ---------%n\" ); int number1 = 0 ; int number2 = 1 ; int number3 = 4 ; int number4 = 9 ; int number5 = 16 ; int [] numbers = new int [ 25 ] ; /* numbers[0] = 0; numbers[1] = 1; numbers[2] = 4; numbers[3] = 9; numbers[4] = 16; */ for ( int index = 0 ; index < numbers . length ; index ++ ) { numbers [ index ] = ( index * index ); } // numbers[5] = 25; // ArrayIndexOutBoundsException! Viereck v1 = new Viereck ( 2 , 3 , 4 , 5 ); v1 . print (); Viereck [] vierecke = new Viereck [ 3 ] ; vierecke [ 0 ] = new Viereck ( 10 , 20 , 30 , 40 ); vierecke [ 0 ] . print (); vierecke [ 1 ] = new Rechteck ( 11 , 22 ); vierecke [ 1 ] . print (); vierecke [ 2 ] = new Quadrat ( 15 ); vierecke [ 2 ] . print (); String [] satz1 = new String [ 4 ] ; satz1 [ 0 ] = \"Das\" ; satz1 [ 1 ] = \"ist\" ; satz1 [ 2 ] = \"ein\" ; satz1 [ 3 ] = \"Satz\" ; String [] satz2 = { \"Das\" , \"ist\" , \"ein\" , \"Satz\" }; System . out . printf ( \"-------- Ausgabe von Arrays ---------%n\" ); for ( int index = 0 ; index < numbers . length ; index ++ ) { System . out . printf ( \"%d \" , numbers [ index ] ); } System . out . println (); for ( int i = 0 ; i < satz1 . length - 1 ; i ++ ) { System . out . print ( satz1 [ i ] + \" \" ); } System . out . println ( satz1 [ satz1 . length - 1 ] + \".\" ); int [] randomnumbers = new int [ 20 ] ; Random r = new Random (); for ( int index = 0 ; index < randomnumbers . length ; index ++ ) { randomnumbers [ index ] = r . nextInt ( 199 ) - 99 ; } for ( int index = 0 ; index < randomnumbers . length ; index ++ ) { System . out . printf ( \"%d \" , randomnumbers [ index ] ); } System . out . println (); } } Video zur Vorlesung Arrays -- 15.12.2021 Vorlesung Eclipse + Arrays -- 21.12.2021 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package vorlesungen.vorlesung1221 ; public class Programclass { public static void main ( String [] args ) { System . out . println ( \"Endlich Eclipse!\" ); System . out . println (); char [] alphabet = new char [ 26 ] ; alphabet [ 0 ] = 'A' ; System . out . println ( \"Laenge des Arrays: \" + alphabet . length ); System . out . println ( \"erstes Element : \" + alphabet [ 0 ] ); alphabet [ 1 ] = 66 ; System . out . println ( \"zweites Element : \" + alphabet [ 1 ] ); // alphabet befuellen for ( int index = 0 ; index < alphabet . length ; index ++ ) { alphabet [ index ] = ( char )( index + 65 ); } // alphabet ausgeben for ( int index = 0 ; index < alphabet . length ; index ++ ) { System . out . print ( alphabet [ index ] + \" \" ); } System . out . println (); MyArrays ma = new MyArrays (); System . out . println ( ma . arrayToString ( alphabet )); ma . printArray ( alphabet ); char [] ca1 = { 'a' , 'b' , 'c' , 'a' , 'b' , 'c' }; ma . printArray ( ca1 ); char [] ca2 = new char [ 0 ] ; // [] ma . printArray ( ca2 ); char [] ca3 = { 'a' }; ma . printArray ( ca3 ); int m = 10000 ; int n = 10000 ; for ( int x = 0 ; x < m ; x ++ ) { for ( int y = 0 ; y < n ; y ++ ) { // n * m O(n^2) System . out . println ( x * y ); // 100.000.000 Ausgaben } } } } MyArrays.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package vorlesungen.vorlesung1221 ; public class MyArrays { public String arrayToString ( char [] carr ) { // [ a, b, c, d, e, f ] // bei Laenge 0: [ ] String s = \"[ \" ; if ( carr . length == 0 ) { s = s + \"]\" ; } else { for ( int index = 0 ; index < carr . length - 1 ; index ++ ) { s = s + carr [ index ] + \", \" ; } s = s + carr [ carr . length - 1 ] + \" ]\" ; } return s ; } public String arrayToString1 ( char [] carr ) { // [ a, b, c, d, e, f ] // bei Laenge 0: [ ] String s = \"[ \" ; for ( int index = 0 ; index < carr . length ; index ++ ) { s = s + carr [ index ] ; if ( index != carr . length - 1 ) { s = s + \", \" ; } } s = s + \" ]\" ; return s ; } public void printArray ( char [] carr ) { System . out . println ( this . arrayToString1 ( carr )); } } Video zur Vorlesung Eclipse + Arrays -- 21.12.2021 Vorlesung TicTacToe -- 22.12.2021 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package vorlesungen.vorlesung1222 ; public class Programclass { public static void main ( String [] args ) { TicTacToe ttt = new TicTacToe ( 3 ); /* ttt.printField(); ttt.move(1, 0); ttt.printField(); ttt.move(1, 1); ttt.printField(); ttt.move(1, 2); ttt.printField(); ttt.move(0, 1); ttt.printField(); ttt.move(0, 1); ttt.printField(); ttt.move(2, 0); ttt.printField(); ttt.move(3, 3); ttt.printField(); ttt.move(2, 1); ttt.printField(); */ ttt . playGame (); } } TicTacToe.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 package vorlesungen.vorlesung1222 ; import java.util.Random ; /** * 3x3 Feld * 2 Spielerinnen (1, 2) * auf dem Feld: 0 --> hat noch niemand gesetzt * 1 --> Spielerin 1 * 2 --> Spielerin 2 * Ziel: 3 gleiche in einer Reihe oder Spalte oder Diagonale * * @author jornfreiheit * */ public class TicTacToe { private int [][] field ; private int player ; // 1 und 2 --> enum viel besser private int size ; public TicTacToe ( int size ) { this . size = size ; this . field = new int [ this . size ][ this . size ] ; for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { this . field [ row ][ col ] = 0 ; } } this . player = 1 ; // 1 faengt an } public void printField () { for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { if ( this . field [ row ][ col ] == 0 ) { System . out . print ( \"- \" ); } else if ( this . field [ row ][ col ] == 1 ) { System . out . print ( \"x \" ); } else if ( this . field [ row ][ col ] == 2 ) { System . out . print ( \"o \" ); } } // Ende der Zeile System . out . println (); } // nach Ausgabe des Feldes System . out . println (); } public void switchPlayer () { if ( this . player == 1 ) { this . player = 2 ; } else // this.player == 2 { this . player = 1 ; } // this.player = (this.player % 2) + 1; // geht auch } public void move ( int row , int col ) { if ( this . movePossible ( row , col )) { this . field [ row ][ col ] = this . player ; /* if(this.won()) { this.printWon(); } else { this.switchPlayer(); } */ } } public boolean movePossible ( int row , int col ) { boolean movePossible = false ; // row und col jeweils koorekter Index ??? if ( row >= 0 && row < this . size && col >= 0 && col < this . size ) { // ist das Feld ueberhaupt leer (0) ??? if ( this . field [ row ][ col ] == 0 ) { movePossible = true ; } } return movePossible ; } public boolean won () { boolean won = false ; // 3 nebeneinander ??? for ( int row = 0 ; row < this . size && ! won ; row ++ ) { if ( this . field [ row ][ 0 ] == this . player && this . field [ row ][ 1 ] == this . player && this . field [ row ][ 2 ] == this . player ) { won = true ; } } // 3 untereinander ??? for ( int col = 0 ; col < this . size && ! won ; col ++ ) { if ( this . field [ 0 ][ col ] == this . player && this . field [ 1 ][ col ] == this . player && this . field [ 2 ][ col ] == this . player ) { won = true ; } } // von links oben nach rechts unten - Diagonale if ( ! won && this . field [ 0 ][ 0 ] == this . player && this . field [ 1 ][ 1 ] == this . player && this . field [ 2 ][ 2 ] == this . player ) { won = true ; } // von rechts oben nach links unten - Diagonale if ( ! won && this . field [ 0 ][ 2 ] == this . player && this . field [ 1 ][ 1 ] == this . player && this . field [ 2 ][ 0 ] == this . player ) { won = true ; } return won ; } public void printWon () { if ( this . player == 1 ) { System . out . println ( \"Spielerin x hat gewonnen !!!\" ); } else { System . out . println ( \"Spielerin o hat gewonnen !!!\" ); } } public boolean fieldFilled () { for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { if ( this . field [ row ][ col ] == 0 ) { return false ; } } } return true ; } public boolean draw () { return this . fieldFilled () && ! this . won (); } public boolean finished () { return this . draw () || this . won (); } public void automaticMove () { Random r = new Random (); int row = r . nextInt ( this . size ); int col = r . nextInt ( this . size ); while ( ! this . movePossible ( row , col )) { row = r . nextInt ( this . size ); col = r . nextInt ( this . size ); } this . move ( row , col ); } public void automaticMoveAndCheck () { this . automaticMove (); this . printField (); if ( this . finished ()) { if ( this . won ()) { this . printWon (); } else // draw { System . out . println ( \"Unentschieden !!!\" ); } } else { this . switchPlayer (); } } public void playGame () { while ( ! this . finished ()) { this . automaticMoveAndCheck (); } } } Video zur Vorlesung TicTacToe -- 22.12.2021 Vorlesung Arrays (getMaximum, areEqual) -- 04.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package vorlesungen.vorlesung0104 ; public class Programclass { public static void main ( String [] args ) { // myArray wird erzeugt und befuellt --> Objektvariable in MyArrays2 MyArrays2 ma = new MyArrays2 ( 10 ); ma . printArray (); System . out . println (); // arr1 wird erzeugt und befuellt int [] arr1 = ma . createAndFill ( 20 ); System . out . print ( \"arr1 : \" ); ma . printArray ( arr1 ); int max1 = ma . getMaximum ( arr1 ); System . out . println ( \"Maximum von arr1 ist : \" + max1 ); System . out . println (); // arr2 wird erzeugt und befuellt int [] arr2 = ma . createAndFill ( 15 ); System . out . print ( \"arr2 : \" ); ma . printArray ( arr2 ); int max2 = ma . getMaximum ( arr2 ); System . out . println ( \"Maximum von arr2 ist : \" + max2 ); System . out . println (); int [] arr3 = new int [ 0 ] ; System . out . print ( \"arr3 : \" ); ma . printArray ( arr3 ); if ( ! ma . isEmpty ( arr3 )) { int max3 = ma . getMaximum ( arr3 ); System . out . println ( \"Maximum von arr3 ist : \" + max3 ); } else { System . out . println ( \"arr3 is empty!\" ); } System . out . println (); int [] arr4 = { 8 , 2 , 4 , 3 }; System . out . print ( \"arr4 : \" ); ma . printArray ( arr4 ); int [] arr5 = { 8 , 2 , 4 , 3 }; System . out . print ( \"arr5 : \" ); ma . printArray ( arr5 ); System . out . println ( \"arr4 gleich arr5 ? \" + ma . areEqual ( arr4 , arr5 )); System . out . println (); int [] arr6 = new int [ 0 ] ; System . out . print ( \"arr6 : \" ); ma . printArray ( arr6 ); System . out . println ( \"arr6 gleich arr5 ? \" + ma . areEqual ( arr6 , arr5 )); System . out . println (); } } MyArrays2.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package vorlesungen.vorlesung0104 ; import java.util.Random ; public class MyArrays2 { int [] myArray ; public MyArrays2 ( int length ) { this . myArray = this . createAndFill ( length ); } public int [] createAndFill ( int length ) { // create int [] a = new int [ length ] ; Random r = new Random (); // fill for ( int index = 0 ; index < a . length ; index ++ ) { a [ index ] = ( r . nextInt ( length ) + 1 ); // 0 ... length-1 } return a ; } public void printArray ( int [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public void printArray () { System . out . print ( \"myArray : [ \" ); for ( int index = 0 ; index < this . myArray . length - 1 ; index ++ ) { System . out . print ( this . myArray [ index ] + \", \" ); } if ( this . myArray . length > 0 ) { System . out . print ( this . myArray [ this . myArray . length - 1 ] ); } System . out . println ( \" ]\" ); } public int getMaximum ( int [] a ) { int aktMaximum = a [ 0 ] ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ] > aktMaximum ) { aktMaximum = a [ index ] ; } } return aktMaximum ; } public boolean isEmpty ( int [] a ) { return ( a . length == 0 ); } public boolean areEqual ( int [] a , int [] b ) { if ( a . length != b . length ) { return false ; } for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ] != b [ index ] ) { return false ; } } return true ; } } Video zur Vorlesung Arrays (getMaximum, areEqual) -- 04.01.2022 Vorlesung Arrays Sortieren -- 05.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package vorlesungen.vorlesung0104 ; public class Programclass { public static void main ( String [] args ) { // myArray wird erzeugt und befuellt --> Objektvariable in MyArrays2 MyArrays2 ma = new MyArrays2 ( 10 ); ma . printArray (); System . out . println (); // arr1 wird erzeugt und befuellt int [] arr1 = ma . createAndFill ( 20 ); System . out . print ( \"arr1 : \" ); ma . printArray ( arr1 ); int max1 = ma . getMaximum ( arr1 ); System . out . println ( \"Maximum von arr1 ist : \" + max1 ); System . out . println (); // arr2 wird erzeugt und befuellt int [] arr2 = ma . createAndFill ( 15 ); System . out . print ( \"arr2 : \" ); ma . printArray ( arr2 ); int max2 = ma . getMaximum ( arr2 ); System . out . println ( \"Maximum von arr2 ist : \" + max2 ); System . out . println (); int [] arr3 = new int [ 0 ] ; System . out . print ( \"arr3 : \" ); ma . printArray ( arr3 ); if ( ! ma . isEmpty ( arr3 )) { int max3 = ma . getMaximum ( arr3 ); System . out . println ( \"Maximum von arr3 ist : \" + max3 ); } else { System . out . println ( \"arr3 is empty!\" ); } System . out . println (); int [] arr4 = { 8 , 2 , 4 , 3 }; System . out . print ( \"arr4 : \" ); ma . printArray ( arr4 ); int [] arr5 = { 8 , 2 , 4 , 3 }; System . out . print ( \"arr5 : \" ); ma . printArray ( arr5 ); System . out . println ( \"arr4 gleich arr5 ? \" + ma . areEqual ( arr4 , arr5 )); System . out . println (); int [] arr6 = new int [ 0 ] ; System . out . print ( \"arr6 : \" ); ma . printArray ( arr6 ); System . out . println ( \"arr6 gleich arr5 ? \" + ma . areEqual ( arr6 , arr5 )); System . out . println (); // ab hier 5.1.2022 int [] arr7 = ma . copy ( arr4 ); ma . printArray ( arr7 ); // Sortieren System . out . printf ( \"%n%n-------------- Sortieren ----------%n%n\" ); int [] arr8 = ma . createAndFill ( 20 ); ma . printArray ( arr8 ); int [] arr9 = ma . bubblesort ( arr8 ); ma . printArray ( arr9 ); } } MyArrays2.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 package vorlesungen.vorlesung0104 ; import java.util.Random ; public class MyArrays2 { int [] myArray ; public MyArrays2 ( int length ) { this . myArray = this . createAndFill ( length ); } public int [] createAndFill ( int length ) { // create int [] a = new int [ length ] ; Random r = new Random (); // fill for ( int index = 0 ; index < a . length ; index ++ ) { a [ index ] = ( r . nextInt ( length ) + 1 ); // 0 ... length-1 } return a ; } public void printArray ( int [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public void printArray () { System . out . print ( \"myArray : [ \" ); for ( int index = 0 ; index < this . myArray . length - 1 ; index ++ ) { System . out . print ( this . myArray [ index ] + \", \" ); } if ( this . myArray . length > 0 ) { System . out . print ( this . myArray [ this . myArray . length - 1 ] ); } System . out . println ( \" ]\" ); } public int getMaximum ( int [] a ) { int aktMaximum = a [ 0 ] ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ] > aktMaximum ) { aktMaximum = a [ index ] ; } } return aktMaximum ; } public boolean isEmpty ( int [] a ) { return ( a . length == 0 ); } public boolean areEqual ( int [] a , int [] b ) { boolean areEqual = true ; if ( a . length != b . length ) { areEqual = false ; } else { for ( int index = 0 ; index < a . length && areEqual ; index ++ ) { if ( a [ index ] != b [ index ] ) { areEqual = false ; } } } return areEqual ; } public int [] copy ( int [] original ) { int [] copy = new int [ original . length ] ; for ( int index = 0 ; index < copy . length ; index ++ ) { copy [ index ] = original [ index ] ; } return copy ; } public int [] bubblesort ( int [] a ) { int [] copy = this . copy ( a ); for ( int bubble = 0 ; bubble < copy . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < copy . length - 1 - bubble ; index ++ ) { if ( copy [ index ] > copy [ index + 1 ] ) { int tmp = copy [ index + 1 ] ; copy [ index + 1 ] = copy [ index ] ; copy [ index ] = tmp ; } } } return copy ; } } Video zur Vorlesung Arrays Sortieren -- 05.01.2022 Vorlesung Bruch und Bubblesort -- 11.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package vorlesungen.vorlesung0111 ; public class Programclass { public static void main ( String [] args ) { System . out . printf ( \"%n%n-------------- Bruch -----------------------%n%n\" ); Bruch b1 = new Bruch ( 3 , 7 ); // 12/28 Bruch b2 = new Bruch ( 3 , 4 ); // 21/28 Bruch sumB1B2 = b1 . plus ( b2 ); System . out . printf ( \"Summe: (%d/%d) %n\" , sumB1B2 . getZaehler (), sumB1B2 . getNenner ()); Bruch diffB1B2 = b1 . minus ( b2 ); System . out . printf ( \"Differenz: (%d/%d) %n\" , diffB1B2 . getZaehler (), diffB1B2 . getNenner ()); Bruch diffB1B1 = b1 . minus ( b1 ); System . out . printf ( \"Differenz: (%d/%d) %n\" , diffB1B1 . getZaehler (), diffB1B1 . getNenner ()); System . out . printf ( \"%n%n-------------- Beispielarrays erzeugen -----------------------%n%n\" ); MyArrays3 m3 = new MyArrays3 (); int [] a1 = m3 . createAndFill ( 20 ); m3 . printArray ( a1 ); m3 . bubblesort ( a1 ); m3 . printArray ( a1 ); } } MyArrays3.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package vorlesungen.vorlesung0111 ; import java.util.Random ; public class MyArrays3 { public void printArray ( int [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public int [] createAndFill ( int length ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int index = 0 ; index < a . length ; index ++ ) { a [ index ] = r . nextInt ( length ) + 1 ; } return a ; } public void bubblesort ( int [] a ) { boolean swapped = true ; for ( int bubble = 0 ; bubble < a . length - 1 && swapped ; bubble ++ ) { swapped = false ; System . out . printf ( \"%n------ Bubble-Phase %2d -------%n\" , bubble ); for ( int index = 0 ; index < a . length - 1 - bubble ; index ++ ) { if ( a [ index ] > a [ index + 1 ] ) { int tmp = a [ index + 1 ] ; a [ index + 1 ] = a [ index ] ; a [ index ] = tmp ; swapped = true ; } } this . printArray ( a ); } } } Bruch.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 package vorlesungen.vorlesung0111 ; public class Bruch { private int nenner ; private int zaehler ; public Bruch ( int zaehler , int nenner ) { this . nenner = nenner ; this . zaehler = zaehler ; } public Bruch plus ( Bruch b ) { int gleichnamigerNenner = this . nenner * b . nenner ; int summeZaehler = this . zaehler * b . nenner + b . zaehler * this . nenner ; Bruch summeBruch = new Bruch ( summeZaehler , gleichnamigerNenner ); Bruch gekuerzterBruch = summeBruch . kuerzen (); return gekuerzterBruch ; } public int getNenner () { return this . nenner ; } public int getZaehler () { return this . zaehler ; } public Bruch minus ( Bruch b ) { int gleichnamigerNenner = this . nenner * b . nenner ; int differenzZaehler = this . zaehler * b . nenner - b . zaehler * this . nenner ; Bruch differenzBruch = new Bruch ( differenzZaehler , gleichnamigerNenner ); Bruch gekuerzterBruch = differenzBruch . kuerzen (); return gekuerzterBruch ; } public Bruch kuerzen () { int ggT = this . ggT ( this . zaehler , this . nenner ); this . zaehler = this . zaehler / ggT ; this . nenner = this . nenner / ggT ; // return new Bruch(this.zaehler, this.nenner); return this ; } public int ggT ( int zahl1 , int zahl2 ) { zahl1 = Math . abs ( zahl1 ); zahl2 = Math . abs ( zahl2 ); /* if(zahl1 < 0 ) { zahl1 = -zahl1; } zahl1 = (zahl1 < 0) ? -zahl1 : zahl1; if(zahl2 < 0) { zahl2 = -zahl2; } */ if ( zahl1 != 0 && zahl2 != 0 ) { while ( zahl1 != zahl2 ) { if ( zahl1 > zahl2 ) { zahl1 = zahl1 - zahl2 ; } else { zahl2 = zahl2 - zahl1 ; } } } else { zahl1 = 1 ; } return zahl1 ; } } Video zur Vorlesung Bruch und Bubblesort -- 11.01.2022 Vorlesung Suche in Arrays -- 12.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package vorlesungen.vorlesung0111 ; public class Programclass { public static void main ( String [] args ) { System . out . printf ( \"%n%n-------------- Suchen in unsortierten Arrays -----------------------%n%n\" ); int [] a2 = m3 . createAndFill ( 20 ); m3 . printArray ( a2 ); int nr = 6 ; System . out . printf ( \"%n%d in a2 ? : %b%n\" , nr , m3 . containsUnsorted ( a2 , nr )); if ( m3 . containsUnsorted ( a2 , nr )) { System . out . printf ( \"%nIndex von %d in a2 ? : %d%n\" , nr , m3 . getIndexUnsorted ( a2 , nr )); } else { System . out . println ( \"Fehlercode : \" + m3 . getIndexUnsorted ( a2 , nr )); } System . out . printf ( \"%n%n-------------- Suchen in sortierten Arrays -----------------------%n%n\" ); m3 . bubblesort ( a2 ); m3 . printArray ( a2 ); System . out . printf ( \"%n%d in a2 ? : %b%n\" , nr , m3 . containsSorted ( a2 , nr )); int [] a3 = { 10 , 12 , 15 , 16 , 23 , 25 , 29 , 34 , 38 , 41 , 43 , 46 , 49 , 52 , 55 }; m3 . printArray ( a3 ); System . out . printf ( \"%n%d in a3 ? : %b%n\" , 25 , m3 . binarySearch ( a3 , 25 )); } } MyArrays3.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 package vorlesungen.vorlesung0111 ; import java.util.Random ; public class MyArrays3 { public void printArray ( int [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public int [] createAndFill ( int length ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int index = 0 ; index < a . length ; index ++ ) { a [ index ] = r . nextInt ( length ) + 1 ; } return a ; } public void bubblesort ( int [] a ) { boolean swapped = true ; for ( int bubble = 0 ; bubble < a . length - 1 && swapped ; bubble ++ ) { swapped = false ; // System.out.printf(\"%n------ Bubble-Phase %2d -------%n\", bubble); for ( int index = 0 ; index < a . length - 1 - bubble ; index ++ ) { if ( a [ index ] > a [ index + 1 ] ) { int tmp = a [ index + 1 ] ; a [ index + 1 ] = a [ index ] ; a [ index ] = tmp ; swapped = true ; } } // this.printArray(a); } } public boolean containsUnsorted ( int [] a , int element ) { boolean found = false ; for ( int index = 0 ; index < a . length && ! found ; index ++ ) { if ( a [ index ] == element ) { found = true ; } } return found ; } public int getIndexUnsorted ( int [] a , int element ) { final int NOT_FOUND = - 1 ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ] == element ) { return index ; } } return NOT_FOUND ; } public boolean containsSorted ( int [] a , int element ) { this . bubblesort ( a ); boolean found = false ; boolean greater = false ; for ( int index = 0 ; index < a . length && ! found && ! greater ; index ++ ) { if ( a [ index ] == element ) { found = true ; } if ( a [ index ] > element ) { greater = true ; } } return found ; } public boolean binarySearch ( int [] a , int element ) { int lo = 0 ; int hi = a . length - 1 ; boolean found = false ; while ( lo <= hi && ! found ) { // suche int mid = ( lo + hi ) / 2 ; if ( a [ mid ] == element ) { found = true ; } else { if ( a [ mid ] > element ) { // wir suchen links von mid weiter hi = mid - 1 ; } else // a[mid] < element { // wir suchen rechts weiter lo = mid + 1 ; } } } return found ; } } Video zur Vorlesung Suche in Arrays -- 12.01.2022 Vorlesung Klausurvorbereitung 1 -- 18.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package vorlesungen.vorlesung0118 ; public class Programclass { public static void main ( String [] args ) { CharArrays caObj1 = new CharArrays (); char [] ca1 = caObj1 . createAndFillCharArray (); caObj1 . print ( ca1 ); if ( caObj1 . contains ( ca1 , 'b' )) { System . out . println ( \"b ist enthalten\" ); } else { System . out . println ( \"b ist nicht enthalten\" ); } } } CharArrays.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 package vorlesungen.vorlesung0118 ; import java.util.Random ; public class CharArrays { char [] alphabet ; public CharArrays () { this . alphabet = new char [ 25 ] ; } public char [] createAndFillCharArray () { final int LAENGE_ALPHABET = 26 ; final int ASCII_CODE_a = 97 ; char [] ca = new char [ LAENGE_ALPHABET - 1 ] ; Random r = new Random (); for ( int index = 0 ; index < ca . length ; index ++ ) { int anzVersuche = 1 ; char c = ( char )( r . nextInt ( LAENGE_ALPHABET ) + ASCII_CODE_a ); while ( this . contains ( ca , c )) { c = ( char )( r . nextInt ( LAENGE_ALPHABET ) + ASCII_CODE_a ); anzVersuche ++ ; } ca [ index ] = c ; System . out . println ( index + \" : \" + anzVersuche + \" Versuche\" ); } return ca ; } public void print ( char [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public void print () { System . out . print ( \"[ \" ); for ( int index = 0 ; index < this . alphabet . length - 1 ; index ++ ) { System . out . print ( this . alphabet [ index ] + \", \" ); } if ( this . alphabet . length > 0 ) { System . out . print ( this . alphabet [ this . alphabet . length - 1 ] ); } System . out . println ( \" ]\" ); } public boolean contains ( char [] caFind , char element ) { for ( int index = 0 ; index < caFind . length ; index ++ ) { if ( caFind [ index ] == element ) { return true ; } } return false ; } public boolean contains ( char element ) { for ( int index = 0 ; index < this . alphabet . length ; index ++ ) { if ( this . alphabet [ index ] == element ) { return true ; } } return false ; } } Video zur Vorlesung Klausurvorbereitung 1 -- 18.01.2022 Vorlesung Klausurvorbereitung 2 -- 19.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package vorlesungen.vorlesung0118 ; public class Programclass { public static void main ( String [] args ) { CharArrays caObj1 = new CharArrays (); System . out . printf ( \"%n%n--------- Erstellen ---------------%n%n\" ); char [] ca1 = caObj1 . createAndFillCharArray (); caObj1 . print ( ca1 ); if ( caObj1 . contains ( ca1 , 'b' )) { System . out . println ( \"b ist enthalten\" ); } else { System . out . println ( \"b ist nicht enthalten\" ); } System . out . printf ( \"%n%n--------- Sortieren ---------------%n%n\" ); caObj1 . sort ( ca1 ); caObj1 . print ( ca1 ); System . out . printf ( \"%n%n--------- Alphabet ---------------%n%n\" ); for ( int asciiValue = 97 ; asciiValue < 123 ; asciiValue ++ ) { char c = ( char ) asciiValue ; if ( ! caObj1 . contains ( ca1 , c )) { System . out . println ( c + \" fehlt!\" ); } } System . out . println ( caObj1 . getMissingLetter ( ca1 ) + \" fehlt!\" ); System . out . printf ( \"%n%n--------- FindWord ---------------%n%n\" ); caObj1 . findWord ( \"weihnachten\" ); } } CharArrays.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 package vorlesungen.vorlesung0118 ; import java.util.Random ; public class CharArrays { char [] alphabet ; public CharArrays () { this . alphabet = new char [ 25 ] ; } public char [] createAndFillCharArray () { final int LAENGE_ALPHABET = 26 ; final int ASCII_CODE_a = 97 ; char [] ca = new char [ LAENGE_ALPHABET - 1 ] ; Random r = new Random (); for ( int index = 0 ; index < ca . length ; index ++ ) { int anzVersuche = 1 ; char c = ( char )( r . nextInt ( LAENGE_ALPHABET ) + ASCII_CODE_a ); while ( this . contains ( ca , c )) { c = ( char )( r . nextInt ( LAENGE_ALPHABET ) + ASCII_CODE_a ); anzVersuche ++ ; } ca [ index ] = c ; // System.out.println(index + \" : \" + anzVersuche + \" Versuche\"); } return ca ; } public void sort ( char [] ca ) { for ( int bubble = 1 ; bubble < ca . length ; bubble ++ ) { for ( int index = 0 ; index < ca . length - bubble ; index ++ ) { if ( ca [ index ] > ca [ index + 1 ] ) { char tmp = ca [ index ] ; ca [ index ] = ca [ index + 1 ] ; ca [ index + 1 ] = tmp ; } } } } public void print ( char [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public void print () { System . out . print ( \"[ \" ); for ( int index = 0 ; index < this . alphabet . length - 1 ; index ++ ) { System . out . print ( this . alphabet [ index ] + \", \" ); } if ( this . alphabet . length > 0 ) { System . out . print ( this . alphabet [ this . alphabet . length - 1 ] ); } System . out . println ( \" ]\" ); } public boolean contains ( char [] caFind , char element ) { for ( int index = 0 ; index < caFind . length ; index ++ ) { if ( caFind [ index ] == element ) { return true ; } } return false ; } public boolean contains ( char element ) { for ( int index = 0 ; index < this . alphabet . length ; index ++ ) { if ( this . alphabet [ index ] == element ) { return true ; } } return false ; } public char getMissingLetter ( char [] a ) { this . sort ( a ); final char FEHLER = 'F' ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( index != ( a [ index ] - 97 )) { return ( char )( index + 97 ); } } /* for(int asciiValue = 97; asciiValue<123; asciiValue++) { char c = (char)asciiValue; if(!this.contains(a, c)) { return c; } } */ return FEHLER ; } public void findWord ( String word ) { String allesKlein = word . toLowerCase (); for ( int index = 0 ; index < allesKlein . length (); index ++ ) { char letter = allesKlein . charAt ( index ); System . out . print ( letter ); char [] ca = this . createAndFillCharArray (); char missingLetter = this . getMissingLetter ( ca ); int anzVersuche = 1 ; while ( missingLetter != letter ) { System . out . print ( \".\" ); ca = this . createAndFillCharArray (); missingLetter = this . getMissingLetter ( ca ); anzVersuche ++ ; } System . out . println ( missingLetter + \" (\" + anzVersuche + \")\" ); } } } Video zur Vorlesung Klausurvorbereitung 2 -- 19.01.2022 Vorlesung Klausurvorbereitung 3 -- 25.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package vorlesungen.vorlesung0125 ; public class Programclass { public static void main ( String [] args ) { MyArray m1 = new MyArray (); m1 . printArray (); m1 . equals ( m1 ); System . out . println ( m1 . getClass ()); Object o = m1 ; System . out . println ( o . getClass ()); MyArray m2 = new MyArray ( 5 ); m2 . printArray (); m2 . equals ( m1 ); m2 . insert ( 3 ); m2 . printArray (); m2 . insert ( 2 ); m2 . printArray (); m2 . insert ( 8 ); m2 . printArray (); m2 . insert ( 7 ); m2 . printArray (); m2 . insert ( 4 ); m2 . printArray (); m2 . insert ( 4 ); m2 . printArray (); int [] a1 = { 1 , 2 , 3 , 4 }; int [] a2 ; a2 = new int [] { 1 , 2 , 3 , 4 }; int i1 = 5 ; int i2 ; i2 = 5 ; System . out . println ( m1 == m2 ); // Referenzvergleich!!! } } MyArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 package vorlesungen.vorlesung0125 ; public class MyArray { private int [] a ; public MyArray () { this . a = new int [ 0 ] ; } public MyArray ( int value ) { this . a = new int [] { value }; } public int getLength () { return this . a . length ; } public void printArray () { System . out . print ( \"[ \" ); for ( int index = 0 ; index < this . a . length - 1 ; index ++ ) { System . out . print ( this . a [ index ] + \", \" ); } if ( this . a . length > 0 ) { System . out . print ( this . a [ this . a . length - 1 ] ); } System . out . println ( \" ]\" ); } public boolean contains ( int value ) { for ( int i = 0 ; i < this . a . length ; i ++ ) { if ( this . a [ i ] == value ) { return true ; } } return false ; } public boolean insert ( int newValue ) { boolean inserted = this . contains ( newValue ); if ( ! inserted ) { // angenommen: this.a = { 2, 4, 7, 9, 11 } // newValue = 8 // newA = mit Laenge 6 (1 groesser als a) int [] newA = new int [ this . a . length + 1 ] ; // jetzt kopiere ich aus this.a alle Werte, die kleiner sind als newValue in newA // newA = { 2, 4, 7, _ , _ , _ } int indexA = 0 ; int indexNewA = 0 ; while ( indexA < this . a . length && ( this . a [ indexA ] < newValue )) { newA [ indexNewA ] = this . a [ indexA ] ; indexA ++ ; indexNewA ++ ; } // wo (auf welchem Index) soll mein newValue in newA gespeichert werden??? // newA = { 2, 4, 7, 8 , _ , _ } newA [ indexNewA ] = newValue ; indexNewA ++ ; // ab jetzt ist indexNewA 1 groesser als indexA // Rest aus this.a nach newA kopieren // newA = { 2, 4, 7, 8 , 9 , 11 } while ( indexA < this . a . length ) { newA [ indexNewA ] = this . a [ indexA ] ; indexA ++ ; indexNewA ++ ; } this . a = newA ; inserted = true ; } return inserted ; } @Override public boolean equals ( Object other ) { if ( other == null ) return false ; if ( this == other ) return true ; if ( this . getClass () != other . getClass ()) return false ; // hier wissen wir, dass other vom Laufzeittyp MyClass ist MyArray otherMyArray = ( MyArray ) other ; // if(this.a.length == other.a.length) if ( this . a . length == otherMyArray . a . length ) { for ( int index = 0 ; index < this . a . length ; index ++ ) { if ( this . a [ index ] != otherMyArray . a [ index ] ) { return false ; } } return true ; } else { return false ; } } } Video zur Vorlesung Klausurvorbereitung 3 -- 25.01.2022 Vorlesung Klausurvorbereitung 4 -- 26.01.2022 Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package vorlesungen.vorlesung0126 ; public class Testklasse { public static void main ( String [] args ) { Zahlenpaar z1 = new Zahlenpaar (); Zahlenpaar z2 = new Zahlenpaar ( 4 , 3 ); System . out . println ( z1 ); System . out . println ( z2 ); while ( ! z1 . equals ( z2 )) { z2 = new Zahlenpaar (); System . out . println ( \" --> \" + z2 ); } System . out . println ( z2 ); System . out . printf ( \"%n----------- ZPArray --------%n\" ); ZPArray zpa1 = new ZPArray ( 8 ); zpa1 . print (); System . out . println (); ZPArray zpa2 = new ZPArray ( 12 ); zpa2 . print (); System . out . println (); zpa2 . sort (); zpa2 . print (); /* * < > <= >= Wertetypen * < > <= >= NICHT fuer Referenztypen * == != Wertetypen * == != auch fuer Referenztypen --> Referenzvergleich */ } } Zahlenpaar.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package vorlesungen.vorlesung0126 ; import java.util.Random ; public class Zahlenpaar { private int [] pair ; public Zahlenpaar () { this . pair = new int [ 2 ] ; Random r = new Random (); int x = r . nextInt ( 10 ) * 2 + 2 ; // 0 1 2 3 4 5 6 7 8 9 (a + b) * c = ac + bc int y = r . nextInt ( 10 ) * 2 + 2 ; this . fillArray ( x , y ); } public Zahlenpaar ( int x , int y ) { this . pair = new int [ 2 ] ; this . fillArray ( x , y ); } private void fillArray ( int x , int y ) { if ( x < y ) { this . pair [ 0 ] = x ; this . pair [ 1 ] = y ; } else { this . pair [ 0 ] = y ; this . pair [ 1 ] = x ; } } @Override public String toString () { String s = String . format ( \"(%2d,%2d)%n\" , this . pair [ 0 ] , this . pair [ 1 ] ); return s ; } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; // Zahlenpaar zp = (Zahlenpaar)o; return ( this . pair [ 0 ] == (( Zahlenpaar ) o ). pair [ 0 ] && this . pair [ 1 ] == (( Zahlenpaar ) o ). pair [ 1 ] ); } public boolean isSmaller ( Zahlenpaar zp ) { return ( this . pair [ 0 ] < zp . pair [ 0 ] ) || (( this . pair [ 0 ] == zp . pair [ 0 ] ) && ( this . pair [ 1 ] < zp . pair [ 1 ] )); } public boolean isBigger ( Zahlenpaar zp ) { // return !this.isSmaller(zp) && !this.equals(zp); return zp . isSmaller ( this ); } } ZPArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package vorlesungen.vorlesung0126 ; public class ZPArray { private Zahlenpaar [] zpa ; public ZPArray ( int length ) { this . zpa = new Zahlenpaar [ length ] ; for ( int index = 0 ; index < this . zpa . length ; index ++ ) { this . zpa [ index ] = new Zahlenpaar (); } } public void print () { for ( int i = 0 ; i < this . zpa . length ; i ++ ) { System . out . print ( this . zpa [ i ] . toString ()); } } public void sort () { for ( int bubble = 1 ; bubble <= this . zpa . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < this . zpa . length - bubble ; index ++ ) { if ( this . zpa [ index + 1 ] . isSmaller ( this . zpa [ index ] )) { Zahlenpaar tmp = this . zpa [ index ] ; this . zpa [ index ] = this . zpa [ index + 1 ] ; this . zpa [ index + 1 ] = tmp ; } } } } } Video zur Vorlesung Klausurvorbereitung 4 -- 26.01.2022 Video zur \u00dcbung Klausurvorbereitung 5 -- 26.01.2022 Vorlesung Klausurvorbereitung 6 -- 01.02.2022 neuer Konstruktor in ZPArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public ZPArray ( int length ) { this . zpa = new Zahlenpaar [ length ] ; for ( int index = 0 ; index < this . zpa . length ; index ++ ) { Random r = new Random (); int x = r . nextInt ( length ); int y = r . nextInt ( length ); Zahlenpaar zp = new Zahlenpaar ( x , y ); while ( this . contains ( zp )) { x = r . nextInt ( length ); y = r . nextInt ( length ); zp = new Zahlenpaar ( x , y ); } this . zpa [ index ] = zp ; } } public boolean contains ( Zahlenpaar zp ) { for ( int index = 0 ; index < this . zpa . length ; index ++ ) { if ( this . zpa [ index ] != null && this . zpa [ index ] . equals ( zp )) { return true ; } } return false ; } equals()-Methode in Uhrzeit.java 1 2 3 4 5 6 7 8 9 10 @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( this . getClass () != o . getClass ()) return false ; Uhrzeit uo = ( Uhrzeit ) o ; return uo . stunden == this . stunden && uo . minuten == this . minuten && uo . sekunden == this . sekunden ; } Video zur Vorlesung Klausurvorbereitung 6 -- 01.02.2022","title":"Home"},{"location":"#programmieren-i","text":"Herzlich willkommen zur Programmieren I Veranstaltung! Wir werden unter Verwendung der Programmiersprache Java die wesentlichen Konzepte lernen, die f\u00fcr das Verst\u00e4ndnis modernen Programmierens notwendig sind. Es sind keinerlei Vorkenntnisse erforderlich. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung! Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren! Sie m\u00fcssen es tun . Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler! Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df!","title":"Programmieren I"},{"location":"#organisatorisches","text":"Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in der Vorlesung vorgestellt und in diesem Skript beschrieben. Es ist geplant, die neuen Themen stets vorab in diesem Skript hier zu ver\u00f6ffentlichen. Sie k\u00f6nnen sich also bereits vorab mit dem jeweiligen neuen Thema besch\u00e4ftigen. Zusammen mit dem Skript (das neue Thema) werden sowohl die dazugeh\u00f6rige \u00dcbung als auch die dazugeh\u00f6rige Aufgabe hochgeladen. Die beiden \u00dcbungen am Mittwoch sind jeweils gleich (d.h. dort werden die gleichen \u00dcbungsaufgaben gel\u00f6st). Die \u00dcbungen behandeln den Stoff, der am Mittwoch in der Vorwoche und am Dienstag in der gleichen Woche besprochen wird. Das bedeutet: das neue Thema wird am Mittwoch und am darauffolgenden Dienstag in der Vorlesung vermittelt und an dem Mittwoch darauf in der \u00dcbung angewendet. Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Sie k\u00f6nnen auch beliebig w\u00f6chentlich wechseln. Es wird ein Tutorium angeboten (Termin wird noch bekanntgegeben). Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu. Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie die Aufgaben (Hausaufgaben) l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 12 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr \"Programmieren 1\". Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht meistens jeweils einem Wochenthema. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, dass Sie sich diese gegenseitig beantworten. Damit w\u00e4re allen geholfen und wir k\u00f6nnen besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Bei Bedarf beantworten die Lehrenden die Fragen nat\u00fcrlich. Es wird ein Programmier-Tutorium angeboten. Dieses findet montags um 16:00 Uhr in C 639 statt - Start ist am 25.10.2021. Unsere Tutorin ist Lisanne Delfs .","title":"Organisatorisches"},{"location":"#planung","text":"Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Woche Themen (Vorlesung) Aufgabe Abgabe Aufgabe bis 1. 11.-15.10.2021 Einf\u00fchrung und Organisatorisches , Klassen und Objekte - BlueJ - - 2. 18.-22.10.2021 Variablen und Datentypen und Operatoren und Ausdr\u00fccke Aufgabe 1 25.10.2021 3. 25.-29.10.2021 Methoden Aufgabe 2 01.11.2021 4. 01.-05.11.2021 Selektion ( if ) und Iteration ( for ) Aufgabe 3 08.11.2021 5. 08.-12.11.2021 Iteration (while) Aufgabe 4 15.11.2021 6. 15.-19.11.2021 Klassen und Objekte Aufgabe 5 22.11.2021 7. 22.-26.11.2021 Konstruktoren, this, eigene Datentypen, R\u00fcckgabe von Objekten Aufgabe 6 29.11.2021 8. 29.-03.12.2021 Eigene Datentypen in Datentypen verwenden Aufgabe 7 06.12.2021 9. 06.-10.12.2021 Vererbung , Object und Polymorphie Aufgabe 8 13.12.2021 10. 13.-17.12.2021 Arrays Aufgabe 9 03.01.2022 11. 20.-24.12.2021 Algorithmen \u00fcber Arrays Aufgabe 10 10.01.2022 12. 03.-07.01.2022 Sortieren von Arrays Aufgabe 11 17.01.2022 13. 10.-14.01.2022 Suchen in Arrays Aufgabe 12 24.01.2022 14. 17.-21.01.2022 Wiederholung, Klausurvorbereitung - - 15. 24.-28.01.2022 Wiederholung, Klausurvorbereitung - - 16. 02.02.2022 14:00 Uhr Klausur - -","title":"Planung"},{"location":"#code-und-videos-aus-der-vorlesung","text":"Vorlesung Variablen -- 19. und 20.10.2021 Variablen.java public class Variablen { // instance variables - replace the example below with your own private int x ; public Variablen () { // initialise instance variables x = 5 ; } public void printObjectState () { System . out . println ( \"endlich programmieren!\" ); System . out . println (); System . out . println ( x ); System . out . println (); System . out . println ( \"endlich programmieren!\" ); System . out . println (); System . out . println ( x ); System . out . println (); int intVariable = 123 ; System . out . println ( intVariable ); intVariable = 5 ; System . out . println ( intVariable ); intVariable = - 1234566 ; System . out . println ( intVariable ); long longVariable = 123456 ; System . out . println ( longVariable ); double doubleVariable ; doubleVariable = 1555.0507897865437654321872 ; System . out . println ( doubleVariable ); double doubleVariable1 ; doubleVariable1 = 15.0507897865437654321872 ; System . out . println ( doubleVariable1 ); float floatVariable ; floatVariable = 0.3f ; char charVariable = 'a' ; System . out . println ( charVariable ); charVariable = 65 ; System . out . println ( charVariable ); charVariable = '\\u00A9' ; System . out . println ( charVariable ); charVariable = '\u00a9' ; System . out . println ( charVariable ); charVariable = 12337 ; System . out . println ( charVariable ); int a = 4 ; int b = 7 ; int summe = a + b ; // 11 int produkt = a * b ; System . out . println ( \"Postfix und Prefix\" ); int a1 = 5 ; System . out . println ( a1 ); a1 ++ ; System . out . println ( a1 ); ++ a1 ; System . out . println ( a1 ); int b1 = a1 ; System . out . println ( b1 ); b1 = a1 ++ ; System . out . println ( b1 ); b1 = ++ a1 ; System . out . println ( b1 ); a1 = 7 ; b1 = 8 ; int c1 = 9 ; boolean result = ( true ^ true ); System . out . println ( result ); String s1 = \"Informatik \" ; String s2 = \"und \" ; String s3 = \"Wirtschaft!\" ; String s4 = s1 + s2 + s3 ; System . out . println ( s1 + s2 + s3 ); int nr1 = 7 ; int nr2 = 4 ; System . out . println ( nr1 + \" + \" + nr2 + \" = \" + ( nr1 + nr2 )); } } Vorlesung Methoden -- 26. und 27.10.2021 Methods.java public class Methods { public Methods () { } public void printSum ( int nr1 , int nr2 ) { System . out . println ( nr1 + \" + \" + nr2 + \" = \" + computeSum ( nr1 , nr2 )); } public int computeSum ( int nr1 , int nr2 ) { int sum = nr1 + nr2 ; return sum ; } public boolean isEven ( int number ) { boolean isEven = (( number % 2 ) == 0 ); return isEven ; } public void start () { System . out . println ( \"Heute Methoden!\" ); printSum ( 3 , 4 ); printSum ( - 7 , 6 ); int sum = computeSum ( computeSum ( 1 , 2 ), 4 ) + computeSum ( - 7 , 6 ); System . out . println ( sum ); } } Vorlesung Selektion if und Iteration for -- 2. und 3.11.2021 SelektionIteration.java public class SelektionIteration { public SelektionIteration () { } public boolean isEven ( int number ) { return ( number % 2 == 0 ); } public void printSumFrom1ToN ( int n ) { int sum = 0 ; String term = \"0\" ; for ( int summand = 1 ; summand <= n ; summand ++ ) { term = term + \" + \" + summand ; sum = sum + summand ; System . out . println ( term + \" = \" + sum ); } } public int computeSumFrom1ToN ( int n ) { int sum = 0 ; for ( int summand = 1 ; summand <= n ; summand ++ ) { sum += summand ; } return sum ; } public void printSomething ( int height , int width ) { for ( int row = height ; row > 0 ; row -- ) { // String output = \"row = \" + row + \" : \"; for ( int col = 0 ; col < row ; col ++ ) { // output += \" col=\" + col; System . out . print ( \"*\" ); } System . out . println (); } } public boolean isOdd ( int number ) { return ! isEven ( number ); } public void start () { boolean result = isEven ( 4 ); int number = 7 ; int a = 3 ; int b = 2 ; if ( isOdd ( number )) { System . out . println ( number + \" ist ungerade\" ); } else { System . out . println ( number + \" ist gerade\" ); } System . out . println ( result ); int i = 0 ; for ( i = 0 ; i > 10 ; i = i + 1 ) { System . out . println ( \"Wert von i \" + ( i + 1 ) ); } System . out . println ( \"Ende der Schleife. Wert von i \" + i ); printSumFrom1ToN ( 7 ); printSomething ( 5 , 4 ); } } Vorlesung Iteration while -- 9.11.2021 IterationWhile.java public class IterationWhile { public IterationWhile () { } public void printCollatz ( int start ) { int number = start ; while ( number > 1 ) { System . out . print ( number + \" \" ); if ( number % 2 == 0 ) { number = number / 2 ; } else { number = 3 * number + 1 ; } } } public void printGGT ( int a , int b ) { int number1 = a ; int number2 = b ; while ( number1 != number2 ) { if ( number1 > number2 ) { number1 = number1 - number2 ; } else { number2 = number2 - number1 ; } } System . out . println ( \"ggT von \" + a + \" und \" + b + \" ist \" + number1 ); } public void start () { printGGT ( 40 , 24 ); printCollatz ( 7 ); } } Vorlesung Schleifen -- 10.11.2021 public class Loops { public Loops () { } public void collatz ( int start ) { int count = 0 ; int number = start ; while ( number > 1 ) { System . out . print ( number + \" \" ); count ++ ; number = successor ( number ); } count ++ ; System . out . println ( number + \" --> \" + count + \" Zahlen\" ); } public int successor ( int nr1 ) { int successor = 0 ; if ( isEven ( nr1 )) { successor = nr1 / 2 ; } else { successor = 3 * nr1 + 1 ; } return successor ; } public boolean isEven ( int nr ) { return ( nr % 2 == 0 ); } public void start () { collatz ( 7 ); } } Vorlesung Klassen und Objekte -- 16.11.2021 Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Adresse { public String street ; public int number ; public int zipcode ; public String city ; public String country ; public String getAddress () { return street + \" \" + number + \" \" + zipcode + \" \" + city ; } public void printAddress () { System . out . println ( getAddress ()); } } AdresseTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; /** * The test class AdresseTest. * * @author (your name) * @version (a version number or a date) */ public class AdresseTest { /** * Default constructor for test class AdresseTest */ public AdresseTest () { } /** * Sets up the test fixture. * * Called before every test case method. */ @BeforeEach public void setUp () { } @Test public void testAdresse () { Adresse adresse1 = new Adresse (); adresse1 . street = \"Wilhelminnenhofstr.\" ; adresse1 . number = 75 ; adresse1 . zipcode = 12459 ; adresse1 . city = \"Berlin\" ; adresse1 . printAddress (); System . out . println ( adresse1 . getAddress ()); Adresse adresse2 = new Adresse (); adresse2 . street = \"Treskowallee\" ; adresse2 . number = 8 ; adresse2 . zipcode = 10318 ; adresse2 . city = \"Berlin\" ; adresse2 . printAddress (); System . out . println ( adresse2 . getAddress ()); } /** * Tears down the test fixture. * * Called after every test case method. */ @AfterEach public void tearDown () { } } Video zur Vorlesung Klassen und Objekte -- 16.11.2021 Vorlesung Klassen und Objekte -- 17.11.2021 Adress.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Address { private String street ; private int number ; private int zipcode ; private String city ; public Address ( String pStreet , int pNumber , int pZipcode , String pCity ) { street = pStreet ; number = pNumber ; zipcode = pZipcode ; city = pCity ; } public void renameStreet ( String newStreetName ) { street = newStreetName ; } public String getAddress () { return street + \" \" + number + \"\\n\" + zipcode + \" \" + city ; } public void printAddress () { System . out . println ( getAddress ()); } } AdressTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; /** * The test class AddressTest. * * @author (your name) * @version (a version number or a date) */ public class AddressTest { /** * Default constructor for test class AddressTest */ public AddressTest () { } /** * Sets up the test fixture. * * Called before every test case method. */ @BeforeEach public void setUp () { } @Test public void testAddress () { Address htwWilh = new Address ( \"Alte Strasse\" , 75 , 1249 , \"Berlin\" ); htwWilh . printAddress (); Address htwTres = new Address ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); htwTres . printAddress (); htwTres . renameStreet ( \"Neue Strasse\" ); htwTres . printAddress (); } /** * Tears down the test fixture. * * Called after every test case method. */ @AfterEach public void tearDown () { } } Video zur Vorlesung Klassen und Objekte -- 17.11.2021 Vorlesung Point und this -- 23.11.2021 Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Point { // Objektvariablen private int x ; private int y ; // Konstruktor public Point ( int x , int y ) { this . x = x ; this . y = y ; } public void print () { System . out . println ( \"[ x=\" + this . x + \", y=\" + this . y + \"]\" ); } public int getX () { return this . x ; } public int getY () { return this . y ; } public void translate ( int deltaX , int deltaY ) { this . x = this . x + deltaX ; this . y = this . y + deltaY ; } public boolean isLeft ( Point p ) { return ( this . x < p . x ); } public boolean isAbove ( Point p ) { return ( this . y > p . y ); } } Programmklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Programmklasse { public void testPoint () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 1 , 2 ); Point p3 = new Point ( - 3 , 6 ); p1 . print (); p2 . print (); p3 . print (); System . out . println ( \"p1 : (\" + p1 . getX () + \", \" + p1 . getY () + \")\" ); System . out . println ( \"p2 : (\" + p2 . getX () + \", \" + p2 . getY () + \")\" ); System . out . println ( \"p3 : (\" + p3 . getX () + \", \" + p3 . getY () + \")\" ); p1 . translate ( 1 , 2 ); System . out . println ( \"p1 : (\" + p1 . getX () + \", \" + p1 . getY () + \")\" ); p1 . print (); p1 . translate ( - 2 , - 4 ); p1 . print (); System . out . println ( \"p1 links von p2 ? \" + p1 . isLeft ( p2 ) ); System . out . println ( \"p2 links von p1 ? \" + p2 . isLeft ( p1 ) ); } } Video zur Vorlesung Point und this -- 23.11.2021 Vorlesung Circle -- 24.11.2021 Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Circle { private double radius ; public Circle ( double radius1 ) { this . radius = radius1 ; } public double getRadius () { return this . radius ; } public double getDiameter () { return 2.0 * this . radius ; } public boolean isSmaller ( Circle otherCircle ) { return this . radius < otherCircle . radius ; } public void print () { System . out . println ( \"Radius : \" + this . radius ); System . out . println ( \"Durchmesser : \" + this . getDiameter () ); } } Programmklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Programmklasse { public void testCircle () { Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 4.0 ); Circle c3 = c1 ; System . out . println ( c1 . getRadius ()); System . out . println ( c2 . getRadius ()); c1 . print (); c2 . print (); c3 . print (); System . out . println ( \"c1 kleiner c2 ? \" + c1 . isSmaller ( c2 )); System . out . println ( \"c2 kleiner c1 ? \" + c2 . isSmaller ( c1 )); } } Video zur Vorlesung Circle -- 24.11.2021 Vorlesung Person, Address, Circle -- 30.11.2021 Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class Circle { private double radius ; public Circle ( double radius ) { this . radius = radius ; } public Circle () { this . radius = 1.0 ; } public double getRadius () { return this . radius ; } public double getDiameter () { return 2.0 * this . radius ; } public double area () { return Math . PI * this . radius * this . radius ; } public boolean isSmaller ( Circle otherCircle ) { return this . radius < otherCircle . radius ; } public void print () { System . out . println ( \"Radius : \" + this . radius ); System . out . println ( \"Durchmesser : \" + this . getDiameter () ); System . out . println ( \"Flaecheninhalt : \" + this . area () ); System . out . println (); } } Address.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Address { private String street ; private int number ; private int zipcode ; private String city ; public Address ( String street , int number , int zipcode , String city ) { this . street = street ; this . number = number ; this . zipcode = zipcode ; this . city = city ; } public void renameStreet ( String newStreetName ) { this . street = newStreetName ; } public String getAddressAsString () { return this . street + \" \" + this . number + \"\\n\" + this . zipcode + \" \" + this . city ; } public void printAddress () { System . out . println ( this . getAddressAsString () ); } } Person.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Person { private String name ; private String forename ; private Address address ; public Person ( String name , String forename , Address address ) { this . name = name ; this . forename = forename ; this . address = address ; } public Address getAddress () { return this . address ; } public void print () { System . out . println ( this . forename + \" \" + this . name ); //this.address.printAddress(); System . out . println ( this . address . getAddressAsString ()); System . out . println (); } } Programmklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 public class Programmklasse { public void testCircle () { Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 4.0 ); Circle c3 = c1 ; Circle c4 = new Circle (); Circle c5 = new Circle ( 6 ); System . out . println ( c1 . getRadius ()); System . out . println ( c2 . getRadius ()); c1 . print (); c2 . print (); c3 . print (); c4 . print (); c5 . print (); System . out . println ( \"c1 kleiner c2 ? \" + c1 . isSmaller ( c2 )); System . out . println ( \"c2 kleiner c1 ? \" + c2 . isSmaller ( c1 )); } public void testPoint () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 1 , 2 ); Point p3 = new Point ( - 3 , 6 ); p1 . print (); p2 . print (); p3 . print (); System . out . println ( \"p1 : (\" + p1 . getX () + \", \" + p1 . getY () + \")\" ); System . out . println ( \"p2 : (\" + p2 . getX () + \", \" + p2 . getY () + \")\" ); System . out . println ( \"p3 : (\" + p3 . getX () + \", \" + p3 . getY () + \")\" ); p1 . translate ( 1 , 2 ); System . out . println ( \"p1 : (\" + p1 . getX () + \", \" + p1 . getY () + \")\" ); p1 . print (); p1 . translate ( - 2 , - 4 ); p1 . print (); System . out . println ( \"p1 links von p2 ? \" + p1 . isLeft ( p2 ) ); System . out . println ( \"p2 links von p1 ? \" + p2 . isLeft ( p1 ) ); } public void testAddress () { Address htwTA = new Address ( \"Treskowallee\" , 8 , 10431 , \"Berlin\" ); Address htwWH = new Address ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); htwTA . printAddress (); htwWH . printAddress (); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , htwTA ); maria . print (); Person max = new Person ( \"Mustermann\" , \"Max\" , new Address ( \"Musterstr.\" , 4 , 11111 , \"Berlin\" )); max . print (); htwTA . renameStreet ( \"Neue Str.\" ); htwTA . printAddress (); //maria.address.renameStreet(\"Teststr.\"); Address mariasAddress = maria . getAddress (); String mariasAddressAsString = mariasAddress . getAddressAsString (); // System.out.println( maria.getAddress().getAddressAsString() ); System . out . println ( mariasAddressAsString ); maria . getAddress (). renameStreet ( \"Teststr. \" ); htwTA . printAddress (); } } Video zur Vorlesung Person, Address, Circle -- 30.11.2021 Vorlesung Methodenstack -- 1.12.2021 Methodenstack.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Methodenstack { public void a ( int vaa ) { int vab = 1 ; System . out . println ( \"+--a() --> vaa = \" + vaa + \" vab = \" + vab ); b ( vaa , vab ); } public void b ( int vba , int vbb ) { System . out . println ( \"+----b() --> vba = \" + vba + \" vbb = \" + vbb ); System . out . println (); } public void start () { for ( int va = 0 ; va < 3 ; va ++ ) { System . out . println ( \"start() --> va = \" + va ); a ( va ); } } } Programclass.java 1 2 3 4 5 6 7 8 public class Programclass { public void main () { Methodenstack ms = new Methodenstack (); ms . start (); } } Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Point { // Objektvariablen private int x ; private int y ; // Konstruktor public Point ( int x , int y ) { this . x = x ; this . y = y ; } public void print () { System . out . println ( \"[ x=\" + this . x + \", y=\" + this . y + \"]\" ); } public int getX () { return this . x ; } public int getY () { return this . y ; } public void translate ( int deltaX , int deltaY ) { this . x = this . x + deltaX ; this . y = this . y + deltaY ; } public boolean isLeft ( Point p ) { return ( this . x < p . x ); } public boolean isAbove ( Point p ) { return ( this . y > p . y ); } } UsePoint.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class UsePoint { public UsePoint () { } public void doSomething ( Point p ) { p . translate ( 2 , 2 ); } public void doSomething ( int a ) { a = 6 ; } public void main () { Point p1 = new Point ( 3 , 4 ); p1 . print (); doSomething ( p1 ); p1 . print (); int a = 5 ; System . out . println ( \"a = \" + a ); doSomething ( a ); System . out . println ( \"a = \" + a ); } } Video zur Vorlesung Methodenstack -- 1.12.2021 Vorlesung Vererbung -- 7.12.2021 Viereck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Viereck { protected int a , b , c , d ; // Seiten des Vierecks public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; // System.out.println(\"Objekt von Viereck erzeugt\"); } public int umfang () { return this . a + this . b + this . c + this . d ; } public String toString () { String s = String . format ( \"[ a=%d, b=%d, c=%d, d=%d ], Umfang des Vierecks : %d %n\" , this . a , this . b , this . c , this . d , this . umfang ()); return s ; } public void print () { System . out . println ( this . toString () ); } } Rechteck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Rechteck extends Viereck // Rechteck erbt von Viereck { // es werden alle Objekteigenschaften der Klasse Viereck geerbt // a, b, c, d, umfang(), toString(), print() public Rechteck ( int laenge , int breite ) { super ( laenge , breite , laenge , breite ); // Aufruf des Konstruktors von Viereck // System.out.println(\"Objekt von Rechteck erzeugt\"); } public int flaecheninhalt () { return this . a * this . b ; } @Override public String toString () { String s = String . format ( \"[ laenge=%d, breite=%d ], Umfang des Rechtecks : %d und Flaecheninhalt : %d %n\" , this . a , this . b , this . umfang (), this . flaecheninhalt ()); return s ; } } Quadrat.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Quadrat extends Rechteck // Quadrat erbt von Rechteck { // es werden alle Objekteigenschaften der Klasse Rechteck geerbt // a, b, c, d, umfang(), toString() (neu), print(), flaecheninhalt() public Quadrat ( int seite ) { super ( seite , seite ); // Aufruf des Konstruktors von Rechteck } @Override public String toString () { String s = String . format ( \"[ seitenlaenge=%d ], Umfang des Quadrats : %d und Flaecheninhalt : %d %n\" , this . a , this . umfang (), this . flaecheninhalt ()); return s ; } } Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Programclass { public void main () { Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 11 , 22 , 33 , 44 ); v2 . print (); // System.out.println(\"Flaecheninhalt des Vierecks : \" + v2.flaecheninhalt()); // Error! Rechteck r1 = new Rechteck ( 15 , 25 ); r1 . print (); System . out . println ( \"Flaecheninhalt des Rechtecks : \" + r1 . flaecheninhalt ()); Quadrat q1 = new Quadrat ( 15 ); q1 . print (); } } ProgramclassTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; public class ProgramclassTest { public ProgramclassTest () { } @Test public void testMain () { Programclass pc = new Programclass (); pc . main (); } } Video zur Vorlesung Vererbung -- 7.12.2021 Vorlesung Object -- 8.12.2021 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 public class Programclass { public void main () { Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); Viereck v2 = new Viereck ( 11 , 22 , 33 , 44 ); Rechteck r1 = new Rechteck ( 15 , 25 ); Quadrat q1 = new Quadrat ( 15 ); /* v1.print(); v2.print(); r1.print(); q1.print(); */ System . out . println ( v1 . toString ()); System . out . println ( r1 . toString ()); System . out . println ( q1 . toString ()); System . out . println ( v1 . getClass ()); System . out . println ( r1 . getClass ()); System . out . println ( q1 . getClass ()); Viereck vn1 = new Viereck ( 11 , 22 , 33 , 44 ); Viereck vn2 = new Rechteck ( 23 , 34 ); Viereck vn3 = new Quadrat ( 7 ); Rechteck rn1 = ( Rechteck ) vn2 ; // vn2 = new Viereck(1, 2, 3, 4); System . out . println ((( Rechteck ) vn2 ). flaecheninhalt ()); System . out . println ( vn2 . getClass ()); Object o1 = new Quadrat ( 1 ); if ( vn2 instanceof Rechteck ) { System . out . println ( \"bin Rechteck\" ); } if ( vn2 instanceof Viereck ) { System . out . println ( \"bin Viereck\" ); } if ( vn2 instanceof Quadrat ) { System . out . println ( \"bin Quadrat\" ); } System . out . printf ( \"%n%n----------- toString() -----%n%n\" ); System . out . println ( vn1 . toString ()); System . out . println ( vn2 . toString ()); System . out . println ( vn3 . toString ()); System . out . printf ( \"%n%n----------- vn1, n2, vn3 -----%n%n\" ); System . out . println ( vn1 ); System . out . println ( vn2 ); System . out . println ( vn3 ); } } Video zur Vorlesung Object -- 8.12.2021 Teil1 (bis zum Absturz :-( ) Teil2 (nach dem Absturz ;-) ) Vorlesung Object (equals())-- 14.12.2021 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class Programclass { public void main () { Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); Rechteck r1 = new Rechteck ( 15 , 25 ); Quadrat q1 = new Quadrat ( 15 ); Viereck vn1 = new Viereck ( 11 , 22 , 33 , 44 ); Viereck vn2 = new Rechteck ( 23 , 34 ); Viereck vn3 = new Quadrat ( 7 ); vn1 . umfang (); //vn2.flaecheninhalt(); Object o1 = new Viereck ( 11 , 22 , 33 , 44 ); Object o2 = new Rechteck ( 23 , 34 ); Object o3 = new Quadrat ( 7 ); // o1.umfang(); if ( vn3 instanceof Quadrat ) { // true } // if(v instanceof Object) {} // IMMER true // Polymorphie!! System . out . println ( vn1 . toString ()); System . out . println ( vn2 . toString ()); System . out . println ( vn3 . toString ()); // exakt gleich zu Zeilen 20-31 System . out . println ( vn1 ); System . out . println ( vn2 ); System . out . println ( vn3 ); Viereck v2 = new Viereck ( 10 , 20 , 30 , 40 ); Viereck v3 = v1 ; v1 . equals ( v1 ); v1 . equals ( v3 ); Viereck v4 ; // \"Wert\" von v4 ist null // v4.equals(v1) // null.equals() System . out . println ( \"v1 gleich v2 ? \" + ( v1 == v2 )); // Referenzvergleich!!! System . out . println ( \"v1 gleich v3 ? \" + ( v1 == v3 )); // Referenzvergleich!!! System . out . println ( \"v1 gleich v2 ? \" + ( v1 . equals ( v2 ))); // Objektvergleich!!! System . out . println ( \"v1 gleich v3 ? \" + ( v1 . equals ( v3 ))); // Objektvergleich!!! } } Viereck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class Viereck { protected int a , b , c , d ; // Seiten des Vierecks public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; // System.out.println(\"Objekt von Viereck erzeugt\"); } public int umfang () { return this . a + this . b + this . c + this . d ; } @Override public String toString () { String s = String . format ( \"[ a=%d, b=%d, c=%d, d=%d ], Umfang des Vierecks : %d %n\" , this . a , this . b , this . c , this . d , this . umfang ()); return s ; } public void print () { System . out . println ( this . toString () ); } @Override public boolean equals ( Object other ) { if ( this == null ) return false ; if ( this == other ) return true ; if ( other . getClass () != this . getClass ()) return false ; Viereck otherV = ( Viereck ) other ; return ( this . a == otherV . a && this . b == otherV . b && this . c == otherV . c && this . d == otherV . d ); } } Video zur Vorlesung Object (equals())-- 14.12.2021 Vorlesung Arrays -- 15.12.2021 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 public class Programclass { public void main () { System . out . printf ( \"-------- Arrays ---------%n\" ); int number1 = 0 ; int number2 = 1 ; int number3 = 4 ; int number4 = 9 ; int number5 = 16 ; int [] numbers = new int [ 25 ] ; /* numbers[0] = 0; numbers[1] = 1; numbers[2] = 4; numbers[3] = 9; numbers[4] = 16; */ for ( int index = 0 ; index < numbers . length ; index ++ ) { numbers [ index ] = ( index * index ); } // numbers[5] = 25; // ArrayIndexOutBoundsException! Viereck v1 = new Viereck ( 2 , 3 , 4 , 5 ); v1 . print (); Viereck [] vierecke = new Viereck [ 3 ] ; vierecke [ 0 ] = new Viereck ( 10 , 20 , 30 , 40 ); vierecke [ 0 ] . print (); vierecke [ 1 ] = new Rechteck ( 11 , 22 ); vierecke [ 1 ] . print (); vierecke [ 2 ] = new Quadrat ( 15 ); vierecke [ 2 ] . print (); String [] satz1 = new String [ 4 ] ; satz1 [ 0 ] = \"Das\" ; satz1 [ 1 ] = \"ist\" ; satz1 [ 2 ] = \"ein\" ; satz1 [ 3 ] = \"Satz\" ; String [] satz2 = { \"Das\" , \"ist\" , \"ein\" , \"Satz\" }; System . out . printf ( \"-------- Ausgabe von Arrays ---------%n\" ); for ( int index = 0 ; index < numbers . length ; index ++ ) { System . out . printf ( \"%d \" , numbers [ index ] ); } System . out . println (); for ( int i = 0 ; i < satz1 . length - 1 ; i ++ ) { System . out . print ( satz1 [ i ] + \" \" ); } System . out . println ( satz1 [ satz1 . length - 1 ] + \".\" ); int [] randomnumbers = new int [ 20 ] ; Random r = new Random (); for ( int index = 0 ; index < randomnumbers . length ; index ++ ) { randomnumbers [ index ] = r . nextInt ( 199 ) - 99 ; } for ( int index = 0 ; index < randomnumbers . length ; index ++ ) { System . out . printf ( \"%d \" , randomnumbers [ index ] ); } System . out . println (); } } Video zur Vorlesung Arrays -- 15.12.2021 Vorlesung Eclipse + Arrays -- 21.12.2021 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package vorlesungen.vorlesung1221 ; public class Programclass { public static void main ( String [] args ) { System . out . println ( \"Endlich Eclipse!\" ); System . out . println (); char [] alphabet = new char [ 26 ] ; alphabet [ 0 ] = 'A' ; System . out . println ( \"Laenge des Arrays: \" + alphabet . length ); System . out . println ( \"erstes Element : \" + alphabet [ 0 ] ); alphabet [ 1 ] = 66 ; System . out . println ( \"zweites Element : \" + alphabet [ 1 ] ); // alphabet befuellen for ( int index = 0 ; index < alphabet . length ; index ++ ) { alphabet [ index ] = ( char )( index + 65 ); } // alphabet ausgeben for ( int index = 0 ; index < alphabet . length ; index ++ ) { System . out . print ( alphabet [ index ] + \" \" ); } System . out . println (); MyArrays ma = new MyArrays (); System . out . println ( ma . arrayToString ( alphabet )); ma . printArray ( alphabet ); char [] ca1 = { 'a' , 'b' , 'c' , 'a' , 'b' , 'c' }; ma . printArray ( ca1 ); char [] ca2 = new char [ 0 ] ; // [] ma . printArray ( ca2 ); char [] ca3 = { 'a' }; ma . printArray ( ca3 ); int m = 10000 ; int n = 10000 ; for ( int x = 0 ; x < m ; x ++ ) { for ( int y = 0 ; y < n ; y ++ ) { // n * m O(n^2) System . out . println ( x * y ); // 100.000.000 Ausgaben } } } } MyArrays.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package vorlesungen.vorlesung1221 ; public class MyArrays { public String arrayToString ( char [] carr ) { // [ a, b, c, d, e, f ] // bei Laenge 0: [ ] String s = \"[ \" ; if ( carr . length == 0 ) { s = s + \"]\" ; } else { for ( int index = 0 ; index < carr . length - 1 ; index ++ ) { s = s + carr [ index ] + \", \" ; } s = s + carr [ carr . length - 1 ] + \" ]\" ; } return s ; } public String arrayToString1 ( char [] carr ) { // [ a, b, c, d, e, f ] // bei Laenge 0: [ ] String s = \"[ \" ; for ( int index = 0 ; index < carr . length ; index ++ ) { s = s + carr [ index ] ; if ( index != carr . length - 1 ) { s = s + \", \" ; } } s = s + \" ]\" ; return s ; } public void printArray ( char [] carr ) { System . out . println ( this . arrayToString1 ( carr )); } } Video zur Vorlesung Eclipse + Arrays -- 21.12.2021 Vorlesung TicTacToe -- 22.12.2021 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package vorlesungen.vorlesung1222 ; public class Programclass { public static void main ( String [] args ) { TicTacToe ttt = new TicTacToe ( 3 ); /* ttt.printField(); ttt.move(1, 0); ttt.printField(); ttt.move(1, 1); ttt.printField(); ttt.move(1, 2); ttt.printField(); ttt.move(0, 1); ttt.printField(); ttt.move(0, 1); ttt.printField(); ttt.move(2, 0); ttt.printField(); ttt.move(3, 3); ttt.printField(); ttt.move(2, 1); ttt.printField(); */ ttt . playGame (); } } TicTacToe.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 package vorlesungen.vorlesung1222 ; import java.util.Random ; /** * 3x3 Feld * 2 Spielerinnen (1, 2) * auf dem Feld: 0 --> hat noch niemand gesetzt * 1 --> Spielerin 1 * 2 --> Spielerin 2 * Ziel: 3 gleiche in einer Reihe oder Spalte oder Diagonale * * @author jornfreiheit * */ public class TicTacToe { private int [][] field ; private int player ; // 1 und 2 --> enum viel besser private int size ; public TicTacToe ( int size ) { this . size = size ; this . field = new int [ this . size ][ this . size ] ; for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { this . field [ row ][ col ] = 0 ; } } this . player = 1 ; // 1 faengt an } public void printField () { for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { if ( this . field [ row ][ col ] == 0 ) { System . out . print ( \"- \" ); } else if ( this . field [ row ][ col ] == 1 ) { System . out . print ( \"x \" ); } else if ( this . field [ row ][ col ] == 2 ) { System . out . print ( \"o \" ); } } // Ende der Zeile System . out . println (); } // nach Ausgabe des Feldes System . out . println (); } public void switchPlayer () { if ( this . player == 1 ) { this . player = 2 ; } else // this.player == 2 { this . player = 1 ; } // this.player = (this.player % 2) + 1; // geht auch } public void move ( int row , int col ) { if ( this . movePossible ( row , col )) { this . field [ row ][ col ] = this . player ; /* if(this.won()) { this.printWon(); } else { this.switchPlayer(); } */ } } public boolean movePossible ( int row , int col ) { boolean movePossible = false ; // row und col jeweils koorekter Index ??? if ( row >= 0 && row < this . size && col >= 0 && col < this . size ) { // ist das Feld ueberhaupt leer (0) ??? if ( this . field [ row ][ col ] == 0 ) { movePossible = true ; } } return movePossible ; } public boolean won () { boolean won = false ; // 3 nebeneinander ??? for ( int row = 0 ; row < this . size && ! won ; row ++ ) { if ( this . field [ row ][ 0 ] == this . player && this . field [ row ][ 1 ] == this . player && this . field [ row ][ 2 ] == this . player ) { won = true ; } } // 3 untereinander ??? for ( int col = 0 ; col < this . size && ! won ; col ++ ) { if ( this . field [ 0 ][ col ] == this . player && this . field [ 1 ][ col ] == this . player && this . field [ 2 ][ col ] == this . player ) { won = true ; } } // von links oben nach rechts unten - Diagonale if ( ! won && this . field [ 0 ][ 0 ] == this . player && this . field [ 1 ][ 1 ] == this . player && this . field [ 2 ][ 2 ] == this . player ) { won = true ; } // von rechts oben nach links unten - Diagonale if ( ! won && this . field [ 0 ][ 2 ] == this . player && this . field [ 1 ][ 1 ] == this . player && this . field [ 2 ][ 0 ] == this . player ) { won = true ; } return won ; } public void printWon () { if ( this . player == 1 ) { System . out . println ( \"Spielerin x hat gewonnen !!!\" ); } else { System . out . println ( \"Spielerin o hat gewonnen !!!\" ); } } public boolean fieldFilled () { for ( int row = 0 ; row < this . size ; row ++ ) { for ( int col = 0 ; col < this . size ; col ++ ) { if ( this . field [ row ][ col ] == 0 ) { return false ; } } } return true ; } public boolean draw () { return this . fieldFilled () && ! this . won (); } public boolean finished () { return this . draw () || this . won (); } public void automaticMove () { Random r = new Random (); int row = r . nextInt ( this . size ); int col = r . nextInt ( this . size ); while ( ! this . movePossible ( row , col )) { row = r . nextInt ( this . size ); col = r . nextInt ( this . size ); } this . move ( row , col ); } public void automaticMoveAndCheck () { this . automaticMove (); this . printField (); if ( this . finished ()) { if ( this . won ()) { this . printWon (); } else // draw { System . out . println ( \"Unentschieden !!!\" ); } } else { this . switchPlayer (); } } public void playGame () { while ( ! this . finished ()) { this . automaticMoveAndCheck (); } } } Video zur Vorlesung TicTacToe -- 22.12.2021 Vorlesung Arrays (getMaximum, areEqual) -- 04.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package vorlesungen.vorlesung0104 ; public class Programclass { public static void main ( String [] args ) { // myArray wird erzeugt und befuellt --> Objektvariable in MyArrays2 MyArrays2 ma = new MyArrays2 ( 10 ); ma . printArray (); System . out . println (); // arr1 wird erzeugt und befuellt int [] arr1 = ma . createAndFill ( 20 ); System . out . print ( \"arr1 : \" ); ma . printArray ( arr1 ); int max1 = ma . getMaximum ( arr1 ); System . out . println ( \"Maximum von arr1 ist : \" + max1 ); System . out . println (); // arr2 wird erzeugt und befuellt int [] arr2 = ma . createAndFill ( 15 ); System . out . print ( \"arr2 : \" ); ma . printArray ( arr2 ); int max2 = ma . getMaximum ( arr2 ); System . out . println ( \"Maximum von arr2 ist : \" + max2 ); System . out . println (); int [] arr3 = new int [ 0 ] ; System . out . print ( \"arr3 : \" ); ma . printArray ( arr3 ); if ( ! ma . isEmpty ( arr3 )) { int max3 = ma . getMaximum ( arr3 ); System . out . println ( \"Maximum von arr3 ist : \" + max3 ); } else { System . out . println ( \"arr3 is empty!\" ); } System . out . println (); int [] arr4 = { 8 , 2 , 4 , 3 }; System . out . print ( \"arr4 : \" ); ma . printArray ( arr4 ); int [] arr5 = { 8 , 2 , 4 , 3 }; System . out . print ( \"arr5 : \" ); ma . printArray ( arr5 ); System . out . println ( \"arr4 gleich arr5 ? \" + ma . areEqual ( arr4 , arr5 )); System . out . println (); int [] arr6 = new int [ 0 ] ; System . out . print ( \"arr6 : \" ); ma . printArray ( arr6 ); System . out . println ( \"arr6 gleich arr5 ? \" + ma . areEqual ( arr6 , arr5 )); System . out . println (); } } MyArrays2.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package vorlesungen.vorlesung0104 ; import java.util.Random ; public class MyArrays2 { int [] myArray ; public MyArrays2 ( int length ) { this . myArray = this . createAndFill ( length ); } public int [] createAndFill ( int length ) { // create int [] a = new int [ length ] ; Random r = new Random (); // fill for ( int index = 0 ; index < a . length ; index ++ ) { a [ index ] = ( r . nextInt ( length ) + 1 ); // 0 ... length-1 } return a ; } public void printArray ( int [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public void printArray () { System . out . print ( \"myArray : [ \" ); for ( int index = 0 ; index < this . myArray . length - 1 ; index ++ ) { System . out . print ( this . myArray [ index ] + \", \" ); } if ( this . myArray . length > 0 ) { System . out . print ( this . myArray [ this . myArray . length - 1 ] ); } System . out . println ( \" ]\" ); } public int getMaximum ( int [] a ) { int aktMaximum = a [ 0 ] ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ] > aktMaximum ) { aktMaximum = a [ index ] ; } } return aktMaximum ; } public boolean isEmpty ( int [] a ) { return ( a . length == 0 ); } public boolean areEqual ( int [] a , int [] b ) { if ( a . length != b . length ) { return false ; } for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ] != b [ index ] ) { return false ; } } return true ; } } Video zur Vorlesung Arrays (getMaximum, areEqual) -- 04.01.2022 Vorlesung Arrays Sortieren -- 05.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package vorlesungen.vorlesung0104 ; public class Programclass { public static void main ( String [] args ) { // myArray wird erzeugt und befuellt --> Objektvariable in MyArrays2 MyArrays2 ma = new MyArrays2 ( 10 ); ma . printArray (); System . out . println (); // arr1 wird erzeugt und befuellt int [] arr1 = ma . createAndFill ( 20 ); System . out . print ( \"arr1 : \" ); ma . printArray ( arr1 ); int max1 = ma . getMaximum ( arr1 ); System . out . println ( \"Maximum von arr1 ist : \" + max1 ); System . out . println (); // arr2 wird erzeugt und befuellt int [] arr2 = ma . createAndFill ( 15 ); System . out . print ( \"arr2 : \" ); ma . printArray ( arr2 ); int max2 = ma . getMaximum ( arr2 ); System . out . println ( \"Maximum von arr2 ist : \" + max2 ); System . out . println (); int [] arr3 = new int [ 0 ] ; System . out . print ( \"arr3 : \" ); ma . printArray ( arr3 ); if ( ! ma . isEmpty ( arr3 )) { int max3 = ma . getMaximum ( arr3 ); System . out . println ( \"Maximum von arr3 ist : \" + max3 ); } else { System . out . println ( \"arr3 is empty!\" ); } System . out . println (); int [] arr4 = { 8 , 2 , 4 , 3 }; System . out . print ( \"arr4 : \" ); ma . printArray ( arr4 ); int [] arr5 = { 8 , 2 , 4 , 3 }; System . out . print ( \"arr5 : \" ); ma . printArray ( arr5 ); System . out . println ( \"arr4 gleich arr5 ? \" + ma . areEqual ( arr4 , arr5 )); System . out . println (); int [] arr6 = new int [ 0 ] ; System . out . print ( \"arr6 : \" ); ma . printArray ( arr6 ); System . out . println ( \"arr6 gleich arr5 ? \" + ma . areEqual ( arr6 , arr5 )); System . out . println (); // ab hier 5.1.2022 int [] arr7 = ma . copy ( arr4 ); ma . printArray ( arr7 ); // Sortieren System . out . printf ( \"%n%n-------------- Sortieren ----------%n%n\" ); int [] arr8 = ma . createAndFill ( 20 ); ma . printArray ( arr8 ); int [] arr9 = ma . bubblesort ( arr8 ); ma . printArray ( arr9 ); } } MyArrays2.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 package vorlesungen.vorlesung0104 ; import java.util.Random ; public class MyArrays2 { int [] myArray ; public MyArrays2 ( int length ) { this . myArray = this . createAndFill ( length ); } public int [] createAndFill ( int length ) { // create int [] a = new int [ length ] ; Random r = new Random (); // fill for ( int index = 0 ; index < a . length ; index ++ ) { a [ index ] = ( r . nextInt ( length ) + 1 ); // 0 ... length-1 } return a ; } public void printArray ( int [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public void printArray () { System . out . print ( \"myArray : [ \" ); for ( int index = 0 ; index < this . myArray . length - 1 ; index ++ ) { System . out . print ( this . myArray [ index ] + \", \" ); } if ( this . myArray . length > 0 ) { System . out . print ( this . myArray [ this . myArray . length - 1 ] ); } System . out . println ( \" ]\" ); } public int getMaximum ( int [] a ) { int aktMaximum = a [ 0 ] ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ] > aktMaximum ) { aktMaximum = a [ index ] ; } } return aktMaximum ; } public boolean isEmpty ( int [] a ) { return ( a . length == 0 ); } public boolean areEqual ( int [] a , int [] b ) { boolean areEqual = true ; if ( a . length != b . length ) { areEqual = false ; } else { for ( int index = 0 ; index < a . length && areEqual ; index ++ ) { if ( a [ index ] != b [ index ] ) { areEqual = false ; } } } return areEqual ; } public int [] copy ( int [] original ) { int [] copy = new int [ original . length ] ; for ( int index = 0 ; index < copy . length ; index ++ ) { copy [ index ] = original [ index ] ; } return copy ; } public int [] bubblesort ( int [] a ) { int [] copy = this . copy ( a ); for ( int bubble = 0 ; bubble < copy . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < copy . length - 1 - bubble ; index ++ ) { if ( copy [ index ] > copy [ index + 1 ] ) { int tmp = copy [ index + 1 ] ; copy [ index + 1 ] = copy [ index ] ; copy [ index ] = tmp ; } } } return copy ; } } Video zur Vorlesung Arrays Sortieren -- 05.01.2022 Vorlesung Bruch und Bubblesort -- 11.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package vorlesungen.vorlesung0111 ; public class Programclass { public static void main ( String [] args ) { System . out . printf ( \"%n%n-------------- Bruch -----------------------%n%n\" ); Bruch b1 = new Bruch ( 3 , 7 ); // 12/28 Bruch b2 = new Bruch ( 3 , 4 ); // 21/28 Bruch sumB1B2 = b1 . plus ( b2 ); System . out . printf ( \"Summe: (%d/%d) %n\" , sumB1B2 . getZaehler (), sumB1B2 . getNenner ()); Bruch diffB1B2 = b1 . minus ( b2 ); System . out . printf ( \"Differenz: (%d/%d) %n\" , diffB1B2 . getZaehler (), diffB1B2 . getNenner ()); Bruch diffB1B1 = b1 . minus ( b1 ); System . out . printf ( \"Differenz: (%d/%d) %n\" , diffB1B1 . getZaehler (), diffB1B1 . getNenner ()); System . out . printf ( \"%n%n-------------- Beispielarrays erzeugen -----------------------%n%n\" ); MyArrays3 m3 = new MyArrays3 (); int [] a1 = m3 . createAndFill ( 20 ); m3 . printArray ( a1 ); m3 . bubblesort ( a1 ); m3 . printArray ( a1 ); } } MyArrays3.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package vorlesungen.vorlesung0111 ; import java.util.Random ; public class MyArrays3 { public void printArray ( int [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public int [] createAndFill ( int length ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int index = 0 ; index < a . length ; index ++ ) { a [ index ] = r . nextInt ( length ) + 1 ; } return a ; } public void bubblesort ( int [] a ) { boolean swapped = true ; for ( int bubble = 0 ; bubble < a . length - 1 && swapped ; bubble ++ ) { swapped = false ; System . out . printf ( \"%n------ Bubble-Phase %2d -------%n\" , bubble ); for ( int index = 0 ; index < a . length - 1 - bubble ; index ++ ) { if ( a [ index ] > a [ index + 1 ] ) { int tmp = a [ index + 1 ] ; a [ index + 1 ] = a [ index ] ; a [ index ] = tmp ; swapped = true ; } } this . printArray ( a ); } } } Bruch.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 package vorlesungen.vorlesung0111 ; public class Bruch { private int nenner ; private int zaehler ; public Bruch ( int zaehler , int nenner ) { this . nenner = nenner ; this . zaehler = zaehler ; } public Bruch plus ( Bruch b ) { int gleichnamigerNenner = this . nenner * b . nenner ; int summeZaehler = this . zaehler * b . nenner + b . zaehler * this . nenner ; Bruch summeBruch = new Bruch ( summeZaehler , gleichnamigerNenner ); Bruch gekuerzterBruch = summeBruch . kuerzen (); return gekuerzterBruch ; } public int getNenner () { return this . nenner ; } public int getZaehler () { return this . zaehler ; } public Bruch minus ( Bruch b ) { int gleichnamigerNenner = this . nenner * b . nenner ; int differenzZaehler = this . zaehler * b . nenner - b . zaehler * this . nenner ; Bruch differenzBruch = new Bruch ( differenzZaehler , gleichnamigerNenner ); Bruch gekuerzterBruch = differenzBruch . kuerzen (); return gekuerzterBruch ; } public Bruch kuerzen () { int ggT = this . ggT ( this . zaehler , this . nenner ); this . zaehler = this . zaehler / ggT ; this . nenner = this . nenner / ggT ; // return new Bruch(this.zaehler, this.nenner); return this ; } public int ggT ( int zahl1 , int zahl2 ) { zahl1 = Math . abs ( zahl1 ); zahl2 = Math . abs ( zahl2 ); /* if(zahl1 < 0 ) { zahl1 = -zahl1; } zahl1 = (zahl1 < 0) ? -zahl1 : zahl1; if(zahl2 < 0) { zahl2 = -zahl2; } */ if ( zahl1 != 0 && zahl2 != 0 ) { while ( zahl1 != zahl2 ) { if ( zahl1 > zahl2 ) { zahl1 = zahl1 - zahl2 ; } else { zahl2 = zahl2 - zahl1 ; } } } else { zahl1 = 1 ; } return zahl1 ; } } Video zur Vorlesung Bruch und Bubblesort -- 11.01.2022 Vorlesung Suche in Arrays -- 12.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package vorlesungen.vorlesung0111 ; public class Programclass { public static void main ( String [] args ) { System . out . printf ( \"%n%n-------------- Suchen in unsortierten Arrays -----------------------%n%n\" ); int [] a2 = m3 . createAndFill ( 20 ); m3 . printArray ( a2 ); int nr = 6 ; System . out . printf ( \"%n%d in a2 ? : %b%n\" , nr , m3 . containsUnsorted ( a2 , nr )); if ( m3 . containsUnsorted ( a2 , nr )) { System . out . printf ( \"%nIndex von %d in a2 ? : %d%n\" , nr , m3 . getIndexUnsorted ( a2 , nr )); } else { System . out . println ( \"Fehlercode : \" + m3 . getIndexUnsorted ( a2 , nr )); } System . out . printf ( \"%n%n-------------- Suchen in sortierten Arrays -----------------------%n%n\" ); m3 . bubblesort ( a2 ); m3 . printArray ( a2 ); System . out . printf ( \"%n%d in a2 ? : %b%n\" , nr , m3 . containsSorted ( a2 , nr )); int [] a3 = { 10 , 12 , 15 , 16 , 23 , 25 , 29 , 34 , 38 , 41 , 43 , 46 , 49 , 52 , 55 }; m3 . printArray ( a3 ); System . out . printf ( \"%n%d in a3 ? : %b%n\" , 25 , m3 . binarySearch ( a3 , 25 )); } } MyArrays3.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 package vorlesungen.vorlesung0111 ; import java.util.Random ; public class MyArrays3 { public void printArray ( int [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public int [] createAndFill ( int length ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int index = 0 ; index < a . length ; index ++ ) { a [ index ] = r . nextInt ( length ) + 1 ; } return a ; } public void bubblesort ( int [] a ) { boolean swapped = true ; for ( int bubble = 0 ; bubble < a . length - 1 && swapped ; bubble ++ ) { swapped = false ; // System.out.printf(\"%n------ Bubble-Phase %2d -------%n\", bubble); for ( int index = 0 ; index < a . length - 1 - bubble ; index ++ ) { if ( a [ index ] > a [ index + 1 ] ) { int tmp = a [ index + 1 ] ; a [ index + 1 ] = a [ index ] ; a [ index ] = tmp ; swapped = true ; } } // this.printArray(a); } } public boolean containsUnsorted ( int [] a , int element ) { boolean found = false ; for ( int index = 0 ; index < a . length && ! found ; index ++ ) { if ( a [ index ] == element ) { found = true ; } } return found ; } public int getIndexUnsorted ( int [] a , int element ) { final int NOT_FOUND = - 1 ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ] == element ) { return index ; } } return NOT_FOUND ; } public boolean containsSorted ( int [] a , int element ) { this . bubblesort ( a ); boolean found = false ; boolean greater = false ; for ( int index = 0 ; index < a . length && ! found && ! greater ; index ++ ) { if ( a [ index ] == element ) { found = true ; } if ( a [ index ] > element ) { greater = true ; } } return found ; } public boolean binarySearch ( int [] a , int element ) { int lo = 0 ; int hi = a . length - 1 ; boolean found = false ; while ( lo <= hi && ! found ) { // suche int mid = ( lo + hi ) / 2 ; if ( a [ mid ] == element ) { found = true ; } else { if ( a [ mid ] > element ) { // wir suchen links von mid weiter hi = mid - 1 ; } else // a[mid] < element { // wir suchen rechts weiter lo = mid + 1 ; } } } return found ; } } Video zur Vorlesung Suche in Arrays -- 12.01.2022 Vorlesung Klausurvorbereitung 1 -- 18.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package vorlesungen.vorlesung0118 ; public class Programclass { public static void main ( String [] args ) { CharArrays caObj1 = new CharArrays (); char [] ca1 = caObj1 . createAndFillCharArray (); caObj1 . print ( ca1 ); if ( caObj1 . contains ( ca1 , 'b' )) { System . out . println ( \"b ist enthalten\" ); } else { System . out . println ( \"b ist nicht enthalten\" ); } } } CharArrays.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 package vorlesungen.vorlesung0118 ; import java.util.Random ; public class CharArrays { char [] alphabet ; public CharArrays () { this . alphabet = new char [ 25 ] ; } public char [] createAndFillCharArray () { final int LAENGE_ALPHABET = 26 ; final int ASCII_CODE_a = 97 ; char [] ca = new char [ LAENGE_ALPHABET - 1 ] ; Random r = new Random (); for ( int index = 0 ; index < ca . length ; index ++ ) { int anzVersuche = 1 ; char c = ( char )( r . nextInt ( LAENGE_ALPHABET ) + ASCII_CODE_a ); while ( this . contains ( ca , c )) { c = ( char )( r . nextInt ( LAENGE_ALPHABET ) + ASCII_CODE_a ); anzVersuche ++ ; } ca [ index ] = c ; System . out . println ( index + \" : \" + anzVersuche + \" Versuche\" ); } return ca ; } public void print ( char [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public void print () { System . out . print ( \"[ \" ); for ( int index = 0 ; index < this . alphabet . length - 1 ; index ++ ) { System . out . print ( this . alphabet [ index ] + \", \" ); } if ( this . alphabet . length > 0 ) { System . out . print ( this . alphabet [ this . alphabet . length - 1 ] ); } System . out . println ( \" ]\" ); } public boolean contains ( char [] caFind , char element ) { for ( int index = 0 ; index < caFind . length ; index ++ ) { if ( caFind [ index ] == element ) { return true ; } } return false ; } public boolean contains ( char element ) { for ( int index = 0 ; index < this . alphabet . length ; index ++ ) { if ( this . alphabet [ index ] == element ) { return true ; } } return false ; } } Video zur Vorlesung Klausurvorbereitung 1 -- 18.01.2022 Vorlesung Klausurvorbereitung 2 -- 19.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package vorlesungen.vorlesung0118 ; public class Programclass { public static void main ( String [] args ) { CharArrays caObj1 = new CharArrays (); System . out . printf ( \"%n%n--------- Erstellen ---------------%n%n\" ); char [] ca1 = caObj1 . createAndFillCharArray (); caObj1 . print ( ca1 ); if ( caObj1 . contains ( ca1 , 'b' )) { System . out . println ( \"b ist enthalten\" ); } else { System . out . println ( \"b ist nicht enthalten\" ); } System . out . printf ( \"%n%n--------- Sortieren ---------------%n%n\" ); caObj1 . sort ( ca1 ); caObj1 . print ( ca1 ); System . out . printf ( \"%n%n--------- Alphabet ---------------%n%n\" ); for ( int asciiValue = 97 ; asciiValue < 123 ; asciiValue ++ ) { char c = ( char ) asciiValue ; if ( ! caObj1 . contains ( ca1 , c )) { System . out . println ( c + \" fehlt!\" ); } } System . out . println ( caObj1 . getMissingLetter ( ca1 ) + \" fehlt!\" ); System . out . printf ( \"%n%n--------- FindWord ---------------%n%n\" ); caObj1 . findWord ( \"weihnachten\" ); } } CharArrays.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 package vorlesungen.vorlesung0118 ; import java.util.Random ; public class CharArrays { char [] alphabet ; public CharArrays () { this . alphabet = new char [ 25 ] ; } public char [] createAndFillCharArray () { final int LAENGE_ALPHABET = 26 ; final int ASCII_CODE_a = 97 ; char [] ca = new char [ LAENGE_ALPHABET - 1 ] ; Random r = new Random (); for ( int index = 0 ; index < ca . length ; index ++ ) { int anzVersuche = 1 ; char c = ( char )( r . nextInt ( LAENGE_ALPHABET ) + ASCII_CODE_a ); while ( this . contains ( ca , c )) { c = ( char )( r . nextInt ( LAENGE_ALPHABET ) + ASCII_CODE_a ); anzVersuche ++ ; } ca [ index ] = c ; // System.out.println(index + \" : \" + anzVersuche + \" Versuche\"); } return ca ; } public void sort ( char [] ca ) { for ( int bubble = 1 ; bubble < ca . length ; bubble ++ ) { for ( int index = 0 ; index < ca . length - bubble ; index ++ ) { if ( ca [ index ] > ca [ index + 1 ] ) { char tmp = ca [ index ] ; ca [ index ] = ca [ index + 1 ] ; ca [ index + 1 ] = tmp ; } } } } public void print ( char [] arr ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < arr . length - 1 ; index ++ ) { System . out . print ( arr [ index ] + \", \" ); } if ( arr . length > 0 ) { System . out . print ( arr [ arr . length - 1 ] ); } System . out . println ( \" ]\" ); } public void print () { System . out . print ( \"[ \" ); for ( int index = 0 ; index < this . alphabet . length - 1 ; index ++ ) { System . out . print ( this . alphabet [ index ] + \", \" ); } if ( this . alphabet . length > 0 ) { System . out . print ( this . alphabet [ this . alphabet . length - 1 ] ); } System . out . println ( \" ]\" ); } public boolean contains ( char [] caFind , char element ) { for ( int index = 0 ; index < caFind . length ; index ++ ) { if ( caFind [ index ] == element ) { return true ; } } return false ; } public boolean contains ( char element ) { for ( int index = 0 ; index < this . alphabet . length ; index ++ ) { if ( this . alphabet [ index ] == element ) { return true ; } } return false ; } public char getMissingLetter ( char [] a ) { this . sort ( a ); final char FEHLER = 'F' ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( index != ( a [ index ] - 97 )) { return ( char )( index + 97 ); } } /* for(int asciiValue = 97; asciiValue<123; asciiValue++) { char c = (char)asciiValue; if(!this.contains(a, c)) { return c; } } */ return FEHLER ; } public void findWord ( String word ) { String allesKlein = word . toLowerCase (); for ( int index = 0 ; index < allesKlein . length (); index ++ ) { char letter = allesKlein . charAt ( index ); System . out . print ( letter ); char [] ca = this . createAndFillCharArray (); char missingLetter = this . getMissingLetter ( ca ); int anzVersuche = 1 ; while ( missingLetter != letter ) { System . out . print ( \".\" ); ca = this . createAndFillCharArray (); missingLetter = this . getMissingLetter ( ca ); anzVersuche ++ ; } System . out . println ( missingLetter + \" (\" + anzVersuche + \")\" ); } } } Video zur Vorlesung Klausurvorbereitung 2 -- 19.01.2022 Vorlesung Klausurvorbereitung 3 -- 25.01.2022 Programclass.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package vorlesungen.vorlesung0125 ; public class Programclass { public static void main ( String [] args ) { MyArray m1 = new MyArray (); m1 . printArray (); m1 . equals ( m1 ); System . out . println ( m1 . getClass ()); Object o = m1 ; System . out . println ( o . getClass ()); MyArray m2 = new MyArray ( 5 ); m2 . printArray (); m2 . equals ( m1 ); m2 . insert ( 3 ); m2 . printArray (); m2 . insert ( 2 ); m2 . printArray (); m2 . insert ( 8 ); m2 . printArray (); m2 . insert ( 7 ); m2 . printArray (); m2 . insert ( 4 ); m2 . printArray (); m2 . insert ( 4 ); m2 . printArray (); int [] a1 = { 1 , 2 , 3 , 4 }; int [] a2 ; a2 = new int [] { 1 , 2 , 3 , 4 }; int i1 = 5 ; int i2 ; i2 = 5 ; System . out . println ( m1 == m2 ); // Referenzvergleich!!! } } MyArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 package vorlesungen.vorlesung0125 ; public class MyArray { private int [] a ; public MyArray () { this . a = new int [ 0 ] ; } public MyArray ( int value ) { this . a = new int [] { value }; } public int getLength () { return this . a . length ; } public void printArray () { System . out . print ( \"[ \" ); for ( int index = 0 ; index < this . a . length - 1 ; index ++ ) { System . out . print ( this . a [ index ] + \", \" ); } if ( this . a . length > 0 ) { System . out . print ( this . a [ this . a . length - 1 ] ); } System . out . println ( \" ]\" ); } public boolean contains ( int value ) { for ( int i = 0 ; i < this . a . length ; i ++ ) { if ( this . a [ i ] == value ) { return true ; } } return false ; } public boolean insert ( int newValue ) { boolean inserted = this . contains ( newValue ); if ( ! inserted ) { // angenommen: this.a = { 2, 4, 7, 9, 11 } // newValue = 8 // newA = mit Laenge 6 (1 groesser als a) int [] newA = new int [ this . a . length + 1 ] ; // jetzt kopiere ich aus this.a alle Werte, die kleiner sind als newValue in newA // newA = { 2, 4, 7, _ , _ , _ } int indexA = 0 ; int indexNewA = 0 ; while ( indexA < this . a . length && ( this . a [ indexA ] < newValue )) { newA [ indexNewA ] = this . a [ indexA ] ; indexA ++ ; indexNewA ++ ; } // wo (auf welchem Index) soll mein newValue in newA gespeichert werden??? // newA = { 2, 4, 7, 8 , _ , _ } newA [ indexNewA ] = newValue ; indexNewA ++ ; // ab jetzt ist indexNewA 1 groesser als indexA // Rest aus this.a nach newA kopieren // newA = { 2, 4, 7, 8 , 9 , 11 } while ( indexA < this . a . length ) { newA [ indexNewA ] = this . a [ indexA ] ; indexA ++ ; indexNewA ++ ; } this . a = newA ; inserted = true ; } return inserted ; } @Override public boolean equals ( Object other ) { if ( other == null ) return false ; if ( this == other ) return true ; if ( this . getClass () != other . getClass ()) return false ; // hier wissen wir, dass other vom Laufzeittyp MyClass ist MyArray otherMyArray = ( MyArray ) other ; // if(this.a.length == other.a.length) if ( this . a . length == otherMyArray . a . length ) { for ( int index = 0 ; index < this . a . length ; index ++ ) { if ( this . a [ index ] != otherMyArray . a [ index ] ) { return false ; } } return true ; } else { return false ; } } } Video zur Vorlesung Klausurvorbereitung 3 -- 25.01.2022 Vorlesung Klausurvorbereitung 4 -- 26.01.2022 Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package vorlesungen.vorlesung0126 ; public class Testklasse { public static void main ( String [] args ) { Zahlenpaar z1 = new Zahlenpaar (); Zahlenpaar z2 = new Zahlenpaar ( 4 , 3 ); System . out . println ( z1 ); System . out . println ( z2 ); while ( ! z1 . equals ( z2 )) { z2 = new Zahlenpaar (); System . out . println ( \" --> \" + z2 ); } System . out . println ( z2 ); System . out . printf ( \"%n----------- ZPArray --------%n\" ); ZPArray zpa1 = new ZPArray ( 8 ); zpa1 . print (); System . out . println (); ZPArray zpa2 = new ZPArray ( 12 ); zpa2 . print (); System . out . println (); zpa2 . sort (); zpa2 . print (); /* * < > <= >= Wertetypen * < > <= >= NICHT fuer Referenztypen * == != Wertetypen * == != auch fuer Referenztypen --> Referenzvergleich */ } } Zahlenpaar.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package vorlesungen.vorlesung0126 ; import java.util.Random ; public class Zahlenpaar { private int [] pair ; public Zahlenpaar () { this . pair = new int [ 2 ] ; Random r = new Random (); int x = r . nextInt ( 10 ) * 2 + 2 ; // 0 1 2 3 4 5 6 7 8 9 (a + b) * c = ac + bc int y = r . nextInt ( 10 ) * 2 + 2 ; this . fillArray ( x , y ); } public Zahlenpaar ( int x , int y ) { this . pair = new int [ 2 ] ; this . fillArray ( x , y ); } private void fillArray ( int x , int y ) { if ( x < y ) { this . pair [ 0 ] = x ; this . pair [ 1 ] = y ; } else { this . pair [ 0 ] = y ; this . pair [ 1 ] = x ; } } @Override public String toString () { String s = String . format ( \"(%2d,%2d)%n\" , this . pair [ 0 ] , this . pair [ 1 ] ); return s ; } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; // Zahlenpaar zp = (Zahlenpaar)o; return ( this . pair [ 0 ] == (( Zahlenpaar ) o ). pair [ 0 ] && this . pair [ 1 ] == (( Zahlenpaar ) o ). pair [ 1 ] ); } public boolean isSmaller ( Zahlenpaar zp ) { return ( this . pair [ 0 ] < zp . pair [ 0 ] ) || (( this . pair [ 0 ] == zp . pair [ 0 ] ) && ( this . pair [ 1 ] < zp . pair [ 1 ] )); } public boolean isBigger ( Zahlenpaar zp ) { // return !this.isSmaller(zp) && !this.equals(zp); return zp . isSmaller ( this ); } } ZPArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package vorlesungen.vorlesung0126 ; public class ZPArray { private Zahlenpaar [] zpa ; public ZPArray ( int length ) { this . zpa = new Zahlenpaar [ length ] ; for ( int index = 0 ; index < this . zpa . length ; index ++ ) { this . zpa [ index ] = new Zahlenpaar (); } } public void print () { for ( int i = 0 ; i < this . zpa . length ; i ++ ) { System . out . print ( this . zpa [ i ] . toString ()); } } public void sort () { for ( int bubble = 1 ; bubble <= this . zpa . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < this . zpa . length - bubble ; index ++ ) { if ( this . zpa [ index + 1 ] . isSmaller ( this . zpa [ index ] )) { Zahlenpaar tmp = this . zpa [ index ] ; this . zpa [ index ] = this . zpa [ index + 1 ] ; this . zpa [ index + 1 ] = tmp ; } } } } } Video zur Vorlesung Klausurvorbereitung 4 -- 26.01.2022 Video zur \u00dcbung Klausurvorbereitung 5 -- 26.01.2022 Vorlesung Klausurvorbereitung 6 -- 01.02.2022 neuer Konstruktor in ZPArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public ZPArray ( int length ) { this . zpa = new Zahlenpaar [ length ] ; for ( int index = 0 ; index < this . zpa . length ; index ++ ) { Random r = new Random (); int x = r . nextInt ( length ); int y = r . nextInt ( length ); Zahlenpaar zp = new Zahlenpaar ( x , y ); while ( this . contains ( zp )) { x = r . nextInt ( length ); y = r . nextInt ( length ); zp = new Zahlenpaar ( x , y ); } this . zpa [ index ] = zp ; } } public boolean contains ( Zahlenpaar zp ) { for ( int index = 0 ; index < this . zpa . length ; index ++ ) { if ( this . zpa [ index ] != null && this . zpa [ index ] . equals ( zp )) { return true ; } } return false ; } equals()-Methode in Uhrzeit.java 1 2 3 4 5 6 7 8 9 10 @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( this . getClass () != o . getClass ()) return false ; Uhrzeit uo = ( Uhrzeit ) o ; return uo . stunden == this . stunden && uo . minuten == this . minuten && uo . sekunden == this . sekunden ; } Video zur Vorlesung Klausurvorbereitung 6 -- 01.02.2022","title":"Code (und Videos) aus der Vorlesung"},{"location":"arrays/","text":"Arrays \u00b6 In einer Variable k\u00f6nnen wir genau einen Wert speichern. Wenn wir 5 Werte speichern wollen, ben\u00f6tigen wir 5 Variablen und wenn wir 1000 Werte speichern wollen, ben\u00f6tigen wir 1000 Variablen. Das ist nat\u00fcrlich unzweckm\u00e4\u00dfig. Wenn Sie mehrere Werte gleichen Typs speichern wollen, dann verwenden Sie dazu besser Arrays ( Felder ). Arrays sind Objekte. Wir schauen uns mal ein einf\u00fchrendes Beispiel an. Angenommen, wir wollen 5 int -Werte 0 , 1 , 4 , 9 und 16 speichern. Bis jetzt ben\u00f6tigten wir dazu 5 Variablen: int number1 = 0 ; int number2 = 1 ; int number3 = 4 ; int number4 = 9 ; int number5 = 16 ; Jetzt wollen wir dazu ein Array verwenden. Die Erzeugung und Initialisierung sieht so aus: 1 2 3 4 5 6 int [] numbers = new int [ 5 ] ; // Array der Laenge 5 numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Ein Array erkennen wir an den eckigen Klammern [] . Unser Array im Beispiel ist vom Typ int , d.h. jedes Element in diesem Array ist vom Typ int . Arrays k\u00f6nnen von einem beliebigen Typ sein, sowohl Wertetypen als auch Referenztypen. Ein Array wird immer f\u00fcr genau einen Typ deklariert, bei uns int \u2192 deshalb int[] . Best\u00fcnde das Array aus lauter Strings, dann w\u00e4re der Typ String[] . In unserem Beispiel ist numbers die Referenzvariable, die auf unser Array-Objekt zeigt. Mithilfe des Schl\u00fcsselwortes new wird unser Array erzeugt. Nach new kommt nochmal das Array ( Typ[] ), aber in den eckigen Klammern steht die L\u00e4nge des Arrays. In unserem Beispiel 5 . Bei der Erzeugung des Arrays muss immer die L\u00e4nge angegeben werden. Die L\u00e4nge eines Arrays kann sich nicht \u00e4ndern. Der Zugriff auf die einzelnen Elemente erfolgt \u00fcber den Index . Jedes Array ist automatisch \"nummeriert\". Die \"Nummerierung\" (der Index) beginnt immer mit 0 und erh\u00f6ht sich f\u00fcr jedes Element um 1 . Der Index eines Arrays ist immer vom Typ int . Wir k\u00f6nnen uns unser Array numbers so vorstellen: Wir haben 5 Elemente (L\u00e4nge 5 ), die jeweils durch den Index nummeriert sind. Diese Elemente k\u00f6nnen nun Werte enthalten: Der Zugriff auf die Werte eines Arrays erfolgt dann immer unter Verwendung der Referenzvariable, dahinter eckige Klammern und in den Klammern der entsprechende Index: Referenzvariable[Index]=Wert; Also in unserem Beispiel numbers[0] . Erzeugung und Initialisierung eines Arrays \u00b6 Die Erzeugung und Initialisierung eines Arrays erfolgt in drei Schritten: Schritt: Definition einer Referenzvariablen, die auf das Array-Objekt zeigt (siehe oben in Zeile 1 : int[] numbers ) Schritt: Erzeugen des Arrays, d. h. eines Array-Objektes, das aus Elementen eines bestimmten Datentyps besteht (und Zuweisung an die zuvor definierte Referenzvariable - siehe oben Zeile 1 : new int[5] ) Schritt: Belegen der Array-Elemente mit Werten, d. h. Initialisierung des Arrays (siehe oben Zeilen 2-6 ). Beispiele verschiedene Arrays erzeugen: double [] noten = new double [ 10 ] ; // Array aus double-Elemente Laenge 10 String [] satz = new String [ 30 ] ; // Array aus Zeichenketten Laenge 30 boolean [] filled = new boolean [ 100 ] ; // Array aus boolean-Elementen Laenge 100 int [] statistics = new int [ 10000 ] ; // Array aus int-Elementen Laenge 10000 Die Initialisierung erfolgt elementweise \u00fcber den Zugriff auf den Index, z.B. (siehe oben): numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Da der Index stets vom Typ int ist, h\u00e4tten wir unser Array auch wie folgt initialisieren k\u00f6nnen: 1 2 3 4 for ( int index = 0 ; index < 5 ; index ++ ) { numbers [ index ] = ( index * index ); } Beachten Sie: Der gr\u00f6\u00dfte Index ist immer um eins kleiner als die L\u00e4nge des Arrays (L\u00e4nge ist 5 , gr\u00f6\u00dfter Index ist 4 \u2192 deshalb index < 5 ) Der Index ist immer int , egal von welchem Typ das Array ist In unserem Beispiel entsprechen die Werte der einzelnen Elementen Quadratzahlen. Deshalb konnten wir als Wert (index * index) verwenden. Die Eigenschaft length \u00b6 Jedes Array besitzt die Eigenschaft length . Dar\u00fcber k\u00f6nnen wir die L\u00e4nge des Arrays auslesen. Der Wert von length kann nicht neu gesetzt werden (ist konstant). Wir benutzen die Eigenschaft length insbesondere in den Schleifen, mit denen wir auf den Index zugreifen. Referenzvariable.length Unser obiges Initialisierungsbeispiel h\u00e4tte also besser so ausgesehen: 1 2 3 4 for ( int index = 0 ; index < numbers . length ; index ++ ) { numbers [ index ] = ( index * index ); } Ausgabe der Werte \u00b6 Den jetzt bereits bekannten Zugriff auf die einzelnen Elemente k\u00f6nnen wir auch f\u00fcr das Auslesen der Werte eines Arrays verwenden: 1 2 3 4 for ( int index = 0 ; index < numbers . length ; index ++ ) { System . out . println ( numbers [ index ] ); } Verwenden der Werte \u00b6 Wir erl\u00e4utern ein einfaches Beispiel zur Verwendung der Werte, wir bilden die Summe aller Werte \u00fcber das Array (wir gehen davon aus, dass das numbers -Array so wie oben erzeugt un initialisiert wurde): int sum = 0 ; for ( int index = 0 ; index < numbers . length ; index ++ ) { sum = sum + numbers [ index ] ; } System . out . println ( \"Summe aller Elemente : \" + sum ); M\u00f6gliche andere Form der Erzeugung und Initialisierung \u00b6 Das Array kann auch in einer anderen Form erzeugt und initialisiert werden: int [] numbers = { 0 , 1 , 4 , 9 , 16 }; Diese Form erzeugt ein int[] -Array der L\u00e4nge 5 mit den Werten numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Es handelt sich um eine einfache Form der Erzeugung und Initialisierung in einem Schritt. Weitere Beispiele von Arrays \u00b6 Wir zeigen einige Beispiele anderer Arrays: 1 2 3 4 5 6 7 8 9 10 11 String [] satz = new String [ 4 ] ; satz [ 0 ] = \"Das\" ; satz [ 1 ] = \"ist\" ; satz [ 2 ] = \"ein\" ; satz [ 3 ] = \"Satz\" ; for ( int index = 0 ; index < satz . length - 1 ; index ++ ) { System . out . print ( satz [ index ] + \" \" ); } System . out . println ( satz [ satz . length - 1 ] + \".\" ); Das Beispiel zeigt die Erzeugung und Initialisierung eines Arrays, in dem alle Elemente vom Typ String sind. Nach der Erzeugung und Initialisierung in den Zeilen 1 bis 5 folgt die Ausgabe der Werte des Arrays. Es werden alle Werte ausgegeben und ein Leerzeichen angeh\u00e4ngt. Das gilt aber nur f\u00fcr alle Elemente einschlie\u00dflich des vorletzten ( index<satz.length-1 ). Hinter das letzte Element ( satz[satz.length-1] ) folgt kein Leerzeichen, sondern ein Punkt. Wir h\u00e4tten das Array auch so erzeugen und initialisieren k\u00f6nnen: String[] satz = {\"Das\", \"ist\", \"ein\", \"Satz\"}; Ein weiteres Beispiel mit einem char -Array: 1 2 3 4 5 6 7 8 9 char [] alphabet = new char [ 26 ] ; for ( int index = 0 ; index < 26 ; index ++ ) { alphabet [ index ] = ( char ) ( index + 65 ); } for ( int index = 0 ; index < 26 ; index ++ ) { System . out . print ( alphabet [ index ]+ \" \" ); } Es wird zun\u00e4chst ein char -Array erzeugt (Zeile 1 ) und initialisiert (Zeilen 2 bis 5 ). Anschlie\u00dfend wird es ausgelesen Zeilen 6 bis 9 ). Es entsteht folgende Ausgabe: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Success Wir k\u00f6nnen uns Arrays erzeugen und initialisieren. Wir k\u00f6nnen Werte in diesen Arrays \u00e4ndern und aus den Arrays auslesen. Wir kennen die length -Variable von Arrays und k\u00f6nnen den Index verwenden, um auf die einzelnen Elemente zuzugreifen. N\u00e4chste Woche geht es mit Arrays weiter! Algorithmen \u00fcber Arrays \u00b6 Wir werden uns mit verschiedenen Algorithmen besch\u00e4ftigen, die alle Arrays zur Grundlage haben. Wir beginnen zur Auffrischung mal mit einer kleinen \u00dcbung. Wir wollen ein Array erstellen, in dem die Fibonacci-Folge enthalten ist. Diese geht so, dass das erste Element den Wert 0 hat und das zweite Element den Wert 1 und alle nachfolgenden Elemente als Wert die Summe der Werte ihrer beiden Vorg\u00e4nger hat, also 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... . Ausgangspunkt ist also etwas in der folgenden Art: public void main ( String [] args ) { int length = 20 ; int [] fibonacci = new int [ length ] ; fibonacci [ 0 ] = 0 ; fibonacci [ 1 ] = 1 ; } Bef\u00fcllen Sie den Rest des fibonacci -Arrays! public void main ( String [] args ) { int length = 20 ; int [] fibonacci = new int [ length ] ; fibonacci [ 0 ] = 0 ; fibonacci [ 1 ] = 1 ; for ( int index = 2 ; index < fibonacci . length ; index ++ ) { fibonacci [ index ] = fibonacci [ index - 1 ] + fibonacci [ index - 2 ] ; } } Wir wollen dieses Array nun mehrfach verwenden, um anhand von Beispielen einige Algorithmen \u00fcber Arrays kennenzulernen. Beachten Sie, dass wir f\u00fcr das fibonacci -Array die L\u00e4nge auf 20 festgesetzt hatten. Dies k\u00f6nnen wir aber problemlos \u00e4ndern und deutlich l\u00e4ngere fibonacci -Arrays erstellen. Alles, was wir dazu tun m\u00fcssen, ist den Wert von length zu \u00e4ndern. Beachten Sie au\u00dferdem, dass length eine von uns erzeugte Variable ist, aber fibonacci.length eine Variable des Arrays (deren Wert wir nicht \u00e4ndern, sondern nur auslesen k\u00f6nnnen). Methoden mit Arrays als Parameter \u00b6 Wir werden uns einige Methoden erstellen, um z.B. ein als Parameter \u00fcbergebenes Array auszugeben oder einige Berechnungen \u00fcber die Werte des Arrays durchzuf\u00fchren. Wir beginnen damit, uns eine Methode zu schreiben, die ein als Parameter \u00fcbergebenes Array auf die Konsole ausgibt. Ausgabe der Werte auf die Konsole \u00b6 Zun\u00e4chst wollen wir alle Werte nur durch Leerzeichen getrennt auf die Konsole ausgeben. Die dazugeh\u00f6rige Methode sieht so aus: 1 2 3 4 5 6 7 8 public void printArray ( int [] a ) { for ( int index = 0 ; index < a . length ; index ++ ) { System . out . print ( a [ index ] + \" \" ); } System . out . println (); } Wir \u00fcbergeben also ein int[] -Array als Parameter und durchlaufen es in einer Schleife vollst\u00e4ndig von index=0 bis index=a.length-1 und geben alle Werte von a[index] auf die Konsole durch Leerzeichen getrennt aus. Wenn wir nun in main() printArray(fibonacci); aufrufen, bekommen wir folgende Ausgabe: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 Jetzt wollen wir die Ausgabe \u00e4ndern. Das Array soll in folgender Form ausgegeben werden: [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 , 987 , 1597 , 2584 , 4181 ] Das hei\u00dft, die Werte sollen alle innerhalb von eckigen Klammern erscheinen und die Werte sind durch Komma getrennt. Das Hauptproblem dabei ist, dass nach dem letzten Wert kein Komma ausgegeben werden soll. Angenommen, wir \u00e4ndern obigen Code nur geringf\u00fcgig: 1 2 3 4 5 6 7 8 9 public void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } System . out . println ( \" ]\" ); } dann h\u00e4tten wir eine Ausgabe in der Form: [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 , 987 , 1597 , 2584 , 4181 , ] Wir h\u00e4tten also schonmal die eckigen Klammern, aber nach dem letzten Wert k\u00e4me noch ein Komma. Deshalb lassen wir nun die Schleife nur noch bis index<a.length-1 laufen und behandeln das letzte Element extra. Welchen Index hat das letzte Element von a ? Wir kennen die L\u00e4nge nicht, wir kennen aber a.length . Das letzte Element hat den Index a.length-1 , d.h. der gr\u00f6\u00dfte Index ist stets die L\u00e4nge des Arrays minus 1. Wir k\u00f6nnten die Methode also so schreiben: 1 2 3 4 5 6 7 8 9 10 public void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length - 1 ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } System . out . print ( a [ a . length - 1 ] ); System . out . println ( \" ]\" ); } Jetzt gibt es nur noch ein kleines Problem: Was passiert, wenn die L\u00e4nge des Arrays 0 ist, das als Parameter \u00fcbergebene Array also gar keine Elemente besitzt? Ein solches Array lie\u00dfe sich z.B. durch int [] arr1 = new int [ 0 ] ; int [] arr2 = {}; erzeugen. Wenn a die L\u00e4nge 0 h\u00e4tte, dann w\u00fcrden wir mit a[a.length-1] auf das Element von a mit dem Index -1 zugreifen wollen und ein solches Element/ein solcher Index existiert nicht. Es w\u00fcrde eine ArrayIndexOutOfBounds -Exception geworfen werden. Um sich dagegen zu sch\u00fctzen, pr\u00fcfen wir vor diesem Zugriff noch, ob die L\u00e4nge gr\u00dfer als 0 ist: 1 2 3 4 5 6 7 8 9 10 11 12 13 public void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length - 1 ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } if ( a . length > 0 ) { System . out . print ( a [ a . length - 1 ] ); } System . out . println ( \" ]\" ); } Was wird ausgegeben, wenn a die L\u00e4nge 0 hat? [ ] Schreiben Sie die obige Methode so, dass die Ausgabe nicht auf der Konsole erfolgt, sondern der Ausgabe-String zur\u00fcckgegeben wird! public String getOutputStringOfArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } return s ; } Maximumwert ermitteln \u00b6 Angenommen, wir bekommen ein int[] -Array als Parameter \u00fcbergeben und sollen den gr\u00f6\u00dften Wert innerhalb dieses Arrays ermitteln (und zur\u00fcckgeben). Eine Idee f\u00fcr einen solchen Algorithmus w\u00e4re: wir merken uns das aktuelle Maximum in einer Variablen wir laufen durch das Array durch und immer wenn der aktuelle Wert im Array gr\u00f6\u00dfer ist, als unser aktuelles Maximum, speichern wir den Wert als (neues) aktuelles Maximum wenn wir vollst\u00e4ndig durch das Array durchgelaufen sind, haben wir den gr\u00f6\u00dften Wert als aktuelles Maximum gespeichert und k\u00f6nnen ihn zur\u00fcckgeben Eine solche Implementierung k\u00f6nnte so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 public int getMaximum ( int [] a ) { int currentMaximum = 0 ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]> currentMaximum ) { currentMaximum = a [ index ] ; } } return currentMaximum ; } Das sieht zun\u00e4chst exakt wie die Implementierung des oben beschriebenen Algorithmus' aus. In Zeile 3 erstellen wir unsere Variable currentMaximum , mit der wir uns das aktuelle Maximum speichern wollen. Mit der for -Schleife laufen wir durch alle Elemente unseres Arrays (Zeile 4 ) und wenn ein Wert aus dem Array gr\u00f6\u00dfer ist als das bis dahin gespeicherte Maximum (Zeile 6 ), speichern wir den Wert des Elements als neues Maximum (Zeile 8 ). Nach dem Verlassen der for -Schleife ist der gr\u00f6\u00dfte Wert in currentMaximum gespeichert und kann zur\u00fcckgegeben werden. Wir testen das mal in main() mit unserer Fibonacci-Folge und rufen System.out.println(getMaximum(fibonacci)); auf. Wir erhalten: 4181 Es scheint also zu funktionieren. Wir haben jedoch ein Problem: Was passiert, wenn die Werte in a alle negativ sind? Dann w\u00fcrde der Vergleich in Zeile 6 nie true sein und currentMaximum nie den Wert \u00e4ndern, da der initiale Wert von currentMaximum gr\u00f6\u00dfer als alle Werte aus dem Array ist. Wir m\u00fcssen also etwas am initialen Wert von currentMaximum \u00e4ndern. Eine Idee ist, dass wir currentMaximum mit dem ersten Wert aus dem a -Array initialisieren: 1 2 3 4 5 6 7 8 9 10 11 12 public int getMaximum ( int [] a ) { int currentMaximum = a [ 0 ] ; for ( int index = 1 ; index < a . length ; index ++ ) { if ( a [ index ]> currentMaximum ) { currentMaximum = a [ index ] ; } } return currentMaximum ; } Dann m\u00fcssen wir beim Schleifendurchlauf nur noch alle Elemente betrachten, deren Index >=1 ist, da wir das Element mit dem Index 0 (das erste Element aus a ) bereits bei der Initialisierung von currentMaximum betrachtet haben. Nun funktioniert unsere Methode auch f\u00fcr Arrays, die nur negative Werte enthalten. Ein Problem bleibt noch: Was passiert, wenn das Array a leer ist, also eine L\u00e4nge von 0 hat? Dann k\u00f6nnen wir n\u00e4mlich auch nicht a[0] aufrufen, da dieses Element (der Index 0 ) nicht existiert. Wir bek\u00e4men eine ArrayIndexOutOfBounds -Exception. Hierbei stellt sich die grunds\u00e4tzliche Frage, was durch unsere Methode zur\u00fcckgegeben werden soll, wenn das \u00fcbergebene Array gar kein Maximum hat, n\u00e4mlich dann, wenn es leer ist? Darauf gibt es keine befriedigende Antwort. W\u00fcr m\u00fcssen ein int zur\u00fcckgeben, aber kein int aus dem Wertebereich w\u00e4re korrekt. Grunds\u00e4tzlich sollte so etwas vor Aufruf der Methode gepr\u00fcft werden. Wir k\u00f6nnten uns z.B. eine Methode isEmpty() schreiben: public boolean isEmpty ( int [] a ) { return ( a . length == 0 ); } Diese Methode gibt true zur\u00fcck, wenn das Array a leer ist (also die L\u00e4nge 0 ) hat und false sonst. Diese Methode kann man f\u00fcr den Aufruf von getMaximum() verwenden: if ( ! isEmpty ( arr1 )) { int maximum = getMaximum ( arr1 ); } Das hei\u00dft, wir rufen die Methode getMaximum() f\u00fcr ein Array nur dann auf, wenn wir wissen, dass dieses Array nicht leer ist. Dann arbeitet unsere Methode n\u00e4mlich korrekt - und nur dann. Zwei Arrays auf Gleichheit pr\u00fcfen \u00b6 Wir wollen eine Methode schreiben, die \u00fcberpr\u00fcft, ob 2 Arrays gleich sind - also vollst\u00e4ndig gleiche Werte enthalten. Z.B. sollen diese Arrays gleich sein: int [] arr1 = { 8 , 9 , 2 , 3 , 7 , 4 , 1 , 0 , 9 , 6 }; int [] arr2 = { 8 , 9 , 2 , 3 , 7 , 4 , 1 , 0 , 9 , 6 }; aber int [] arr3 = { 8 , 9 , 2 , 3 , 7 , 5 , 1 , 0 , 9 , 6 }; ist ungleich zu arr1 und arr2 , da arr3 an 6. Stelle den Wert 5 statt 4 hat. Die algorithmische Idee ist: wir laufen gleichzeitig durch beide Arrays durch solange die Werte bei gleichem Index gleich sind, machen wir weiter sobald zwei Werte bei gleichem Index ungleich sind, wissen wir, dass die Arrays ungleich sind wenn wir alle Elemente betrachtet haben und alle waren gleich, dann sind auch unsere Arrays gleich 1 2 3 4 5 6 7 8 9 10 11 12 public boolean areEqual ( int [] a , int [] b ) { boolean areEqual = true ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]!= b [ index ] ) { areEqual = false ; } } return areEqual ; } Diese Methode setzt unseren Algorithmus um und wenn wir die Methode mit den obigen Arrays testen System . out . println ( areEqual ( arr1 , arr2 )); System . out . println ( areEqual ( arr1 , arr3 )); , dann wird auch korrekt true false ausgegeben. Doch was passiert, wenn wir die Methode f\u00fcr diese beiden Arrays aufrufen: int [] arr4 = { 8 , 9 , 2 }; int [] arr5 = { 8 , 9 , 2 , 3 }; Welcher Wert wird bei Aufruf System.out.println(areEqual(arr4, arr5)); ausgegeben? true Wollen wir das? Welcher Wert wird bei Aufruf System.out.println(areEqual(arr5, arr4)); ausgegeben? keiner, sondern Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 Warum? Grunds\u00e4tzlich sollte es bei einer solchen Methode egal sein, welche Reihenfolge die \u00fcbergebenen Arrays in der Parameterliste haben, d.h. areEqual(arr4, arr5) und areEqual(arr5, arr4) sollten den gleichen Wert zur\u00fcckliefern, denn entweder sind sie gleich true oder sie sind es nicht false . Die Gleichheit ist eine symmetrische Relation . Was ist das Problem unserer bisherigen L\u00f6sung? Wir durchlaufen die Schleife auch dann, wenn die Arrays unterschiedliche L\u00e4nge haben. In dem Aufruf areEqual(arr4, arr5) wird das letzte Element von arr5 gar nicht mehr gepr\u00fcft, da der index in der Schleife nur bis arr4.length-1 l\u00e4uft. In dem Aufruf areEqual(arr5, arr4) wird versucht, das letzte Element von arr5 mit einem Element von arr4 zu vergleichen, das gar nicht existiert. Der Zugriff auf arr4[3] f\u00fchrt zu einer ArrayIndexOutOfBoundsException . Wir werden deshalb zun\u00e4chst pr\u00fcfen, ob die beiden Arrays \u00fcberhaupt gleich lang sind und nur dann durchlaufen wir die beiden Arrays: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public boolean areEqual ( int [] a , int [] b ) { boolean areEqual = true ; if ( a . length != b . length ) { areEqual = false ; } for ( int index = 0 ; index < a . length && areEqual ; index ++ ) { if ( a [ index ]!= b [ index ] ) { areEqual = false ; } } return areEqual ; } Au\u00dferdem haben wir in die for -Schleife die Bedingung um && areEqual erweitert. Das hat zwei Gr\u00fcnde: erstens betreten wir die for -Schleife dann gar nicht, wenn die beiden Arrays unterschiedliche L\u00e4ngen haben, denn dann ist areEqual==fasle und somit ist die gesamte Bedingung index < a.length && areEqual false . \u2192 das ist also notwendig, um korrekt zu sein (wir k\u00f6nnten auch die for -Schleife in den else -Block der Selektion packen) zweitens beenden wir das Durchlaufen der for -Schleife sofort, wenn wir ungleiche Elemente gefunden haben, denn dann setzen wir ja auch areEqual auf false . Es gen\u00fcgt ja, zwei ungleiche Elemente zu finden, dann sind die Arrays ungleich und wir m\u00fcssen gar nicht weiter suchen. \u2192 das ist also nicht notwendig, aber performanter Zur \u00dcbung mit einem Array als Parameter k\u00f6nnen Sie: Bestimmen Sie die Summe aller Werte eines int -Arrays, welches als Parameter der Methode \u00fcbergeben wird. Geben Sie die Summe zur\u00fcck. public int getSumme ( int [] a ) { int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ i ] ; } return sum ; } Bestimmen Sie den Durchschnitt/Mittelwert aller Werte eines int -Arrays, welches als Parameter der Methode \u00fcbergeben wird. Geben Sie den Durchschnitt zur\u00fcck zur\u00fcck. public double getAverage ( int [] a ) { /* * diese Aufgabe ist leider komplizierter, da wir * das Problem haben, dass getSumme(a) ein int * zurueckliefert und a.length ebenfalls ein int ist * und wir somit int / int rechnen, also eine * ganzzahlige Division durchf\u00fchren * Mithilfe des Typkonvertierungsoperators (double) * k\u00f6nnen wir aber aus einem int ein double machen, * z.B. wird mit (double)a.length aus der Laenge ein * double * int / double ist eine Gleitkommadivision * Probieren Sie es einmal ohne (double) und * einmal mit (double) aus */ double average = getSumme ( a ) / ( double ) a . length ; return average ; } Methoden mit Array als R\u00fcckgabe \u00b6 Wir betrachten nun Methoden, die ein Array zur\u00fcckgeben. Wir fangen an mit einer Methode, der eine int length \u00fcbergeben wird und die damit ein int[] der L\u00e4nge length erzeugt und dieses Array mit Zufallszahlen bef\u00fcllt: 1 2 3 4 5 6 7 8 9 10 public int [] createAndFillArray ( int length ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt (); } return a ; } Betrachten wir die Methode genauer: in Zeile 3 wird eine Variable a vom Typ int[] deklariert und ein int[] -Array der L\u00e4nge length erzeugt. Die Variable a zeigt auf dieses neu erzeugte Array. in Zeile 4 erzeugen wir ein Random -Objekt und die Referenzvariable r vom Typ Random zeigt auf dieses Objekt. Beachten Sie, dass Sie die Klasse Random aus dem java.util -Paket importieren m\u00fcssen! in den Zeilen 5-8 laufen wir durch das Array durch und belegen jedes Element mit einer Zufallszahl indem wir r.nextInt() aufrufen. in Zeile 9 wird das Array zur\u00fcckgegeben. Aufruf der Methode in main() (oder einer anderen Methode): int [] arr6 = createAndFillArray ( 5 ); printArray ( arr6 ); Wir rufen die Methode mit einem Wert 5 f\u00fcr length auf. Das bedeutet, dass die Methode ein Array der L\u00e4nge 5 erzeugt und mit Zufallszahlen bef\u00fcllt. Das zur\u00fcckgegebene Arry speichern wir in der Variablen arr6 , die ebenfalls vom Typ int[] ist. Wir geben das Array mithilfe der von uns erzeugten Methode printArray(arr6); aus (wir h\u00e4tten auch direkt printArray(createAndFillArray(5)); aufrufen k\u00f6nnen, dann h\u00e4tten wir das erzeugte Array aber nirgendwo gespeichert). Es erscheint z.B. eine Ausgabe wie: [ 1463666318 , -2121738539, -1174806146, 337579240 , -108604609 ] Wenn wir den Wertebereich der zuf\u00e4llig erzeugten Zahlen eingrenzen m\u00f6chten, z.B. nur Werte aus dem Bereich [0, 1, ..., 19] , k\u00f6nnen wir die nextInt(int bound) -Methode von Random verwenden ( siehe ). Wir erweitern die Methode createAndFillArray() um einen solchen bound -Parameter: 1 2 3 4 5 6 7 8 9 10 public int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } Beachten Sie, dass bei nextInt(int bound) der Wert von bound exklusiv ist, d.h. dieser Wert gibt die erste Zahl an, die nicht mehr zuf\u00e4llig erzeugt wird. Wenn wir also zuf\u00e4llig Zahlen aus dem Bereich [0, 1, ..., 19] erzeugen wollen, dann muss bound=20 sein. Der Aufruf von int [] arr7 = createAndFillArray ( 10 , 20 ); printArray ( arr7 ); erzeugt dann z.B. eine solche Ausgabe (bei Ihnen nat\u00fcrlich anders - sind ja Zufallszahlen): [ 2 , 17 , 7 , 5 , 17 , 3 , 19 , 8 , 6 , 18 ] Array kopieren \u00b6 Wir erstellen eine Methode, der ein Array als Parameter \u00fcbergeben wird und die davon eine Kopie erstellt und diese Kopie zur\u00fcckgibt. 1 2 3 4 5 6 7 8 9 10 public int [] copyArray ( int [] original ) { int length = original . length ; int [] copy = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) { copy [ index ] = original [ index ] ; } return copy ; } in Zeile 1 wird das Original-Array \u00fcbergeben und in der Referenzvariablen original gespeichert, in Zeile 3 erstellen wir uns eine Variable length vom Typ int , in der die L\u00e4nge des Original-Arrays gespeichert wird, in Zeile 4 wird das copy -Array erstellt, das genau so lang ist, wie das Original, In den Zeilen 5-8 kopieren wir jeden einzelnen Wert aus dem Original-Array in das copy -Array (elementweise), in Zeile 9 geben wir das copy -Array zur\u00fcck 1 Der Aufruf der Methode, z.B. int [] original = createAndFillArray ( 10 , 20 ); System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original ); System . out . print ( \"copy : \" ); printArray ( copy ); erzeugt folgende Ausgabe (Zufallszahlen): original : [ 2 , 2 , 5 , 19 , 19 , 6 , 1 , 1 , 4 , 8 ] copy : [ 2 , 2 , 5 , 19 , 19 , 6 , 1 , 1 , 4 , 8 ] Angenommen, wir \u00fcbergeben unserer Methode nicht nur das Original-Array, sondern auch eine L\u00e4nge, bis zu der das Original-Array kopiert werden soll. Der Methodenkopf w\u00fcrde dann also so aussehen: public int [] copyArray ( int [] original , int newLength ) Dann gibt es 3 verschiedene Varianten: Original-Array und Kopie des Arrays gleich lang (wenn newLength == original.length ) Original-Array k\u00fcrzer als Kopie (z.B. falls Original-Array zu klein geworden ist, um weitere Elemente einzuf\u00fcgen; wenn newLength > original.length ) Original-Array l\u00e4nger als Kopie (falls nur ein Teil kopiert werden soll; wenn newLength < original.length ) Wir f\u00fcgen in unsere Methode eine entsprechende Fallunterscheidung ein: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public int [] copyArray ( int [] original , int newLength ) { int [] copy = new int [ newLength ] ; if ( original . length <= newLength ) { for ( int index = 0 ; index < original . length ; index ++ ) { copy [ index ]= original [ index ] ; } } else { for ( int index = 0 ; index < copy . length ; index ++ ) { copy [ index ]= original [ index ] ; } } return copy ; } in Zeile 1 wurde der neue Parameter newLength hinzugef\u00fcgt, der die L\u00e4nge des copy -Arrays bestimmt, in Zeile 3 wird das copy -Array mit der L\u00e4nge newLength erzeugt, in Zeile 4 erfolgt die Fallunterscheidung: falls die Kopie mindestens so lang ist wie das Original, werden alle Elemente aus dem Original in die Kopie kopiert (Zeilen 6-9 ) \u2192 Beachten Sie Verwendung von original.length in der Bedingung der for -Schleife, falls die Kopie k\u00fcrzer ist als das Original, werden nur die ersten newLength Elemente aus dem Original-Array kopiert (Zeilen 13-16 ) \u2192 Beachten Sie Verwendung von copy.length in der Bedingung der for -Schleife, Bei dem Aufruf von int [] original = createAndFillArray ( 10 , 20 ); // Original Laenge 10 System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original , 8 ); // Kopie Laenge 8 System . out . print ( \"copy : \" ); printArray ( copy ); erfolgt folgende Ausgabe (Zufallszahlen): original : [ 8 , 13 , 11 , 4 , 7 , 2 , 5 , 1 , 15 , 5 ] copy : [ 8 , 13 , 11 , 4 , 7 , 2 , 5 , 1 ] Bei dem Aufruf von int [] original = createAndFillArray ( 10 , 20 ); // Original Laenge 10 System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original , 18 ); // Kopie Laenge 18 System . out . print ( \"copy : \" ); printArray ( copy ); erfolgt folgende Ausgabe (Zufallszahlen): original : [ 1 , 18 , 0 , 9 , 12 , 18 , 2 , 8 , 17 , 12 ] copy : [ 1 , 18 , 0 , 9 , 12 , 18 , 2 , 8 , 17 , 12 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] Beachten Sie, dass Elementen, denen kein Wert zugewiesen wurde, den Wert 0 haben (Standardwert von int ). Array verketten \u00b6 Wir erstellen eine Methode, der zwei Arrays als Parameter \u00fcbergeben werden und die daraus ein neues Array erstellt, welche alle Elemente des einen und alle Elemente des anderen Arrays enth\u00e4lt. Die algorithmische Idee dabei ist wie folgt: Array a und Array b aneinanderh\u00e4ngen: neues Array c erzeugen (die L\u00e4nge von c ergibt sich aus a.length + b.length ), Elemente von a nach c kopieren (bis Index a.length-1 ), Elemente von b nach c kopieren (ab Index a.length ), c zur\u00fcckgeben Die folgende Abbildung verdeutlicht ein Beispiel mit a.length==6 und b.length==4 . Es wird ein Array c mit L\u00e4nge 10 erzeugt. In die ersten 6 Elemente von c werden die Werte von a kopiert und in die folgenden 4 Elemente die Werte von b . Beachten Sie, dass in dem Beispiel z.B. c[6]=b[0] kopiert wird. Eine m\u00f6gliche Methode k\u00f6nnte so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public int [] concatArrays ( int [] a , int [] b ) { int [] c = new int [ a . length + b . length ] ; for ( int index = 0 ; index < a . length ; index ++ ) { c [ index ] = a [ index ] ; } for ( int index = 0 ; index < b . length ; index ++ ) { c [ index + a . length ] = b [ index ] ; } return c ; } Wichtig ist hier, unbedingt zu verstehen, warum wir innerhalb der zweiten for -Schleife c[index+a.length] = b[index]; verwenden! Suchen in Arrays \u00b6 Bei der Suche in Arrays geht es darum, einen bestimmten Wert zu finden, der im Array enthalten ist (oder er wird nicht gefunden, falls er nicht im Array existiert.) Grunds\u00e4tzlich m\u00fcssen wir zwischen der Suche in unsortierten und sortierten Arrays unterscheiden. In sortierten Arrays sind die Elemente alle hinsichtlich ihrer Werte geordnet, also z.B. numerisch bei Zahlen oder alphanumerisch bei Zeichen und Zeichenketten. Wir beginnen mit der Suche in unsortierten Arrays. Suche in unsortierten Arrays \u00b6 Wir wollen eine Methode erstellen, der ein Array \u00fcbergeben wird und ein Element gleichen Typs. Die Methode soll ein true zur\u00fcckgeben, wenn das Element in dem Array enthalten ist und ein false , wenn nicht. Die Idee dabei ist wir durchlaufen das Array solange, bis wir entweder das Element gefunden haben \u2192 dann k\u00f6nnen wir die Suche beenden und ein true zur\u00fcckgeben oder wir am Ende des Arrays angekommen sind und das Element nicht gefunden haben \u2192 dann geben wir ein false zur\u00fcck Eine solche Methode k\u00f6nnte so aussehen: public boolean contains ( int [] a , int element ) { boolean found = false ; for ( int index = 0 ; index < a . length && ! found ; index ++ ) { if ( a [ index ]== element ) { found = true ; } } return found ; } Wir pr\u00fcfen also, ob element als Wert in a enthalten ist. in Zeile 3 definieren wir uns eine Variable found , deren Wert initial auf false gesetzt wird ( element noch nicht gefunden) in Zeilen 4-10 durchlaufen wir das Array, entweder so lange bis wir das element gefunden haben (Zeilen 6-9 ) \u2192 found==true oder bis wir das Ende des Arrays erreicht haben ( index==a.length ) \u2192 found==false in Zeile 11 geben wir den Wert von found zur\u00fcck Beachten Sie, dass es wichtig ist, dass found initial den Wert false bekommt und dass die Schleife sofort verlassen wird, sobald wir das Element gefunden haben (Schleifen bedingung && !found ). Wir bleiben bei der Suche in unsortierten Arrays. Jetzt soll unsere Methode aber den Index zur\u00fcckgeben, an dem das Element im Array enthalten ist. Wir wissen, dass der Index nur Werte zwischen 0 und array.length-1 annehmen kann, also nur positive Werte. Wenn das Element nicht im Array enthalten ist, dann geben wir eine -1 zur\u00fcck. Hierbei sind zwei Sachen zu beachten: Erstens sollten wir solche \"Codierungen\" von R\u00fcckgabewerten vermeiden. Die aufrufende Methode muss ja \"wissen\", dass ein negativer R\u00fcckgabewert bedeutet, dass das Element gar nicht im Array enthalten ist. Auf der anderen Seite m\u00fcssen wir aber ein int zur\u00fcckgeben. Im Gegensatz zur getMaximum() -Methode oben, gibt es hier jedoch zumindest eine \"L\u00f6sung\" f\u00fcr das Problem, dass das Element nicht enthalten ist. Trotzdem sollte man auf jeden Fall zun\u00e4chst contains() aufrufen und nur, wenn contains() ein true zur\u00fcckliefert, dann die getIndex() -Methode. Zweitens ist die -1 eine sogenannte magic number . Wir sollten ihr einen Namen geben. Wir betrachten die Methode zun\u00e4chst ohne einen Namen f\u00fcr die -1 : 1 2 3 4 5 6 7 8 9 10 11 12 public int getIndex ( int [] a , int element ) { int indexAtElement = - 1 ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]== element ) { indexAtElement = index ; } } return indexAtElement ; } Wir durchlaufen das Array und sobald wir das element \"finden\" (Zeile 6 ), merken wir uns den aktuellen Index (Zeile 8 ). Am Ende wird der gemerkte Index zur\u00fcckgegeben (Zeile 11 ). Wenn Zeile 8 nie ausgef\u00fchrt wurde, dann wird der initiale Wert von indexAtElement zur\u00fcckgegeben, n\u00e4mlich -1 . Diese -1 ist eine sogenannte magic number . Man kennt die Bedeutung dieses Wertes nicht. Es ist deshalb besser, daf\u00fcr einen Namen einzuf\u00fchren - als Konstante (zu Konstanten siehe hier ). 1 2 3 4 5 6 7 8 9 10 11 12 13 public int getIndex ( int [] a , int element ) { final int NOT_FOUND = - 1 ; int indexAtElement = NOT_FOUND ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]== element ) { indexAtElement = index ; } } return indexAtElement ; } Eine Konstante ist eine Variable, die genau einmal einen Wert zugewiesen bekommt (initialisiert wird) und deren Wert nie wieder \u00fcberschrieben werden kann. Die Namen von Konstanten schreiben wir durchgehend GROSS. Angenommen, das element kommt mehrmals im Array a vor. Wird der erste Index des Auftretens von element im Array zur\u00fcckgegeben oder der letzte Index? Wie k\u00f6nnte man das \u00e4ndern? Der letzte. Man k\u00f6nnte beim ersten Finden des Elementes die Schleife sofort verlassen (aber nicht break; verwenden!) Suche in sortierten Arrays \u00b6 In sortierten Arrays sucht es sich etwas schneller nach einem element . Daf\u00fcr gibt es zwei Gr\u00fcnde: einerseits kann eine sequentielle Suche (also das Durchlaufen des Arrays) schneller abgebrochen werden, falls das Element nicht im Array enthalten ist, denn sobald man einen Wert im Array erreicht, der gr\u00f6\u00dfer ist, als der gesuchte Wert, kann das element ja gar nicht mehr vorkommen (falls das Array aufsteigend sortiert ist) andererseits kann man Algorithmen anwenden, die den Suchraum schnell einschr\u00e4nken, eine sogenannte bin\u00e4re Suche . Wir betrachten zun\u00e4chst die sequentielle Suche. Angenommen, wir haben folgendes aufsteigend sortiertes Array: [ 0 , 2 , 2 , 3 , 4 , 4 , 5 , 7 , 8 , 9 , 11 , 11 , 11 , 14 , 16 , 16 , 18 , 18 , 18 , 19 ] und angenommen, wir wollen pr\u00fcfen, ob die 10 im Array enthalten ist. In einem unsortierten Array m\u00fcssten wir das gesamte Array durchlaufen, um zu merken, dass die 10 nicht enthalten ist. Hier, bei dem sortierten Array, merken wir das schon, wenn wir die erste 11 gefunden haben, denn danach kann die 10 nicht mehr kommen. Die contains() -Methode kann also ein weiteres Abbruchkriterium der Suche enthalten: public boolean containsSorted ( int [] aSorted , int element ) { boolean found = false ; boolean greater = false ; for ( int index = 0 ; index < aSorted . length && ! found && ! greater ; index ++ ) { if ( aSorted [ index ]== element ) { found = true ; } if ( aSorted [ index ]> element ) { greater = true ; } } return found ; } Im Vergleich zur contains() -Methode f\u00fcr unsortierte Arrays haben wir einen weiteren \"Schalter\" hinzugef\u00fcgt, greater . Damit haben wir auch die Bedingung in der for -Schleife erweitert ( && !greater ). Sollten wir das element noch nicht gefunden haben, der Wert aSorted[index] aber gr\u00f6\u00dfer als element sein (Zeile 11 ), setzen wir greater auf true und die Schleife wird verlassen. Funktioniert die contains() -Methode, die wir f\u00fcr unsortierte Arrays implementiert haben, auch f\u00fcr sortierte Arrays? Ja, wir nutzen nur die M\u00f6glichkeit des fr\u00fcheren Abbruchs der Suche nicht aus. Schreiben Sie eine Methode getIndexSorted(int[] aSorted, int element) , die den Index von element in a zur\u00fcckgibt (und sonst -1 ). Genau wie getIndex() f\u00fcr unsortierte Arrays, aber auch hier nutzen Sie die fr\u00fchere Abbruchm\u00f6glichkeit der Suche aus. public int getIndexSorted ( int [] aSorted , int element ) { final int NOT_FOUND = - 1 ; boolean greater = false ; int indexAtElement = NOT_FOUND ; for ( int index = 0 ; index < aSorted . length && ! greater ; index ++ ) { if ( aSorted [ index ]== element ) { indexAtElement = index ; } if ( aSorted [ index ]> element ) { greater = true ; } } return indexAtElement ; } Bis jetzt sind wir immer sequenziell durch das Array durchgelaufen, also von vorne nach hinten, beginnend mit dem Index 0 bis wir bei array.length angekommen waren. In sortierten Arrays k\u00f6nnen wir das Prinzip \u00e4ndern: Wir fangen einfach in der Mitte des Arrays an und wenn der Wert, den wir suchen, kleiner ist, als der Wert in der Mitte, dann suchen wir links weiter und sonst suchen wir rechts weiter. Dann gehen wir mit der linken bzw. rechten H\u00e4lfte genau so vor usw. Diese Suche nennt sich bin\u00e4re Suche ( binary search ), in jedem Schritt wird der (verbliebene) Suchraum halbiert. Angenommen, wir suchen in dem folgenden Array die 25 : wir ermitteln zun\u00e4chst den Index, der in der Mitte des Arrays ist ( mid ). Dieser ergibt sich aus dem Mittelwert von lo (das ist der kleinste Index, der ist am Anfang 0 ) und hi (das ist der gr\u00f6\u00dfte Index, der ist am Anfang 14 , da unser Beispiel-Array die L\u00e4nge 15 hat). Unserer Index in der Mitte ist also mid=7 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 34 . 34 ist gr\u00f6\u00dfer als die gesuchte 25 \u2192 wir suchen also in dem linken Teil des Arrays weiter. Wir ermitteln den gr\u00f6\u00dften Index hi in diesem Teil (der ist um 1 kleiner als mid davor, also 6 ). Der Wert von lo bleibt 0 . Der neue Wert von mid ist 3 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 16 . 16 ist kleiner als die gesuchte 25 \u2192 wir suchen also in dem rechten Teil des Arrays weiter. Wir ermitteln den gr\u00f6\u00dften Index lo in diesem Teil (der ist um 1 gr\u00f6\u00dfer als mid davor, also 4 ). Der Wert von hi bleibt 6 . Der neue Wert von mid ist 5 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 25 . Wir haben das Element gefunden. Ehe Sie sich die Implementierung der bin\u00e4ren Suche anschauen, sollten Sie in dem Beispiel aus dem Bild noch die 41 suchen. Achten Sie insbesondere darauf, wie sich die Werte von lo , mid und high in jedem Suchschritt \u00e4ndern. wir beginnen mit lo=0 , hi=14 und also mid=7 . Der Wert im Index 7 ist 34 und somit kleiner als die gesuchte 41 \u2192 wir suchen rechts weiter lo=8 , hi=14 und also mid=11 . Der Wert im Index 11 ist 46 und somit gr\u00f6\u00dfer als die gesuchte 41 \u2192 wir suchen links weiter lo=8 , hi=10 und also mid=9 . Der Wert im Index 9 ist 41 \u2192 gefunden Ehe Sie sich die Implementierung der bin\u00e4ren Suche anschauen, sollten Sie in dem Beispiel aus dem Bild noch die 42 suchen. Wann stellen Sie fest, dass die 42 nicht im Array enthalten ist? wir beginnen mit lo=0 , hi=14 und also mid=7 . Der Wert im Index 7 ist 34 und somit kleiner als die gesuchte 42 \u2192 wir suchen rechts weiter lo=8 , hi=14 und also mid=11 . Der Wert im Index 11 ist 46 und somit gr\u00f6\u00dfer als die gesuchte 42 \u2192 wir suchen links weiter lo=8 , hi=10 und also mid=9 . Der Wert im Index 9 ist 41 und somit kleiner als die gesuchte 42 \u2192 wir suchen rechts weiter lo=10 , hi=10 und also mid=10 . Der Wert im Index 10 ist 46 \u2192 nicht gefunden ( hi und lo haben den gleichen Wert \u2192 zu Ende) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public boolean containsBinarySearch ( int [] aSorted , int element ) { boolean found = false ; int lo = 0 ; int hi = aSorted . length - 1 ; while ( lo <= hi && ! found ) { int mid = ( hi + lo ) / 2 ; if ( element == aSorted [ mid ] ) // gefunden { found = true ; } else // nicht gefunden { if ( element < aSorted [ mid ] ) // links weitersuchen { hi = mid - 1 ; } else // element > aSorted[mid] rechts weitersuchen { lo = mid + 1 ; } } } return found ; } in Zeile 4 wir die lo -Variable mit dem Index-Wert 0 initialisiert (kleinster Index), in Zeile 5 wir die hi -Variable mit dem Index-Wert aSorted.length-1 initialisiert (gr\u00f6\u00dfter Index), in Zeile 6 steht die Bedingung, wie lange die Suche fortgesetzt werden soll: solange das Element noch nicht gefunden wurde ( !found ) oder solange der kleinere Index lo kleiner (gleich) hi ist; falls element nicht gefunden wurde in Zeile 8 steht die Berechnung des mittleren Index mid . Beachten Sie, dass es sich um eine Integer-Division handelt. Es k\u00f6nnte also auch sein, dass die Summe von lo und hi ungerade ist, aber selbst dann ist mid eine ganze positive Zahl wenn das element gefunden wird (Bedingung in Zeile 9 ist true ), dann wird found auf true gesetzt und die while -Schleife wird verlassen wenn links weiter gesucht wird (Bedingung in Zeile 15 ist true ), dann wird hi neu gesetzt und die Schleifenbedingung erneut gepr\u00fcft wenn rechts weiter gesucht wird (Bedingung in Zeile 15 ist false ), dann wird lo neu gesetzt und die Schleifenbedingung erneut gepr\u00fcft zur\u00fcckgegeben (Zeile 25 ) wird true , wenn das element gefunden wurde (Zeilen 9-12 oder false , wenn es nicht gefunden wurde - initialer Wert von found ) Implementieren Sie eine getIndexBinarySearch() -Methode unter Verwendung des Prinzips der bin\u00e4ren Suche! public int getIndexBinarySearch ( int [] aSorted , int element ) { boolean found = false ; final int NOT_FOUND = - 1 ; int indexAtElement = NOT_FOUND ; int lo = 0 ; int hi = aSorted . length - 1 ; while ( lo <= hi && ! found ) { int mid = ( hi + lo ) / 2 ; if ( element == aSorted [ mid ] ) // gefunden { found = true ; indexAtElement = mid ; } else // nicht gefunden { if ( element < aSorted [ mid ] ) // links weitersuchen { hi = mid - 1 ; } else // element > aSorted[mid] rechts weitersuchen { lo = mid + 1 ; } } } return indexAtElement ; } Nur zur Info : Mithilfe der bin\u00e4ren Suche ist die Suche nach einem Element in einem sortierten Array enorm beschleunigt. Unter der Komplexit\u00e4t eines Algorithmus wird der Bedarf des Algorithmus an den zur Verf\u00fcgung stehenden Ressourcen Laufzeit (wie schnell?) \u2192 sogenannte Zeitkomplexit\u00e4t Speicherplatz (wie viel Speicherplatz n\u00f6tig?) \u2192 sogenannte Speicherkomplexit\u00e4t verstanden. Die Komplexit\u00e4t eines Algorithmus in Abh\u00e4ngigkeit von der Gr\u00f6\u00dfe n der von ihm bearbeiteten Daten ausgedr\u00fcckt. Daf\u00fcr hat sich die Landau-Notation durchgesetzt. Diese beschreibt mit O(n) sogenannte Komplexit\u00e4tsklassen . Beispielsweise wird die Verkettung von zwei Arrays der L\u00e4nge n und m mit der Komplexit\u00e4tsklasse O(n+m) angegeben (maximale Zeit- und Speicherkomplexit\u00e4t), w\u00e4hrend die Komplexit\u00e4tsklasse der sequentiellen Suche in unsortierten und sortierten Arrays O(n) ist und die bin\u00e4re Suche in sortierten Arrays O(log n) . Wir messen im Folgenden einmal den Zeitverbrauch der Methoden getIndex() , getIndexSorted() und getIndexBinarySearch() unter Verweung der Klassen Instant und Duration aus dem Paket java.time : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int [] test = createAndFillArray ( 100000000 , 10000000 ); Arrays . sort ( test ); Instant start = Instant . now (); int index = getIndex ( test , 80000000 ); Instant finish = Instant . now (); long duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); start = Instant . now (); index = getIndexSorted ( test , 80000000 ); finish = Instant . now (); duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); start = Instant . now (); index = getIndexBinarySearch ( test , 80000000 ); finish = Instant . now (); duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); Zeile 1 : Wir erstellen uns mithilfe der Methode createAndFillArray() ein Array mit 100 Millionen Eintr\u00e4gen. Zeile 2 : Unter Verwendung der Klasse Arrays (aus dem java.util -Paket) wird dieses Array sortiert (die Klasse kennen wir noch nicht). Zeile 3 : Mithilfe der Instant -Klasse (aus java.time ) und deren Methode now() ermitteln wir die aktuelle Zeit und speichern sie in der Variablen start (vom Typ Instant ); die Klasse kennen wir noch nicht Zeile 4 : Wir verwenden die Methode getIndex() , um das Element mit dem Wert 8.000.000 im Array test zu suchen Zeile 5 : Mithilfe Instant.now() ermitteln wir erneut die aktuelle Zeit und speichern sie in der Variablen finish Zeile 6 : wir berechnen die Differenz zwischen finish und start in Millisekunden und speichern sie in der Variablen duration vom Typ long (zur Differenzberechnung verwenden wir die Klasse Duration aus dem java.time -Paket; die Klasse kennen wir noch nicht) Zeile 7 : wir geben den Index und die Dauer der Ausf\u00fchrung aus Zeile 10 : wir wiederholen alles mit der getIndexSorted() -Methode Zeile 16 : wir wiederholen alles mit der getIndexBinarySearch() -Methode Es erfolgt folgende Ausgabe (Element wurde in diesem Fall nicht gefunden): index : -1 duration : 47 index : -1 duration : 94 index : -1 duration : 0 getIndexBinarySearch() verbraucht also (fast) keine Zeit. Es \u00fcberrascht vielleicht, dass getIndexSorted() doppelt so viel Zeit verbraucht, wie getIndex() . Das liegt aber daran, dass in getIndex() einerseits die Bedingung der for -Schleife nur eine Pr\u00fcfung enth\u00e4lt, w\u00e4hrend es in getIndexSorted() drei Teilbedingungen sind, die verkn\u00fcpft werden m\u00fcssen und es au\u00dferdem in getIndex() innerhalb der for -Schleife nur eine Bedingung zur Pr\u00fcfung gibt, w\u00e4hrend es in getIndexSorted() zwei sind. Da das gesuchte Element mit dem Wert 8 Mio relativ weit hinten im Array liegen w\u00fcrde (der Bereich der Zufallszahlen ist [0 ... 9999999] Zufallszahlen in den 100 Mio Eintr\u00e4gen des Arrays), ist der Vorteil der Suche im sortierten Array hier zu gering. W\u00fcrden wir z.B. stattdessen nach der Zahl 100000 suchen, w\u00e4re das Ergebnis so: index : 1000579 duration : 53 index : 1000579 duration : 4 index : 1000575 duration : 0 Einf\u00fcgen in Arrays \u00b6 Hier geht es darum, dass wir ein Element in ein Array einf\u00fcgen wollen. Wir unterscheiden wieder zwischen dem Einf\u00fcgen in ein unsortiertes und dem Einf\u00fcgen in ein sortiertes Array. Wir betrachten zun\u00e4chst das Einf\u00fcgen in ein unsortiertes Array. Einf\u00fcgen in ein unsortiertes Array \u00b6 Angenommen, wir haben folgendes int -Array a : und wir wollen ein weiteres Element mit dem Wert 13 einf\u00fcgen. Man k\u00f6nnte auf die Idee kommen, dass die Elemente mit dem Index 10 bis 14 daf\u00fcr zur Verf\u00fcgung stehen, da diese mit dem Standartwert f\u00fcr int , der 0 belegt sind. Aber woher sollen wir wissen, dass dies gar keine \"richtigen\" Werte sind? Da das Array ein unsortiertes int -Array ist, k\u00f6nnen Nullen an allen Stellen vorkommen. Bei dem Einf\u00fcgen in ein unsortiertes Array handelt es sich eigentlich um ein Anh\u00e4ngen ( append ) des neuen Elementes an das alte Array. Wir ben\u00f6tigen dazu ein neues Array, das um 1 l\u00e4nger ist als das urspr\u00fcngliche Array. Wir gehen also wie folgt vor: wir erzeugen ein neues Array b , das um 1 l\u00e4nger ist als das Array a wir kopieren alle Werte aus a nach b wir speichern in das letzte Element von b den neuen Wert element Eine m\u00f6gliche Implementierung daf\u00fcr sieht so aus: 1 2 3 4 5 6 7 8 9 10 11 public int [] append ( int [] a , int element ) { int [] b = new int [ a . length + 1 ] ; for ( int index = 0 ; index < a . length ; index ++ ) { b [ index ]= a [ index ] ; } b [ b . length - 1 ] = element ; return b ; } in Zeile 3 wird das neue Array b erzeugt, das um 1 \u00e4nger ist als a in den Zeilen 4-7 werden alle Werte aus a nach b kopiert in Zeile 9 wird dem letzten Element von b der Wert element zugewiesen Es geschieht also folgendes: Wir merken uns also: das Einf\u00fcgen in ein unsortiertes Array ist in Wirklichkeit ein Anh\u00e4ngen des Elementes an ein unsortiertes Array. Dazu muss ein neues Array erzeugt werden, das um 1 l\u00e4nger ist als das Array, an das angeh\u00e4ngt werden soll. Einf\u00fcgen in ein sortiertes Array \u00b6 Das Einf\u00fcgen in ein sortiertes Array ist deutlich komplizierter, denn das einzuf\u00fcgende Element muss korrekt, d.h. an die richtige Stelle entsprechend der Sortierung, eingef\u00fcgt werden. Angenommen, wir haben folgende Ausgangsposition: Das einzuf\u00fcgende Element mit dem Wert 13 muss zwischen die beiden Elemente mit den Werten 12 und 14 eingef\u00fcgt werden. Wir gehen dabei wie folgt vor: wir erzeugen ein neues Array b , das um 1 l\u00e4nger ist als a wir kopieren alle Werte aus a nach b solange die Werte kleiner sind als das einzuf\u00fcgende Element wenn wir auf das erste Element in a sto\u00dfen, das gr\u00f6\u00dfer ist als das einzuf\u00fcgende Element, f\u00fcgen wir das Element ein danach kopieren wir die restlichen Werte aus a nach b Wir setzen obigen Algorithmus in folgender Methode um: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int [] insertIntoSortedArray ( int [] a , int element ) { int [] b = new int [ a . length + 1 ] ; int indexB = 0 , indexA = 0 ; while ( indexA < a . length && a [ indexA ]< element ) { b [ indexB ++]= a [ indexA ++] ; } b [ indexB ++] = element ; // from now on indexB = indexA+1 while ( indexB < b . length ) { b [ indexB ++]= a [ indexA ++] ; } return b ; } in Zeile 3 wird das Array b erzeugt, welches um 1 l\u00e4nger ist als a in Zeilen 5-8 kopieren wir alle Werte aus a nach b , die kleiner sind als unser element in Zeile 10 wird element in b eingef\u00fcgt in Zeilen 12-15 kopieren wir die restlichen Werte aus a nach b Beachten Sie: in der Anweisung b[indexB++]=a[indexA++]; passieren mehrere Sachen auf einmal: einerseits b[indexB]=a[indexA]; und au\u00dferdem noch indexB++; und indexA++ ; nach der Anweisung b[indexB++] = element; ist indexB um 1 gr\u00f6\u00dfer als indexA (was ja auch gut ist, siehe im Bild das \"rote\" Kopieren) Spielen Sie den Fall durch, dass eine 0 in das Beispiel-Array aus der Abbildung eingef\u00fcgt werden soll! Dann wird die erste while -Schleife gar nicht betreten, da die (Teil-)Bedingung a[indexA]<element gleich false ist Spielen Sie den Fall durch, dass eine 27 in das Beispiel-Array aus der Abbildung eingef\u00fcgt werden soll! Dann wird die zweite while -Schleife gar nicht betreten, da die Bedingung indexB<b.length gleich false ist Die Bedingung der ersten while -Schleife lautet indexA<a.length && a[indexA]<element . K\u00f6nnte man das auch umdrehen und a[indexA]<element && indexA<a.length schreiben? Nein, das k\u00f6nnte zu einem Fehler f\u00fchren. Der Operator && hat (im Gegensatz zum Operator & ) die Eigenschaft, dass die zweite Teilbedingung (also a[indexA]<element ) gar nicht mehr gepr\u00fcft wird, wenn die erste bereits false ist. Angenommen, die Teilbedingung indexA<a.length ist false , dann ist indexA==a.length . Dann k\u00f6nnen wir aber nicht mehr mit a[indexA] auf ein Element in a zugreifen, da der Index a.length nicht existiert. Wir w\u00fcrden eine ArrayIndexOutOfBoundsException geworfen bekommen. F\u00fcr den Fall also, dass das neu einzuf\u00fcgende Element ganz an das Ende des neuen Arrays b kommt, muss die Bedingung genau in dieser Reihenfolge formuliert werden. Success Wir kennen jetzt Arrays. Wir k\u00f6nnen sie erzeugen, wir k\u00f6nnen sie miteinander verbinden. Wir k\u00f6nnen Elemente darin suchen, sowohl in sortierten als auch in unsortierten Arrays. Wir k\u00f6nnen Elemente einf\u00fcgen. Bitte beachten Sie, dass die Elemente eines Arrays von jedem beliebigen Typ sein k\u00f6nnen, auch Referenztypen. Jetzt lernen wir noch, wie wir Arrays sortieren k\u00f6nnen und werden uns sp\u00e4ter nochmal mit Arrays besch\u00e4ftigen, deren Elemente von Referenztypen sind und somit Objekte beinhalten. ganz genau geben wir die Referenz auf das copy -Array zur\u00fcck, aber dazu sp\u00e4ter \u21a9","title":"Arrays"},{"location":"arrays/#arrays","text":"In einer Variable k\u00f6nnen wir genau einen Wert speichern. Wenn wir 5 Werte speichern wollen, ben\u00f6tigen wir 5 Variablen und wenn wir 1000 Werte speichern wollen, ben\u00f6tigen wir 1000 Variablen. Das ist nat\u00fcrlich unzweckm\u00e4\u00dfig. Wenn Sie mehrere Werte gleichen Typs speichern wollen, dann verwenden Sie dazu besser Arrays ( Felder ). Arrays sind Objekte. Wir schauen uns mal ein einf\u00fchrendes Beispiel an. Angenommen, wir wollen 5 int -Werte 0 , 1 , 4 , 9 und 16 speichern. Bis jetzt ben\u00f6tigten wir dazu 5 Variablen: int number1 = 0 ; int number2 = 1 ; int number3 = 4 ; int number4 = 9 ; int number5 = 16 ; Jetzt wollen wir dazu ein Array verwenden. Die Erzeugung und Initialisierung sieht so aus: 1 2 3 4 5 6 int [] numbers = new int [ 5 ] ; // Array der Laenge 5 numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Ein Array erkennen wir an den eckigen Klammern [] . Unser Array im Beispiel ist vom Typ int , d.h. jedes Element in diesem Array ist vom Typ int . Arrays k\u00f6nnen von einem beliebigen Typ sein, sowohl Wertetypen als auch Referenztypen. Ein Array wird immer f\u00fcr genau einen Typ deklariert, bei uns int \u2192 deshalb int[] . Best\u00fcnde das Array aus lauter Strings, dann w\u00e4re der Typ String[] . In unserem Beispiel ist numbers die Referenzvariable, die auf unser Array-Objekt zeigt. Mithilfe des Schl\u00fcsselwortes new wird unser Array erzeugt. Nach new kommt nochmal das Array ( Typ[] ), aber in den eckigen Klammern steht die L\u00e4nge des Arrays. In unserem Beispiel 5 . Bei der Erzeugung des Arrays muss immer die L\u00e4nge angegeben werden. Die L\u00e4nge eines Arrays kann sich nicht \u00e4ndern. Der Zugriff auf die einzelnen Elemente erfolgt \u00fcber den Index . Jedes Array ist automatisch \"nummeriert\". Die \"Nummerierung\" (der Index) beginnt immer mit 0 und erh\u00f6ht sich f\u00fcr jedes Element um 1 . Der Index eines Arrays ist immer vom Typ int . Wir k\u00f6nnen uns unser Array numbers so vorstellen: Wir haben 5 Elemente (L\u00e4nge 5 ), die jeweils durch den Index nummeriert sind. Diese Elemente k\u00f6nnen nun Werte enthalten: Der Zugriff auf die Werte eines Arrays erfolgt dann immer unter Verwendung der Referenzvariable, dahinter eckige Klammern und in den Klammern der entsprechende Index: Referenzvariable[Index]=Wert; Also in unserem Beispiel numbers[0] .","title":"Arrays"},{"location":"arrays/#erzeugung-und-initialisierung-eines-arrays","text":"Die Erzeugung und Initialisierung eines Arrays erfolgt in drei Schritten: Schritt: Definition einer Referenzvariablen, die auf das Array-Objekt zeigt (siehe oben in Zeile 1 : int[] numbers ) Schritt: Erzeugen des Arrays, d. h. eines Array-Objektes, das aus Elementen eines bestimmten Datentyps besteht (und Zuweisung an die zuvor definierte Referenzvariable - siehe oben Zeile 1 : new int[5] ) Schritt: Belegen der Array-Elemente mit Werten, d. h. Initialisierung des Arrays (siehe oben Zeilen 2-6 ). Beispiele verschiedene Arrays erzeugen: double [] noten = new double [ 10 ] ; // Array aus double-Elemente Laenge 10 String [] satz = new String [ 30 ] ; // Array aus Zeichenketten Laenge 30 boolean [] filled = new boolean [ 100 ] ; // Array aus boolean-Elementen Laenge 100 int [] statistics = new int [ 10000 ] ; // Array aus int-Elementen Laenge 10000 Die Initialisierung erfolgt elementweise \u00fcber den Zugriff auf den Index, z.B. (siehe oben): numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Da der Index stets vom Typ int ist, h\u00e4tten wir unser Array auch wie folgt initialisieren k\u00f6nnen: 1 2 3 4 for ( int index = 0 ; index < 5 ; index ++ ) { numbers [ index ] = ( index * index ); } Beachten Sie: Der gr\u00f6\u00dfte Index ist immer um eins kleiner als die L\u00e4nge des Arrays (L\u00e4nge ist 5 , gr\u00f6\u00dfter Index ist 4 \u2192 deshalb index < 5 ) Der Index ist immer int , egal von welchem Typ das Array ist In unserem Beispiel entsprechen die Werte der einzelnen Elementen Quadratzahlen. Deshalb konnten wir als Wert (index * index) verwenden.","title":"Erzeugung und Initialisierung eines Arrays"},{"location":"arrays/#die-eigenschaft-length","text":"Jedes Array besitzt die Eigenschaft length . Dar\u00fcber k\u00f6nnen wir die L\u00e4nge des Arrays auslesen. Der Wert von length kann nicht neu gesetzt werden (ist konstant). Wir benutzen die Eigenschaft length insbesondere in den Schleifen, mit denen wir auf den Index zugreifen. Referenzvariable.length Unser obiges Initialisierungsbeispiel h\u00e4tte also besser so ausgesehen: 1 2 3 4 for ( int index = 0 ; index < numbers . length ; index ++ ) { numbers [ index ] = ( index * index ); }","title":"Die Eigenschaft length"},{"location":"arrays/#ausgabe-der-werte","text":"Den jetzt bereits bekannten Zugriff auf die einzelnen Elemente k\u00f6nnen wir auch f\u00fcr das Auslesen der Werte eines Arrays verwenden: 1 2 3 4 for ( int index = 0 ; index < numbers . length ; index ++ ) { System . out . println ( numbers [ index ] ); }","title":"Ausgabe der Werte"},{"location":"arrays/#verwenden-der-werte","text":"Wir erl\u00e4utern ein einfaches Beispiel zur Verwendung der Werte, wir bilden die Summe aller Werte \u00fcber das Array (wir gehen davon aus, dass das numbers -Array so wie oben erzeugt un initialisiert wurde): int sum = 0 ; for ( int index = 0 ; index < numbers . length ; index ++ ) { sum = sum + numbers [ index ] ; } System . out . println ( \"Summe aller Elemente : \" + sum );","title":"Verwenden der Werte"},{"location":"arrays/#mogliche-andere-form-der-erzeugung-und-initialisierung","text":"Das Array kann auch in einer anderen Form erzeugt und initialisiert werden: int [] numbers = { 0 , 1 , 4 , 9 , 16 }; Diese Form erzeugt ein int[] -Array der L\u00e4nge 5 mit den Werten numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Es handelt sich um eine einfache Form der Erzeugung und Initialisierung in einem Schritt.","title":"M\u00f6gliche andere Form der Erzeugung und Initialisierung"},{"location":"arrays/#weitere-beispiele-von-arrays","text":"Wir zeigen einige Beispiele anderer Arrays: 1 2 3 4 5 6 7 8 9 10 11 String [] satz = new String [ 4 ] ; satz [ 0 ] = \"Das\" ; satz [ 1 ] = \"ist\" ; satz [ 2 ] = \"ein\" ; satz [ 3 ] = \"Satz\" ; for ( int index = 0 ; index < satz . length - 1 ; index ++ ) { System . out . print ( satz [ index ] + \" \" ); } System . out . println ( satz [ satz . length - 1 ] + \".\" ); Das Beispiel zeigt die Erzeugung und Initialisierung eines Arrays, in dem alle Elemente vom Typ String sind. Nach der Erzeugung und Initialisierung in den Zeilen 1 bis 5 folgt die Ausgabe der Werte des Arrays. Es werden alle Werte ausgegeben und ein Leerzeichen angeh\u00e4ngt. Das gilt aber nur f\u00fcr alle Elemente einschlie\u00dflich des vorletzten ( index<satz.length-1 ). Hinter das letzte Element ( satz[satz.length-1] ) folgt kein Leerzeichen, sondern ein Punkt. Wir h\u00e4tten das Array auch so erzeugen und initialisieren k\u00f6nnen: String[] satz = {\"Das\", \"ist\", \"ein\", \"Satz\"}; Ein weiteres Beispiel mit einem char -Array: 1 2 3 4 5 6 7 8 9 char [] alphabet = new char [ 26 ] ; for ( int index = 0 ; index < 26 ; index ++ ) { alphabet [ index ] = ( char ) ( index + 65 ); } for ( int index = 0 ; index < 26 ; index ++ ) { System . out . print ( alphabet [ index ]+ \" \" ); } Es wird zun\u00e4chst ein char -Array erzeugt (Zeile 1 ) und initialisiert (Zeilen 2 bis 5 ). Anschlie\u00dfend wird es ausgelesen Zeilen 6 bis 9 ). Es entsteht folgende Ausgabe: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Success Wir k\u00f6nnen uns Arrays erzeugen und initialisieren. Wir k\u00f6nnen Werte in diesen Arrays \u00e4ndern und aus den Arrays auslesen. Wir kennen die length -Variable von Arrays und k\u00f6nnen den Index verwenden, um auf die einzelnen Elemente zuzugreifen. N\u00e4chste Woche geht es mit Arrays weiter!","title":"Weitere Beispiele von Arrays"},{"location":"arrays/#algorithmen-uber-arrays","text":"Wir werden uns mit verschiedenen Algorithmen besch\u00e4ftigen, die alle Arrays zur Grundlage haben. Wir beginnen zur Auffrischung mal mit einer kleinen \u00dcbung. Wir wollen ein Array erstellen, in dem die Fibonacci-Folge enthalten ist. Diese geht so, dass das erste Element den Wert 0 hat und das zweite Element den Wert 1 und alle nachfolgenden Elemente als Wert die Summe der Werte ihrer beiden Vorg\u00e4nger hat, also 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... . Ausgangspunkt ist also etwas in der folgenden Art: public void main ( String [] args ) { int length = 20 ; int [] fibonacci = new int [ length ] ; fibonacci [ 0 ] = 0 ; fibonacci [ 1 ] = 1 ; } Bef\u00fcllen Sie den Rest des fibonacci -Arrays! public void main ( String [] args ) { int length = 20 ; int [] fibonacci = new int [ length ] ; fibonacci [ 0 ] = 0 ; fibonacci [ 1 ] = 1 ; for ( int index = 2 ; index < fibonacci . length ; index ++ ) { fibonacci [ index ] = fibonacci [ index - 1 ] + fibonacci [ index - 2 ] ; } } Wir wollen dieses Array nun mehrfach verwenden, um anhand von Beispielen einige Algorithmen \u00fcber Arrays kennenzulernen. Beachten Sie, dass wir f\u00fcr das fibonacci -Array die L\u00e4nge auf 20 festgesetzt hatten. Dies k\u00f6nnen wir aber problemlos \u00e4ndern und deutlich l\u00e4ngere fibonacci -Arrays erstellen. Alles, was wir dazu tun m\u00fcssen, ist den Wert von length zu \u00e4ndern. Beachten Sie au\u00dferdem, dass length eine von uns erzeugte Variable ist, aber fibonacci.length eine Variable des Arrays (deren Wert wir nicht \u00e4ndern, sondern nur auslesen k\u00f6nnnen).","title":"Algorithmen \u00fcber Arrays"},{"location":"arrays/#methoden-mit-arrays-als-parameter","text":"Wir werden uns einige Methoden erstellen, um z.B. ein als Parameter \u00fcbergebenes Array auszugeben oder einige Berechnungen \u00fcber die Werte des Arrays durchzuf\u00fchren. Wir beginnen damit, uns eine Methode zu schreiben, die ein als Parameter \u00fcbergebenes Array auf die Konsole ausgibt.","title":"Methoden mit Arrays als Parameter"},{"location":"arrays/#ausgabe-der-werte-auf-die-konsole","text":"Zun\u00e4chst wollen wir alle Werte nur durch Leerzeichen getrennt auf die Konsole ausgeben. Die dazugeh\u00f6rige Methode sieht so aus: 1 2 3 4 5 6 7 8 public void printArray ( int [] a ) { for ( int index = 0 ; index < a . length ; index ++ ) { System . out . print ( a [ index ] + \" \" ); } System . out . println (); } Wir \u00fcbergeben also ein int[] -Array als Parameter und durchlaufen es in einer Schleife vollst\u00e4ndig von index=0 bis index=a.length-1 und geben alle Werte von a[index] auf die Konsole durch Leerzeichen getrennt aus. Wenn wir nun in main() printArray(fibonacci); aufrufen, bekommen wir folgende Ausgabe: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 Jetzt wollen wir die Ausgabe \u00e4ndern. Das Array soll in folgender Form ausgegeben werden: [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 , 987 , 1597 , 2584 , 4181 ] Das hei\u00dft, die Werte sollen alle innerhalb von eckigen Klammern erscheinen und die Werte sind durch Komma getrennt. Das Hauptproblem dabei ist, dass nach dem letzten Wert kein Komma ausgegeben werden soll. Angenommen, wir \u00e4ndern obigen Code nur geringf\u00fcgig: 1 2 3 4 5 6 7 8 9 public void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } System . out . println ( \" ]\" ); } dann h\u00e4tten wir eine Ausgabe in der Form: [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 , 987 , 1597 , 2584 , 4181 , ] Wir h\u00e4tten also schonmal die eckigen Klammern, aber nach dem letzten Wert k\u00e4me noch ein Komma. Deshalb lassen wir nun die Schleife nur noch bis index<a.length-1 laufen und behandeln das letzte Element extra. Welchen Index hat das letzte Element von a ? Wir kennen die L\u00e4nge nicht, wir kennen aber a.length . Das letzte Element hat den Index a.length-1 , d.h. der gr\u00f6\u00dfte Index ist stets die L\u00e4nge des Arrays minus 1. Wir k\u00f6nnten die Methode also so schreiben: 1 2 3 4 5 6 7 8 9 10 public void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length - 1 ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } System . out . print ( a [ a . length - 1 ] ); System . out . println ( \" ]\" ); } Jetzt gibt es nur noch ein kleines Problem: Was passiert, wenn die L\u00e4nge des Arrays 0 ist, das als Parameter \u00fcbergebene Array also gar keine Elemente besitzt? Ein solches Array lie\u00dfe sich z.B. durch int [] arr1 = new int [ 0 ] ; int [] arr2 = {}; erzeugen. Wenn a die L\u00e4nge 0 h\u00e4tte, dann w\u00fcrden wir mit a[a.length-1] auf das Element von a mit dem Index -1 zugreifen wollen und ein solches Element/ein solcher Index existiert nicht. Es w\u00fcrde eine ArrayIndexOutOfBounds -Exception geworfen werden. Um sich dagegen zu sch\u00fctzen, pr\u00fcfen wir vor diesem Zugriff noch, ob die L\u00e4nge gr\u00dfer als 0 ist: 1 2 3 4 5 6 7 8 9 10 11 12 13 public void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length - 1 ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } if ( a . length > 0 ) { System . out . print ( a [ a . length - 1 ] ); } System . out . println ( \" ]\" ); } Was wird ausgegeben, wenn a die L\u00e4nge 0 hat? [ ] Schreiben Sie die obige Methode so, dass die Ausgabe nicht auf der Konsole erfolgt, sondern der Ausgabe-String zur\u00fcckgegeben wird! public String getOutputStringOfArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } return s ; }","title":"Ausgabe der Werte auf die Konsole"},{"location":"arrays/#maximumwert-ermitteln","text":"Angenommen, wir bekommen ein int[] -Array als Parameter \u00fcbergeben und sollen den gr\u00f6\u00dften Wert innerhalb dieses Arrays ermitteln (und zur\u00fcckgeben). Eine Idee f\u00fcr einen solchen Algorithmus w\u00e4re: wir merken uns das aktuelle Maximum in einer Variablen wir laufen durch das Array durch und immer wenn der aktuelle Wert im Array gr\u00f6\u00dfer ist, als unser aktuelles Maximum, speichern wir den Wert als (neues) aktuelles Maximum wenn wir vollst\u00e4ndig durch das Array durchgelaufen sind, haben wir den gr\u00f6\u00dften Wert als aktuelles Maximum gespeichert und k\u00f6nnen ihn zur\u00fcckgeben Eine solche Implementierung k\u00f6nnte so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 public int getMaximum ( int [] a ) { int currentMaximum = 0 ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]> currentMaximum ) { currentMaximum = a [ index ] ; } } return currentMaximum ; } Das sieht zun\u00e4chst exakt wie die Implementierung des oben beschriebenen Algorithmus' aus. In Zeile 3 erstellen wir unsere Variable currentMaximum , mit der wir uns das aktuelle Maximum speichern wollen. Mit der for -Schleife laufen wir durch alle Elemente unseres Arrays (Zeile 4 ) und wenn ein Wert aus dem Array gr\u00f6\u00dfer ist als das bis dahin gespeicherte Maximum (Zeile 6 ), speichern wir den Wert des Elements als neues Maximum (Zeile 8 ). Nach dem Verlassen der for -Schleife ist der gr\u00f6\u00dfte Wert in currentMaximum gespeichert und kann zur\u00fcckgegeben werden. Wir testen das mal in main() mit unserer Fibonacci-Folge und rufen System.out.println(getMaximum(fibonacci)); auf. Wir erhalten: 4181 Es scheint also zu funktionieren. Wir haben jedoch ein Problem: Was passiert, wenn die Werte in a alle negativ sind? Dann w\u00fcrde der Vergleich in Zeile 6 nie true sein und currentMaximum nie den Wert \u00e4ndern, da der initiale Wert von currentMaximum gr\u00f6\u00dfer als alle Werte aus dem Array ist. Wir m\u00fcssen also etwas am initialen Wert von currentMaximum \u00e4ndern. Eine Idee ist, dass wir currentMaximum mit dem ersten Wert aus dem a -Array initialisieren: 1 2 3 4 5 6 7 8 9 10 11 12 public int getMaximum ( int [] a ) { int currentMaximum = a [ 0 ] ; for ( int index = 1 ; index < a . length ; index ++ ) { if ( a [ index ]> currentMaximum ) { currentMaximum = a [ index ] ; } } return currentMaximum ; } Dann m\u00fcssen wir beim Schleifendurchlauf nur noch alle Elemente betrachten, deren Index >=1 ist, da wir das Element mit dem Index 0 (das erste Element aus a ) bereits bei der Initialisierung von currentMaximum betrachtet haben. Nun funktioniert unsere Methode auch f\u00fcr Arrays, die nur negative Werte enthalten. Ein Problem bleibt noch: Was passiert, wenn das Array a leer ist, also eine L\u00e4nge von 0 hat? Dann k\u00f6nnen wir n\u00e4mlich auch nicht a[0] aufrufen, da dieses Element (der Index 0 ) nicht existiert. Wir bek\u00e4men eine ArrayIndexOutOfBounds -Exception. Hierbei stellt sich die grunds\u00e4tzliche Frage, was durch unsere Methode zur\u00fcckgegeben werden soll, wenn das \u00fcbergebene Array gar kein Maximum hat, n\u00e4mlich dann, wenn es leer ist? Darauf gibt es keine befriedigende Antwort. W\u00fcr m\u00fcssen ein int zur\u00fcckgeben, aber kein int aus dem Wertebereich w\u00e4re korrekt. Grunds\u00e4tzlich sollte so etwas vor Aufruf der Methode gepr\u00fcft werden. Wir k\u00f6nnten uns z.B. eine Methode isEmpty() schreiben: public boolean isEmpty ( int [] a ) { return ( a . length == 0 ); } Diese Methode gibt true zur\u00fcck, wenn das Array a leer ist (also die L\u00e4nge 0 ) hat und false sonst. Diese Methode kann man f\u00fcr den Aufruf von getMaximum() verwenden: if ( ! isEmpty ( arr1 )) { int maximum = getMaximum ( arr1 ); } Das hei\u00dft, wir rufen die Methode getMaximum() f\u00fcr ein Array nur dann auf, wenn wir wissen, dass dieses Array nicht leer ist. Dann arbeitet unsere Methode n\u00e4mlich korrekt - und nur dann.","title":"Maximumwert ermitteln"},{"location":"arrays/#zwei-arrays-auf-gleichheit-prufen","text":"Wir wollen eine Methode schreiben, die \u00fcberpr\u00fcft, ob 2 Arrays gleich sind - also vollst\u00e4ndig gleiche Werte enthalten. Z.B. sollen diese Arrays gleich sein: int [] arr1 = { 8 , 9 , 2 , 3 , 7 , 4 , 1 , 0 , 9 , 6 }; int [] arr2 = { 8 , 9 , 2 , 3 , 7 , 4 , 1 , 0 , 9 , 6 }; aber int [] arr3 = { 8 , 9 , 2 , 3 , 7 , 5 , 1 , 0 , 9 , 6 }; ist ungleich zu arr1 und arr2 , da arr3 an 6. Stelle den Wert 5 statt 4 hat. Die algorithmische Idee ist: wir laufen gleichzeitig durch beide Arrays durch solange die Werte bei gleichem Index gleich sind, machen wir weiter sobald zwei Werte bei gleichem Index ungleich sind, wissen wir, dass die Arrays ungleich sind wenn wir alle Elemente betrachtet haben und alle waren gleich, dann sind auch unsere Arrays gleich 1 2 3 4 5 6 7 8 9 10 11 12 public boolean areEqual ( int [] a , int [] b ) { boolean areEqual = true ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]!= b [ index ] ) { areEqual = false ; } } return areEqual ; } Diese Methode setzt unseren Algorithmus um und wenn wir die Methode mit den obigen Arrays testen System . out . println ( areEqual ( arr1 , arr2 )); System . out . println ( areEqual ( arr1 , arr3 )); , dann wird auch korrekt true false ausgegeben. Doch was passiert, wenn wir die Methode f\u00fcr diese beiden Arrays aufrufen: int [] arr4 = { 8 , 9 , 2 }; int [] arr5 = { 8 , 9 , 2 , 3 }; Welcher Wert wird bei Aufruf System.out.println(areEqual(arr4, arr5)); ausgegeben? true Wollen wir das? Welcher Wert wird bei Aufruf System.out.println(areEqual(arr5, arr4)); ausgegeben? keiner, sondern Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 Warum? Grunds\u00e4tzlich sollte es bei einer solchen Methode egal sein, welche Reihenfolge die \u00fcbergebenen Arrays in der Parameterliste haben, d.h. areEqual(arr4, arr5) und areEqual(arr5, arr4) sollten den gleichen Wert zur\u00fcckliefern, denn entweder sind sie gleich true oder sie sind es nicht false . Die Gleichheit ist eine symmetrische Relation . Was ist das Problem unserer bisherigen L\u00f6sung? Wir durchlaufen die Schleife auch dann, wenn die Arrays unterschiedliche L\u00e4nge haben. In dem Aufruf areEqual(arr4, arr5) wird das letzte Element von arr5 gar nicht mehr gepr\u00fcft, da der index in der Schleife nur bis arr4.length-1 l\u00e4uft. In dem Aufruf areEqual(arr5, arr4) wird versucht, das letzte Element von arr5 mit einem Element von arr4 zu vergleichen, das gar nicht existiert. Der Zugriff auf arr4[3] f\u00fchrt zu einer ArrayIndexOutOfBoundsException . Wir werden deshalb zun\u00e4chst pr\u00fcfen, ob die beiden Arrays \u00fcberhaupt gleich lang sind und nur dann durchlaufen wir die beiden Arrays: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public boolean areEqual ( int [] a , int [] b ) { boolean areEqual = true ; if ( a . length != b . length ) { areEqual = false ; } for ( int index = 0 ; index < a . length && areEqual ; index ++ ) { if ( a [ index ]!= b [ index ] ) { areEqual = false ; } } return areEqual ; } Au\u00dferdem haben wir in die for -Schleife die Bedingung um && areEqual erweitert. Das hat zwei Gr\u00fcnde: erstens betreten wir die for -Schleife dann gar nicht, wenn die beiden Arrays unterschiedliche L\u00e4ngen haben, denn dann ist areEqual==fasle und somit ist die gesamte Bedingung index < a.length && areEqual false . \u2192 das ist also notwendig, um korrekt zu sein (wir k\u00f6nnten auch die for -Schleife in den else -Block der Selektion packen) zweitens beenden wir das Durchlaufen der for -Schleife sofort, wenn wir ungleiche Elemente gefunden haben, denn dann setzen wir ja auch areEqual auf false . Es gen\u00fcgt ja, zwei ungleiche Elemente zu finden, dann sind die Arrays ungleich und wir m\u00fcssen gar nicht weiter suchen. \u2192 das ist also nicht notwendig, aber performanter Zur \u00dcbung mit einem Array als Parameter k\u00f6nnen Sie: Bestimmen Sie die Summe aller Werte eines int -Arrays, welches als Parameter der Methode \u00fcbergeben wird. Geben Sie die Summe zur\u00fcck. public int getSumme ( int [] a ) { int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ i ] ; } return sum ; } Bestimmen Sie den Durchschnitt/Mittelwert aller Werte eines int -Arrays, welches als Parameter der Methode \u00fcbergeben wird. Geben Sie den Durchschnitt zur\u00fcck zur\u00fcck. public double getAverage ( int [] a ) { /* * diese Aufgabe ist leider komplizierter, da wir * das Problem haben, dass getSumme(a) ein int * zurueckliefert und a.length ebenfalls ein int ist * und wir somit int / int rechnen, also eine * ganzzahlige Division durchf\u00fchren * Mithilfe des Typkonvertierungsoperators (double) * k\u00f6nnen wir aber aus einem int ein double machen, * z.B. wird mit (double)a.length aus der Laenge ein * double * int / double ist eine Gleitkommadivision * Probieren Sie es einmal ohne (double) und * einmal mit (double) aus */ double average = getSumme ( a ) / ( double ) a . length ; return average ; }","title":"Zwei Arrays auf Gleichheit pr\u00fcfen"},{"location":"arrays/#methoden-mit-array-als-ruckgabe","text":"Wir betrachten nun Methoden, die ein Array zur\u00fcckgeben. Wir fangen an mit einer Methode, der eine int length \u00fcbergeben wird und die damit ein int[] der L\u00e4nge length erzeugt und dieses Array mit Zufallszahlen bef\u00fcllt: 1 2 3 4 5 6 7 8 9 10 public int [] createAndFillArray ( int length ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt (); } return a ; } Betrachten wir die Methode genauer: in Zeile 3 wird eine Variable a vom Typ int[] deklariert und ein int[] -Array der L\u00e4nge length erzeugt. Die Variable a zeigt auf dieses neu erzeugte Array. in Zeile 4 erzeugen wir ein Random -Objekt und die Referenzvariable r vom Typ Random zeigt auf dieses Objekt. Beachten Sie, dass Sie die Klasse Random aus dem java.util -Paket importieren m\u00fcssen! in den Zeilen 5-8 laufen wir durch das Array durch und belegen jedes Element mit einer Zufallszahl indem wir r.nextInt() aufrufen. in Zeile 9 wird das Array zur\u00fcckgegeben. Aufruf der Methode in main() (oder einer anderen Methode): int [] arr6 = createAndFillArray ( 5 ); printArray ( arr6 ); Wir rufen die Methode mit einem Wert 5 f\u00fcr length auf. Das bedeutet, dass die Methode ein Array der L\u00e4nge 5 erzeugt und mit Zufallszahlen bef\u00fcllt. Das zur\u00fcckgegebene Arry speichern wir in der Variablen arr6 , die ebenfalls vom Typ int[] ist. Wir geben das Array mithilfe der von uns erzeugten Methode printArray(arr6); aus (wir h\u00e4tten auch direkt printArray(createAndFillArray(5)); aufrufen k\u00f6nnen, dann h\u00e4tten wir das erzeugte Array aber nirgendwo gespeichert). Es erscheint z.B. eine Ausgabe wie: [ 1463666318 , -2121738539, -1174806146, 337579240 , -108604609 ] Wenn wir den Wertebereich der zuf\u00e4llig erzeugten Zahlen eingrenzen m\u00f6chten, z.B. nur Werte aus dem Bereich [0, 1, ..., 19] , k\u00f6nnen wir die nextInt(int bound) -Methode von Random verwenden ( siehe ). Wir erweitern die Methode createAndFillArray() um einen solchen bound -Parameter: 1 2 3 4 5 6 7 8 9 10 public int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } Beachten Sie, dass bei nextInt(int bound) der Wert von bound exklusiv ist, d.h. dieser Wert gibt die erste Zahl an, die nicht mehr zuf\u00e4llig erzeugt wird. Wenn wir also zuf\u00e4llig Zahlen aus dem Bereich [0, 1, ..., 19] erzeugen wollen, dann muss bound=20 sein. Der Aufruf von int [] arr7 = createAndFillArray ( 10 , 20 ); printArray ( arr7 ); erzeugt dann z.B. eine solche Ausgabe (bei Ihnen nat\u00fcrlich anders - sind ja Zufallszahlen): [ 2 , 17 , 7 , 5 , 17 , 3 , 19 , 8 , 6 , 18 ]","title":"Methoden mit Array als R\u00fcckgabe"},{"location":"arrays/#array-kopieren","text":"Wir erstellen eine Methode, der ein Array als Parameter \u00fcbergeben wird und die davon eine Kopie erstellt und diese Kopie zur\u00fcckgibt. 1 2 3 4 5 6 7 8 9 10 public int [] copyArray ( int [] original ) { int length = original . length ; int [] copy = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) { copy [ index ] = original [ index ] ; } return copy ; } in Zeile 1 wird das Original-Array \u00fcbergeben und in der Referenzvariablen original gespeichert, in Zeile 3 erstellen wir uns eine Variable length vom Typ int , in der die L\u00e4nge des Original-Arrays gespeichert wird, in Zeile 4 wird das copy -Array erstellt, das genau so lang ist, wie das Original, In den Zeilen 5-8 kopieren wir jeden einzelnen Wert aus dem Original-Array in das copy -Array (elementweise), in Zeile 9 geben wir das copy -Array zur\u00fcck 1 Der Aufruf der Methode, z.B. int [] original = createAndFillArray ( 10 , 20 ); System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original ); System . out . print ( \"copy : \" ); printArray ( copy ); erzeugt folgende Ausgabe (Zufallszahlen): original : [ 2 , 2 , 5 , 19 , 19 , 6 , 1 , 1 , 4 , 8 ] copy : [ 2 , 2 , 5 , 19 , 19 , 6 , 1 , 1 , 4 , 8 ] Angenommen, wir \u00fcbergeben unserer Methode nicht nur das Original-Array, sondern auch eine L\u00e4nge, bis zu der das Original-Array kopiert werden soll. Der Methodenkopf w\u00fcrde dann also so aussehen: public int [] copyArray ( int [] original , int newLength ) Dann gibt es 3 verschiedene Varianten: Original-Array und Kopie des Arrays gleich lang (wenn newLength == original.length ) Original-Array k\u00fcrzer als Kopie (z.B. falls Original-Array zu klein geworden ist, um weitere Elemente einzuf\u00fcgen; wenn newLength > original.length ) Original-Array l\u00e4nger als Kopie (falls nur ein Teil kopiert werden soll; wenn newLength < original.length ) Wir f\u00fcgen in unsere Methode eine entsprechende Fallunterscheidung ein: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public int [] copyArray ( int [] original , int newLength ) { int [] copy = new int [ newLength ] ; if ( original . length <= newLength ) { for ( int index = 0 ; index < original . length ; index ++ ) { copy [ index ]= original [ index ] ; } } else { for ( int index = 0 ; index < copy . length ; index ++ ) { copy [ index ]= original [ index ] ; } } return copy ; } in Zeile 1 wurde der neue Parameter newLength hinzugef\u00fcgt, der die L\u00e4nge des copy -Arrays bestimmt, in Zeile 3 wird das copy -Array mit der L\u00e4nge newLength erzeugt, in Zeile 4 erfolgt die Fallunterscheidung: falls die Kopie mindestens so lang ist wie das Original, werden alle Elemente aus dem Original in die Kopie kopiert (Zeilen 6-9 ) \u2192 Beachten Sie Verwendung von original.length in der Bedingung der for -Schleife, falls die Kopie k\u00fcrzer ist als das Original, werden nur die ersten newLength Elemente aus dem Original-Array kopiert (Zeilen 13-16 ) \u2192 Beachten Sie Verwendung von copy.length in der Bedingung der for -Schleife, Bei dem Aufruf von int [] original = createAndFillArray ( 10 , 20 ); // Original Laenge 10 System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original , 8 ); // Kopie Laenge 8 System . out . print ( \"copy : \" ); printArray ( copy ); erfolgt folgende Ausgabe (Zufallszahlen): original : [ 8 , 13 , 11 , 4 , 7 , 2 , 5 , 1 , 15 , 5 ] copy : [ 8 , 13 , 11 , 4 , 7 , 2 , 5 , 1 ] Bei dem Aufruf von int [] original = createAndFillArray ( 10 , 20 ); // Original Laenge 10 System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original , 18 ); // Kopie Laenge 18 System . out . print ( \"copy : \" ); printArray ( copy ); erfolgt folgende Ausgabe (Zufallszahlen): original : [ 1 , 18 , 0 , 9 , 12 , 18 , 2 , 8 , 17 , 12 ] copy : [ 1 , 18 , 0 , 9 , 12 , 18 , 2 , 8 , 17 , 12 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] Beachten Sie, dass Elementen, denen kein Wert zugewiesen wurde, den Wert 0 haben (Standardwert von int ).","title":"Array kopieren"},{"location":"arrays/#array-verketten","text":"Wir erstellen eine Methode, der zwei Arrays als Parameter \u00fcbergeben werden und die daraus ein neues Array erstellt, welche alle Elemente des einen und alle Elemente des anderen Arrays enth\u00e4lt. Die algorithmische Idee dabei ist wie folgt: Array a und Array b aneinanderh\u00e4ngen: neues Array c erzeugen (die L\u00e4nge von c ergibt sich aus a.length + b.length ), Elemente von a nach c kopieren (bis Index a.length-1 ), Elemente von b nach c kopieren (ab Index a.length ), c zur\u00fcckgeben Die folgende Abbildung verdeutlicht ein Beispiel mit a.length==6 und b.length==4 . Es wird ein Array c mit L\u00e4nge 10 erzeugt. In die ersten 6 Elemente von c werden die Werte von a kopiert und in die folgenden 4 Elemente die Werte von b . Beachten Sie, dass in dem Beispiel z.B. c[6]=b[0] kopiert wird. Eine m\u00f6gliche Methode k\u00f6nnte so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public int [] concatArrays ( int [] a , int [] b ) { int [] c = new int [ a . length + b . length ] ; for ( int index = 0 ; index < a . length ; index ++ ) { c [ index ] = a [ index ] ; } for ( int index = 0 ; index < b . length ; index ++ ) { c [ index + a . length ] = b [ index ] ; } return c ; } Wichtig ist hier, unbedingt zu verstehen, warum wir innerhalb der zweiten for -Schleife c[index+a.length] = b[index]; verwenden!","title":"Array verketten"},{"location":"arrays/#suchen-in-arrays","text":"Bei der Suche in Arrays geht es darum, einen bestimmten Wert zu finden, der im Array enthalten ist (oder er wird nicht gefunden, falls er nicht im Array existiert.) Grunds\u00e4tzlich m\u00fcssen wir zwischen der Suche in unsortierten und sortierten Arrays unterscheiden. In sortierten Arrays sind die Elemente alle hinsichtlich ihrer Werte geordnet, also z.B. numerisch bei Zahlen oder alphanumerisch bei Zeichen und Zeichenketten. Wir beginnen mit der Suche in unsortierten Arrays.","title":"Suchen in Arrays"},{"location":"arrays/#suche-in-unsortierten-arrays","text":"Wir wollen eine Methode erstellen, der ein Array \u00fcbergeben wird und ein Element gleichen Typs. Die Methode soll ein true zur\u00fcckgeben, wenn das Element in dem Array enthalten ist und ein false , wenn nicht. Die Idee dabei ist wir durchlaufen das Array solange, bis wir entweder das Element gefunden haben \u2192 dann k\u00f6nnen wir die Suche beenden und ein true zur\u00fcckgeben oder wir am Ende des Arrays angekommen sind und das Element nicht gefunden haben \u2192 dann geben wir ein false zur\u00fcck Eine solche Methode k\u00f6nnte so aussehen: public boolean contains ( int [] a , int element ) { boolean found = false ; for ( int index = 0 ; index < a . length && ! found ; index ++ ) { if ( a [ index ]== element ) { found = true ; } } return found ; } Wir pr\u00fcfen also, ob element als Wert in a enthalten ist. in Zeile 3 definieren wir uns eine Variable found , deren Wert initial auf false gesetzt wird ( element noch nicht gefunden) in Zeilen 4-10 durchlaufen wir das Array, entweder so lange bis wir das element gefunden haben (Zeilen 6-9 ) \u2192 found==true oder bis wir das Ende des Arrays erreicht haben ( index==a.length ) \u2192 found==false in Zeile 11 geben wir den Wert von found zur\u00fcck Beachten Sie, dass es wichtig ist, dass found initial den Wert false bekommt und dass die Schleife sofort verlassen wird, sobald wir das Element gefunden haben (Schleifen bedingung && !found ). Wir bleiben bei der Suche in unsortierten Arrays. Jetzt soll unsere Methode aber den Index zur\u00fcckgeben, an dem das Element im Array enthalten ist. Wir wissen, dass der Index nur Werte zwischen 0 und array.length-1 annehmen kann, also nur positive Werte. Wenn das Element nicht im Array enthalten ist, dann geben wir eine -1 zur\u00fcck. Hierbei sind zwei Sachen zu beachten: Erstens sollten wir solche \"Codierungen\" von R\u00fcckgabewerten vermeiden. Die aufrufende Methode muss ja \"wissen\", dass ein negativer R\u00fcckgabewert bedeutet, dass das Element gar nicht im Array enthalten ist. Auf der anderen Seite m\u00fcssen wir aber ein int zur\u00fcckgeben. Im Gegensatz zur getMaximum() -Methode oben, gibt es hier jedoch zumindest eine \"L\u00f6sung\" f\u00fcr das Problem, dass das Element nicht enthalten ist. Trotzdem sollte man auf jeden Fall zun\u00e4chst contains() aufrufen und nur, wenn contains() ein true zur\u00fcckliefert, dann die getIndex() -Methode. Zweitens ist die -1 eine sogenannte magic number . Wir sollten ihr einen Namen geben. Wir betrachten die Methode zun\u00e4chst ohne einen Namen f\u00fcr die -1 : 1 2 3 4 5 6 7 8 9 10 11 12 public int getIndex ( int [] a , int element ) { int indexAtElement = - 1 ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]== element ) { indexAtElement = index ; } } return indexAtElement ; } Wir durchlaufen das Array und sobald wir das element \"finden\" (Zeile 6 ), merken wir uns den aktuellen Index (Zeile 8 ). Am Ende wird der gemerkte Index zur\u00fcckgegeben (Zeile 11 ). Wenn Zeile 8 nie ausgef\u00fchrt wurde, dann wird der initiale Wert von indexAtElement zur\u00fcckgegeben, n\u00e4mlich -1 . Diese -1 ist eine sogenannte magic number . Man kennt die Bedeutung dieses Wertes nicht. Es ist deshalb besser, daf\u00fcr einen Namen einzuf\u00fchren - als Konstante (zu Konstanten siehe hier ). 1 2 3 4 5 6 7 8 9 10 11 12 13 public int getIndex ( int [] a , int element ) { final int NOT_FOUND = - 1 ; int indexAtElement = NOT_FOUND ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]== element ) { indexAtElement = index ; } } return indexAtElement ; } Eine Konstante ist eine Variable, die genau einmal einen Wert zugewiesen bekommt (initialisiert wird) und deren Wert nie wieder \u00fcberschrieben werden kann. Die Namen von Konstanten schreiben wir durchgehend GROSS. Angenommen, das element kommt mehrmals im Array a vor. Wird der erste Index des Auftretens von element im Array zur\u00fcckgegeben oder der letzte Index? Wie k\u00f6nnte man das \u00e4ndern? Der letzte. Man k\u00f6nnte beim ersten Finden des Elementes die Schleife sofort verlassen (aber nicht break; verwenden!)","title":"Suche in unsortierten Arrays"},{"location":"arrays/#suche-in-sortierten-arrays","text":"In sortierten Arrays sucht es sich etwas schneller nach einem element . Daf\u00fcr gibt es zwei Gr\u00fcnde: einerseits kann eine sequentielle Suche (also das Durchlaufen des Arrays) schneller abgebrochen werden, falls das Element nicht im Array enthalten ist, denn sobald man einen Wert im Array erreicht, der gr\u00f6\u00dfer ist, als der gesuchte Wert, kann das element ja gar nicht mehr vorkommen (falls das Array aufsteigend sortiert ist) andererseits kann man Algorithmen anwenden, die den Suchraum schnell einschr\u00e4nken, eine sogenannte bin\u00e4re Suche . Wir betrachten zun\u00e4chst die sequentielle Suche. Angenommen, wir haben folgendes aufsteigend sortiertes Array: [ 0 , 2 , 2 , 3 , 4 , 4 , 5 , 7 , 8 , 9 , 11 , 11 , 11 , 14 , 16 , 16 , 18 , 18 , 18 , 19 ] und angenommen, wir wollen pr\u00fcfen, ob die 10 im Array enthalten ist. In einem unsortierten Array m\u00fcssten wir das gesamte Array durchlaufen, um zu merken, dass die 10 nicht enthalten ist. Hier, bei dem sortierten Array, merken wir das schon, wenn wir die erste 11 gefunden haben, denn danach kann die 10 nicht mehr kommen. Die contains() -Methode kann also ein weiteres Abbruchkriterium der Suche enthalten: public boolean containsSorted ( int [] aSorted , int element ) { boolean found = false ; boolean greater = false ; for ( int index = 0 ; index < aSorted . length && ! found && ! greater ; index ++ ) { if ( aSorted [ index ]== element ) { found = true ; } if ( aSorted [ index ]> element ) { greater = true ; } } return found ; } Im Vergleich zur contains() -Methode f\u00fcr unsortierte Arrays haben wir einen weiteren \"Schalter\" hinzugef\u00fcgt, greater . Damit haben wir auch die Bedingung in der for -Schleife erweitert ( && !greater ). Sollten wir das element noch nicht gefunden haben, der Wert aSorted[index] aber gr\u00f6\u00dfer als element sein (Zeile 11 ), setzen wir greater auf true und die Schleife wird verlassen. Funktioniert die contains() -Methode, die wir f\u00fcr unsortierte Arrays implementiert haben, auch f\u00fcr sortierte Arrays? Ja, wir nutzen nur die M\u00f6glichkeit des fr\u00fcheren Abbruchs der Suche nicht aus. Schreiben Sie eine Methode getIndexSorted(int[] aSorted, int element) , die den Index von element in a zur\u00fcckgibt (und sonst -1 ). Genau wie getIndex() f\u00fcr unsortierte Arrays, aber auch hier nutzen Sie die fr\u00fchere Abbruchm\u00f6glichkeit der Suche aus. public int getIndexSorted ( int [] aSorted , int element ) { final int NOT_FOUND = - 1 ; boolean greater = false ; int indexAtElement = NOT_FOUND ; for ( int index = 0 ; index < aSorted . length && ! greater ; index ++ ) { if ( aSorted [ index ]== element ) { indexAtElement = index ; } if ( aSorted [ index ]> element ) { greater = true ; } } return indexAtElement ; } Bis jetzt sind wir immer sequenziell durch das Array durchgelaufen, also von vorne nach hinten, beginnend mit dem Index 0 bis wir bei array.length angekommen waren. In sortierten Arrays k\u00f6nnen wir das Prinzip \u00e4ndern: Wir fangen einfach in der Mitte des Arrays an und wenn der Wert, den wir suchen, kleiner ist, als der Wert in der Mitte, dann suchen wir links weiter und sonst suchen wir rechts weiter. Dann gehen wir mit der linken bzw. rechten H\u00e4lfte genau so vor usw. Diese Suche nennt sich bin\u00e4re Suche ( binary search ), in jedem Schritt wird der (verbliebene) Suchraum halbiert. Angenommen, wir suchen in dem folgenden Array die 25 : wir ermitteln zun\u00e4chst den Index, der in der Mitte des Arrays ist ( mid ). Dieser ergibt sich aus dem Mittelwert von lo (das ist der kleinste Index, der ist am Anfang 0 ) und hi (das ist der gr\u00f6\u00dfte Index, der ist am Anfang 14 , da unser Beispiel-Array die L\u00e4nge 15 hat). Unserer Index in der Mitte ist also mid=7 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 34 . 34 ist gr\u00f6\u00dfer als die gesuchte 25 \u2192 wir suchen also in dem linken Teil des Arrays weiter. Wir ermitteln den gr\u00f6\u00dften Index hi in diesem Teil (der ist um 1 kleiner als mid davor, also 6 ). Der Wert von lo bleibt 0 . Der neue Wert von mid ist 3 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 16 . 16 ist kleiner als die gesuchte 25 \u2192 wir suchen also in dem rechten Teil des Arrays weiter. Wir ermitteln den gr\u00f6\u00dften Index lo in diesem Teil (der ist um 1 gr\u00f6\u00dfer als mid davor, also 4 ). Der Wert von hi bleibt 6 . Der neue Wert von mid ist 5 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 25 . Wir haben das Element gefunden. Ehe Sie sich die Implementierung der bin\u00e4ren Suche anschauen, sollten Sie in dem Beispiel aus dem Bild noch die 41 suchen. Achten Sie insbesondere darauf, wie sich die Werte von lo , mid und high in jedem Suchschritt \u00e4ndern. wir beginnen mit lo=0 , hi=14 und also mid=7 . Der Wert im Index 7 ist 34 und somit kleiner als die gesuchte 41 \u2192 wir suchen rechts weiter lo=8 , hi=14 und also mid=11 . Der Wert im Index 11 ist 46 und somit gr\u00f6\u00dfer als die gesuchte 41 \u2192 wir suchen links weiter lo=8 , hi=10 und also mid=9 . Der Wert im Index 9 ist 41 \u2192 gefunden Ehe Sie sich die Implementierung der bin\u00e4ren Suche anschauen, sollten Sie in dem Beispiel aus dem Bild noch die 42 suchen. Wann stellen Sie fest, dass die 42 nicht im Array enthalten ist? wir beginnen mit lo=0 , hi=14 und also mid=7 . Der Wert im Index 7 ist 34 und somit kleiner als die gesuchte 42 \u2192 wir suchen rechts weiter lo=8 , hi=14 und also mid=11 . Der Wert im Index 11 ist 46 und somit gr\u00f6\u00dfer als die gesuchte 42 \u2192 wir suchen links weiter lo=8 , hi=10 und also mid=9 . Der Wert im Index 9 ist 41 und somit kleiner als die gesuchte 42 \u2192 wir suchen rechts weiter lo=10 , hi=10 und also mid=10 . Der Wert im Index 10 ist 46 \u2192 nicht gefunden ( hi und lo haben den gleichen Wert \u2192 zu Ende) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public boolean containsBinarySearch ( int [] aSorted , int element ) { boolean found = false ; int lo = 0 ; int hi = aSorted . length - 1 ; while ( lo <= hi && ! found ) { int mid = ( hi + lo ) / 2 ; if ( element == aSorted [ mid ] ) // gefunden { found = true ; } else // nicht gefunden { if ( element < aSorted [ mid ] ) // links weitersuchen { hi = mid - 1 ; } else // element > aSorted[mid] rechts weitersuchen { lo = mid + 1 ; } } } return found ; } in Zeile 4 wir die lo -Variable mit dem Index-Wert 0 initialisiert (kleinster Index), in Zeile 5 wir die hi -Variable mit dem Index-Wert aSorted.length-1 initialisiert (gr\u00f6\u00dfter Index), in Zeile 6 steht die Bedingung, wie lange die Suche fortgesetzt werden soll: solange das Element noch nicht gefunden wurde ( !found ) oder solange der kleinere Index lo kleiner (gleich) hi ist; falls element nicht gefunden wurde in Zeile 8 steht die Berechnung des mittleren Index mid . Beachten Sie, dass es sich um eine Integer-Division handelt. Es k\u00f6nnte also auch sein, dass die Summe von lo und hi ungerade ist, aber selbst dann ist mid eine ganze positive Zahl wenn das element gefunden wird (Bedingung in Zeile 9 ist true ), dann wird found auf true gesetzt und die while -Schleife wird verlassen wenn links weiter gesucht wird (Bedingung in Zeile 15 ist true ), dann wird hi neu gesetzt und die Schleifenbedingung erneut gepr\u00fcft wenn rechts weiter gesucht wird (Bedingung in Zeile 15 ist false ), dann wird lo neu gesetzt und die Schleifenbedingung erneut gepr\u00fcft zur\u00fcckgegeben (Zeile 25 ) wird true , wenn das element gefunden wurde (Zeilen 9-12 oder false , wenn es nicht gefunden wurde - initialer Wert von found ) Implementieren Sie eine getIndexBinarySearch() -Methode unter Verwendung des Prinzips der bin\u00e4ren Suche! public int getIndexBinarySearch ( int [] aSorted , int element ) { boolean found = false ; final int NOT_FOUND = - 1 ; int indexAtElement = NOT_FOUND ; int lo = 0 ; int hi = aSorted . length - 1 ; while ( lo <= hi && ! found ) { int mid = ( hi + lo ) / 2 ; if ( element == aSorted [ mid ] ) // gefunden { found = true ; indexAtElement = mid ; } else // nicht gefunden { if ( element < aSorted [ mid ] ) // links weitersuchen { hi = mid - 1 ; } else // element > aSorted[mid] rechts weitersuchen { lo = mid + 1 ; } } } return indexAtElement ; } Nur zur Info : Mithilfe der bin\u00e4ren Suche ist die Suche nach einem Element in einem sortierten Array enorm beschleunigt. Unter der Komplexit\u00e4t eines Algorithmus wird der Bedarf des Algorithmus an den zur Verf\u00fcgung stehenden Ressourcen Laufzeit (wie schnell?) \u2192 sogenannte Zeitkomplexit\u00e4t Speicherplatz (wie viel Speicherplatz n\u00f6tig?) \u2192 sogenannte Speicherkomplexit\u00e4t verstanden. Die Komplexit\u00e4t eines Algorithmus in Abh\u00e4ngigkeit von der Gr\u00f6\u00dfe n der von ihm bearbeiteten Daten ausgedr\u00fcckt. Daf\u00fcr hat sich die Landau-Notation durchgesetzt. Diese beschreibt mit O(n) sogenannte Komplexit\u00e4tsklassen . Beispielsweise wird die Verkettung von zwei Arrays der L\u00e4nge n und m mit der Komplexit\u00e4tsklasse O(n+m) angegeben (maximale Zeit- und Speicherkomplexit\u00e4t), w\u00e4hrend die Komplexit\u00e4tsklasse der sequentiellen Suche in unsortierten und sortierten Arrays O(n) ist und die bin\u00e4re Suche in sortierten Arrays O(log n) . Wir messen im Folgenden einmal den Zeitverbrauch der Methoden getIndex() , getIndexSorted() und getIndexBinarySearch() unter Verweung der Klassen Instant und Duration aus dem Paket java.time : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int [] test = createAndFillArray ( 100000000 , 10000000 ); Arrays . sort ( test ); Instant start = Instant . now (); int index = getIndex ( test , 80000000 ); Instant finish = Instant . now (); long duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); start = Instant . now (); index = getIndexSorted ( test , 80000000 ); finish = Instant . now (); duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); start = Instant . now (); index = getIndexBinarySearch ( test , 80000000 ); finish = Instant . now (); duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); Zeile 1 : Wir erstellen uns mithilfe der Methode createAndFillArray() ein Array mit 100 Millionen Eintr\u00e4gen. Zeile 2 : Unter Verwendung der Klasse Arrays (aus dem java.util -Paket) wird dieses Array sortiert (die Klasse kennen wir noch nicht). Zeile 3 : Mithilfe der Instant -Klasse (aus java.time ) und deren Methode now() ermitteln wir die aktuelle Zeit und speichern sie in der Variablen start (vom Typ Instant ); die Klasse kennen wir noch nicht Zeile 4 : Wir verwenden die Methode getIndex() , um das Element mit dem Wert 8.000.000 im Array test zu suchen Zeile 5 : Mithilfe Instant.now() ermitteln wir erneut die aktuelle Zeit und speichern sie in der Variablen finish Zeile 6 : wir berechnen die Differenz zwischen finish und start in Millisekunden und speichern sie in der Variablen duration vom Typ long (zur Differenzberechnung verwenden wir die Klasse Duration aus dem java.time -Paket; die Klasse kennen wir noch nicht) Zeile 7 : wir geben den Index und die Dauer der Ausf\u00fchrung aus Zeile 10 : wir wiederholen alles mit der getIndexSorted() -Methode Zeile 16 : wir wiederholen alles mit der getIndexBinarySearch() -Methode Es erfolgt folgende Ausgabe (Element wurde in diesem Fall nicht gefunden): index : -1 duration : 47 index : -1 duration : 94 index : -1 duration : 0 getIndexBinarySearch() verbraucht also (fast) keine Zeit. Es \u00fcberrascht vielleicht, dass getIndexSorted() doppelt so viel Zeit verbraucht, wie getIndex() . Das liegt aber daran, dass in getIndex() einerseits die Bedingung der for -Schleife nur eine Pr\u00fcfung enth\u00e4lt, w\u00e4hrend es in getIndexSorted() drei Teilbedingungen sind, die verkn\u00fcpft werden m\u00fcssen und es au\u00dferdem in getIndex() innerhalb der for -Schleife nur eine Bedingung zur Pr\u00fcfung gibt, w\u00e4hrend es in getIndexSorted() zwei sind. Da das gesuchte Element mit dem Wert 8 Mio relativ weit hinten im Array liegen w\u00fcrde (der Bereich der Zufallszahlen ist [0 ... 9999999] Zufallszahlen in den 100 Mio Eintr\u00e4gen des Arrays), ist der Vorteil der Suche im sortierten Array hier zu gering. W\u00fcrden wir z.B. stattdessen nach der Zahl 100000 suchen, w\u00e4re das Ergebnis so: index : 1000579 duration : 53 index : 1000579 duration : 4 index : 1000575 duration : 0","title":"Suche in sortierten Arrays"},{"location":"arrays/#einfugen-in-arrays","text":"Hier geht es darum, dass wir ein Element in ein Array einf\u00fcgen wollen. Wir unterscheiden wieder zwischen dem Einf\u00fcgen in ein unsortiertes und dem Einf\u00fcgen in ein sortiertes Array. Wir betrachten zun\u00e4chst das Einf\u00fcgen in ein unsortiertes Array.","title":"Einf\u00fcgen in Arrays"},{"location":"arrays/#einfugen-in-ein-unsortiertes-array","text":"Angenommen, wir haben folgendes int -Array a : und wir wollen ein weiteres Element mit dem Wert 13 einf\u00fcgen. Man k\u00f6nnte auf die Idee kommen, dass die Elemente mit dem Index 10 bis 14 daf\u00fcr zur Verf\u00fcgung stehen, da diese mit dem Standartwert f\u00fcr int , der 0 belegt sind. Aber woher sollen wir wissen, dass dies gar keine \"richtigen\" Werte sind? Da das Array ein unsortiertes int -Array ist, k\u00f6nnen Nullen an allen Stellen vorkommen. Bei dem Einf\u00fcgen in ein unsortiertes Array handelt es sich eigentlich um ein Anh\u00e4ngen ( append ) des neuen Elementes an das alte Array. Wir ben\u00f6tigen dazu ein neues Array, das um 1 l\u00e4nger ist als das urspr\u00fcngliche Array. Wir gehen also wie folgt vor: wir erzeugen ein neues Array b , das um 1 l\u00e4nger ist als das Array a wir kopieren alle Werte aus a nach b wir speichern in das letzte Element von b den neuen Wert element Eine m\u00f6gliche Implementierung daf\u00fcr sieht so aus: 1 2 3 4 5 6 7 8 9 10 11 public int [] append ( int [] a , int element ) { int [] b = new int [ a . length + 1 ] ; for ( int index = 0 ; index < a . length ; index ++ ) { b [ index ]= a [ index ] ; } b [ b . length - 1 ] = element ; return b ; } in Zeile 3 wird das neue Array b erzeugt, das um 1 \u00e4nger ist als a in den Zeilen 4-7 werden alle Werte aus a nach b kopiert in Zeile 9 wird dem letzten Element von b der Wert element zugewiesen Es geschieht also folgendes: Wir merken uns also: das Einf\u00fcgen in ein unsortiertes Array ist in Wirklichkeit ein Anh\u00e4ngen des Elementes an ein unsortiertes Array. Dazu muss ein neues Array erzeugt werden, das um 1 l\u00e4nger ist als das Array, an das angeh\u00e4ngt werden soll.","title":"Einf\u00fcgen in ein unsortiertes Array"},{"location":"arrays/#einfugen-in-ein-sortiertes-array","text":"Das Einf\u00fcgen in ein sortiertes Array ist deutlich komplizierter, denn das einzuf\u00fcgende Element muss korrekt, d.h. an die richtige Stelle entsprechend der Sortierung, eingef\u00fcgt werden. Angenommen, wir haben folgende Ausgangsposition: Das einzuf\u00fcgende Element mit dem Wert 13 muss zwischen die beiden Elemente mit den Werten 12 und 14 eingef\u00fcgt werden. Wir gehen dabei wie folgt vor: wir erzeugen ein neues Array b , das um 1 l\u00e4nger ist als a wir kopieren alle Werte aus a nach b solange die Werte kleiner sind als das einzuf\u00fcgende Element wenn wir auf das erste Element in a sto\u00dfen, das gr\u00f6\u00dfer ist als das einzuf\u00fcgende Element, f\u00fcgen wir das Element ein danach kopieren wir die restlichen Werte aus a nach b Wir setzen obigen Algorithmus in folgender Methode um: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int [] insertIntoSortedArray ( int [] a , int element ) { int [] b = new int [ a . length + 1 ] ; int indexB = 0 , indexA = 0 ; while ( indexA < a . length && a [ indexA ]< element ) { b [ indexB ++]= a [ indexA ++] ; } b [ indexB ++] = element ; // from now on indexB = indexA+1 while ( indexB < b . length ) { b [ indexB ++]= a [ indexA ++] ; } return b ; } in Zeile 3 wird das Array b erzeugt, welches um 1 l\u00e4nger ist als a in Zeilen 5-8 kopieren wir alle Werte aus a nach b , die kleiner sind als unser element in Zeile 10 wird element in b eingef\u00fcgt in Zeilen 12-15 kopieren wir die restlichen Werte aus a nach b Beachten Sie: in der Anweisung b[indexB++]=a[indexA++]; passieren mehrere Sachen auf einmal: einerseits b[indexB]=a[indexA]; und au\u00dferdem noch indexB++; und indexA++ ; nach der Anweisung b[indexB++] = element; ist indexB um 1 gr\u00f6\u00dfer als indexA (was ja auch gut ist, siehe im Bild das \"rote\" Kopieren) Spielen Sie den Fall durch, dass eine 0 in das Beispiel-Array aus der Abbildung eingef\u00fcgt werden soll! Dann wird die erste while -Schleife gar nicht betreten, da die (Teil-)Bedingung a[indexA]<element gleich false ist Spielen Sie den Fall durch, dass eine 27 in das Beispiel-Array aus der Abbildung eingef\u00fcgt werden soll! Dann wird die zweite while -Schleife gar nicht betreten, da die Bedingung indexB<b.length gleich false ist Die Bedingung der ersten while -Schleife lautet indexA<a.length && a[indexA]<element . K\u00f6nnte man das auch umdrehen und a[indexA]<element && indexA<a.length schreiben? Nein, das k\u00f6nnte zu einem Fehler f\u00fchren. Der Operator && hat (im Gegensatz zum Operator & ) die Eigenschaft, dass die zweite Teilbedingung (also a[indexA]<element ) gar nicht mehr gepr\u00fcft wird, wenn die erste bereits false ist. Angenommen, die Teilbedingung indexA<a.length ist false , dann ist indexA==a.length . Dann k\u00f6nnen wir aber nicht mehr mit a[indexA] auf ein Element in a zugreifen, da der Index a.length nicht existiert. Wir w\u00fcrden eine ArrayIndexOutOfBoundsException geworfen bekommen. F\u00fcr den Fall also, dass das neu einzuf\u00fcgende Element ganz an das Ende des neuen Arrays b kommt, muss die Bedingung genau in dieser Reihenfolge formuliert werden. Success Wir kennen jetzt Arrays. Wir k\u00f6nnen sie erzeugen, wir k\u00f6nnen sie miteinander verbinden. Wir k\u00f6nnen Elemente darin suchen, sowohl in sortierten als auch in unsortierten Arrays. Wir k\u00f6nnen Elemente einf\u00fcgen. Bitte beachten Sie, dass die Elemente eines Arrays von jedem beliebigen Typ sein k\u00f6nnen, auch Referenztypen. Jetzt lernen wir noch, wie wir Arrays sortieren k\u00f6nnen und werden uns sp\u00e4ter nochmal mit Arrays besch\u00e4ftigen, deren Elemente von Referenztypen sind und somit Objekte beinhalten. ganz genau geben wir die Referenz auf das copy -Array zur\u00fcck, aber dazu sp\u00e4ter \u21a9","title":"Einf\u00fcgen in ein sortiertes Array"},{"location":"aufgaben/","text":"Aufgaben \u00b6 Hier finden Sie die Aufgaben. Die Abgabefristen der einzelnen Aufgaben stehen hier . Beachten Sie die nachfolgenden Hinweise zum Hochladen der Aufgaben. Hinweise zur Abgabe der Aufgaben \u00b6 Die Aufgaben laden Sie in Moodle unter dem Reiter \"Aufgaben\" hoch. Dort ist f\u00fcr jede Aufgabe eine Moodle-Aufgabe erstellt. Beachten Sie, dass ein Hochladen nach Ablauf der Abgabefrist nicht mehr m\u00f6glich ist. BlueJ vs. Eclipse \u00b6 Die ersten Wochen verwenden wir als Entwicklungsumgebung BlueJ. F\u00fcr die Aufgaben, die wir mit BlueJ l\u00f6sen, werde ich Ihnen jeweils Hinweise zur Abgabe f\u00fcr jede Aufgabe einzeln geben. Sobald wir Eclipse verwenden, gelten die folgenden Hinweise: Achten Sie darauf, dass Sie die Quelldateien (also die .java -Dateien aus dem src -Verzeichnis) hochladen. Ihre Klassen erstellen Sie immer in einem package aufgaben.aufgabeX . Das hei\u00dft, Aufgabe1 ist im package aufgaben.aufgabe1 , Aufgabe2 im package aufgaben.aufgabe2 usw. In Ihrem workspace gibt es dann einen Ordner f\u00fcr Ihr Java-Projekt, z.B. WS21 (je nachdem, wie Sie Ihr Java-Projekt genannt haben) und darin befindet sich ein bin - und ein src -Ordner. In dem src -Ordner befindet sich dann ein Ordner aufgaben und darin ein Ordner aufgaben1 (f\u00fcr Aufgabe1). Darin befindet sich Ihre .java -Datei, die Sie hochladen sollen. Angenommen, Sie haben Ihre Klasse Aufgabe1 genannt, dann hei\u00dft die Klasse also Aufgabe1.java . Sie folgen also dem Pfad workspace \u2192 Java-Projekt (z.B. WS21 ) \u2192 src \u2192 aufgaben \u2192 aufgabe X . Wenn Ihre L\u00f6sung aus mehreren Klassen (mehreren .java -Dateien) besteht, k\u00f6nnen Sie entweder die Dateien einzeln hochladen oder Sie zippen Ihre Dateien (am besten dann den aufgabeX -Ordner und laden das .zip -File hoch. In Ihrer L\u00f6sung (Ihrer/n Klasse/n) f\u00fcgen Sie direkt oberhalb Ihrer Klassendefinition einen JavaDoc-Kommentar ein ( /** ... */ ). Dieser enth\u00e4lt ein @author -Tag. dahinter schreiben Sie Ihren Namen. Das sieht dann z.B. so aus: package aufgaben.aufgabe1 ; /** * * @author J\u00f6rn Freiheit * * Diese Klasse gibt auf die Konsole ein Rhombus (eine Raute) aus. * Der Rhombus ist entweder gefuellt oder ungefuellt. * */ public class Aufgabe1 { // hier Ihre Implementierung } Sie k\u00f6nnen Ihre Aufgaben zu zweit l\u00f6sen. Tragen Sie dann hinter das @author -Tag beide Namen ein und laden Sie bitte beide die L\u00f6sung in Moodle hoch! Code Review \u00b6 F\u00fcr jede abgegebene Aufgabe wird Ihnen die L\u00f6sung einer Kommilitonin zum Review zugewiesen. Analysieren Sie den Code Ihrer Kommilitonin und geben Sie ihr dazu eine R\u00fcckmeldung! Es gen\u00fcgen 2 bis 3 Review-Kommentare. Zur offiziellen Abgabe einer Aufgabe geh\u00f6ren also das Hochladen der eigenen L\u00f6sung, das Analysieren/Kommentieren einer fremden L\u00f6sung. Hinweise zum Review: \u00b6 Es geht nicht darum, das Programm zu \u00fcberarbeiten, sondern darum es nachzuvollziehen und Ihrer Kommilitonin eine R\u00fcckmeldung und eventuell Anregungen zu geben. Weisen Sie sowohl auf St\u00e4rken als auch auf Schw\u00e4chen des Quelltexts hin. Worauf Sie u.a. achten k\u00f6nnen: Ist der Quelltext gut strukturiert und verst\u00e4ndlich? Haben Variablen und Methoden passende Namen? Werden die Namen konsistent verwendet? Werden Konventionen eingehalten? Beispiel: Klassennamen starten immer mit Gro\u00dfbuchstaben, Objektnamen immer mit Kleinbuchstaben Ist das Programm \u00fcbersichtlich formatiert? Beispiel: kein horizontales Scrolling n\u00f6tig Machen Sie ggf. Vorschl\u00e4ge f\u00fcr (alternative) L\u00f6sungen. Gehen Sie respektvoll miteinander um, es gibt keinen Grund, unh\u00f6flich zu sein. Lesen Sie Ihre Kommentare noch einmal durch, bevor Sie sie an Ihre Kommilitonin weitergeben. Aufgaben \u00b6 Aufgabe 1 (Abgabe bis 25.10.2021 24:00 Uhr) \u00b6 Aufgabe1 - Square mit Circles Verwenden Sie BlueJ und \u00f6ffnen Sie das Projekt picture aus dem examples -Ordner von BlueJ. Speichern Sie das Projekt als Projekt aufgabe1 ab. Die Klasse Picture k\u00f6nnen Sie wie folgt anpassen: /** * Aufgabe 1 * */ public class Picture { /** * Constructor for objects of class Picture */ public Picture () { // nothing to do... instance variables are automatically set to null } /** * Draw this picture. */ public void draw () { Square s1 = new Square (); Circle c1 = new Circle (); Circle c2 = new Circle (); Circle c3 = new Circle (); Circle c4 = new Circle (); // hier die Implementierung } } Programmieren Sie die draw() -Methode so, dass folgendes Bild gezeichnet wird: Die Gr\u00f6\u00dfen bleiben Ihnen \u00fcberlassen, aber die vier Kreise sollen das gelbe Quadrat vollst\u00e4ndig ausf\u00fcllen. Den Titel des Fensters m\u00fcssen Sie nicht \u00e4ndern (geht aber in der Klasse Canvas ). Erstellen Sie sich eine Testklasse PictureTest , in der es eine Testmethode testDraw() gibt, die die draw() -Methode f\u00fcr ein Picture -Objekt ausf\u00fchrt. Zippen Sie Ihr Projekt aufgabe1 und laden es in Moodle hoch. Aufgabe 2 (Abgabe bis 01.11.2021 24:00 Uhr) \u00b6 Aufgabe2 - Methoden und Ausgaben Erstellen Sie sich ein neues Projekt aufgabe2 und darin eine neue Klasse Aufgabe2 , die wie folgt aussieht: public class Aufgabe2 { public Aufgabe2 () { } public void start () { // rufen Sie hier Ihre Methoden auf: } } Implementieren Sie eine Methode computeSum(double number1, double number2) , die die Summe der beiden Zahlen number1 und number2 als double zur\u00fcckgibt . Implementieren Sie eine Methode printSum(double number1, double number2 , die die Summe der beiden Zahlen number1 und number2 in der folgenden Form ausgibt . Die Ausgabe sieht f\u00fcr die Beispielwerte number1 = 4.0 und number2 = 5.0 so aus: 4 .0 + 5 .0 = 9 .0 Rufen Sie in der printSum(double number1, double number2 -Methode die Methode computeSum(double number1, double number2) auf! Implementieren Sie \u00e4hnliche Methoden auch f\u00fcr die Subtraktion, Multiplikation und Division von zwei double -Zahlen. Verwenden Sie jeweils die computeXXX() -Methoden in den printXXX() -Methoden. Erstellen Sie eine Methode printComputations(double number1, double number2) , in der alle vier printXXX() -Methoden aufgerufen werden, so dass durch den Aufruf der printComputations(double number1, double number2) -Methode folgende Ausgabe erscheint (Beispielwerte 4.0 und 5.0 ): 4 .0 + 5 .0 = 9 .0 4 .0 - 5 .0 = -1.0 4 .0 * 5 .0 = 20 .0 4 .0 / 5 .0 = 0 .8 Zippen Sie Ihr Projekt aufgabe2 und laden es in Moodle hoch. Aufgabe 3 (Abgabe bis 08.11.2021 24:00 Uhr) \u00b6 Aufgabe3 - Rechteck Erstellen Sie sich ein neues Projekt aufgabe3 und darin eine neue Klasse Aufgabe3 , die wie folgt aussieht: public class Aufgabe3 { public Aufgabe3 () { } public void start () { // rufen Sie hier Ihre Methoden auf: } } Implementieren Sie eine Methode public void printRectangle(int width, int height, boolean filled){} Ist der Parameterwert von filled true , dann soll ein Rechteck wie folgt auf die Konsole ausgegeben werden (Beispielausgabe f\u00fcr width=11 und height=5 ): *********** *********** *********** *********** *********** Ist der Parameterwert von filled false , dann soll das Rechteck ungef\u00fcllt sein, also so: *********** * * * * * * *********** Die obere Ausgabe ist also durch die Anweisung printRectangle(11, 5, true); und die untere durch die Anweisung printRectangle(11, 5, false); entstanden. Tipp: : Schreiben Sie sich zwei weitere Methoden public void printRectangleFilled(int width, int height){} und public void printRectangleUnfilled(int width, int height){} , die Sie entsprechend des Wertes von filled aufrufen. In der einen Methode erstellen Sie das ausgef\u00fcllte Rechteck und in der anderen das ungef\u00fcllte. Dann wird Ihr Programm nicht zu un\u00fcbersichtlich. Fangen Sie am besten mit der ausgef\u00fcllten an, die ist etwas leichter. Das Programm soll f\u00fcr beliebige (nicht so gro\u00dfe - max. Werte f\u00fcr width und height je 100 ) positive Zahlen (also > 0 ) funktionieren. Insbesondere sind die Tests f\u00fcr width=1 und height=1 bzw. height=2 interessant. Zippen Sie Ihr Projekt aufgabe3 und laden es in Moodle hoch. Viel Spa\u00df und viel Erfolg! Aufgabe 4 (Abgabe bis 15.11.2021 24:00 Uhr) \u00b6 Aufgabe4 - Rhombus Erstellen Sie sich ein neues Projekt aufgabe4 und darin eine neue Klasse Aufgabe4 , die wie folgt aussieht: public class Aufgabe4 { public Aufgabe4 () { } public void start () { // rufen Sie hier Ihre Methoden auf: } } Implementieren Sie eine Methode public void printRhombus(int upperHalf, boolean filled){} Ist der Parameterwert von filled true , dann soll ein Rhombus (eine Raute) wie folgt auf die Konsole ausgegeben werden: * *** ***** ******* ********* *********** ********* ******* ***** *** * Ist der Parameterwert von filled false , dann soll der Rhombus ungef\u00fcllt sein, also so: * * * * * * * * * * * * * * * * * * * * der Wert f\u00fcr upperHalf gibt die H\u00f6he einer H\u00e4lfte des Rhombus an. Die Gesamth\u00f6he des Rhombus berechnet sich aus ` int height = 2 * upperHalf + 1 ; In unserem oben gezeigten Beispiel ist der Wert von upperHalf 5 und die Gesamth\u00f6he des Rhombus 11 . Die obere Ausgabe ist also durch die Anweisung printRhombus(5, true); und die untere durch die Anweisung printRhombus(5, false); entstanden. Die Berechnung der H\u00f6he aus dem Parameterwert upperHalf hat die Vorteile, dass die H\u00f6he dadurch immer eine ungerade Zahl ist (was notwendig ist) und dass Sie den Wert upperHalf gut verwenden k\u00f6nnen (was ebenfalls notwendig ist, wie Sie merken werden) Tipp: : Schreiben Sie sich zwei weitere Methoden public void printRhombusFilled(int upperHalf){} und public void printRhombusUnfilled(int upperHalf){} , die Sie entsprechend des Wertes von filled aufrufen. In der einen Methode erstellen Sie die ausgef\u00fcllte Raute und in der anderen die ungef\u00fcllte. Dann wird Ihr Programm nicht zu un\u00fcbersichtlich. Fangen Sie am besten mit der ausgef\u00fcllten an, die ist etwas leichter. Das Programm soll f\u00fcr beliebige (nicht so gro\u00dfe - max. Wert 100 ) positive Zahlen (also > 0 ) von upperHalf funktionieren. Insbesondere sind die Tests f\u00fcr upperhalf == 1 interssant. Zippen Sie Ihr Projekt aufgabe4 und laden es in Moodle hoch. Viel Spa\u00df und viel Erfolg! Aufgabe 5 (Abgabe bis 22.11.2021 24:00 Uhr) \u00b6 Aufgabe5 - Knobeleien Diese Aufgabe ist haupts\u00e4chlich dazu da, um das algorithmische Denken zu schulen. Sie werden im Netz jeweils viele L\u00f6sungen finden, aber Sie sollten versuchen, alleine auf eine L\u00f6sung zu kommen. Versuchen Sie es! Ich gebe zu jeder Aufgabe kleine Tipps. Erstellen Sie sich ein neues Projekt aufgabe5 und darin eine neue Klasse Aufgabe5 , die wie folgt aussieht: public class Aufgabe5 { public Aufgabe5 () { } public void start () { // rufen Sie hier Ihre Methoden auf: } } Implementieren Sie eine Methode public int computeChecksum(int number){} . Diese Methode berechnet die Quersumme der Zahl number und gibt diese zur\u00fcck. Hier ein paar Beispiele: number: 123456 -> checksum: 21 number: -123456 -> checksum: -21 number: 0 -> checksum: 0 number: 2147483647 -> checksum: 46 number: -2147483648 -> checksum: -47 Tipp : \"Laufen\" Sie am besten von hinten nach vorne durch die Zahl number und l\u00f6sen immer die letzte Ziffer von der Zahl, um diese dann zur Quersumme zu addieren. Welchen Operator kennen Sie, um als Ergebnis die letzte Ziffer einer Dezimalzahl zu erhalten? Wie lange m\u00fcssen Sie \"laufen\"? Implementieren Sie eine Methode public void printCombinations36(){} . Diese Methode gibt alle Kombinationen f\u00fcr 3 ganze Zahlen x , y und z auf der Konsole aus, f\u00fcr die Folgendes gilt: x <= y <= z und x * y * z = 36 Tipp : \u00dcberlegen Sie sich zuerst, wie man z.B. alle Kombinationen ermitteln kann, wenn x , y und z jeweils Werte zwischen -50 und 50 (das ist aber nicht der endg\u00fcltige Wertebereich!!! - Sie k\u00f6nnen gerne auch anders anfangen) annehmen k\u00f6nnen (das sind dann 100^3 , also 1000000 Kombinationen). \u00dcberlegen Sie dann, wie Sie diese Wertebereiche mithilfe der beiden Bedingungen einschr\u00e4nken k\u00f6nnen. Es gibt \u00fcbrigens 28 Kombinationen, f\u00fcr die die beiden obigen Bedingungen gelten. Wenn Sie diese beiden Aufgaben erledigt haben, dann haben Sie genug geknobelt. Herzlichen Gl\u00fcckwunsch - Aufgabe erf\u00fcllt! Nur f\u00fcr diejenigen unter Ihnen, die vom Knobeln nicht genug bekommen k\u00f6nnen, gibt es die folgende Zusatzaufgabe. Ist aber wirklich keine Pflicht, sondern soll nur Vergn\u00fcgen sein :-) Zusatzaufgabe : Implementieren Sie eine Methode public void printPrimeFactors(int number){} , die f\u00fcr die \u00fcbergebene Zahl number die Primzahlfaktorzerlegung auf die Konsole ausgibt, also z.B. so: 480 --> 2 2 2 2 2 3 5 17 --> 17 12345 --> 3 5 823 Tipp: : N\u00fctzliche Methoden sind sicherlich boolean isPrime(int number) und boolean isDivider(int factor, int number) , wobei Letztere pr\u00fcft, ob factor ein ganzzahliger Teiler von number ist. Achten Sie darauf, dass wenn Sie einen Primfaktor gefunden haben, es auch derselbe Primfaktor wiederholt sein kann. Ist knifflig! Aufgabe 6 (Abgabe bis 29.11.2021 24:00 Uhr) \u00b6 Aufgabe6 - Triangle Wir erstellen uns einen neuen Datentyp Triangle Erstellen Sie sich ein neues Projekt aufgabe6 und darin eine neue Klasse Triangle sowie daf\u00fcr eine Testklasse TestTriangle mit einer testTriangle() -Methode. In der Klasse Triangle erstellen Sie drei Objektvariablen a , b und c jeweils vom Typ int und alle private . Das sollen die Seiten unseres Dreiecks sein. Erstellen Sie einen Konstruktor, dem drei Parameterwerte \u00fcbergeben werden pa , pb und pc alle vom Typ int . Mit diesen Werten werden die Objektvariablen initialisiert. Schreiben Sie eine Objektmethode print() , die die Seitenl\u00e4ngen des Dreiecks in der folgenden Form ausgibt: Seiten : a = 3 , b = 4 , c = 5 f\u00fcr den Fall, dass die Seitenl\u00e4ngen 3 , 4 und 5 sind. Wenn Sie jetzt in der testTriangle() -Methode der Testklasse TestTriangle folgende Anweisungen ausf\u00fchren Triangle t1 = new Triangle ( 3 , 4 , 5 ); Triangle t2 = new Triangle ( 4 , 4 , 7 ); Triangle t3 = new Triangle ( 5 , 5 , 5 ); Triangle t4 = new Triangle ( 4 , 5 , 3 ); Triangle t5 = new Triangle ( 4 , 3 , 5 ); Triangle t6 = new Triangle ( 3 , 4 , 5 ); t1 . print (); t2 . print (); t3 . print (); t4 . print (); t5 . print (); t6 . print (); dann sollte die Ausgabe ungef\u00e4hr so aussehen: Seiten : a = 3 , b = 4 , c = 5 Seiten : a = 4 , b = 4 , c = 7 Seiten : a = 5 , b = 5 , c = 5 Seiten : a = 4 , b = 5 , c = 3 Seiten : a = 4 , b = 3 , c = 5 Seiten : a = 3 , b = 4 , c = 5 Erstellen Sie in der Klasse Triangle eine Objektmethode public int circumference() , die den Umfang des Dreiecks zur\u00fcckgibt (also die Summe der drei Seitenl\u00e4ngen). Erstellen Sie in der Klasse Triangle eine Objektmethode public double area() , die den Flaecheninhalt des Dreiecks zur\u00fcckgibt. Der Fl\u00e4cheninhalt A eines Dreiecks l\u00e4sst sich nach der Heron'schen Formel wie folgt berechnen: A = Math.sqrt(s * (s-a) * (s-b) * (s-c)) wobei s = (a + b + c) / 2 Achten Sie darauf, dass Sie stets mit double rechnen! Beachten Sie, dass in einem Dreieck keine Seite l\u00e4nger sein darf als die Summe der beiden anderen. F\u00fcr die oben in der testTriangle() -Methode erstellten Objekte gilt das aber. Wir m\u00fcssen deshalb nichts weiter beachten. Erweitern Sie die Objektmethode print() nun so, dass auch der Umfang und der Flaecheninhalt in der folgenden Form ausgegeben werden (Sie k\u00f6nnen in die print() -methode auch die Leerzeile integrieren): Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Seiten : a = 4 , b = 4 , c = 7 Umfang : 15 Flaecheninhalt : 6 .777720855862979 Seiten : a = 5 , b = 5 , c = 5 Umfang : 15 Flaecheninhalt : 10 .825317547305483 Seiten : a = 4 , b = 5 , c = 3 Umfang : 12 Flaecheninhalt : 6 .0 Seiten : a = 4 , b = 3 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean equilateral() , die ein true zur\u00fcckgibt, wenn das Dreieck gleichseitig ist (also alle Seiten des Dreiecks gleich lang sind) und false sonst. Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean isosceles() , die ein true zur\u00fcckgibt, wenn das Dreieck gleichschenklig ist (also zwei Seiten des Dreiecks gleich lang sind) und false sonst. Erweitern Sie die Objektmethode print() nun so, dass die Pr\u00fcfungen, ob sich um ein gleichseitiges oder gleichschenkliges (oder unregelm\u00e4\u00dfiges) Dreieck handelt, in der folgenden Form ausgegeben werden: Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Seiten : a = 4 , b = 4 , c = 7 Umfang : 15 Flaecheninhalt : 6 .777720855862979 Das Dreieck ist gleichschenklig. Seiten : a = 5 , b = 5 , c = 5 Umfang : 15 Flaecheninhalt : 10 .825317547305483 Das Dreieck ist gleichseitig. Seiten : a = 4 , b = 5 , c = 3 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Seiten : a = 4 , b = 3 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgenden Aufgaben sind optional (kann auch sein, dass wir die Objektvergleiche noch gar nicht haben, dann wird es erst recht knifflig :-) ): Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean sameCircumference(Triangle t) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt den gleichen Umfang hat wie t und false sonst. Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean isSmaller(Triangle t) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren Fl\u00e4cheninhalt hat, als t und false sonst. Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean isBigger(Triangle t) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt einen gr\u00f6\u00dferen Fl\u00e4cheninhalt hat, als t und false sonst. Testen Sie in der testTriangle() -Methode der Testklasse TestTriangle die drei zuletztgeschriebenen Methoden, so dass folgende Ausgaben erzeugt werden: t1 und t2 gleicher Umfang ? : false t1 und t3 gleicher Umfang ? : false t2 und t3 gleicher Umfang ? : true t1 kleiner als t2 ? : true t2 kleiner als t1 ? : false t1 kleiner als t4 ? : false t4 kleiner als t1 ? : false t1 groesser als t2 ? : false t2 groesser als t1 ? : true t1 groesser als t4 ? : false t4 groesser als t1 ? : false Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean sidesAreEqual(Triangle t) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt die gleichen Seitenl\u00e4ngen hat wie t und false sonst. Beachten Sie, dass folgende Dreiecke mit z.B. dem Dreieck ( a=3, b=4, c=5 ) gleich sein sollen: ( a=3, b=4, c=5 ), aber auch ( a=4, b=5, c=3 ), aber auch ( a=5, b=3, c=4 ) \u2192 die \"Benennung\" der Seiten ist also egal Jedoch soll z.B. ( a=4, b=3, c=5 ) nicht gleich zu ( a=3, b=4, c=5 ) sein f\u00fcr die obigen Objekte soll somit gelten: t1 und t2 gleiche Seiten ? : false t1 und t4 gleiche Seiten ? : true t1 und t5 gleiche Seiten ? : false t1 und t6 gleiche Seiten ? : true Erzeugen Sie diese Ausgabe in testTriangle() . Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean isRightAngled() , die ein true zur\u00fcckgibt, wenn das Dreieck rechtwinklig ist und false sonst. der Satz des Pythagoras besagt, dass in einem rechtwinkligen Dreieck gilt: a^2 + b^2 = c^2 es gilt aber auch die Umkehrung, d.h. wenn von 2 Seiten die Summe der Quadrate dem Quadrat der dritten Seite entspricht, dann ist das Dreieck rechtwinklig Erweitern Sie die Objektmethode print() nun so, dass die Pr\u00fcfungen, ob sich um ein rechtwinkliges Dreieck handelt, in der folgenden Form ausgegeben werden: Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Das Dreieck ist rechtwinklig. Seiten : a = 4 , b = 4 , c = 7 Umfang : 15 Flaecheninhalt : 6 .777720855862979 Das Dreieck ist gleichschenklig. Das Dreieck ist nicht rechtwinklig. Seiten : a = 5 , b = 5 , c = 5 Umfang : 15 Flaecheninhalt : 10 .825317547305483 Das Dreieck ist gleichseitig. Das Dreieck ist nicht rechtwinklig. Seiten : a = 4 , b = 5 , c = 3 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Das Dreieck ist rechtwinklig. Seiten : a = 4 , b = 3 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Das Dreieck ist rechtwinklig. Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Das Dreieck ist rechtwinklig. Viel Spa\u00df und viel Erfolg! Aufgabe 7 (Abgabe bis 6.12.2021 24:00 Uhr) \u00b6 Aufgabe7 - Time Wir erstellen uns einen neuen Datentyp Time Erstellen Sie sich ein neues Projekt aufgabe7 und darin eine neue Klasse Time sowie daf\u00fcr eine Testklasse TimeTest mit einer testTime() -Methode. In der Klasse Time erstellen Sie zwei Objektvariablen hours und minutes , jeweils vom Typ int und beide private . Erstellen Sie einen parameterlosen Konstruktor, der die Objektvariablen mit jeweils 0 initialisiert. Implementieren Sie eine Methode public void changeTime(int diffMinutes) . Dieser Methode wird als Parameterwert eine Anzahl von Minuten \u00fcbergeben, um die sich die aktuelle Zeit \u00e4ndern soll. Beachten Sie: die Objektvariable minutes soll nur Werte von 0 bis 59 annehmen d\u00fcrfen, die Objektvariable hours soll nur Werte von 0 bis 23 annehmen d\u00fcrfen, diffMinutes kann auch negativ sein. Implementieren Sie eine Methode public String timeToString() . Diese Methode gibt die aktuelle Zeit in der Form hh:mm als String zur\u00fcck. Beachten Sie: Sowohl die Stunden als auch die Minuten haben eventuelle f\u00fchrende Nullen, d.h. Beispiele f\u00fcr den R\u00fcckgabestring k\u00f6nnen auch 01:00 sein oder 09:09 . Implementieren Sie eine Methode public void printTime() . Diese Methode gibt die aktuelle Uhrzeit unter Verwendung der Methode timeToString() auf die Konsole aus. Wenn Sie die Testmethode testTime() z.B. wie folgt implementieren: @Test public void testTime () { Time t1 = new Time (); t1 . printTime (); t1 . changeTime ( 30 ); t1 . printTime (); t1 . changeTime ( 30 ); t1 . printTime (); t1 . changeTime ( 60 ); t1 . printTime (); t1 . changeTime ( 600 ); t1 . printTime (); t1 . changeTime ( 660 ); t1 . printTime (); t1 . changeTime ( 60 ); t1 . printTime (); t1 . changeTime ( - 60 ); t1 . printTime (); } dann sollte folgende Ausgabe auf der Konsole erscheinen: 00 :00 00 :30 01 :00 02 :00 12 :00 23 :00 00 :00 23 :00 Insbesondere f\u00fcr die changeTime() -Methode sollten Sie erst ausf\u00fchrlich \u00fcberlegen, ehe Sie losprogrammieren. Nicht vergessen, dass Zettel und Stift die wichtigsten Werkzeuge der Programmiererin sind! Viel Spa\u00df und viel Erfolg! Aufgabe 8 (Abgabe bis 13.12.2021 24:00 Uhr) \u00b6 Aufgabe8 - Counter und Clock Wir erstellen uns zwei neue Datentypen Counter und Clock Erstellen Sie sich ein neues Projekt aufgabe8 und darin eine neue Klasse Counter sowie eine Programm-/Testklasse Programclass mit einer start() -Methode. Die Idee der Klasse Counter soll sein, einen counter bis zu einem bestimmten limit hochzuz\u00e4hlen. Bevor der counter das limit erreicht, wird er wieder auf 0 gesetzt. Angenommen also das limit ist 60 und der counter hat den aktuellen Wert 59 und soll erh\u00f6ht werden, dann ist der n\u00e4chste Wert von counter wieder 0 , da das limit erreicht wurde. In der Klasse Counter erstellen Sie zwei Objektvariablen counter und limit , jeweils vom Typ int (beide nur in der Klasse sichtbar). Erstellen Sie einen parametrisierten Konstruktor public Counter(int limit) , der den counter auf 0 initialisiert und das limit auf den Parameterwert. Implementieren Sie eine Methode public boolean increase() . Diese Methode soll den Wert von counter um 1 erh\u00f6hen. Es muss jedoch gepr\u00fcft werden, ob eventuell das limit erreicht wurde. Sollte dies der Fall sein, wird der Wert von counter wieder auf 0 gesetzt. Wird der counter tats\u00e4chlich um 1 erh\u00f6ht, gibt die Methode ein true zur\u00fcck, wurde der Wert von counter jedoch auf 0 gesetzt, gibt die Methode false zur\u00fcck. Beispiel: Angenommen counter hat den Wert 58 und das limit ist 60 . Dann ist der neue Wert von counter 59 und die Methode gibt true zur\u00fcck. Angenommen counter hat den Wert 59 und das limit ist 60 . Dann ist der neue Wert von counter 0 und die Methode gibt false zur\u00fcck. Implementieren Sie eine Methode public String toString() . Diese Methode gibt den Wert von counter als zweistelligen String zur\u00fcck. Beachten Sie Ist der Wert von counter einstellig, z.B. 5 , dann soll der String \"05\" zur\u00fcckgegeben werden. Implementieren Sie eine Methode public void print() . Diese Methode gibt den aktuellen Wert von counter unter Verwendung der Methode toString() auf die Konsole aus. Wenn Sie die Methode start() in der Programclass z.B. wie folgt implementieren: public void start () { Counter counter = new Counter ( 60 ); for ( int i = 0 ; i < 120 ; i ++ ) { counter . increase (); System . out . printf ( \"%3d : \" , i ); counter . print (); } } dann sollte folgende Ausgabe auf der Konsole erscheinen: Ausgabe auf der Konsole 0 : 01 1 : 02 2 : 03 3 : 04 4 : 05 5 : 06 6 : 07 7 : 08 8 : 09 9 : 10 10 : 11 11 : 12 12 : 13 13 : 14 14 : 15 15 : 16 16 : 17 17 : 18 18 : 19 19 : 20 20 : 21 21 : 22 22 : 23 23 : 24 24 : 25 25 : 26 26 : 27 27 : 28 28 : 29 29 : 30 30 : 31 31 : 32 32 : 33 33 : 34 34 : 35 35 : 36 36 : 37 37 : 38 38 : 39 39 : 40 40 : 41 41 : 42 42 : 43 43 : 44 44 : 45 45 : 46 46 : 47 47 : 48 48 : 49 49 : 50 50 : 51 51 : 52 52 : 53 53 : 54 54 : 55 55 : 56 56 : 57 57 : 58 58 : 59 59 : 00 60 : 01 61 : 02 62 : 03 63 : 04 64 : 05 65 : 06 66 : 07 67 : 08 68 : 09 69 : 10 70 : 11 71 : 12 72 : 13 73 : 14 74 : 15 75 : 16 76 : 17 77 : 18 78 : 19 79 : 20 80 : 21 81 : 22 82 : 23 83 : 24 84 : 25 85 : 26 86 : 27 87 : 28 88 : 29 89 : 30 90 : 31 91 : 32 92 : 33 93 : 34 94 : 35 95 : 36 96 : 37 97 : 38 98 : 39 99 : 40 100 : 41 101 : 42 102 : 43 103 : 44 104 : 45 105 : 46 106 : 47 107 : 48 108 : 49 109 : 50 110 : 51 111 : 52 112 : 53 113 : 54 114 : 55 115 : 56 116 : 57 117 : 58 118 : 59 119 : 00 Erstellen Sie sich im Projekt aufgabe8 eine weitere Klasse Clock . In der Klasse Clock verwenden Sie zwei Counter . Der eine Counter z\u00e4hlt die minutes und hat das limit 60 und der andere Counter z\u00e4hlt die hours udn hat das limit 24 . In der Klasse Clock erstellen Sie zwei Objektvariablen minutes und hours , jeweils vom Typ Counter (beide nur in der Klasse sichtbar). Erstellen Sie einen parameterlosen Konstruktor public Clock() . Darin erzeugen Sie f\u00fcr minutes das Counter -Objekt mit dem limit 60 und f\u00fcr hours das Counter -Objekt mit dem limit 24 . Implementieren Sie eine Methode public void increase() . Diese Methode soll den Wert von minutes um 1 erh\u00f6hen. Sollte jedoch das limit von minutes erreicht sein, wird auch hours um 1 erh\u00f6ht. Nutzen Sie die increase() -Methode von Counter ! Implementieren Sie eine Methode public String toString() . Diese Methode gibt die Werte von minutes und hours in der Form hh:mm als String zur\u00fcck, also z.B. \"23:59\" oder \"01:09\" . Nutzen Sie die toString() -Methode von Counter ! Implementieren Sie eine Methode public void print() . Diese Methode gibt den aktuellen Wert von Clock unter Verwendung der Methode toString() auf die Konsole aus. Wenn Sie die Methode start() in der Programclass z.B. wie folgt erweitern (der Test von Counter ist hier gel\u00f6scht): public void start () { Clock clock = new Clock (); for ( int i = 0 ; i < 1600 ; i ++ ) { clock . increase (); if ( i % 50 == 0 ) { System . out . printf ( \"%4d : \" , i ); clock . print (); } } } dann sollte folgende Ausgabe auf der Konsole erscheinen: Ausgabe auf der Konsole 0 : 00 :01 50 : 00 :51 100 : 01 :41 150 : 02 :31 200 : 03 :21 250 : 04 :11 300 : 05 :01 350 : 05 :51 400 : 06 :41 450 : 07 :31 500 : 08 :21 550 : 09 :11 600 : 10 :01 650 : 10 :51 700 : 11 :41 750 : 12 :31 800 : 13 :21 850 : 14 :11 900 : 15 :01 950 : 15 :51 1000 : 16 :41 1050 : 17 :31 1100 : 18 :21 1150 : 19 :11 1200 : 20 :01 1250 : 20 :51 1300 : 21 :41 1350 : 22 :31 1400 : 23 :21 1450 : 00 :11 1500 : 01 :01 1550 : 01 :51 Viel Spa\u00df und viel Erfolg! Aufgabe 9 (Abgabe bis 03.01.2022 24:00 Uhr) \u00b6 Aufgabe9 - Bruch Wir erstellen uns einen Datentyp Bruch (extra mal etwas Mathematisches ;-)) Erstellen Sie sich ein neues Projekt aufgabe9 und darin eine neue Klasse Bruch sowie eine Programm-/Testklasse Programclass mit einer main() -Methode. In der Klasse Bruch erstellen Sie zwei Objektvariablen zaehler und nenner jeweils vom Typ int und private . Implementieren Sie fu\u0308r die Klasse Bruch zwei verschiedene Konstruktoren parameterlos \u2192 zaehler und nenner erhalten jeweils den Wert 1 mit zwei Parametern ( int zaehler, int nenner ) \u2192 entspr. Werte der Objektvariablen Implementieren Sie folgende Objektmethoden public Bruch plus(Bruch b) \u2192 gibt den geku\u0308rzten Bruch aus der Addition eines Bruchs mit b zuru\u0308ck public Bruch minus(Bruch b) \u2192 gibt den geku\u0308rzten Bruch aus der Subtraktion eines Bruchs mit b zuru\u0308ck public Bruch mal(Bruch b) \u2192 gibt den geku\u0308rzten Bruch aus der Multiplikation eines Bruchs mit b zuru\u0308ck public Bruch geteilt(Bruch b) \u2192 gibt den geku\u0308rzten Bruch aus der Division eines Bruchs mit b zuru\u0308ck public Bruch kuerzen() \u2192 gibt den geku\u0308rzten Bruch zuru\u0308ck (Sie brauchen dazu den ggT ) _ public String toString() \u2192 gibt einen Bruch als String in der Form zaehler / nenner zur\u00fcck (annotieren Sie diese Methode als \u00fcberschrieben !) public int ggT(int zahl1, int zahl2) \u2192 gibt den gr\u00f6\u00dften gemeinsamen Teiler (ggT) der beiden Zahlen zahl1 und zahl2 als int zuru\u0308ck - siehe Euklidischer Algorithmus Geben Sie in die main() -Methode der Programclass -Klasse mindestens folgende Anweisungen ein: Bruch b1 = new Bruch ( 3 , 7 ); Bruch b2 = new Bruch ( 4 , 8 ); Bruch b3 = new Bruch ( 2 , 5 ); Bruch b4 = new Bruch ( 5 , 11 ); Bruch b5 = new Bruch (); System . out . printf ( \"%n%n------------------------- Rechnen -----------------------------------%n%n\" ); System . out . printf ( \"%5s + %5s = %5s %n\" , b1 . toString (), b2 . toString (), b1 . plus ( b2 ). toString ()); System . out . printf ( \"%5s - %5s = %5s %n\" , b3 . toString (), b4 . toString (), b3 . minus ( b4 ). toString ()); System . out . printf ( \"%5s * %5s = %5s %n\" , b1 . toString (), b3 . toString (), b1 . mal ( b3 ). toString ()); System . out . printf ( \"%5s / %5s = %5s %n\" , b2 . toString (), b1 . toString (), b2 . geteilt ( b1 ). toString ()); System . out . printf ( \"%5s + %5s = %5s %n\" , b5 . toString (), b4 . toString (), b5 . plus ( b4 ). toString ()); System . out . printf ( \"%5s - %5s = %5s %n\" , b1 . toString (), b1 . toString (), b1 . minus ( b1 ). toString ()); // nenner sollte ungleich 0 bleiben! und f\u00fchren Sie die main() -Methode aus. Es sollten folgende Augaben entstehen: ------------------------- Rechnen ----------------------------------- 3 /7 + 4 /8 = 13 /14 2 /5 - 5 /11 = -3/55 3 /7 * 2 /5 = 6 /35 4 /8 / 3 /7 = 7 /6 1 /1 + 5 /11 = 16 /11 3 /7 - 3 /7 = 0 /1 Implementieren Sie folgende Objektmethoden public boolean istGroesser(Bruch b) \u2192 gibt true zur\u00fcck, wenn der aufrufende Bruch gr\u00f6\u00dfer als b ist, false sonst public boolean istKleiner(Bruch b) \u2192 gibt true zur\u00fcck, wenn der aufrufende Bruch kleiner als b ist, false sonst public boolean istGleich(Bruch b) \u2192 gibt true zur\u00fcck, wenn der aufrufende Bruch gleich b ist, false sonst Geben Sie in die main() -Methode der Programclass -Klasse mindestens folgende weitere Anweisungen ein: System . out . printf ( \"%n%n------------------------- Vergleichen -----------------------------------%n%n\" ); System . out . printf ( \"%5s > %5s ? %b %n\" , b1 . toString (), b2 . toString (), b1 . istGroesser ( b2 )); System . out . printf ( \"%5s < %5s ? %b %n\" , b1 . toString (), b2 . toString (), b1 . istKleiner ( b2 )); System . out . printf ( \"%5s == %5s ? %b %n\" , b1 . toString (), b2 . toString (), b1 . istGleich ( b2 )); System . out . printf ( \"%5s > %5s ? %b %n\" , b3 . toString (), b4 . toString (), b3 . istGroesser ( b4 )); System . out . printf ( \"%5s < %5s ? %b %n\" , b3 . toString (), b4 . toString (), b3 . istKleiner ( b4 )); System . out . printf ( \"%5s == %5s ? %b %n\" , b3 . toString (), b4 . toString (), b3 . istGleich ( b4 )); System . out . printf ( \"%5s > %5s ? %b %n\" , b5 . toString (), b5 . toString (), b5 . istGroesser ( b5 )); System . out . printf ( \"%5s < %5s ? %b %n\" , b5 . toString (), b5 . toString (), b5 . istKleiner ( b5 )); System . out . printf ( \"%5s == %5s ? %b %n\" , b5 . toString (), b5 . toString (), b5 . istGleich ( b5 )); und f\u00fchren Sie die main() -Methode aus. Es sollten folgende weitere Ausgaben entstehen: ------------------------- Vergleichen ----------------------------------- 3 /7 > 4 /8 ? false 3 /7 < 4 /8 ? true 3 /7 == 4 /8 ? false 2 /5 > 5 /11 ? false 2 /5 < 5 /11 ? true 2 /5 == 5 /11 ? false 1 /1 > 1 /1 ? false 1 /1 < 1 /1 ? false 1 /1 == 1 /1 ? true Zusatzaufgabe : \u00dcberschreiben Sie f\u00fcr Bruch die Methoden public boolean equals(Object o) und public int hashCode() . Viel Spa\u00df und viel Erfolg! Aufgabe 10 (Abgabe bis 10.01.2022 24:00 Uhr) \u00b6 Aufgabe 10 - Arrays ausgeben L\u00f6sen Sie die Aufgabe mit Eclipse oder einer IDE Ihrer Wahl. Wir geben Arrays in verschiedenen Arten auf der Konsole aus. Erstellen Sie sich ein package aufgaben.aufgabe10 und in diesem package zwei Klassen Programmklasse (mit main() -Methode) und Aufgabe10 . Implementieren Sie in der Klasse Aufgabe10 eine Methode public int[] createAndFillArray(int length, int fromInclusive, int toInclusive) . Diese Methode soll genau so sein, wie die createAndFillArray(int length, int bound) -Methode in Methoden mit Array als R\u00fcckgabe mit dem einzigen Unterschied, dass wir nicht den bound angeben (der sorgt ja daf\u00fcr, dass wir Zufallswerte aus dem Bereich [0, 1, ... , bound-1] erzeugen), sondern fromInclusive und toExclusive , so dass wir Zufallswerte aus dem Wertebereich [fromInclusive, ... , toInclusive] erzeugen. Siehe dazu auch nextInt(bound) . Implementieren Sie eine Methode public void printArray(int[] a) so, dass sie ein int -Array in der Form [ 27, 30, 25, 26, 23, 20, 30, 30, 22, 21, 29, 29, 21, 20 ] (also Werte durch Komma getrennt in eckigen Klammern) ausgibt. Siehe dazu Ausgabe von Arrays . Rufen Sie in der main() die beiden Methoden wie folgt auf: Random r = new Random (); // java.util.Random importieren Aufgab10 a10 = new Aufgabe10 (); int length = r . nextInt ( 10 ) + 10 ; int [] arr1 = a10 . createAndFillArray ( length , 20 , 30 ); System . out . printf ( \"%n%n%n----------- printArray -----------------%n%n%n\" ); a10 . printArray ( arr1 ); Implementieren Sie eine Methode public void printTable(int[] a) . Diese gibt das Array a als Tabelle in folgender Form aus: | Index : | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | | ------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | | Wert : | 27 | 30 | 25 | 26 | 23 | 20 | 30 | 30 | 22 | 21 | 29 | 29 | 21 | 20 | Rufen Sie in der main() die Methode printTable() wie folgt auf: System . out . printf ( \"%n%n%n----------- printTable -----------------%n%n%n\" ); a10 . printTable ( arr1 ); Implementieren Sie eine Methode public void printHorizontal(int[] a) . Diese gibt das Array a in folgender Form aus: | 0 | *************************** | 1 | ****************************** | 2 | ************************* | 3 | ************************** | 4 | *********************** | 5 | ******************** | 6 | ****************************** | 7 | ****************************** | 8 | ********************** | 9 | ********************* | 10 | ***************************** | 11 | ***************************** | 12 | ********************* | 13 | ******************** | Das hei\u00dft, f\u00fcr jeden Wert im Array wird die entsprechende Anzahl von Sternen ausgegeben. Ganz links steht jeweils der Index, unter dem der Wert im Array gespeichert wird. Rufen Sie in der main() die Methode printTable() wie folgt auf: System . out . printf ( \"%n%n%n----------- printHorizontal ------------%n%n%n\" ); a10 . printHorizontal ( arr1 ); Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgende(n) Aufgabe(n) sind optional : Implementieren Sie eine Methode public void printUpsideDown(int[] a) oder eine Methode public void printVertical(int[] a) (beide gleicher Aufwand). Diese geben das Array a in folgender Form aus: ----------- printUpsideDown ------------ | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 ----+---------------------------------------------------------------------- 1 | * * * * * * * * * * * * * * 2 | * * * * * * * * * * * * * * 3 | * * * * * * * * * * * * * * 4 | * * * * * * * * * * * * * * 5 | * * * * * * * * * * * * * * 6 | * * * * * * * * * * * * * * 7 | * * * * * * * * * * * * * * 8 | * * * * * * * * * * * * * * 9 | * * * * * * * * * * * * * * 10 | * * * * * * * * * * * * * * 11 | * * * * * * * * * * * * * * 12 | * * * * * * * * * * * * * * 13 | * * * * * * * * * * * * * * 14 | * * * * * * * * * * * * * * 15 | * * * * * * * * * * * * * * 16 | * * * * * * * * * * * * * * 17 | * * * * * * * * * * * * * * 18 | * * * * * * * * * * * * * * 19 | * * * * * * * * * * * * * * 20 | * * * * * * * * * * * * * * 21 | * * * * * * * * * * * * 22 | * * * * * * * * * * 23 | * * * * * * * * * 24 | * * * * * * * * 25 | * * * * * * * * 26 | * * * * * * * 27 | * * * * * * 28 | * * * * * 29 | * * * * * 30 | * * * ----------- printVertical -------------- 30 | * * * 29 | * * * * * 28 | * * * * * 27 | * * * * * * 26 | * * * * * * * 25 | * * * * * * * * 24 | * * * * * * * * 23 | * * * * * * * * * 22 | * * * * * * * * * * 21 | * * * * * * * * * * * * 20 | * * * * * * * * * * * * * * 19 | * * * * * * * * * * * * * * 18 | * * * * * * * * * * * * * * 17 | * * * * * * * * * * * * * * 16 | * * * * * * * * * * * * * * 15 | * * * * * * * * * * * * * * 14 | * * * * * * * * * * * * * * 13 | * * * * * * * * * * * * * * 12 | * * * * * * * * * * * * * * 11 | * * * * * * * * * * * * * * 10 | * * * * * * * * * * * * * * 9 | * * * * * * * * * * * * * * 8 | * * * * * * * * * * * * * * 7 | * * * * * * * * * * * * * * 6 | * * * * * * * * * * * * * * 5 | * * * * * * * * * * * * * * 4 | * * * * * * * * * * * * * * 3 | * * * * * * * * * * * * * * 2 | * * * * * * * * * * * * * * 1 | * * * * * * * * * * * * * * ----+---------------------------------------------------------------------- | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 Rufen Sie in der main() die beiden Methoden (oder die, die Sie implememntiert haben) wie folgt auf: System . out . printf ( \"%n%n%n----------- printUpsideDown ------------%n%n%n\" ); a10 . printUpsideDown ( arr1 ); System . out . printf ( \"%n%n%n----------- printVertical --------------%n%n%n\" ); a10 . printVertical ( arr1 ); Tipps zum L\u00f6sen der Zusatzaufgabe: Sie m\u00fcssen zun\u00e4chst ermitteln, welcher der gr\u00f6\u00dfte Wert innerhalb des Arrays ist, denn dieser gibt Ihnen die Anzahl der Zeilen im Diagramm vor. Stellen Sie sich das Problem als eine Matrix aus Zeilen und Spalten vor. Die Spalten lassen sich auf den Index des Arrays mappen und die Zeilen auf die Werte im Array. Viel Spa\u00df und viel Erfolg! Aufgabe 11 (Abgabe bis 17.01.2022 24:00 Uhr) \u00b6 Aufgabe 11 - Arrays bef\u00fcllen L\u00f6sen Sie die Aufgabe mit Eclipse oder einer IDE Ihrer Wahl. Wir bef\u00fcllen ein char -Array, aber das ist leider gar nicht so einfach ;-) Erstellen Sie sich ein package aufgaben.aufgabe11 und in diesem package zwei Klassen Programmklasse (mit main() -Methode) und Aufgabe11 . einleitende Vorbetrachtung: angenommen, wir haben die folgende Schleife: 1 2 3 4 5 for ( int asciiValue = 97 ; asciiValue < 123 ; asciiValue ++ ) { char c = ( char ) asciiValue ; System . out . print ( c + \" \" ); } Durch diese wird uns das gesamte Alphabet in Kleinbuchstaben ausgegeben: a b c d e f g h i j k l m n o p q r s t u v w x y z Kopieren Sie die Schleife einfach in Ihre main() -Methode und f\u00fchren Sie sie aus, dann erhalten Sie obige Ausgabe. Dahinter steckt, dass wir der int -Variablen asciiValue den ASCII-Code der Kleinbuchstaben zuweisen (beginnend bei 97 - das ist ein a ). Siehe z.B. hier . Der letzte kleine Buchstabe z hat den ASCII-Wert 122 , deshalb l\u00e4uft die Schleife auch bis <123 . In Zeile 3 der Schleife findet eine Typkonvertierung statt. Aus dem int wird ein char . Dies geschieht durch den Typkonvertierungsoperator (char) . In Zeile 4 wird das Zeichen c vom Typ char ausgegeben. Aufgabe Die Aufgabe ist es nun, ein char -Array zu bef\u00fcllen. Es gelten folgende Bedingungen: das Array hat (nur) die L\u00e4nge 25 in dem Array darf es keine Doppelungen geben (also kein Zeichen darf doppelt enthalten sein) die Zeichen werden zuf\u00e4llig erzeugt, d.h. mithilfe der Klasse Random und der Methode nextInt(bound) , die Werte zwischen 97 und einschlie\u00dflich 122 erzeugen soll Schreiben Sie daf\u00fcr eine Methode public char[] createAndFillCharArray() in dieser Methode erzeugen Sie das char[] der L\u00e4nge 25 , ein Random -Objekt, mit dem Sie unter Verwendung der nextInt(bound) -Methode zuf\u00e4llig Zahlen zwischen 97 und einschlie\u00dflich 122 erzeugen, die erzeugten int -Werte konvertieren Sie mithilfe des (char) -Typecast-Operators nach char , dann bef\u00fcllen Sie das char[] \u2192 passen Sie aber auf, dass Sie kein Zeichen hinzuf\u00fcgen, das bereits im Array enthalten ist \u2192 dazu ben\u00f6tigen Sie die contains() -Methode: Schreiben Sie eine Methode public boolean contains(char[] ca, char c) . Diese gibt ein true zur\u00fcck, wenn c in ca enthalten ist und ein false , wenn nicht. Schreiben Sie eine Methode public char[] sort(char[] a) . Diese gibt ein char[] zur\u00fcck, welches sortiert ist. Das \u00fcbergebene Array a ist unsortiert. Siehe dazu Sortieren von Arrays . Schreiben Sie eine Methode public void print(char[] a) , die ein \u00fcbergebenes char[] in der Form [ o, g, f, p, a, c, s, i, e, q, h, l, t, r, w, z, v, x, y, u, b, j, k, m, n ] ausgibt. Geben Sie in Ihre main() -Methode folgende Anweisungen ein: Aufgabe11 a11 = new Aufgabe11 (); System . out . printf ( \"%n%n----------------- Erzeugen ------------------%n%n\" ); char [] ca1 = a11 . createAndFillCharArray (); a11 . print ( ca1 ); System . out . printf ( \"%n%n----------------- Sortieren ------------------%n%n\" ); char [] ca2 = a11 . sort ( ca1 ); a11 . print ( ca2 ); Es sollten Ausgaben in der Form: ----------------- Erzeugen ------------------ [ o, g, f, p, a, c, s, i, e, q, h, l, t, r, w, z, v, x, y, u, b, j, k, m, n ] ----------------- Sortieren ------------------ [ a, b, c, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z ] erscheinen. Beachten Sie, dass die Eintr\u00e4ge im Array zuf\u00e4llig erzeugt wurden. Beachten Sie au\u00dferdem, dass ein Buchstabe aus dem Alphabet fehlt, hier z.B. d (das Array hat die L\u00e4nge 25 , das Alphabet hat 26 Buchstaben). Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgende(n) Aufgabe(n) sind optional : Schreiben Sie eine Methode public char getMissingLetter(char[] a) . Dieser Methode wird ein durch die obige Methode createAndFillCharArray() erstelltes char -Array \u00fcbergeben. Das Array hat also die L\u00e4nge 25 hat und aus dem Alphabet fehlt genau ein kleiner Buchstabe. Finden Sie den Buchstaben und geben ihn zur\u00fcck. Schreiben Sie eine Methode public void findWord(String word) . Dieser Methode wird eine Zeichenkette \u00fcbergeben, die nur aus Buchstaben besteht. Sie k\u00f6nnen annehmen, dass es nur kleine Buchstaben sind, Sie k\u00f6nnen aber erstmal die toLowerCase() -Methode anwenden (siehe String ). Rufen Sie f\u00fcr jedes Zeichen aus dem String die beiden Methoden createAndFillCharArray() und getMissingLetter() auf, bis das von der getMissingLetter() -Methode zur\u00fcckgegebene Zeichen dem Zeichen des Strings entspricht, das Sie gerade betrachten. Eine Ausgabe als Beispiel: w..........w ( 11 ) e.e ( 2 ) i..i ( 3 ) h............h ( 13 ) n..............................n ( 31 ) a........a ( 9 ) c..c ( 3 ) h...........................................................h ( 60 ) t....t ( 5 ) e.....e ( 6 ) nn ( 1 ) Die Ausgabe erfolgte durch den Aufruf von findWord(\"weihnachten\"); . Ganz links in der Zeile steht immer das Zeichen des Strings, das gerade betrachtet wird. Dann kommen f\u00fcr jeden fehlgeschlagenen Versuch, durch getMissingLetter() das 'w' zur\u00fcck zu bekommen, die Ausgabe eines Punktes. Sollte getMissingLetter() das 'w'` zur\u00fcckgeben, wird es ausgegeben und au\u00dferdem noch in Klammern die Anzahl der Versuche. Der Cursor wechselt in die n\u00e4chste Zeile und das n\u00e4chste Zeichen des Strings ist dran. Viel Spa\u00df und viel Erfolg! Aufgabe 12 (Abgabe bis 24.01.2022 24:00 Uhr) \u00b6 Aufgabe 12 - SortedArray Wir erstellen uns einen neuen Datentyp SortedArray Idee : Ein Objekt dieser Klasse beschreibt (enth\u00e4lt) ein int -Array, in dem die Elemente aufsteigend sortiert sind und kein Element doppelt vorkommt. Das Array ist stets genau so gro\u00df, so viele Elemente es enth\u00e4lt! Erstellen Sie im package aufgaben.aufgabe12 eine Klasse SortedArray ohne main() -Methode und eine Klasse SortedArrayTest mit main() -Methode. In der Klasse SortedArray erstellen Sie eine Objektvariable s vom Typ int[] ( private ). Implementieren Sie fu\u0308r die Klasse SortedArray zwei verschiedene Konstruktoren parameterlos \u2192 der Konstruktor erzeugt ein leeres Array s (mit der L\u00e4nge 0 ) mit einem Parameter ( int element ) \u2192 der Konstruktor erzeugt ein einelementiges Array s (mit der L\u00e4nge 1 ), wobei s[0] den Wert von element annimmt. Implementieren Sie eine Objektmethode public boolean insert(int element) . Diese Methode gibt ein false zuru\u0308ck, wenn element bereits in s enthalten ist. Dann wird das element nicht dem Array hinzugefu\u0308gt. Die Methode gibt true zuru\u0308ck, wenn element in s eingefu\u0308gt wurde. Um element einzufu\u0308gen, wird ein neues Array fu\u0308r s erzeugt, in dem alle vorherigen Werte aus s und das neue element (an der richtigen Stelle einsortiert) enthalten sind. Implementieren Sie eine Objektmethode public boolean delete(int element) . Diese Methode gibt ein false zuru\u0308ck, wenn element nicht in s enthalten ist. Die Methode gibt true zuru\u0308ck, wenn element aus s gel\u00f6scht wurde. Beachten Sie, dass nach L\u00f6schen aus s die L\u00e4nge von s um eins kleiner ist, als vor dem L\u00f6schen. Es muss also auch hier wieder ein neues Array erzeugt werden, welches nach dem L\u00f6schen dem \"Wert\" von s entspricht. Implementieren Sie eine Objektmethode public void print() , die das Array s in der Form [ 4, 5, 9 ] (Beispielwerte) ausgibt. Tipp : Um zu \u00fcberpr\u00fcfen, ob ein int element in s enthalten ist, sollten Sie sich eine Methode boolean contains(int element) schreiben (diese kann private sein, wenn sie nur innerhalb der Klasse verwendet werden soll; sogenannte Servicemethode ). Angenommen, Sie haben zwei Arrays: s = [ 4, 9 ] und copy = [ 4, 5, 9] , dann gilt nach s = copy; , dass s == [ 4, 5, 9 ] . Geben Sie in die main() -Methode der SortedArrayTest -Klasse mindestens folgende Anweisungen ein: System . out . printf ( \"%n%n------------------------- Test a1 -----------------------------------%n%n\" ); SortedArray a1 = new SortedArray (); a1 . print (); a1 . delete ( 5 ); a1 . print (); a1 . insert ( 5 ); a1 . print (); a1 . insert ( 7 ); a1 . print (); a1 . delete ( 5 ); a1 . print (); a1 . insert ( 6 ); a1 . print (); a1 . insert ( 4 ); a1 . print (); a1 . insert ( 8 ); a1 . print (); a1 . delete ( 8 ); a1 . print (); a1 . delete ( 6 ); a1 . print (); System . out . printf ( \"%n%n------------------------- Test a2 -----------------------------------%n%n\" ); SortedArray a2 = new SortedArray ( 9 ); a2 . print (); a2 . insert ( 5 ); a2 . print (); a2 . insert ( 9 ); a2 . print (); a2 . insert ( 5 ); a2 . print (); a2 . insert ( 4 ); a2 . print (); a2 . insert ( 4 ); a2 . print (); a2 . delete ( 5 ); a2 . print (); a2 . delete ( 9 ); a2 . print (); a2 . delete ( 4 ); a2 . print (); a2 . delete ( 4 ); a2 . print (); und f\u00fchren Sie die SortedArrayTest -Klasse aus. Es sollten folgende Augaben entstehen: ------------------------- Test a1 ----------------------------------- [ ] [ ] [ 5 ] [ 5 , 7 ] [ 7 ] [ 6 , 7 ] [ 4 , 6 , 7 ] [ 4 , 6 , 7 , 8 ] [ 4 , 6 , 7 ] [ 4 , 7 ] ------------------------- Test a2 ----------------------------------- [ 9 ] [ 5 , 9 ] [ 5 , 9 ] [ 5 , 9 ] [ 4 , 5 , 9 ] [ 4 , 5 , 9 ] [ 4 , 9 ] [ 4 ] [ ] [ ] Viel Spa\u00df und viel Erfolg!","title":"Aufgaben"},{"location":"aufgaben/#aufgaben","text":"Hier finden Sie die Aufgaben. Die Abgabefristen der einzelnen Aufgaben stehen hier . Beachten Sie die nachfolgenden Hinweise zum Hochladen der Aufgaben.","title":"Aufgaben"},{"location":"aufgaben/#hinweise-zur-abgabe-der-aufgaben","text":"Die Aufgaben laden Sie in Moodle unter dem Reiter \"Aufgaben\" hoch. Dort ist f\u00fcr jede Aufgabe eine Moodle-Aufgabe erstellt. Beachten Sie, dass ein Hochladen nach Ablauf der Abgabefrist nicht mehr m\u00f6glich ist.","title":"Hinweise zur Abgabe der Aufgaben"},{"location":"aufgaben/#bluej-vs-eclipse","text":"Die ersten Wochen verwenden wir als Entwicklungsumgebung BlueJ. F\u00fcr die Aufgaben, die wir mit BlueJ l\u00f6sen, werde ich Ihnen jeweils Hinweise zur Abgabe f\u00fcr jede Aufgabe einzeln geben. Sobald wir Eclipse verwenden, gelten die folgenden Hinweise: Achten Sie darauf, dass Sie die Quelldateien (also die .java -Dateien aus dem src -Verzeichnis) hochladen. Ihre Klassen erstellen Sie immer in einem package aufgaben.aufgabeX . Das hei\u00dft, Aufgabe1 ist im package aufgaben.aufgabe1 , Aufgabe2 im package aufgaben.aufgabe2 usw. In Ihrem workspace gibt es dann einen Ordner f\u00fcr Ihr Java-Projekt, z.B. WS21 (je nachdem, wie Sie Ihr Java-Projekt genannt haben) und darin befindet sich ein bin - und ein src -Ordner. In dem src -Ordner befindet sich dann ein Ordner aufgaben und darin ein Ordner aufgaben1 (f\u00fcr Aufgabe1). Darin befindet sich Ihre .java -Datei, die Sie hochladen sollen. Angenommen, Sie haben Ihre Klasse Aufgabe1 genannt, dann hei\u00dft die Klasse also Aufgabe1.java . Sie folgen also dem Pfad workspace \u2192 Java-Projekt (z.B. WS21 ) \u2192 src \u2192 aufgaben \u2192 aufgabe X . Wenn Ihre L\u00f6sung aus mehreren Klassen (mehreren .java -Dateien) besteht, k\u00f6nnen Sie entweder die Dateien einzeln hochladen oder Sie zippen Ihre Dateien (am besten dann den aufgabeX -Ordner und laden das .zip -File hoch. In Ihrer L\u00f6sung (Ihrer/n Klasse/n) f\u00fcgen Sie direkt oberhalb Ihrer Klassendefinition einen JavaDoc-Kommentar ein ( /** ... */ ). Dieser enth\u00e4lt ein @author -Tag. dahinter schreiben Sie Ihren Namen. Das sieht dann z.B. so aus: package aufgaben.aufgabe1 ; /** * * @author J\u00f6rn Freiheit * * Diese Klasse gibt auf die Konsole ein Rhombus (eine Raute) aus. * Der Rhombus ist entweder gefuellt oder ungefuellt. * */ public class Aufgabe1 { // hier Ihre Implementierung } Sie k\u00f6nnen Ihre Aufgaben zu zweit l\u00f6sen. Tragen Sie dann hinter das @author -Tag beide Namen ein und laden Sie bitte beide die L\u00f6sung in Moodle hoch!","title":"BlueJ vs. Eclipse"},{"location":"aufgaben/#code-review","text":"F\u00fcr jede abgegebene Aufgabe wird Ihnen die L\u00f6sung einer Kommilitonin zum Review zugewiesen. Analysieren Sie den Code Ihrer Kommilitonin und geben Sie ihr dazu eine R\u00fcckmeldung! Es gen\u00fcgen 2 bis 3 Review-Kommentare. Zur offiziellen Abgabe einer Aufgabe geh\u00f6ren also das Hochladen der eigenen L\u00f6sung, das Analysieren/Kommentieren einer fremden L\u00f6sung.","title":"Code Review"},{"location":"aufgaben/#hinweise-zum-review","text":"Es geht nicht darum, das Programm zu \u00fcberarbeiten, sondern darum es nachzuvollziehen und Ihrer Kommilitonin eine R\u00fcckmeldung und eventuell Anregungen zu geben. Weisen Sie sowohl auf St\u00e4rken als auch auf Schw\u00e4chen des Quelltexts hin. Worauf Sie u.a. achten k\u00f6nnen: Ist der Quelltext gut strukturiert und verst\u00e4ndlich? Haben Variablen und Methoden passende Namen? Werden die Namen konsistent verwendet? Werden Konventionen eingehalten? Beispiel: Klassennamen starten immer mit Gro\u00dfbuchstaben, Objektnamen immer mit Kleinbuchstaben Ist das Programm \u00fcbersichtlich formatiert? Beispiel: kein horizontales Scrolling n\u00f6tig Machen Sie ggf. Vorschl\u00e4ge f\u00fcr (alternative) L\u00f6sungen. Gehen Sie respektvoll miteinander um, es gibt keinen Grund, unh\u00f6flich zu sein. Lesen Sie Ihre Kommentare noch einmal durch, bevor Sie sie an Ihre Kommilitonin weitergeben.","title":"Hinweise zum Review:"},{"location":"aufgaben/#aufgaben_1","text":"","title":"Aufgaben"},{"location":"aufgaben/#aufgabe-1-abgabe-bis-25102021-2400-uhr","text":"Aufgabe1 - Square mit Circles Verwenden Sie BlueJ und \u00f6ffnen Sie das Projekt picture aus dem examples -Ordner von BlueJ. Speichern Sie das Projekt als Projekt aufgabe1 ab. Die Klasse Picture k\u00f6nnen Sie wie folgt anpassen: /** * Aufgabe 1 * */ public class Picture { /** * Constructor for objects of class Picture */ public Picture () { // nothing to do... instance variables are automatically set to null } /** * Draw this picture. */ public void draw () { Square s1 = new Square (); Circle c1 = new Circle (); Circle c2 = new Circle (); Circle c3 = new Circle (); Circle c4 = new Circle (); // hier die Implementierung } } Programmieren Sie die draw() -Methode so, dass folgendes Bild gezeichnet wird: Die Gr\u00f6\u00dfen bleiben Ihnen \u00fcberlassen, aber die vier Kreise sollen das gelbe Quadrat vollst\u00e4ndig ausf\u00fcllen. Den Titel des Fensters m\u00fcssen Sie nicht \u00e4ndern (geht aber in der Klasse Canvas ). Erstellen Sie sich eine Testklasse PictureTest , in der es eine Testmethode testDraw() gibt, die die draw() -Methode f\u00fcr ein Picture -Objekt ausf\u00fchrt. Zippen Sie Ihr Projekt aufgabe1 und laden es in Moodle hoch.","title":"Aufgabe 1 (Abgabe bis 25.10.2021 24:00 Uhr)"},{"location":"aufgaben/#aufgabe-2-abgabe-bis-01112021-2400-uhr","text":"Aufgabe2 - Methoden und Ausgaben Erstellen Sie sich ein neues Projekt aufgabe2 und darin eine neue Klasse Aufgabe2 , die wie folgt aussieht: public class Aufgabe2 { public Aufgabe2 () { } public void start () { // rufen Sie hier Ihre Methoden auf: } } Implementieren Sie eine Methode computeSum(double number1, double number2) , die die Summe der beiden Zahlen number1 und number2 als double zur\u00fcckgibt . Implementieren Sie eine Methode printSum(double number1, double number2 , die die Summe der beiden Zahlen number1 und number2 in der folgenden Form ausgibt . Die Ausgabe sieht f\u00fcr die Beispielwerte number1 = 4.0 und number2 = 5.0 so aus: 4 .0 + 5 .0 = 9 .0 Rufen Sie in der printSum(double number1, double number2 -Methode die Methode computeSum(double number1, double number2) auf! Implementieren Sie \u00e4hnliche Methoden auch f\u00fcr die Subtraktion, Multiplikation und Division von zwei double -Zahlen. Verwenden Sie jeweils die computeXXX() -Methoden in den printXXX() -Methoden. Erstellen Sie eine Methode printComputations(double number1, double number2) , in der alle vier printXXX() -Methoden aufgerufen werden, so dass durch den Aufruf der printComputations(double number1, double number2) -Methode folgende Ausgabe erscheint (Beispielwerte 4.0 und 5.0 ): 4 .0 + 5 .0 = 9 .0 4 .0 - 5 .0 = -1.0 4 .0 * 5 .0 = 20 .0 4 .0 / 5 .0 = 0 .8 Zippen Sie Ihr Projekt aufgabe2 und laden es in Moodle hoch.","title":"Aufgabe 2 (Abgabe bis 01.11.2021 24:00 Uhr)"},{"location":"aufgaben/#aufgabe-3-abgabe-bis-08112021-2400-uhr","text":"Aufgabe3 - Rechteck Erstellen Sie sich ein neues Projekt aufgabe3 und darin eine neue Klasse Aufgabe3 , die wie folgt aussieht: public class Aufgabe3 { public Aufgabe3 () { } public void start () { // rufen Sie hier Ihre Methoden auf: } } Implementieren Sie eine Methode public void printRectangle(int width, int height, boolean filled){} Ist der Parameterwert von filled true , dann soll ein Rechteck wie folgt auf die Konsole ausgegeben werden (Beispielausgabe f\u00fcr width=11 und height=5 ): *********** *********** *********** *********** *********** Ist der Parameterwert von filled false , dann soll das Rechteck ungef\u00fcllt sein, also so: *********** * * * * * * *********** Die obere Ausgabe ist also durch die Anweisung printRectangle(11, 5, true); und die untere durch die Anweisung printRectangle(11, 5, false); entstanden. Tipp: : Schreiben Sie sich zwei weitere Methoden public void printRectangleFilled(int width, int height){} und public void printRectangleUnfilled(int width, int height){} , die Sie entsprechend des Wertes von filled aufrufen. In der einen Methode erstellen Sie das ausgef\u00fcllte Rechteck und in der anderen das ungef\u00fcllte. Dann wird Ihr Programm nicht zu un\u00fcbersichtlich. Fangen Sie am besten mit der ausgef\u00fcllten an, die ist etwas leichter. Das Programm soll f\u00fcr beliebige (nicht so gro\u00dfe - max. Werte f\u00fcr width und height je 100 ) positive Zahlen (also > 0 ) funktionieren. Insbesondere sind die Tests f\u00fcr width=1 und height=1 bzw. height=2 interessant. Zippen Sie Ihr Projekt aufgabe3 und laden es in Moodle hoch. Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 3 (Abgabe bis 08.11.2021 24:00 Uhr)"},{"location":"aufgaben/#aufgabe-4-abgabe-bis-15112021-2400-uhr","text":"Aufgabe4 - Rhombus Erstellen Sie sich ein neues Projekt aufgabe4 und darin eine neue Klasse Aufgabe4 , die wie folgt aussieht: public class Aufgabe4 { public Aufgabe4 () { } public void start () { // rufen Sie hier Ihre Methoden auf: } } Implementieren Sie eine Methode public void printRhombus(int upperHalf, boolean filled){} Ist der Parameterwert von filled true , dann soll ein Rhombus (eine Raute) wie folgt auf die Konsole ausgegeben werden: * *** ***** ******* ********* *********** ********* ******* ***** *** * Ist der Parameterwert von filled false , dann soll der Rhombus ungef\u00fcllt sein, also so: * * * * * * * * * * * * * * * * * * * * der Wert f\u00fcr upperHalf gibt die H\u00f6he einer H\u00e4lfte des Rhombus an. Die Gesamth\u00f6he des Rhombus berechnet sich aus ` int height = 2 * upperHalf + 1 ; In unserem oben gezeigten Beispiel ist der Wert von upperHalf 5 und die Gesamth\u00f6he des Rhombus 11 . Die obere Ausgabe ist also durch die Anweisung printRhombus(5, true); und die untere durch die Anweisung printRhombus(5, false); entstanden. Die Berechnung der H\u00f6he aus dem Parameterwert upperHalf hat die Vorteile, dass die H\u00f6he dadurch immer eine ungerade Zahl ist (was notwendig ist) und dass Sie den Wert upperHalf gut verwenden k\u00f6nnen (was ebenfalls notwendig ist, wie Sie merken werden) Tipp: : Schreiben Sie sich zwei weitere Methoden public void printRhombusFilled(int upperHalf){} und public void printRhombusUnfilled(int upperHalf){} , die Sie entsprechend des Wertes von filled aufrufen. In der einen Methode erstellen Sie die ausgef\u00fcllte Raute und in der anderen die ungef\u00fcllte. Dann wird Ihr Programm nicht zu un\u00fcbersichtlich. Fangen Sie am besten mit der ausgef\u00fcllten an, die ist etwas leichter. Das Programm soll f\u00fcr beliebige (nicht so gro\u00dfe - max. Wert 100 ) positive Zahlen (also > 0 ) von upperHalf funktionieren. Insbesondere sind die Tests f\u00fcr upperhalf == 1 interssant. Zippen Sie Ihr Projekt aufgabe4 und laden es in Moodle hoch. Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 4 (Abgabe bis 15.11.2021 24:00 Uhr)"},{"location":"aufgaben/#aufgabe-5-abgabe-bis-22112021-2400-uhr","text":"Aufgabe5 - Knobeleien Diese Aufgabe ist haupts\u00e4chlich dazu da, um das algorithmische Denken zu schulen. Sie werden im Netz jeweils viele L\u00f6sungen finden, aber Sie sollten versuchen, alleine auf eine L\u00f6sung zu kommen. Versuchen Sie es! Ich gebe zu jeder Aufgabe kleine Tipps. Erstellen Sie sich ein neues Projekt aufgabe5 und darin eine neue Klasse Aufgabe5 , die wie folgt aussieht: public class Aufgabe5 { public Aufgabe5 () { } public void start () { // rufen Sie hier Ihre Methoden auf: } } Implementieren Sie eine Methode public int computeChecksum(int number){} . Diese Methode berechnet die Quersumme der Zahl number und gibt diese zur\u00fcck. Hier ein paar Beispiele: number: 123456 -> checksum: 21 number: -123456 -> checksum: -21 number: 0 -> checksum: 0 number: 2147483647 -> checksum: 46 number: -2147483648 -> checksum: -47 Tipp : \"Laufen\" Sie am besten von hinten nach vorne durch die Zahl number und l\u00f6sen immer die letzte Ziffer von der Zahl, um diese dann zur Quersumme zu addieren. Welchen Operator kennen Sie, um als Ergebnis die letzte Ziffer einer Dezimalzahl zu erhalten? Wie lange m\u00fcssen Sie \"laufen\"? Implementieren Sie eine Methode public void printCombinations36(){} . Diese Methode gibt alle Kombinationen f\u00fcr 3 ganze Zahlen x , y und z auf der Konsole aus, f\u00fcr die Folgendes gilt: x <= y <= z und x * y * z = 36 Tipp : \u00dcberlegen Sie sich zuerst, wie man z.B. alle Kombinationen ermitteln kann, wenn x , y und z jeweils Werte zwischen -50 und 50 (das ist aber nicht der endg\u00fcltige Wertebereich!!! - Sie k\u00f6nnen gerne auch anders anfangen) annehmen k\u00f6nnen (das sind dann 100^3 , also 1000000 Kombinationen). \u00dcberlegen Sie dann, wie Sie diese Wertebereiche mithilfe der beiden Bedingungen einschr\u00e4nken k\u00f6nnen. Es gibt \u00fcbrigens 28 Kombinationen, f\u00fcr die die beiden obigen Bedingungen gelten. Wenn Sie diese beiden Aufgaben erledigt haben, dann haben Sie genug geknobelt. Herzlichen Gl\u00fcckwunsch - Aufgabe erf\u00fcllt! Nur f\u00fcr diejenigen unter Ihnen, die vom Knobeln nicht genug bekommen k\u00f6nnen, gibt es die folgende Zusatzaufgabe. Ist aber wirklich keine Pflicht, sondern soll nur Vergn\u00fcgen sein :-) Zusatzaufgabe : Implementieren Sie eine Methode public void printPrimeFactors(int number){} , die f\u00fcr die \u00fcbergebene Zahl number die Primzahlfaktorzerlegung auf die Konsole ausgibt, also z.B. so: 480 --> 2 2 2 2 2 3 5 17 --> 17 12345 --> 3 5 823 Tipp: : N\u00fctzliche Methoden sind sicherlich boolean isPrime(int number) und boolean isDivider(int factor, int number) , wobei Letztere pr\u00fcft, ob factor ein ganzzahliger Teiler von number ist. Achten Sie darauf, dass wenn Sie einen Primfaktor gefunden haben, es auch derselbe Primfaktor wiederholt sein kann. Ist knifflig!","title":"Aufgabe 5 (Abgabe bis 22.11.2021 24:00 Uhr)"},{"location":"aufgaben/#aufgabe-6-abgabe-bis-29112021-2400-uhr","text":"Aufgabe6 - Triangle Wir erstellen uns einen neuen Datentyp Triangle Erstellen Sie sich ein neues Projekt aufgabe6 und darin eine neue Klasse Triangle sowie daf\u00fcr eine Testklasse TestTriangle mit einer testTriangle() -Methode. In der Klasse Triangle erstellen Sie drei Objektvariablen a , b und c jeweils vom Typ int und alle private . Das sollen die Seiten unseres Dreiecks sein. Erstellen Sie einen Konstruktor, dem drei Parameterwerte \u00fcbergeben werden pa , pb und pc alle vom Typ int . Mit diesen Werten werden die Objektvariablen initialisiert. Schreiben Sie eine Objektmethode print() , die die Seitenl\u00e4ngen des Dreiecks in der folgenden Form ausgibt: Seiten : a = 3 , b = 4 , c = 5 f\u00fcr den Fall, dass die Seitenl\u00e4ngen 3 , 4 und 5 sind. Wenn Sie jetzt in der testTriangle() -Methode der Testklasse TestTriangle folgende Anweisungen ausf\u00fchren Triangle t1 = new Triangle ( 3 , 4 , 5 ); Triangle t2 = new Triangle ( 4 , 4 , 7 ); Triangle t3 = new Triangle ( 5 , 5 , 5 ); Triangle t4 = new Triangle ( 4 , 5 , 3 ); Triangle t5 = new Triangle ( 4 , 3 , 5 ); Triangle t6 = new Triangle ( 3 , 4 , 5 ); t1 . print (); t2 . print (); t3 . print (); t4 . print (); t5 . print (); t6 . print (); dann sollte die Ausgabe ungef\u00e4hr so aussehen: Seiten : a = 3 , b = 4 , c = 5 Seiten : a = 4 , b = 4 , c = 7 Seiten : a = 5 , b = 5 , c = 5 Seiten : a = 4 , b = 5 , c = 3 Seiten : a = 4 , b = 3 , c = 5 Seiten : a = 3 , b = 4 , c = 5 Erstellen Sie in der Klasse Triangle eine Objektmethode public int circumference() , die den Umfang des Dreiecks zur\u00fcckgibt (also die Summe der drei Seitenl\u00e4ngen). Erstellen Sie in der Klasse Triangle eine Objektmethode public double area() , die den Flaecheninhalt des Dreiecks zur\u00fcckgibt. Der Fl\u00e4cheninhalt A eines Dreiecks l\u00e4sst sich nach der Heron'schen Formel wie folgt berechnen: A = Math.sqrt(s * (s-a) * (s-b) * (s-c)) wobei s = (a + b + c) / 2 Achten Sie darauf, dass Sie stets mit double rechnen! Beachten Sie, dass in einem Dreieck keine Seite l\u00e4nger sein darf als die Summe der beiden anderen. F\u00fcr die oben in der testTriangle() -Methode erstellten Objekte gilt das aber. Wir m\u00fcssen deshalb nichts weiter beachten. Erweitern Sie die Objektmethode print() nun so, dass auch der Umfang und der Flaecheninhalt in der folgenden Form ausgegeben werden (Sie k\u00f6nnen in die print() -methode auch die Leerzeile integrieren): Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Seiten : a = 4 , b = 4 , c = 7 Umfang : 15 Flaecheninhalt : 6 .777720855862979 Seiten : a = 5 , b = 5 , c = 5 Umfang : 15 Flaecheninhalt : 10 .825317547305483 Seiten : a = 4 , b = 5 , c = 3 Umfang : 12 Flaecheninhalt : 6 .0 Seiten : a = 4 , b = 3 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean equilateral() , die ein true zur\u00fcckgibt, wenn das Dreieck gleichseitig ist (also alle Seiten des Dreiecks gleich lang sind) und false sonst. Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean isosceles() , die ein true zur\u00fcckgibt, wenn das Dreieck gleichschenklig ist (also zwei Seiten des Dreiecks gleich lang sind) und false sonst. Erweitern Sie die Objektmethode print() nun so, dass die Pr\u00fcfungen, ob sich um ein gleichseitiges oder gleichschenkliges (oder unregelm\u00e4\u00dfiges) Dreieck handelt, in der folgenden Form ausgegeben werden: Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Seiten : a = 4 , b = 4 , c = 7 Umfang : 15 Flaecheninhalt : 6 .777720855862979 Das Dreieck ist gleichschenklig. Seiten : a = 5 , b = 5 , c = 5 Umfang : 15 Flaecheninhalt : 10 .825317547305483 Das Dreieck ist gleichseitig. Seiten : a = 4 , b = 5 , c = 3 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Seiten : a = 4 , b = 3 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgenden Aufgaben sind optional (kann auch sein, dass wir die Objektvergleiche noch gar nicht haben, dann wird es erst recht knifflig :-) ): Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean sameCircumference(Triangle t) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt den gleichen Umfang hat wie t und false sonst. Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean isSmaller(Triangle t) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren Fl\u00e4cheninhalt hat, als t und false sonst. Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean isBigger(Triangle t) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt einen gr\u00f6\u00dferen Fl\u00e4cheninhalt hat, als t und false sonst. Testen Sie in der testTriangle() -Methode der Testklasse TestTriangle die drei zuletztgeschriebenen Methoden, so dass folgende Ausgaben erzeugt werden: t1 und t2 gleicher Umfang ? : false t1 und t3 gleicher Umfang ? : false t2 und t3 gleicher Umfang ? : true t1 kleiner als t2 ? : true t2 kleiner als t1 ? : false t1 kleiner als t4 ? : false t4 kleiner als t1 ? : false t1 groesser als t2 ? : false t2 groesser als t1 ? : true t1 groesser als t4 ? : false t4 groesser als t1 ? : false Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean sidesAreEqual(Triangle t) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt die gleichen Seitenl\u00e4ngen hat wie t und false sonst. Beachten Sie, dass folgende Dreiecke mit z.B. dem Dreieck ( a=3, b=4, c=5 ) gleich sein sollen: ( a=3, b=4, c=5 ), aber auch ( a=4, b=5, c=3 ), aber auch ( a=5, b=3, c=4 ) \u2192 die \"Benennung\" der Seiten ist also egal Jedoch soll z.B. ( a=4, b=3, c=5 ) nicht gleich zu ( a=3, b=4, c=5 ) sein f\u00fcr die obigen Objekte soll somit gelten: t1 und t2 gleiche Seiten ? : false t1 und t4 gleiche Seiten ? : true t1 und t5 gleiche Seiten ? : false t1 und t6 gleiche Seiten ? : true Erzeugen Sie diese Ausgabe in testTriangle() . Erstellen Sie in der Klasse Triangle eine Objektmethode public boolean isRightAngled() , die ein true zur\u00fcckgibt, wenn das Dreieck rechtwinklig ist und false sonst. der Satz des Pythagoras besagt, dass in einem rechtwinkligen Dreieck gilt: a^2 + b^2 = c^2 es gilt aber auch die Umkehrung, d.h. wenn von 2 Seiten die Summe der Quadrate dem Quadrat der dritten Seite entspricht, dann ist das Dreieck rechtwinklig Erweitern Sie die Objektmethode print() nun so, dass die Pr\u00fcfungen, ob sich um ein rechtwinkliges Dreieck handelt, in der folgenden Form ausgegeben werden: Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Das Dreieck ist rechtwinklig. Seiten : a = 4 , b = 4 , c = 7 Umfang : 15 Flaecheninhalt : 6 .777720855862979 Das Dreieck ist gleichschenklig. Das Dreieck ist nicht rechtwinklig. Seiten : a = 5 , b = 5 , c = 5 Umfang : 15 Flaecheninhalt : 10 .825317547305483 Das Dreieck ist gleichseitig. Das Dreieck ist nicht rechtwinklig. Seiten : a = 4 , b = 5 , c = 3 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Das Dreieck ist rechtwinklig. Seiten : a = 4 , b = 3 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Das Dreieck ist rechtwinklig. Seiten : a = 3 , b = 4 , c = 5 Umfang : 12 Flaecheninhalt : 6 .0 Das Dreieck ist unregelmaessig. Das Dreieck ist rechtwinklig. Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 6 (Abgabe bis 29.11.2021 24:00 Uhr)"},{"location":"aufgaben/#aufgabe-7-abgabe-bis-6122021-2400-uhr","text":"Aufgabe7 - Time Wir erstellen uns einen neuen Datentyp Time Erstellen Sie sich ein neues Projekt aufgabe7 und darin eine neue Klasse Time sowie daf\u00fcr eine Testklasse TimeTest mit einer testTime() -Methode. In der Klasse Time erstellen Sie zwei Objektvariablen hours und minutes , jeweils vom Typ int und beide private . Erstellen Sie einen parameterlosen Konstruktor, der die Objektvariablen mit jeweils 0 initialisiert. Implementieren Sie eine Methode public void changeTime(int diffMinutes) . Dieser Methode wird als Parameterwert eine Anzahl von Minuten \u00fcbergeben, um die sich die aktuelle Zeit \u00e4ndern soll. Beachten Sie: die Objektvariable minutes soll nur Werte von 0 bis 59 annehmen d\u00fcrfen, die Objektvariable hours soll nur Werte von 0 bis 23 annehmen d\u00fcrfen, diffMinutes kann auch negativ sein. Implementieren Sie eine Methode public String timeToString() . Diese Methode gibt die aktuelle Zeit in der Form hh:mm als String zur\u00fcck. Beachten Sie: Sowohl die Stunden als auch die Minuten haben eventuelle f\u00fchrende Nullen, d.h. Beispiele f\u00fcr den R\u00fcckgabestring k\u00f6nnen auch 01:00 sein oder 09:09 . Implementieren Sie eine Methode public void printTime() . Diese Methode gibt die aktuelle Uhrzeit unter Verwendung der Methode timeToString() auf die Konsole aus. Wenn Sie die Testmethode testTime() z.B. wie folgt implementieren: @Test public void testTime () { Time t1 = new Time (); t1 . printTime (); t1 . changeTime ( 30 ); t1 . printTime (); t1 . changeTime ( 30 ); t1 . printTime (); t1 . changeTime ( 60 ); t1 . printTime (); t1 . changeTime ( 600 ); t1 . printTime (); t1 . changeTime ( 660 ); t1 . printTime (); t1 . changeTime ( 60 ); t1 . printTime (); t1 . changeTime ( - 60 ); t1 . printTime (); } dann sollte folgende Ausgabe auf der Konsole erscheinen: 00 :00 00 :30 01 :00 02 :00 12 :00 23 :00 00 :00 23 :00 Insbesondere f\u00fcr die changeTime() -Methode sollten Sie erst ausf\u00fchrlich \u00fcberlegen, ehe Sie losprogrammieren. Nicht vergessen, dass Zettel und Stift die wichtigsten Werkzeuge der Programmiererin sind! Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 7 (Abgabe bis 6.12.2021 24:00 Uhr)"},{"location":"aufgaben/#aufgabe-8-abgabe-bis-13122021-2400-uhr","text":"Aufgabe8 - Counter und Clock Wir erstellen uns zwei neue Datentypen Counter und Clock Erstellen Sie sich ein neues Projekt aufgabe8 und darin eine neue Klasse Counter sowie eine Programm-/Testklasse Programclass mit einer start() -Methode. Die Idee der Klasse Counter soll sein, einen counter bis zu einem bestimmten limit hochzuz\u00e4hlen. Bevor der counter das limit erreicht, wird er wieder auf 0 gesetzt. Angenommen also das limit ist 60 und der counter hat den aktuellen Wert 59 und soll erh\u00f6ht werden, dann ist der n\u00e4chste Wert von counter wieder 0 , da das limit erreicht wurde. In der Klasse Counter erstellen Sie zwei Objektvariablen counter und limit , jeweils vom Typ int (beide nur in der Klasse sichtbar). Erstellen Sie einen parametrisierten Konstruktor public Counter(int limit) , der den counter auf 0 initialisiert und das limit auf den Parameterwert. Implementieren Sie eine Methode public boolean increase() . Diese Methode soll den Wert von counter um 1 erh\u00f6hen. Es muss jedoch gepr\u00fcft werden, ob eventuell das limit erreicht wurde. Sollte dies der Fall sein, wird der Wert von counter wieder auf 0 gesetzt. Wird der counter tats\u00e4chlich um 1 erh\u00f6ht, gibt die Methode ein true zur\u00fcck, wurde der Wert von counter jedoch auf 0 gesetzt, gibt die Methode false zur\u00fcck. Beispiel: Angenommen counter hat den Wert 58 und das limit ist 60 . Dann ist der neue Wert von counter 59 und die Methode gibt true zur\u00fcck. Angenommen counter hat den Wert 59 und das limit ist 60 . Dann ist der neue Wert von counter 0 und die Methode gibt false zur\u00fcck. Implementieren Sie eine Methode public String toString() . Diese Methode gibt den Wert von counter als zweistelligen String zur\u00fcck. Beachten Sie Ist der Wert von counter einstellig, z.B. 5 , dann soll der String \"05\" zur\u00fcckgegeben werden. Implementieren Sie eine Methode public void print() . Diese Methode gibt den aktuellen Wert von counter unter Verwendung der Methode toString() auf die Konsole aus. Wenn Sie die Methode start() in der Programclass z.B. wie folgt implementieren: public void start () { Counter counter = new Counter ( 60 ); for ( int i = 0 ; i < 120 ; i ++ ) { counter . increase (); System . out . printf ( \"%3d : \" , i ); counter . print (); } } dann sollte folgende Ausgabe auf der Konsole erscheinen: Ausgabe auf der Konsole 0 : 01 1 : 02 2 : 03 3 : 04 4 : 05 5 : 06 6 : 07 7 : 08 8 : 09 9 : 10 10 : 11 11 : 12 12 : 13 13 : 14 14 : 15 15 : 16 16 : 17 17 : 18 18 : 19 19 : 20 20 : 21 21 : 22 22 : 23 23 : 24 24 : 25 25 : 26 26 : 27 27 : 28 28 : 29 29 : 30 30 : 31 31 : 32 32 : 33 33 : 34 34 : 35 35 : 36 36 : 37 37 : 38 38 : 39 39 : 40 40 : 41 41 : 42 42 : 43 43 : 44 44 : 45 45 : 46 46 : 47 47 : 48 48 : 49 49 : 50 50 : 51 51 : 52 52 : 53 53 : 54 54 : 55 55 : 56 56 : 57 57 : 58 58 : 59 59 : 00 60 : 01 61 : 02 62 : 03 63 : 04 64 : 05 65 : 06 66 : 07 67 : 08 68 : 09 69 : 10 70 : 11 71 : 12 72 : 13 73 : 14 74 : 15 75 : 16 76 : 17 77 : 18 78 : 19 79 : 20 80 : 21 81 : 22 82 : 23 83 : 24 84 : 25 85 : 26 86 : 27 87 : 28 88 : 29 89 : 30 90 : 31 91 : 32 92 : 33 93 : 34 94 : 35 95 : 36 96 : 37 97 : 38 98 : 39 99 : 40 100 : 41 101 : 42 102 : 43 103 : 44 104 : 45 105 : 46 106 : 47 107 : 48 108 : 49 109 : 50 110 : 51 111 : 52 112 : 53 113 : 54 114 : 55 115 : 56 116 : 57 117 : 58 118 : 59 119 : 00 Erstellen Sie sich im Projekt aufgabe8 eine weitere Klasse Clock . In der Klasse Clock verwenden Sie zwei Counter . Der eine Counter z\u00e4hlt die minutes und hat das limit 60 und der andere Counter z\u00e4hlt die hours udn hat das limit 24 . In der Klasse Clock erstellen Sie zwei Objektvariablen minutes und hours , jeweils vom Typ Counter (beide nur in der Klasse sichtbar). Erstellen Sie einen parameterlosen Konstruktor public Clock() . Darin erzeugen Sie f\u00fcr minutes das Counter -Objekt mit dem limit 60 und f\u00fcr hours das Counter -Objekt mit dem limit 24 . Implementieren Sie eine Methode public void increase() . Diese Methode soll den Wert von minutes um 1 erh\u00f6hen. Sollte jedoch das limit von minutes erreicht sein, wird auch hours um 1 erh\u00f6ht. Nutzen Sie die increase() -Methode von Counter ! Implementieren Sie eine Methode public String toString() . Diese Methode gibt die Werte von minutes und hours in der Form hh:mm als String zur\u00fcck, also z.B. \"23:59\" oder \"01:09\" . Nutzen Sie die toString() -Methode von Counter ! Implementieren Sie eine Methode public void print() . Diese Methode gibt den aktuellen Wert von Clock unter Verwendung der Methode toString() auf die Konsole aus. Wenn Sie die Methode start() in der Programclass z.B. wie folgt erweitern (der Test von Counter ist hier gel\u00f6scht): public void start () { Clock clock = new Clock (); for ( int i = 0 ; i < 1600 ; i ++ ) { clock . increase (); if ( i % 50 == 0 ) { System . out . printf ( \"%4d : \" , i ); clock . print (); } } } dann sollte folgende Ausgabe auf der Konsole erscheinen: Ausgabe auf der Konsole 0 : 00 :01 50 : 00 :51 100 : 01 :41 150 : 02 :31 200 : 03 :21 250 : 04 :11 300 : 05 :01 350 : 05 :51 400 : 06 :41 450 : 07 :31 500 : 08 :21 550 : 09 :11 600 : 10 :01 650 : 10 :51 700 : 11 :41 750 : 12 :31 800 : 13 :21 850 : 14 :11 900 : 15 :01 950 : 15 :51 1000 : 16 :41 1050 : 17 :31 1100 : 18 :21 1150 : 19 :11 1200 : 20 :01 1250 : 20 :51 1300 : 21 :41 1350 : 22 :31 1400 : 23 :21 1450 : 00 :11 1500 : 01 :01 1550 : 01 :51 Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 8 (Abgabe bis 13.12.2021 24:00 Uhr)"},{"location":"aufgaben/#aufgabe-9-abgabe-bis-03012022-2400-uhr","text":"Aufgabe9 - Bruch Wir erstellen uns einen Datentyp Bruch (extra mal etwas Mathematisches ;-)) Erstellen Sie sich ein neues Projekt aufgabe9 und darin eine neue Klasse Bruch sowie eine Programm-/Testklasse Programclass mit einer main() -Methode. In der Klasse Bruch erstellen Sie zwei Objektvariablen zaehler und nenner jeweils vom Typ int und private . Implementieren Sie fu\u0308r die Klasse Bruch zwei verschiedene Konstruktoren parameterlos \u2192 zaehler und nenner erhalten jeweils den Wert 1 mit zwei Parametern ( int zaehler, int nenner ) \u2192 entspr. Werte der Objektvariablen Implementieren Sie folgende Objektmethoden public Bruch plus(Bruch b) \u2192 gibt den geku\u0308rzten Bruch aus der Addition eines Bruchs mit b zuru\u0308ck public Bruch minus(Bruch b) \u2192 gibt den geku\u0308rzten Bruch aus der Subtraktion eines Bruchs mit b zuru\u0308ck public Bruch mal(Bruch b) \u2192 gibt den geku\u0308rzten Bruch aus der Multiplikation eines Bruchs mit b zuru\u0308ck public Bruch geteilt(Bruch b) \u2192 gibt den geku\u0308rzten Bruch aus der Division eines Bruchs mit b zuru\u0308ck public Bruch kuerzen() \u2192 gibt den geku\u0308rzten Bruch zuru\u0308ck (Sie brauchen dazu den ggT ) _ public String toString() \u2192 gibt einen Bruch als String in der Form zaehler / nenner zur\u00fcck (annotieren Sie diese Methode als \u00fcberschrieben !) public int ggT(int zahl1, int zahl2) \u2192 gibt den gr\u00f6\u00dften gemeinsamen Teiler (ggT) der beiden Zahlen zahl1 und zahl2 als int zuru\u0308ck - siehe Euklidischer Algorithmus Geben Sie in die main() -Methode der Programclass -Klasse mindestens folgende Anweisungen ein: Bruch b1 = new Bruch ( 3 , 7 ); Bruch b2 = new Bruch ( 4 , 8 ); Bruch b3 = new Bruch ( 2 , 5 ); Bruch b4 = new Bruch ( 5 , 11 ); Bruch b5 = new Bruch (); System . out . printf ( \"%n%n------------------------- Rechnen -----------------------------------%n%n\" ); System . out . printf ( \"%5s + %5s = %5s %n\" , b1 . toString (), b2 . toString (), b1 . plus ( b2 ). toString ()); System . out . printf ( \"%5s - %5s = %5s %n\" , b3 . toString (), b4 . toString (), b3 . minus ( b4 ). toString ()); System . out . printf ( \"%5s * %5s = %5s %n\" , b1 . toString (), b3 . toString (), b1 . mal ( b3 ). toString ()); System . out . printf ( \"%5s / %5s = %5s %n\" , b2 . toString (), b1 . toString (), b2 . geteilt ( b1 ). toString ()); System . out . printf ( \"%5s + %5s = %5s %n\" , b5 . toString (), b4 . toString (), b5 . plus ( b4 ). toString ()); System . out . printf ( \"%5s - %5s = %5s %n\" , b1 . toString (), b1 . toString (), b1 . minus ( b1 ). toString ()); // nenner sollte ungleich 0 bleiben! und f\u00fchren Sie die main() -Methode aus. Es sollten folgende Augaben entstehen: ------------------------- Rechnen ----------------------------------- 3 /7 + 4 /8 = 13 /14 2 /5 - 5 /11 = -3/55 3 /7 * 2 /5 = 6 /35 4 /8 / 3 /7 = 7 /6 1 /1 + 5 /11 = 16 /11 3 /7 - 3 /7 = 0 /1 Implementieren Sie folgende Objektmethoden public boolean istGroesser(Bruch b) \u2192 gibt true zur\u00fcck, wenn der aufrufende Bruch gr\u00f6\u00dfer als b ist, false sonst public boolean istKleiner(Bruch b) \u2192 gibt true zur\u00fcck, wenn der aufrufende Bruch kleiner als b ist, false sonst public boolean istGleich(Bruch b) \u2192 gibt true zur\u00fcck, wenn der aufrufende Bruch gleich b ist, false sonst Geben Sie in die main() -Methode der Programclass -Klasse mindestens folgende weitere Anweisungen ein: System . out . printf ( \"%n%n------------------------- Vergleichen -----------------------------------%n%n\" ); System . out . printf ( \"%5s > %5s ? %b %n\" , b1 . toString (), b2 . toString (), b1 . istGroesser ( b2 )); System . out . printf ( \"%5s < %5s ? %b %n\" , b1 . toString (), b2 . toString (), b1 . istKleiner ( b2 )); System . out . printf ( \"%5s == %5s ? %b %n\" , b1 . toString (), b2 . toString (), b1 . istGleich ( b2 )); System . out . printf ( \"%5s > %5s ? %b %n\" , b3 . toString (), b4 . toString (), b3 . istGroesser ( b4 )); System . out . printf ( \"%5s < %5s ? %b %n\" , b3 . toString (), b4 . toString (), b3 . istKleiner ( b4 )); System . out . printf ( \"%5s == %5s ? %b %n\" , b3 . toString (), b4 . toString (), b3 . istGleich ( b4 )); System . out . printf ( \"%5s > %5s ? %b %n\" , b5 . toString (), b5 . toString (), b5 . istGroesser ( b5 )); System . out . printf ( \"%5s < %5s ? %b %n\" , b5 . toString (), b5 . toString (), b5 . istKleiner ( b5 )); System . out . printf ( \"%5s == %5s ? %b %n\" , b5 . toString (), b5 . toString (), b5 . istGleich ( b5 )); und f\u00fchren Sie die main() -Methode aus. Es sollten folgende weitere Ausgaben entstehen: ------------------------- Vergleichen ----------------------------------- 3 /7 > 4 /8 ? false 3 /7 < 4 /8 ? true 3 /7 == 4 /8 ? false 2 /5 > 5 /11 ? false 2 /5 < 5 /11 ? true 2 /5 == 5 /11 ? false 1 /1 > 1 /1 ? false 1 /1 < 1 /1 ? false 1 /1 == 1 /1 ? true Zusatzaufgabe : \u00dcberschreiben Sie f\u00fcr Bruch die Methoden public boolean equals(Object o) und public int hashCode() . Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 9 (Abgabe bis 03.01.2022 24:00 Uhr)"},{"location":"aufgaben/#aufgabe-10-abgabe-bis-10012022-2400-uhr","text":"Aufgabe 10 - Arrays ausgeben L\u00f6sen Sie die Aufgabe mit Eclipse oder einer IDE Ihrer Wahl. Wir geben Arrays in verschiedenen Arten auf der Konsole aus. Erstellen Sie sich ein package aufgaben.aufgabe10 und in diesem package zwei Klassen Programmklasse (mit main() -Methode) und Aufgabe10 . Implementieren Sie in der Klasse Aufgabe10 eine Methode public int[] createAndFillArray(int length, int fromInclusive, int toInclusive) . Diese Methode soll genau so sein, wie die createAndFillArray(int length, int bound) -Methode in Methoden mit Array als R\u00fcckgabe mit dem einzigen Unterschied, dass wir nicht den bound angeben (der sorgt ja daf\u00fcr, dass wir Zufallswerte aus dem Bereich [0, 1, ... , bound-1] erzeugen), sondern fromInclusive und toExclusive , so dass wir Zufallswerte aus dem Wertebereich [fromInclusive, ... , toInclusive] erzeugen. Siehe dazu auch nextInt(bound) . Implementieren Sie eine Methode public void printArray(int[] a) so, dass sie ein int -Array in der Form [ 27, 30, 25, 26, 23, 20, 30, 30, 22, 21, 29, 29, 21, 20 ] (also Werte durch Komma getrennt in eckigen Klammern) ausgibt. Siehe dazu Ausgabe von Arrays . Rufen Sie in der main() die beiden Methoden wie folgt auf: Random r = new Random (); // java.util.Random importieren Aufgab10 a10 = new Aufgabe10 (); int length = r . nextInt ( 10 ) + 10 ; int [] arr1 = a10 . createAndFillArray ( length , 20 , 30 ); System . out . printf ( \"%n%n%n----------- printArray -----------------%n%n%n\" ); a10 . printArray ( arr1 ); Implementieren Sie eine Methode public void printTable(int[] a) . Diese gibt das Array a als Tabelle in folgender Form aus: | Index : | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | | ------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | | Wert : | 27 | 30 | 25 | 26 | 23 | 20 | 30 | 30 | 22 | 21 | 29 | 29 | 21 | 20 | Rufen Sie in der main() die Methode printTable() wie folgt auf: System . out . printf ( \"%n%n%n----------- printTable -----------------%n%n%n\" ); a10 . printTable ( arr1 ); Implementieren Sie eine Methode public void printHorizontal(int[] a) . Diese gibt das Array a in folgender Form aus: | 0 | *************************** | 1 | ****************************** | 2 | ************************* | 3 | ************************** | 4 | *********************** | 5 | ******************** | 6 | ****************************** | 7 | ****************************** | 8 | ********************** | 9 | ********************* | 10 | ***************************** | 11 | ***************************** | 12 | ********************* | 13 | ******************** | Das hei\u00dft, f\u00fcr jeden Wert im Array wird die entsprechende Anzahl von Sternen ausgegeben. Ganz links steht jeweils der Index, unter dem der Wert im Array gespeichert wird. Rufen Sie in der main() die Methode printTable() wie folgt auf: System . out . printf ( \"%n%n%n----------- printHorizontal ------------%n%n%n\" ); a10 . printHorizontal ( arr1 ); Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgende(n) Aufgabe(n) sind optional : Implementieren Sie eine Methode public void printUpsideDown(int[] a) oder eine Methode public void printVertical(int[] a) (beide gleicher Aufwand). Diese geben das Array a in folgender Form aus: ----------- printUpsideDown ------------ | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 ----+---------------------------------------------------------------------- 1 | * * * * * * * * * * * * * * 2 | * * * * * * * * * * * * * * 3 | * * * * * * * * * * * * * * 4 | * * * * * * * * * * * * * * 5 | * * * * * * * * * * * * * * 6 | * * * * * * * * * * * * * * 7 | * * * * * * * * * * * * * * 8 | * * * * * * * * * * * * * * 9 | * * * * * * * * * * * * * * 10 | * * * * * * * * * * * * * * 11 | * * * * * * * * * * * * * * 12 | * * * * * * * * * * * * * * 13 | * * * * * * * * * * * * * * 14 | * * * * * * * * * * * * * * 15 | * * * * * * * * * * * * * * 16 | * * * * * * * * * * * * * * 17 | * * * * * * * * * * * * * * 18 | * * * * * * * * * * * * * * 19 | * * * * * * * * * * * * * * 20 | * * * * * * * * * * * * * * 21 | * * * * * * * * * * * * 22 | * * * * * * * * * * 23 | * * * * * * * * * 24 | * * * * * * * * 25 | * * * * * * * * 26 | * * * * * * * 27 | * * * * * * 28 | * * * * * 29 | * * * * * 30 | * * * ----------- printVertical -------------- 30 | * * * 29 | * * * * * 28 | * * * * * 27 | * * * * * * 26 | * * * * * * * 25 | * * * * * * * * 24 | * * * * * * * * 23 | * * * * * * * * * 22 | * * * * * * * * * * 21 | * * * * * * * * * * * * 20 | * * * * * * * * * * * * * * 19 | * * * * * * * * * * * * * * 18 | * * * * * * * * * * * * * * 17 | * * * * * * * * * * * * * * 16 | * * * * * * * * * * * * * * 15 | * * * * * * * * * * * * * * 14 | * * * * * * * * * * * * * * 13 | * * * * * * * * * * * * * * 12 | * * * * * * * * * * * * * * 11 | * * * * * * * * * * * * * * 10 | * * * * * * * * * * * * * * 9 | * * * * * * * * * * * * * * 8 | * * * * * * * * * * * * * * 7 | * * * * * * * * * * * * * * 6 | * * * * * * * * * * * * * * 5 | * * * * * * * * * * * * * * 4 | * * * * * * * * * * * * * * 3 | * * * * * * * * * * * * * * 2 | * * * * * * * * * * * * * * 1 | * * * * * * * * * * * * * * ----+---------------------------------------------------------------------- | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 Rufen Sie in der main() die beiden Methoden (oder die, die Sie implememntiert haben) wie folgt auf: System . out . printf ( \"%n%n%n----------- printUpsideDown ------------%n%n%n\" ); a10 . printUpsideDown ( arr1 ); System . out . printf ( \"%n%n%n----------- printVertical --------------%n%n%n\" ); a10 . printVertical ( arr1 ); Tipps zum L\u00f6sen der Zusatzaufgabe: Sie m\u00fcssen zun\u00e4chst ermitteln, welcher der gr\u00f6\u00dfte Wert innerhalb des Arrays ist, denn dieser gibt Ihnen die Anzahl der Zeilen im Diagramm vor. Stellen Sie sich das Problem als eine Matrix aus Zeilen und Spalten vor. Die Spalten lassen sich auf den Index des Arrays mappen und die Zeilen auf die Werte im Array. Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 10 (Abgabe bis 10.01.2022 24:00 Uhr)"},{"location":"aufgaben/#aufgabe-11-abgabe-bis-17012022-2400-uhr","text":"Aufgabe 11 - Arrays bef\u00fcllen L\u00f6sen Sie die Aufgabe mit Eclipse oder einer IDE Ihrer Wahl. Wir bef\u00fcllen ein char -Array, aber das ist leider gar nicht so einfach ;-) Erstellen Sie sich ein package aufgaben.aufgabe11 und in diesem package zwei Klassen Programmklasse (mit main() -Methode) und Aufgabe11 . einleitende Vorbetrachtung: angenommen, wir haben die folgende Schleife: 1 2 3 4 5 for ( int asciiValue = 97 ; asciiValue < 123 ; asciiValue ++ ) { char c = ( char ) asciiValue ; System . out . print ( c + \" \" ); } Durch diese wird uns das gesamte Alphabet in Kleinbuchstaben ausgegeben: a b c d e f g h i j k l m n o p q r s t u v w x y z Kopieren Sie die Schleife einfach in Ihre main() -Methode und f\u00fchren Sie sie aus, dann erhalten Sie obige Ausgabe. Dahinter steckt, dass wir der int -Variablen asciiValue den ASCII-Code der Kleinbuchstaben zuweisen (beginnend bei 97 - das ist ein a ). Siehe z.B. hier . Der letzte kleine Buchstabe z hat den ASCII-Wert 122 , deshalb l\u00e4uft die Schleife auch bis <123 . In Zeile 3 der Schleife findet eine Typkonvertierung statt. Aus dem int wird ein char . Dies geschieht durch den Typkonvertierungsoperator (char) . In Zeile 4 wird das Zeichen c vom Typ char ausgegeben. Aufgabe Die Aufgabe ist es nun, ein char -Array zu bef\u00fcllen. Es gelten folgende Bedingungen: das Array hat (nur) die L\u00e4nge 25 in dem Array darf es keine Doppelungen geben (also kein Zeichen darf doppelt enthalten sein) die Zeichen werden zuf\u00e4llig erzeugt, d.h. mithilfe der Klasse Random und der Methode nextInt(bound) , die Werte zwischen 97 und einschlie\u00dflich 122 erzeugen soll Schreiben Sie daf\u00fcr eine Methode public char[] createAndFillCharArray() in dieser Methode erzeugen Sie das char[] der L\u00e4nge 25 , ein Random -Objekt, mit dem Sie unter Verwendung der nextInt(bound) -Methode zuf\u00e4llig Zahlen zwischen 97 und einschlie\u00dflich 122 erzeugen, die erzeugten int -Werte konvertieren Sie mithilfe des (char) -Typecast-Operators nach char , dann bef\u00fcllen Sie das char[] \u2192 passen Sie aber auf, dass Sie kein Zeichen hinzuf\u00fcgen, das bereits im Array enthalten ist \u2192 dazu ben\u00f6tigen Sie die contains() -Methode: Schreiben Sie eine Methode public boolean contains(char[] ca, char c) . Diese gibt ein true zur\u00fcck, wenn c in ca enthalten ist und ein false , wenn nicht. Schreiben Sie eine Methode public char[] sort(char[] a) . Diese gibt ein char[] zur\u00fcck, welches sortiert ist. Das \u00fcbergebene Array a ist unsortiert. Siehe dazu Sortieren von Arrays . Schreiben Sie eine Methode public void print(char[] a) , die ein \u00fcbergebenes char[] in der Form [ o, g, f, p, a, c, s, i, e, q, h, l, t, r, w, z, v, x, y, u, b, j, k, m, n ] ausgibt. Geben Sie in Ihre main() -Methode folgende Anweisungen ein: Aufgabe11 a11 = new Aufgabe11 (); System . out . printf ( \"%n%n----------------- Erzeugen ------------------%n%n\" ); char [] ca1 = a11 . createAndFillCharArray (); a11 . print ( ca1 ); System . out . printf ( \"%n%n----------------- Sortieren ------------------%n%n\" ); char [] ca2 = a11 . sort ( ca1 ); a11 . print ( ca2 ); Es sollten Ausgaben in der Form: ----------------- Erzeugen ------------------ [ o, g, f, p, a, c, s, i, e, q, h, l, t, r, w, z, v, x, y, u, b, j, k, m, n ] ----------------- Sortieren ------------------ [ a, b, c, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z ] erscheinen. Beachten Sie, dass die Eintr\u00e4ge im Array zuf\u00e4llig erzeugt wurden. Beachten Sie au\u00dferdem, dass ein Buchstabe aus dem Alphabet fehlt, hier z.B. d (das Array hat die L\u00e4nge 25 , das Alphabet hat 26 Buchstaben). Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgende(n) Aufgabe(n) sind optional : Schreiben Sie eine Methode public char getMissingLetter(char[] a) . Dieser Methode wird ein durch die obige Methode createAndFillCharArray() erstelltes char -Array \u00fcbergeben. Das Array hat also die L\u00e4nge 25 hat und aus dem Alphabet fehlt genau ein kleiner Buchstabe. Finden Sie den Buchstaben und geben ihn zur\u00fcck. Schreiben Sie eine Methode public void findWord(String word) . Dieser Methode wird eine Zeichenkette \u00fcbergeben, die nur aus Buchstaben besteht. Sie k\u00f6nnen annehmen, dass es nur kleine Buchstaben sind, Sie k\u00f6nnen aber erstmal die toLowerCase() -Methode anwenden (siehe String ). Rufen Sie f\u00fcr jedes Zeichen aus dem String die beiden Methoden createAndFillCharArray() und getMissingLetter() auf, bis das von der getMissingLetter() -Methode zur\u00fcckgegebene Zeichen dem Zeichen des Strings entspricht, das Sie gerade betrachten. Eine Ausgabe als Beispiel: w..........w ( 11 ) e.e ( 2 ) i..i ( 3 ) h............h ( 13 ) n..............................n ( 31 ) a........a ( 9 ) c..c ( 3 ) h...........................................................h ( 60 ) t....t ( 5 ) e.....e ( 6 ) nn ( 1 ) Die Ausgabe erfolgte durch den Aufruf von findWord(\"weihnachten\"); . Ganz links in der Zeile steht immer das Zeichen des Strings, das gerade betrachtet wird. Dann kommen f\u00fcr jeden fehlgeschlagenen Versuch, durch getMissingLetter() das 'w' zur\u00fcck zu bekommen, die Ausgabe eines Punktes. Sollte getMissingLetter() das 'w'` zur\u00fcckgeben, wird es ausgegeben und au\u00dferdem noch in Klammern die Anzahl der Versuche. Der Cursor wechselt in die n\u00e4chste Zeile und das n\u00e4chste Zeichen des Strings ist dran. Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 11 (Abgabe bis 17.01.2022 24:00 Uhr)"},{"location":"aufgaben/#aufgabe-12-abgabe-bis-24012022-2400-uhr","text":"Aufgabe 12 - SortedArray Wir erstellen uns einen neuen Datentyp SortedArray Idee : Ein Objekt dieser Klasse beschreibt (enth\u00e4lt) ein int -Array, in dem die Elemente aufsteigend sortiert sind und kein Element doppelt vorkommt. Das Array ist stets genau so gro\u00df, so viele Elemente es enth\u00e4lt! Erstellen Sie im package aufgaben.aufgabe12 eine Klasse SortedArray ohne main() -Methode und eine Klasse SortedArrayTest mit main() -Methode. In der Klasse SortedArray erstellen Sie eine Objektvariable s vom Typ int[] ( private ). Implementieren Sie fu\u0308r die Klasse SortedArray zwei verschiedene Konstruktoren parameterlos \u2192 der Konstruktor erzeugt ein leeres Array s (mit der L\u00e4nge 0 ) mit einem Parameter ( int element ) \u2192 der Konstruktor erzeugt ein einelementiges Array s (mit der L\u00e4nge 1 ), wobei s[0] den Wert von element annimmt. Implementieren Sie eine Objektmethode public boolean insert(int element) . Diese Methode gibt ein false zuru\u0308ck, wenn element bereits in s enthalten ist. Dann wird das element nicht dem Array hinzugefu\u0308gt. Die Methode gibt true zuru\u0308ck, wenn element in s eingefu\u0308gt wurde. Um element einzufu\u0308gen, wird ein neues Array fu\u0308r s erzeugt, in dem alle vorherigen Werte aus s und das neue element (an der richtigen Stelle einsortiert) enthalten sind. Implementieren Sie eine Objektmethode public boolean delete(int element) . Diese Methode gibt ein false zuru\u0308ck, wenn element nicht in s enthalten ist. Die Methode gibt true zuru\u0308ck, wenn element aus s gel\u00f6scht wurde. Beachten Sie, dass nach L\u00f6schen aus s die L\u00e4nge von s um eins kleiner ist, als vor dem L\u00f6schen. Es muss also auch hier wieder ein neues Array erzeugt werden, welches nach dem L\u00f6schen dem \"Wert\" von s entspricht. Implementieren Sie eine Objektmethode public void print() , die das Array s in der Form [ 4, 5, 9 ] (Beispielwerte) ausgibt. Tipp : Um zu \u00fcberpr\u00fcfen, ob ein int element in s enthalten ist, sollten Sie sich eine Methode boolean contains(int element) schreiben (diese kann private sein, wenn sie nur innerhalb der Klasse verwendet werden soll; sogenannte Servicemethode ). Angenommen, Sie haben zwei Arrays: s = [ 4, 9 ] und copy = [ 4, 5, 9] , dann gilt nach s = copy; , dass s == [ 4, 5, 9 ] . Geben Sie in die main() -Methode der SortedArrayTest -Klasse mindestens folgende Anweisungen ein: System . out . printf ( \"%n%n------------------------- Test a1 -----------------------------------%n%n\" ); SortedArray a1 = new SortedArray (); a1 . print (); a1 . delete ( 5 ); a1 . print (); a1 . insert ( 5 ); a1 . print (); a1 . insert ( 7 ); a1 . print (); a1 . delete ( 5 ); a1 . print (); a1 . insert ( 6 ); a1 . print (); a1 . insert ( 4 ); a1 . print (); a1 . insert ( 8 ); a1 . print (); a1 . delete ( 8 ); a1 . print (); a1 . delete ( 6 ); a1 . print (); System . out . printf ( \"%n%n------------------------- Test a2 -----------------------------------%n%n\" ); SortedArray a2 = new SortedArray ( 9 ); a2 . print (); a2 . insert ( 5 ); a2 . print (); a2 . insert ( 9 ); a2 . print (); a2 . insert ( 5 ); a2 . print (); a2 . insert ( 4 ); a2 . print (); a2 . insert ( 4 ); a2 . print (); a2 . delete ( 5 ); a2 . print (); a2 . delete ( 9 ); a2 . print (); a2 . delete ( 4 ); a2 . print (); a2 . delete ( 4 ); a2 . print (); und f\u00fchren Sie die SortedArrayTest -Klasse aus. Es sollten folgende Augaben entstehen: ------------------------- Test a1 ----------------------------------- [ ] [ ] [ 5 ] [ 5 , 7 ] [ 7 ] [ 6 , 7 ] [ 4 , 6 , 7 ] [ 4 , 6 , 7 , 8 ] [ 4 , 6 , 7 ] [ 4 , 7 ] ------------------------- Test a2 ----------------------------------- [ 9 ] [ 5 , 9 ] [ 5 , 9 ] [ 5 , 9 ] [ 4 , 5 , 9 ] [ 4 , 5 , 9 ] [ 4 , 9 ] [ 4 ] [ ] [ ] Viel Spa\u00df und viel Erfolg!","title":"Aufgabe 12 (Abgabe bis 24.01.2022 24:00 Uhr)"},{"location":"ausdruecke/","text":"Operatoren und Ausdr\u00fccke \u00b6 Im vorherigen Abschnitt haben wir Variablen und Datentypen kennengelernt. Wir k\u00f6nnen Variablen deklarieren und initialisieren und ihnen neue Werte zuweisen. Nun f\u00fchren wir Operationen ein, die wir in den jeweiligen Datentypen verwenden k\u00f6nnen, um neue Werte zu erzeugen. Wir beginnen bei den arithmetischen Operatoren, d.h. mit den Operatoren, die wir f\u00fcr die ganzzahligen Datentypen und die Gleitkomma-Datentypen verwenden k\u00f6nnen. Arithmetische Operatoren \u00b6 Arithmetische Operationen kennen wir nat\u00fcrlich schon. Die einfachsten arithmetischen Operatoren sind die un\u00e4ren Operatoren, auch Vorzeichenoperatoren genannt. Ansonsten gibt es die Addition + , die Subtraktion - , die Multiplikation * und die Division / . Au\u00dferdem gibt es auch einen Restwertoperator (auch modulo genannt), der bei der ganzzahligen Division den verbleibenden Rest als Ergebnis ermittelt ( % ). Ganz wichtig ist, dass das Divisionssymbol / eine unterschiedliche Bedeutung hat, je nachdem, ob wir ganze Zahlen dividieren oder Gleitkommazahlen. Bei der Division von ganzen Zahlen ist das Ergebnis der Division der ganzzahlige Wert (also z.B. 5 / 4 ergibt 1 ), aber bei der Division von Gleitkommazahlen ein Gleitkommawert (also z.B. 5.0 / 4.0 ergibt 1.25 ). Der Restwertoperator wird wirklich sinnvoll eigentlich nur f\u00fcr ganze Zahlen verwendet (also z.B. 7 % 4 ergibt 3 - der verbleibende Rest der ganzzahligen Divsion ist 3 ). Trotzdem kann der Restwertoperator auch auf Gleitkommazahlen angewendet werden (obwohl dort ja eigentlich kein Rest bleibt). So ergibt 7.0 % 4.0 auch 3.0 und/aber 7.5 % 4.0 ergibt 3.5 . Operatorsymbol(e) Bedeutung Beispiel Un\u00e4re Operatoren + Wird als Vorzeichen vor ganzen Zahlen (z.B. +5 ) oder vor Gleikommazahlen (z.B. +5.5 ) verwendet. + \u00e4ndert nichts und kann immer weggelassen werden. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = +x; Wert von x ist -5 - Wird als Vorzeichen vor ganzen Zahlen (z.B. -5 ) oder vor Gleikommazahlen (z.B. -5.5 ) verwendet. -x dreht das Vorzeichen von x um. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = -x; Wert von x ist +5 double y = -5.5; y = -y; Wert von y ist +5.5 Bin\u00e4re Operatoren + Addition von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 + 6; Wert von x: +1 double y = -5.5 + 6.5; Wert von y: +1.0 - Subtraktion von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 - 6; Wert von x ist -11 double y = -5.5 - 6.5; Wert von y: -12.0 * Multiplikation von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 * 6; Wert von x: -30 double y = -5.0 * 6.0; Wert von y: -30.0 / Division von Zahlen. Achtung! Sie m\u00fcssen unterscheiden, ob Sie ganze Zahlen dividieren oder Gleitkommazahlen! Bei ganzen Zahlen handelt es sich um die ganzzahlige Division! int x = 5 / 4; Wert von x: +1 double y = 5.0 / 4.0; Wert von y: +1.25 % Restwertoperator. Ergebnis ist der Rest, der bei ganzzahliger Division \u00fcbrig bleibt. Wirklich sinnvoll nur bei ganzzahligen Werten, geht aber auch bei Gleitkommazahlen. int x = 7 % 4; Wert von x ist 3 double y = 6.5 % 5.0; Wert von y ist 1.5 Pr\u00e4- und Postfix-Operatoren \u00b6 Dar\u00fcber hinaus gibt es noch besondere Operatoren, die eingef\u00fchrt wurden, weil sie eine h\u00e4ufig vorkommende Operation in der Schreibweise verk\u00fcrzen. Angenommen, wir haben eine Variable int x = 5; . Da es (insbesondere sp\u00e4ter in Schleifen) h\u00e4ufig vorkommt, dass der Wert dieser Variablen um 1 erh\u00f6ht werden soll, hat man daf\u00fcr einen eigenen Operator eingef\u00fchrt: ++ . Dieser Operator steht f\u00fcr die Erh\u00f6hung des Wertes um den Summanden 1 . Er kann sowohl als Pr\u00e4fix-Operator ( ++x ) als auch als Postfix-Operator eingesetzt werden. Man spricht hier von Pr\u00e4- und Postfix- Inkrement -Operatoren. 1 2 3 4 5 int x = 5 ; System . out . println ( x ++ ); // 5 System . out . println ( x ); // 6 System . out . println ( ++ x ); // 7 System . out . println ( x ); // 7 Der Unterschied zwischen den beiden wird im obigen Beispiel deutlich. x hat nach der Initialisierung den Wert 5 . In Zeile 2 geben wir den Wert aus und erh\u00f6hen x danach um 1 . Ausgegeben wird also der Wert 5 , aber nach der Ausgabe ist der Wert um 1 erh\u00f6ht auf 6 (siehe Zeile 3 ). Bei dem Prefix-Operator (Zeile 4 ) wird der Wert erst erh\u00f6ht und dann ausgelesen. Es wird also bereits der neue Wert 7 ausgegeben. Im Prinzip entsprechen beide Operatoren aber der Anweisung x = x + 1; . Den \u00e4quivalenten Operator gibt es auch f\u00fcr die Subtraktion minus 1 . Dies wird mit dem Prefix-Operator --x; sowie mit dem Postfix-Operator x--; erreicht. Diese hei\u00dfen Pr\u00e4- und Postfix- Dekrement -Operatoren. Verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren \u00b6 Aus dieser Verwendung haben sich weitere Schreibweisen etabliert: Operatoren (Beispiele) Bedeutung x+=7; x = x + 7; x-=7; x = x - 7; x*=7; x = x * 7; x/=7; x = x / 7; x%=7; x = x % 7; Vergleichsoperatoren \u00b6 Werden die oben genannten Operatoren auf arithmetische Datentypen angewendet, so ist das Ergebnis selbst wieder von einem arithmetischen Datentyp ( int oder double ). Bei den folgenden Vergleichsoperatoren ist das anders. Die Operanden sind zwar auch wieder von arithmetischen Datentypen, aber das Ergebnis ist ein boolean , das hei\u00dft, der Vergleich resultiert in einem Wert true oder in einem Wert false . Vergleichsoperator Beispiel Bedeutung == x == y Vergleich auf Gleichheit. Ergibt true , wenn x den gleichen Wert hat wie y , sonst false < x < y Kleiner als. Ergibt true , wenn x einen echt kleineren Wert hat als y , sonst false > x > y Gr\u00f6\u00dfer als. Ergibt true , wenn x einen echt gr\u00f6\u00dferen Wert hat als y , sonst false < = x < = y Kleiner gleich. Ergibt true , wenn x einen kleineren als oder den gleichen Wert wie y hat, sonst false >= x >= y Gr\u00f6\u00dfer gleich. Ergibt true , wenn x einen gr\u00f6\u00dferen als oder den gleichen Wert wie y hat, sonst false != x != y Ungleich. Ergibt true , wenn x einen anderen Wert hat als y , sonst false Wertzuweisungsoperator \u00b6 Einen weiteren Operator kennen wir bereits, den Wertzuweisungsoperator = . Auf der linken Seite der Zuweisung steht immer eine Variable und auf der rechten Seite ein Wert, der sich auch aus einem Ausdruck ergeben kann, z.B. int x = 5 + 6; . Dann wird x der Wert 11 zugeweisen. Beachte Der Zuweisungsoperator ist zun\u00e4chst gew\u00f6hnungsbed\u00fcrftig, denn eine Zuweisung der Form x = x+1; sieht ja aus mathematischer Sicht komisch aus, da in der Mathematik das Symbol = f\u00fcr die Gleichheit verwendet wird. In der (Java-)Programmierung hat dieses Symbol aber eine andere Bedeutung, n\u00e4mlich die Zuweisung des Wertes auf der rechten Seite zur Variablen auf der linken Seite. In der Zuweisung x = x+1; wird also erst der Wert x+1 berechnet und dieser Wert dann der Variablen x zugeordnet (die dann einen um 1 h\u00f6heren Wert hat als zuvor). Der Operator f\u00fcr die Gleichheit ist \u00fcbrigens == , wie wir gleich sehen werden. Logische Operatoren \u00b6 Die arithmetischen Operatoren werden auf Operanden angewendet, die von einem ganzzahligen Datentyp oder von einem Gleitkomma-Datentyp sind. Jetzt lernen wir Operatoren kennen, die auf Operanden vom Typ boolean angewendet werden. Nehmen wir in der folgenden Tabelle an, dass die Variablen a und b jeweils vom Typ boolean sind. Sie wurden also wie folgt deklariert: boolean a; und boolean b; . Logischer Operator Beispiel Bedeutung && a && b UND-Operator. Ergibt true , wenn a den Wert true hat UND b auch den Wert true , sonst false || a || b ODER-Operator. Ergibt true , wenn a den Wert true hat ODER b den Wert true (oder beide), sonst false ^ a ^ b EXCLUSIVES ODER. Ergibt true , wenn ENTWEDER a den Wert true hat ODER b den Wert true (aber NICHT beide), sonst false ! !a NEGATION (un\u00e4rer Operator). Ergibt true , wenn a den Wert false hat, ergibt false , wenn a den Wert true hat Es sein angemerkt, dass es f\u00fcr die Operatoren && und || jeweils auch die Operatoren & und | gibt. Das logische Prinzip ist das gleiche (also UND und ODER). Es gibt nur jeweils eine Unterscheidung und diese ist im folgenden Beispiel dargestellt: false && a // a wird nicht mehr gepr\u00fcft, Ausdruck ist false false & a // a wird gepr\u00fcft, Ausdruck ist false true || b // b wird nicht mehr gepr\u00fcft, Ausdruck ist true true | b // b wird gepr\u00fcft, Ausdruck ist true Ist beim logischen UND bereits der erste Operand false , dann kann das Ergebnis nicht mehr true sein, sondern ist false . Egal, welchen Wert der zweite Operand hat. Bei dem Operator && wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator & aber doch. && ist somit effizienter. Ist beim logischen ODER bereits der erste Operand true , dann ist das Ergebnis bereits true , egal, welchen Wert der zweite Operand hat. Bei dem Operator || wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator | aber doch. || ist somit effizienter. Wir verwenden deshalb immer && und || anstatt & und | . Wahrheitstabellen \u00b6 Hier nochmal eine Veranschaulichung der obigen logischen Operatoren in einer Wahrheitstabelle. Wir nehmen wieder an, dass die Variablen a und b jeweils vom Typ boolean sind. a b a && b a || b a ^ b !a true true true true false false true false false true true false false true false true true true false false false false false true \u00dcbung Exclusives Oder Angenommen, es g\u00e4be den Operator ^ f\u00fcr das Exclusive Oder nicht und Sie h\u00e4tten nur die Operatoren && , || und ! . Wie k\u00f6nnen Sie mit && , || und ! das exclusive Oder \"nachbauen\"? Ausdr\u00fccke und Anweisungen \u00b6 Anweisungen haben wir bereits kennengelernt. Zum Beispiel sind Deklarationen Anweisungen und Initialisierungen auch. Neben Anweisungen gibt es im Programmcode auch Ausdr\u00fccke . Ausdr\u00fccke unterscheiden sich von Anweisungen dahingehened, dass sie einen Wert (genauer einen R\u00fcckgabewert ) haben. Jeder Wert in Java hat einen Typ. Wir schauen uns zun\u00e4chst die einfachsten Ausdr\u00fccke an, die es gibt, n\u00e4mlich sogenannte Literale . Literale \u00b6 Ein Literal ist ein konstanter Wert im Java-Quellcode. Literale sind z.B. ganze Zahlen (z.B. 123 oder -123 ), Gleikommazahlen (z.B 5.5 oder -6.0 ), Wahrheitswerte ( true oder false ), ein Character (z.B. 'a' oder 'A' ) Wir werden sp\u00e4ter noch andere Literale kennenlernen: Zeichenketten (Datentyp String ), z.B. \"Hallo FIW!\" die leere Referenz null Jedes Literal ist ein Ausdruck. Der R\u00fcckgabewert des Literals ist der Wert des Literals. Jedes Literal ist von einem konkreten Datentyp. Die folgenden Anweisungen werden auch Ausdrucksanweisung genannt, da in der Anweisung ein Ausdruck verwendet wird und der Wert dieses Ausdrucks als Nebeneffekt zum Tragen kommt (nur die ersten beiden sind Ausdrucksanweisungen - die folgenden drei sind Fehler ): int x = 123 ; // auf der rechten Seite des Zuweisungsoperators steht ein Ausdruck; // der Wert des Ausdrucks wird der Wert der Variablen x x ++ ; // x++ ist ein Ausdruck - durch das Semikolon wird der Ausdruck hier zu einer Ausdrucksanweisung x ++ // der Ausdruck selbst kann so nicht stehen (Compilerfehler) // da steht nur ein Wert mit dem nichts gemacht wird 5 + 6 // gleicher Fehler wie oben; nur ein Ausdruck, kann so nicht alleine stehen 5 + 6 ; // geht auch nicht; hier gibt es keinen Nebeneffekt (keine Zuweisung) // keine g\u00fcltige Ausdrucksanweisung Ausdr\u00fccke sind Literale Literale, die mit (passenden) Operatoren verkn\u00fcpft sind Ausdr\u00fccke, die mit passenden Operatoren verkn\u00fcpft sind Ausdr\u00fccke mit Operatoren \u00b6 Verbinden wir Literale mit Operatoren, entstehen dadurch Ausdr\u00fccke. Ausdr\u00fccke k\u00f6nnen wiederum mithilfe von Operatoren mit weiteren Literalen oder auch mit weiteren Ausdr\u00fccken verbunden werden. Beachten Sie, dass Ausdr\u00fccke immer einen Wert haben, der Wert ermittelt wird, indem der Ausdruck aufgel\u00f6st wird, d.h. die Operatoren angewendet werden. Dies erfolgt in folgender Reihenfolge: wenn runde Klammern um einen Ausdruck gesetzt sind, wird zun\u00e4chst der geklammerte Ausdruck aufgerufen, un\u00e4re (also einelementige) Operatoren binden st\u00e4rker als bin\u00e4re (also zweielementige) Operatoren, d.h. es werden zun\u00e4chst die einelementigen Operatoren angewendet, bei arithmetischen Operatoren gilt \"Punkt vor Strich-Rechnung\", bei logischen Operatoren gilt folgende Reihenfolge (st\u00e4rkere Bindung von links nach rechts) == , != -> & \u2192 ^ \u2192 | \u2192 && \u2192 || (lernen Sie das aber keinesfalls auswendig und verlassen sich dann auf Ihr Ged\u00e4chtnis, sondern verwenden Sie Klammern!) der Zuweisungsoperator ( = ) sowie += , -= , /= , *= , %= binden am schw\u00e4chsten dann erfolgt die Aufl\u00f6sung von links nach rechts Achten Sie darauf, dass Ausdr\u00fccke einen anderen Typ haben k\u00f6nnen als die Literale (bzw. Ausdr\u00fccke), die man im Ausdruck mithilfe von Operatoren miteinander verbindet, z.B. 3 == 4 ist vom Typ boolean , aber 3 und 4 sind jeweils vom Typ int . Beispiele f\u00fcr Ausdr\u00fccke sind: 5 + 6 - 8 // Ergebnis (Wert) ist ein int true && false // Ergebnis (Wert) ist ein boolean 5 < 6 // Ergebnis (Wert) ist ein boolean 7 >= 7 // Ergebnis (Wert) ist ein boolean 6 == 6 // Ergebnis (Wert) ist ein boolean 6 != 6 // Ergebnis (Wert) ist ein boolean 5.5 * 2.0 // Ergebnis (Wert) ist ein double 7.0 / 4.0 // Ergebnis (Wert) ist ein double ( 7.0 / 4.0 ) > 1.0 // Ergebnis (Wert) ist ein boolean \u00dcbung Ausdruck Angenommen, a , b und c seien vom Typ int . Was ist an diesem Ausdruck falsch: a < b < c ? Wie w\u00e4re es richtig? \u00dcbung Durchschnitt berechnen Angenommen, Sie sollen die Durchschnittsnote von folgenden Noten berechnen: 1 , 1 , 1 , 1 , 2 , 2 , 3 , 4 . Sie \u00fcberlegen sich folgendes Programm daf\u00fcr: int summe = 1 + 1 + 1 + 1 + 2 + 2 + 3 + 4 ; int anzahl = 8 ; System . out . println ( summe / anzahl ); Vom Ergebnis sind Sie aber entt\u00e4uscht. Welches Ergebnis wird ausgegeben? Welches w\u00e4re richtig gewesen? Was ist an Ihrem Programm falsch? Wie geht es besser? Bei der Verwendung des Zuweisungsoperators gibt es auf der linken Seite immer eine Variable und auf der rechten Seite immer einen Ausdruck. Bevor die Zuweisung erfolgt, wird der Wert des Ausdrucks auf der rechten Seite ausgewertet. Beispiele: int x = 0 ; // Wert von x ist 0 x = 7 + 4 / 2 ; // Wert von x ist 9 int y = 7 % 4 ; // Wert von y ist 3 x = y ++ ; // Achtung Wert von x ist 3 (Postfix); Wert von y ist 4 x = y ; // Wert von x ist 4 boolean a = ( 7 > 4 ); // Wert von a ist true a = ! a ; // Wert von a ist false a = ( a || true ); // Wert von a ist true a = !! a && true ; // Wert von a ist true Beachte Generell gilt bei der Zuweisung immer , dass der Ausdruck auf der rechten Seite erst vollst\u00e4ndig ausgerechnet wird und der berechnete Wert dann der Variablen auf der linken Seite zugewiesen wird. \"Leider\" macht der Postfix-Operator dabei eine Ausnahme . Bei diesem Operator erfolgt erst die Zuweisung und dann die Berechnung: int x = 3 ; // x hat den Wert 3 int y = x ++ ; // y hat den Wert 3 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = a -- ; // b hat den Wert 3 und a den Wert 2 Das gilt nicht f\u00fcr den Pr\u00e4fix-Operator: int x = 3 ; // x hat den Wert 3 int y = ++ x ; // y hat den Wert 4 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = -- a ; // b hat den Wert 2 und a den Wert 2","title":"Ausdr\u00fccke"},{"location":"ausdruecke/#operatoren-und-ausdrucke","text":"Im vorherigen Abschnitt haben wir Variablen und Datentypen kennengelernt. Wir k\u00f6nnen Variablen deklarieren und initialisieren und ihnen neue Werte zuweisen. Nun f\u00fchren wir Operationen ein, die wir in den jeweiligen Datentypen verwenden k\u00f6nnen, um neue Werte zu erzeugen. Wir beginnen bei den arithmetischen Operatoren, d.h. mit den Operatoren, die wir f\u00fcr die ganzzahligen Datentypen und die Gleitkomma-Datentypen verwenden k\u00f6nnen.","title":"Operatoren und Ausdr\u00fccke"},{"location":"ausdruecke/#arithmetische-operatoren","text":"Arithmetische Operationen kennen wir nat\u00fcrlich schon. Die einfachsten arithmetischen Operatoren sind die un\u00e4ren Operatoren, auch Vorzeichenoperatoren genannt. Ansonsten gibt es die Addition + , die Subtraktion - , die Multiplikation * und die Division / . Au\u00dferdem gibt es auch einen Restwertoperator (auch modulo genannt), der bei der ganzzahligen Division den verbleibenden Rest als Ergebnis ermittelt ( % ). Ganz wichtig ist, dass das Divisionssymbol / eine unterschiedliche Bedeutung hat, je nachdem, ob wir ganze Zahlen dividieren oder Gleitkommazahlen. Bei der Division von ganzen Zahlen ist das Ergebnis der Division der ganzzahlige Wert (also z.B. 5 / 4 ergibt 1 ), aber bei der Division von Gleitkommazahlen ein Gleitkommawert (also z.B. 5.0 / 4.0 ergibt 1.25 ). Der Restwertoperator wird wirklich sinnvoll eigentlich nur f\u00fcr ganze Zahlen verwendet (also z.B. 7 % 4 ergibt 3 - der verbleibende Rest der ganzzahligen Divsion ist 3 ). Trotzdem kann der Restwertoperator auch auf Gleitkommazahlen angewendet werden (obwohl dort ja eigentlich kein Rest bleibt). So ergibt 7.0 % 4.0 auch 3.0 und/aber 7.5 % 4.0 ergibt 3.5 . Operatorsymbol(e) Bedeutung Beispiel Un\u00e4re Operatoren + Wird als Vorzeichen vor ganzen Zahlen (z.B. +5 ) oder vor Gleikommazahlen (z.B. +5.5 ) verwendet. + \u00e4ndert nichts und kann immer weggelassen werden. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = +x; Wert von x ist -5 - Wird als Vorzeichen vor ganzen Zahlen (z.B. -5 ) oder vor Gleikommazahlen (z.B. -5.5 ) verwendet. -x dreht das Vorzeichen von x um. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = -x; Wert von x ist +5 double y = -5.5; y = -y; Wert von y ist +5.5 Bin\u00e4re Operatoren + Addition von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 + 6; Wert von x: +1 double y = -5.5 + 6.5; Wert von y: +1.0 - Subtraktion von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 - 6; Wert von x ist -11 double y = -5.5 - 6.5; Wert von y: -12.0 * Multiplikation von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 * 6; Wert von x: -30 double y = -5.0 * 6.0; Wert von y: -30.0 / Division von Zahlen. Achtung! Sie m\u00fcssen unterscheiden, ob Sie ganze Zahlen dividieren oder Gleitkommazahlen! Bei ganzen Zahlen handelt es sich um die ganzzahlige Division! int x = 5 / 4; Wert von x: +1 double y = 5.0 / 4.0; Wert von y: +1.25 % Restwertoperator. Ergebnis ist der Rest, der bei ganzzahliger Division \u00fcbrig bleibt. Wirklich sinnvoll nur bei ganzzahligen Werten, geht aber auch bei Gleitkommazahlen. int x = 7 % 4; Wert von x ist 3 double y = 6.5 % 5.0; Wert von y ist 1.5","title":"Arithmetische Operatoren"},{"location":"ausdruecke/#pra-und-postfix-operatoren","text":"Dar\u00fcber hinaus gibt es noch besondere Operatoren, die eingef\u00fchrt wurden, weil sie eine h\u00e4ufig vorkommende Operation in der Schreibweise verk\u00fcrzen. Angenommen, wir haben eine Variable int x = 5; . Da es (insbesondere sp\u00e4ter in Schleifen) h\u00e4ufig vorkommt, dass der Wert dieser Variablen um 1 erh\u00f6ht werden soll, hat man daf\u00fcr einen eigenen Operator eingef\u00fchrt: ++ . Dieser Operator steht f\u00fcr die Erh\u00f6hung des Wertes um den Summanden 1 . Er kann sowohl als Pr\u00e4fix-Operator ( ++x ) als auch als Postfix-Operator eingesetzt werden. Man spricht hier von Pr\u00e4- und Postfix- Inkrement -Operatoren. 1 2 3 4 5 int x = 5 ; System . out . println ( x ++ ); // 5 System . out . println ( x ); // 6 System . out . println ( ++ x ); // 7 System . out . println ( x ); // 7 Der Unterschied zwischen den beiden wird im obigen Beispiel deutlich. x hat nach der Initialisierung den Wert 5 . In Zeile 2 geben wir den Wert aus und erh\u00f6hen x danach um 1 . Ausgegeben wird also der Wert 5 , aber nach der Ausgabe ist der Wert um 1 erh\u00f6ht auf 6 (siehe Zeile 3 ). Bei dem Prefix-Operator (Zeile 4 ) wird der Wert erst erh\u00f6ht und dann ausgelesen. Es wird also bereits der neue Wert 7 ausgegeben. Im Prinzip entsprechen beide Operatoren aber der Anweisung x = x + 1; . Den \u00e4quivalenten Operator gibt es auch f\u00fcr die Subtraktion minus 1 . Dies wird mit dem Prefix-Operator --x; sowie mit dem Postfix-Operator x--; erreicht. Diese hei\u00dfen Pr\u00e4- und Postfix- Dekrement -Operatoren.","title":"Pr\u00e4- und Postfix-Operatoren"},{"location":"ausdruecke/#verkurzte-schreibweisen-fur-arithmetische-operatoren","text":"Aus dieser Verwendung haben sich weitere Schreibweisen etabliert: Operatoren (Beispiele) Bedeutung x+=7; x = x + 7; x-=7; x = x - 7; x*=7; x = x * 7; x/=7; x = x / 7; x%=7; x = x % 7;","title":"Verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren"},{"location":"ausdruecke/#vergleichsoperatoren","text":"Werden die oben genannten Operatoren auf arithmetische Datentypen angewendet, so ist das Ergebnis selbst wieder von einem arithmetischen Datentyp ( int oder double ). Bei den folgenden Vergleichsoperatoren ist das anders. Die Operanden sind zwar auch wieder von arithmetischen Datentypen, aber das Ergebnis ist ein boolean , das hei\u00dft, der Vergleich resultiert in einem Wert true oder in einem Wert false . Vergleichsoperator Beispiel Bedeutung == x == y Vergleich auf Gleichheit. Ergibt true , wenn x den gleichen Wert hat wie y , sonst false < x < y Kleiner als. Ergibt true , wenn x einen echt kleineren Wert hat als y , sonst false > x > y Gr\u00f6\u00dfer als. Ergibt true , wenn x einen echt gr\u00f6\u00dferen Wert hat als y , sonst false < = x < = y Kleiner gleich. Ergibt true , wenn x einen kleineren als oder den gleichen Wert wie y hat, sonst false >= x >= y Gr\u00f6\u00dfer gleich. Ergibt true , wenn x einen gr\u00f6\u00dferen als oder den gleichen Wert wie y hat, sonst false != x != y Ungleich. Ergibt true , wenn x einen anderen Wert hat als y , sonst false","title":"Vergleichsoperatoren"},{"location":"ausdruecke/#wertzuweisungsoperator","text":"Einen weiteren Operator kennen wir bereits, den Wertzuweisungsoperator = . Auf der linken Seite der Zuweisung steht immer eine Variable und auf der rechten Seite ein Wert, der sich auch aus einem Ausdruck ergeben kann, z.B. int x = 5 + 6; . Dann wird x der Wert 11 zugeweisen. Beachte Der Zuweisungsoperator ist zun\u00e4chst gew\u00f6hnungsbed\u00fcrftig, denn eine Zuweisung der Form x = x+1; sieht ja aus mathematischer Sicht komisch aus, da in der Mathematik das Symbol = f\u00fcr die Gleichheit verwendet wird. In der (Java-)Programmierung hat dieses Symbol aber eine andere Bedeutung, n\u00e4mlich die Zuweisung des Wertes auf der rechten Seite zur Variablen auf der linken Seite. In der Zuweisung x = x+1; wird also erst der Wert x+1 berechnet und dieser Wert dann der Variablen x zugeordnet (die dann einen um 1 h\u00f6heren Wert hat als zuvor). Der Operator f\u00fcr die Gleichheit ist \u00fcbrigens == , wie wir gleich sehen werden.","title":"Wertzuweisungsoperator"},{"location":"ausdruecke/#logische-operatoren","text":"Die arithmetischen Operatoren werden auf Operanden angewendet, die von einem ganzzahligen Datentyp oder von einem Gleitkomma-Datentyp sind. Jetzt lernen wir Operatoren kennen, die auf Operanden vom Typ boolean angewendet werden. Nehmen wir in der folgenden Tabelle an, dass die Variablen a und b jeweils vom Typ boolean sind. Sie wurden also wie folgt deklariert: boolean a; und boolean b; . Logischer Operator Beispiel Bedeutung && a && b UND-Operator. Ergibt true , wenn a den Wert true hat UND b auch den Wert true , sonst false || a || b ODER-Operator. Ergibt true , wenn a den Wert true hat ODER b den Wert true (oder beide), sonst false ^ a ^ b EXCLUSIVES ODER. Ergibt true , wenn ENTWEDER a den Wert true hat ODER b den Wert true (aber NICHT beide), sonst false ! !a NEGATION (un\u00e4rer Operator). Ergibt true , wenn a den Wert false hat, ergibt false , wenn a den Wert true hat Es sein angemerkt, dass es f\u00fcr die Operatoren && und || jeweils auch die Operatoren & und | gibt. Das logische Prinzip ist das gleiche (also UND und ODER). Es gibt nur jeweils eine Unterscheidung und diese ist im folgenden Beispiel dargestellt: false && a // a wird nicht mehr gepr\u00fcft, Ausdruck ist false false & a // a wird gepr\u00fcft, Ausdruck ist false true || b // b wird nicht mehr gepr\u00fcft, Ausdruck ist true true | b // b wird gepr\u00fcft, Ausdruck ist true Ist beim logischen UND bereits der erste Operand false , dann kann das Ergebnis nicht mehr true sein, sondern ist false . Egal, welchen Wert der zweite Operand hat. Bei dem Operator && wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator & aber doch. && ist somit effizienter. Ist beim logischen ODER bereits der erste Operand true , dann ist das Ergebnis bereits true , egal, welchen Wert der zweite Operand hat. Bei dem Operator || wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator | aber doch. || ist somit effizienter. Wir verwenden deshalb immer && und || anstatt & und | .","title":"Logische Operatoren"},{"location":"ausdruecke/#wahrheitstabellen","text":"Hier nochmal eine Veranschaulichung der obigen logischen Operatoren in einer Wahrheitstabelle. Wir nehmen wieder an, dass die Variablen a und b jeweils vom Typ boolean sind. a b a && b a || b a ^ b !a true true true true false false true false false true true false false true false true true true false false false false false true \u00dcbung Exclusives Oder Angenommen, es g\u00e4be den Operator ^ f\u00fcr das Exclusive Oder nicht und Sie h\u00e4tten nur die Operatoren && , || und ! . Wie k\u00f6nnen Sie mit && , || und ! das exclusive Oder \"nachbauen\"?","title":"Wahrheitstabellen"},{"location":"ausdruecke/#ausdrucke-und-anweisungen","text":"Anweisungen haben wir bereits kennengelernt. Zum Beispiel sind Deklarationen Anweisungen und Initialisierungen auch. Neben Anweisungen gibt es im Programmcode auch Ausdr\u00fccke . Ausdr\u00fccke unterscheiden sich von Anweisungen dahingehened, dass sie einen Wert (genauer einen R\u00fcckgabewert ) haben. Jeder Wert in Java hat einen Typ. Wir schauen uns zun\u00e4chst die einfachsten Ausdr\u00fccke an, die es gibt, n\u00e4mlich sogenannte Literale .","title":"Ausdr\u00fccke und Anweisungen"},{"location":"ausdruecke/#literale","text":"Ein Literal ist ein konstanter Wert im Java-Quellcode. Literale sind z.B. ganze Zahlen (z.B. 123 oder -123 ), Gleikommazahlen (z.B 5.5 oder -6.0 ), Wahrheitswerte ( true oder false ), ein Character (z.B. 'a' oder 'A' ) Wir werden sp\u00e4ter noch andere Literale kennenlernen: Zeichenketten (Datentyp String ), z.B. \"Hallo FIW!\" die leere Referenz null Jedes Literal ist ein Ausdruck. Der R\u00fcckgabewert des Literals ist der Wert des Literals. Jedes Literal ist von einem konkreten Datentyp. Die folgenden Anweisungen werden auch Ausdrucksanweisung genannt, da in der Anweisung ein Ausdruck verwendet wird und der Wert dieses Ausdrucks als Nebeneffekt zum Tragen kommt (nur die ersten beiden sind Ausdrucksanweisungen - die folgenden drei sind Fehler ): int x = 123 ; // auf der rechten Seite des Zuweisungsoperators steht ein Ausdruck; // der Wert des Ausdrucks wird der Wert der Variablen x x ++ ; // x++ ist ein Ausdruck - durch das Semikolon wird der Ausdruck hier zu einer Ausdrucksanweisung x ++ // der Ausdruck selbst kann so nicht stehen (Compilerfehler) // da steht nur ein Wert mit dem nichts gemacht wird 5 + 6 // gleicher Fehler wie oben; nur ein Ausdruck, kann so nicht alleine stehen 5 + 6 ; // geht auch nicht; hier gibt es keinen Nebeneffekt (keine Zuweisung) // keine g\u00fcltige Ausdrucksanweisung Ausdr\u00fccke sind Literale Literale, die mit (passenden) Operatoren verkn\u00fcpft sind Ausdr\u00fccke, die mit passenden Operatoren verkn\u00fcpft sind","title":"Literale"},{"location":"ausdruecke/#ausdrucke-mit-operatoren","text":"Verbinden wir Literale mit Operatoren, entstehen dadurch Ausdr\u00fccke. Ausdr\u00fccke k\u00f6nnen wiederum mithilfe von Operatoren mit weiteren Literalen oder auch mit weiteren Ausdr\u00fccken verbunden werden. Beachten Sie, dass Ausdr\u00fccke immer einen Wert haben, der Wert ermittelt wird, indem der Ausdruck aufgel\u00f6st wird, d.h. die Operatoren angewendet werden. Dies erfolgt in folgender Reihenfolge: wenn runde Klammern um einen Ausdruck gesetzt sind, wird zun\u00e4chst der geklammerte Ausdruck aufgerufen, un\u00e4re (also einelementige) Operatoren binden st\u00e4rker als bin\u00e4re (also zweielementige) Operatoren, d.h. es werden zun\u00e4chst die einelementigen Operatoren angewendet, bei arithmetischen Operatoren gilt \"Punkt vor Strich-Rechnung\", bei logischen Operatoren gilt folgende Reihenfolge (st\u00e4rkere Bindung von links nach rechts) == , != -> & \u2192 ^ \u2192 | \u2192 && \u2192 || (lernen Sie das aber keinesfalls auswendig und verlassen sich dann auf Ihr Ged\u00e4chtnis, sondern verwenden Sie Klammern!) der Zuweisungsoperator ( = ) sowie += , -= , /= , *= , %= binden am schw\u00e4chsten dann erfolgt die Aufl\u00f6sung von links nach rechts Achten Sie darauf, dass Ausdr\u00fccke einen anderen Typ haben k\u00f6nnen als die Literale (bzw. Ausdr\u00fccke), die man im Ausdruck mithilfe von Operatoren miteinander verbindet, z.B. 3 == 4 ist vom Typ boolean , aber 3 und 4 sind jeweils vom Typ int . Beispiele f\u00fcr Ausdr\u00fccke sind: 5 + 6 - 8 // Ergebnis (Wert) ist ein int true && false // Ergebnis (Wert) ist ein boolean 5 < 6 // Ergebnis (Wert) ist ein boolean 7 >= 7 // Ergebnis (Wert) ist ein boolean 6 == 6 // Ergebnis (Wert) ist ein boolean 6 != 6 // Ergebnis (Wert) ist ein boolean 5.5 * 2.0 // Ergebnis (Wert) ist ein double 7.0 / 4.0 // Ergebnis (Wert) ist ein double ( 7.0 / 4.0 ) > 1.0 // Ergebnis (Wert) ist ein boolean \u00dcbung Ausdruck Angenommen, a , b und c seien vom Typ int . Was ist an diesem Ausdruck falsch: a < b < c ? Wie w\u00e4re es richtig? \u00dcbung Durchschnitt berechnen Angenommen, Sie sollen die Durchschnittsnote von folgenden Noten berechnen: 1 , 1 , 1 , 1 , 2 , 2 , 3 , 4 . Sie \u00fcberlegen sich folgendes Programm daf\u00fcr: int summe = 1 + 1 + 1 + 1 + 2 + 2 + 3 + 4 ; int anzahl = 8 ; System . out . println ( summe / anzahl ); Vom Ergebnis sind Sie aber entt\u00e4uscht. Welches Ergebnis wird ausgegeben? Welches w\u00e4re richtig gewesen? Was ist an Ihrem Programm falsch? Wie geht es besser? Bei der Verwendung des Zuweisungsoperators gibt es auf der linken Seite immer eine Variable und auf der rechten Seite immer einen Ausdruck. Bevor die Zuweisung erfolgt, wird der Wert des Ausdrucks auf der rechten Seite ausgewertet. Beispiele: int x = 0 ; // Wert von x ist 0 x = 7 + 4 / 2 ; // Wert von x ist 9 int y = 7 % 4 ; // Wert von y ist 3 x = y ++ ; // Achtung Wert von x ist 3 (Postfix); Wert von y ist 4 x = y ; // Wert von x ist 4 boolean a = ( 7 > 4 ); // Wert von a ist true a = ! a ; // Wert von a ist false a = ( a || true ); // Wert von a ist true a = !! a && true ; // Wert von a ist true Beachte Generell gilt bei der Zuweisung immer , dass der Ausdruck auf der rechten Seite erst vollst\u00e4ndig ausgerechnet wird und der berechnete Wert dann der Variablen auf der linken Seite zugewiesen wird. \"Leider\" macht der Postfix-Operator dabei eine Ausnahme . Bei diesem Operator erfolgt erst die Zuweisung und dann die Berechnung: int x = 3 ; // x hat den Wert 3 int y = x ++ ; // y hat den Wert 3 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = a -- ; // b hat den Wert 3 und a den Wert 2 Das gilt nicht f\u00fcr den Pr\u00e4fix-Operator: int x = 3 ; // x hat den Wert 3 int y = ++ x ; // y hat den Wert 4 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = -- a ; // b hat den Wert 2 und a den Wert 2","title":"Ausdr\u00fccke mit Operatoren"},{"location":"bluej/","text":"BlueJ \u00b6 Wir lernen unsere Entwicklungsumgebung kennen, die wir in den ersten Wochen f\u00fcr das Programmieren nutzen werden. Es handelt sich um BlueJ . BlueJ wurde extra f\u00fcr Studierende entwickelt, die Programmieren lernen. Das J in BlueJ steht f\u00fcr Java . Mit BlueJ wird also das Programmieren mit Java gelernt. Eine wesentliche Idee hinter der Entwicklung von BlueJ bestand darin, gleich am Anfang mit der objektorientierten Programmierung zu beginnen, d.h. sich gleich mit Klassen und Objekten zu besch\u00e4ftigen. Das passiert h\u00e4ufig erst recht sp\u00e4t in der Programmierausbildung. Wir geben zun\u00e4chst einen groben \u00dcberblick und lernen dabei in kurzer Zeit viele neue Konzepte und Begriffe kennen. Aber keine Sorge, mit all diesen Konzepten besch\u00e4ftigen wir uns jeweils noch ganz ausf\u00fchrlich. Objekte und Klassen \u00b6 Wenn wir uns die Welt betrachten, dann besteht diese aus lauter Objekten , die miteinander in Beziehung stehen. Man ganz konkret \u00fcber bestimmte Objekte sprechen: \u201edas ist ein sch\u00f6ner Stuhl\u201c \u201edas ist ein teurer Tisch\u201c \u201edas Auto ist blau\u201c oder ganz allgemein \u00fcber eine Klasse von Objekten: \u201eInformatikerInnen sind Nerds\u201c \u201eComputer machen immer, was sie wollen\u201c \u201edie Bahnen kommen immer zu sp\u00e4t\u201c In der Welt des objektorientierten Programmierens sind die Klassen die \"Muster\" oder die \"Bauanleitungen\" f\u00fcr konkrete Objekte . Mit Klassen beschreiben wir die allgemeinen Eigenschaften, die f\u00fcr alle Objekte dieser Klasse gelten. Klassen beschreiben eine Struktur der Objekte (das sind die sogenannten Objektvariablen ) und ein Verhalten dieser Objekte (das sind die sogenannten Objektmethoden ). Insgesamt sprechen wir bei der Struktur und dem Verhalten von den Eigenschaften einer Klasse. Eine Klasse ist ein Datentyp und jeder \"Wert\" 1 ist ein konkretes Objekt von diesem Typ. Von einer Klasse k\u00f6nnen wir beliebig viele Objekte erzeugen. Objekte werden aus Klassen erzeugt. Eine Klasse beschreibt die Art und Weise, den Aufbau von Objekten. Objekte sind die speziellen Instanzen einer allgemeinen Klasse. Ein typisches Beispiel ist Auto . Ein Auto kann fahren, hat eine Farbe, ist von einer bestimmten Marke, hat einen bestimmten Motor, eine bestimmte Anzahl von T\u00fcren und so weiter. Das sind alles Eigenschaften eines Autos. Diese Eigenschaften werden in einer Klasse definiert und beschreiben ein Auto im Allgemeinen. Davon gibt es dann konkrete Objekte: ein roter VW Golf mit 5 T\u00fcren, ein blauer Toyota mit 3 T\u00fcren usw. Eine Klasse beschreibt also alle m\u00f6glichen Objekte, die von dieser Klasse erstellt werden k\u00f6nnen. Die Eigenschaften der Objekte werden in Objektvariablen und Objektmethoden beschrieben. Beispiele daf\u00fcr zeigen zun\u00e4chst die folgenden Abbildungen: Objektvariablen \u00b6 In der Klasse Stuhl ist beschrieben, dass jeder Stuhl (jedes Stuhl -Objekt) eine Inventarnummer hat, in einem Raum steht, eine bestimmt Anzahl Beine hat und einen Status , der beschreibt, ob er frei oder besetzt ist. Diese Eigenschaften werden als Objektvariablen definiert. Jedes Objekt der Klasse Stuhl hat seinen eigenen Objektvariablen , n\u00e4mlich genau die vier. Das bedeutet, alle Objekte der Klasse Stuhl haben die gleichen Eigenschaften, aber die konkreten Werte dieser Objektvariablen sind von Stuhl(-Objekt) zu Stuhl(-Objekt) unterschiedlich. Vier konkrete Stuhl-Objekte stuhl1 , stuhl2 , stuhl3 und stuhl4 sind in der Abbildung dargestellt. Objektmethoden \u00b6 Jedes Objekt der Klasse Stuhl hat jeweils konkrete Werte f\u00fcr die Objektvariablen. Zum Beispiel hat das Objekt stuhl1 den Wert 1 f\u00fcr die Inventarnummer , den Wert 123 f\u00fcr den Raum , den Wert 4 f\u00fcr Anzahl Beine und den Wert frei f\u00fcr Status . Wie k\u00f6nnen diese Werte ge\u00e4ndert werden? Die Antwort ist: durch Objektmethoden . Objektmethoden beschreiben das Verhalten eines Objektes. Z.B. kann der Status dadurch ge\u00e4ndert werden, dass man sich auf den Stuhl setzt oder wieder aufsteht. Solche T\u00e4tigkeiten bzw. so ein Verhalten lassen sich durch Obejktmethoden beschreiben. Darin wird etwas getan und zwar haupts\u00e4chlich die Werte von Objektvariablen ge\u00e4ndert oder einfach ausgelesen. M\u00f6gliche Objektmethoden w\u00e4ren also aufstehen (den Status in frei \u00e4ndern), hinsetzen (den Status in besetzt \u00e4ndern), umziehen (den Raum \u00e4ndern), inventarisieren (die Inventarnummer auslesen), zusammenkrachen (die Anzahl Beine \u00e4ndern) usw. Ein erstes Beispiel mit BlueJ \u00b6 Wir \u00f6ffnen BlueJ dann im Men\u00fc auf Project --> Open Project . Im examples -Ordner von BlueJ finden wir den Ordner shapes . Wir w\u00e4hlen den Ordner und klicken auf Open . Es erscheint: Klicken Sie den Button Compile . Objekt erzeugen \u00b6 Klicken Sie dann mit der rechten Maustaste auf das orangene K\u00e4stchen Circle und w\u00e4hlen aus dem Kontextmen\u00fc new Circle () Den Namen circle1 k\u00f6nnen Sie einfach mit Ok best\u00e4tigen. Sie haben soben Ihr erstes Objekt erzeugt! Das orangene K\u00e4stchen, auf das Sie mit der rechten Maus geklickt haben, repr\u00e4sentiert die Klasse Circle . Das rote K\u00e4stchen links unten mit dem Namen circle1 repr\u00e4sentiert ein Objekt dieser Klasse. Konvention: Klassennamen beginnen immer mit Gro\u00dfbuchstaben und Objektnamen immer mit einem kleinen Buchstaben. Methoden aufrufen \u00b6 Klicken Sie nun mit der rechten Maustaste auf das rote K\u00e4stchen circle1 (also auf das Objekt) und w\u00e4hlen dann void makeVisible () aus. Es erscheint: makeVisible() ist eine Methode . Genauer gesagt, handelt es sich um eine Objektmethode . Als wir darauf geklickt haben, haben wir diese Methode aufgerufen . \u00dcbung Methoden aufrufen Rufen Sie (auch mehrmals) die Methoden makeLeft() , makeRight() , makeUp und makeDown() auf. Rufen Sie auch makeInvisible() und dann wieder makeVisible() auf. Methoden erkennen wir an den runden Klammern () hinter dem Namen. In diesen Klammern kann auch ein Wert stehen. Dazu kommen wir jetzt, zu den sogenannten Parametern . Parameter \u00b6 Nun rufen wir die Methode moveHorizontal(int distance) auf. Es erscheint ein Dialog: geben Sie in das Eingabefeld eine Zahl ein, z.B. 50 und klicken OK . Der Kreis bewegt sich horizontal um 50 Bildschirmpunkte nach rechts. Wir \u00fcbergeben dem Methodenaufruf einen Wert (hier: der Wert 50 ). Klicken Sie mit der rechten Maustaste auf das orangene K\u00e4stchen Circle1 (also auf die Klasse Circle ) und w\u00e4hlen Sie Open Editor . Es erscheint: Das Fenster, das sich \u00f6ffnet, ist der sogenannte Editor . Darin sehen wir die Implementierung der Klasse Circle . So sieht ein Java-Programm aus. Wir kommen zu den Details sp\u00e4ter. Zun\u00e4chst suchen wir den folgenden gelb hinterlegten Block (ab Zeile 81 2 ): /** * Move the circle horizontally by 'distance' pixels. */ public void moveHorizontal ( int distance ) { erase (); xPosition += distance ; draw (); } Bei den ersten drei Zeilen /** * Move the circle horizontally by 'distance' pixels. */ handelt es sich um einen Kommentar (genauer gesagt, um einen JavaDoc-Kommentar). Wir kommen bald zu Kommentaren. Jetzt geht es uns zun\u00e4chst nur um diese Zeile: public void moveHorizontal ( int distance ) Dies ist die sogenannte Signatur der Methode moveHorizontal . moveHorizontal ist der Name der Methode und distance ist der Name des Parameters der Methode. Vor dem Namen des Parameters steht ein Datentyp . In diesem Fall ist es der Datentyp int . Datentypen \u00b6 int steht f\u00fcr Integer und bedeutet ganze Zahl (also auch negative Zahlen). Wir werden uns ausgiebig mit Datentypen besch\u00e4ftigen. In dem Beispiel int distance steht der Datentyp int daf\u00fcr, dass wir der Methode moveHorizontal bei dem Aufruf einen ganzzahligen Wert \u00fcbergeben m\u00fcssen. Rufen Sie die Methode moveHorizontal auf und \u00fcbergeben Ihr einen negativen Zahlenwert! Wenn wir uns die Java-Implementierung der Klasse Circle nochmal genauer anschauen, dann sehen wir, dass die Methoden entweder keinen Parameter haben: public Circle () public void makeVisible () public void makeInvisible () public void moveRight () public void moveLeft () public void moveUp () public void moveDown () private void draw () private void erase () , dann muss dem Aufruf der Methode kein Wert \u00fcbergeben werden. Oder die Methode erwartet einen Parameterwert und dieser Wert muss einer ganzen Zahl entsprechen: public void moveHorizontal ( int distance ) public void moveVertical ( int distance ) public void slowMoveHorizontal ( int distance ) public void slowMoveVertical ( int distance ) public void changeSize ( int newDiameter ) Au\u00dferdem gibt es noch eine Methode, die als Parameterwert einen String erwartet. String ist ebenfalls ein Datentyp. Dieser Datentyp steht aber nicht f\u00fcr ganze Zahlen, sondern f\u00fcr Zeichenketten . public void changeColor ( String newColor ) Zeichenketten ( String ) schreiben wir in Java in doppelten Anf\u00fchrungszeichen \"Zeichenkette\" . Rufen Sie die Methode changeColor auf und \u00fcbergeben Sie als Parameterwert \"red\" . Probieren Sie auch die Werte \"yellow\" , \"green\" , \"magenta\" und \"black\" aus. Fragen Was passiert, wenn Sie nur red schreiben? Was passiert, wenn Sie \"pink\" schreiben? Was passiert, wenn Sie \"blau\" schreiben? Was passiert, wenn Sie \"hallo\" schreiben? Mehrere Objekte \u00b6 Von unserer Klasse Circle haben wir bereits ein Objekt circle1 erzeugt. Von einer Klasse lassen sich beliebig viele Objekte erzeugen! Alle diese Objekte haben dieselben Eigenschaften! Das bedeutet, dass all diesen Objekten, die Sie erzeugen, die gleichen Objektmethoden zur Verf\u00fcgung stehen (und auch die gleichen Objektvariablen). Aufgabe Erzeugen Sie f\u00fcnf Objekte von der Klasse Circle . Weisen Sie allen Objekten unterschiedliche Farben zu! Sorgen Sie daf\u00fcr, dass sich die Objekte in der Darstellung nicht \u00fcberdecken! Wie Sie sehen, haben zwar alle Objekte dieselben Eigenschaften (dieselben Objektmethoden und dieselben Objektvariablen). Aber wir k\u00f6nnen ihnen jeweils unterschiedliche Werte zuweisen, so dass einige Circle -Objekte z.B. rot oder blau oder schwarz sind und auch jeweils andere Positionen haben. Wir schauen uns im Folgenden an, dass jedes Objekt einen eigenen Zustand hat. Der Zustand eines Objektes \u00b6 Klicken Sie mit der rechten Maustaste auf ein Objekt und w\u00e4hlen Sie Inspect . Es \u00f6ffnet sich das folgende Fenster: Lassen Sie dieses Inspektionsfenster ge\u00f6ffnet und \u00e4ndern Sie die Farbe des Objektes. Was beobachten Sie im Inspektionsfenster? Das Inspektionsfenster zeigt den Zustand eines Objektes. Der Zustand wird durch die Werte der Objektvariablen beschrieben. Schauen wir uns die Java-Implementierung der Klasse Circle an, dann finden wir in den Zeilen 13-17 folgende Anweisungen: private int diameter ; private int xPosition ; private int yPosition ; private String color ; private boolean isVisible ; Das sind die Objektvariablen der Klasse Circle . Jedes Objekt der Klasse Circle besitzt seine eigenen Objektvariablen. Jede Variable hat einen Wert . Die Variablen diameter , xPosition und yPosition haben als Wert eine ganze Zahl. Diese Zahl gibt z.B. f\u00fcr diameter die Gr\u00f6\u00dfe des Umfanges des Kreises an. Der Wert f\u00fcr xPosition beschreibt den Wert auf der x-Koordinate und der Wert von yPosition beschreibt den Wert auf der y-Koordinate zur Darstellung des Kreises. Der Wert der Objektvariablen color beschreibt die Farbe des Kreises als Zeichenkette ( String ). Die Objektvariable isVisible ist von einem Datentyp, den wir noch nicht kennen: boolean . Diese Variable kann nur zwei verschiedene Werte annehmen: true (sichtbar) oder false (nicht sichtbar). Die Werte der Variablen k\u00f6nnen mithilfe der Objektmethoden ge\u00e4ndert werden. Fragen Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen color zu \u00e4ndern? Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen diameter zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen isVisible zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen xPosition zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen yPosition zu \u00e4ndern? Die Kombination der Werte aller Objektvariablen beschreibt den Zustand eines Objektes. Aufgabe Erzeugen Sie mehrere Objekte der Klasse Circle ! \u00d6ffnen Sie f\u00fcr alle Objekte jeweils das Inspektionsfenster. \u00c4ndern Sie f\u00fcr unterschiedliche Objekte die Werte von Objektvariablen durch Methodenaufrufe und beobachten Sie die jeweiligen Zustands\u00e4nderungen. Zusammenfassung \u00b6 Wir haben viele neue Begriffe kennengelernt: Klassen und Objekte , Methoden , Methodenaufrufe , Parameter , Datentypen ( int , String , boolean ), Objektvariablen , Objektmethoden , Zustand eines Objektes. Das ist ganz sch\u00f6n viel auf einmal! Diese Begriffe werden wir in den kommenden Wochen verwenden und vertiefen. Zun\u00e4chst zum Abschluss noch eine \"kleine\" Aufgabe zum Entspannen. Zeichnen Sie dieses Bild: Success Wir kennen schon Klassen, Objekte, Objektvariablen, Objektmethoden, Parameter, einige Datentypen, k\u00f6nnen Objekte erzeugen und Objektmethoden aufrufen. Super! In der objektorientierten Programmierung unterscheiden wir sehr genau zwischen Objekten und Werten. Werte sind soetwas wie 4 , true , 5.5 usw. Solche Werte haben kein Verhalten. Objekte haben aber ein Verhalten (die Objektmethoden - siehe z.B. f\u00fcr String die Methoden charAt() , length() , substring() ). Wir werden sehr detailliert auf die Unterschiede zwischen Werten und Objekten eingehen. Die Datentypen, die wir erstellen, sind sogenannte Referenztypen . Eine Variable von so einem Referenztyp zeigt auf (referenziert) ein Objekt. \u21a9 Um sich die Zeilennummern anzeigen zu lassen, \u00f6ffnen Sie das BlueJ -Men\u00fc und w\u00e4hlen Preferences . Unter dem Reiter Editor finden Sie Display line numbers . Setzen Sie dort das H\u00e4kchen. \u21a9","title":"BlueJ"},{"location":"bluej/#bluej","text":"Wir lernen unsere Entwicklungsumgebung kennen, die wir in den ersten Wochen f\u00fcr das Programmieren nutzen werden. Es handelt sich um BlueJ . BlueJ wurde extra f\u00fcr Studierende entwickelt, die Programmieren lernen. Das J in BlueJ steht f\u00fcr Java . Mit BlueJ wird also das Programmieren mit Java gelernt. Eine wesentliche Idee hinter der Entwicklung von BlueJ bestand darin, gleich am Anfang mit der objektorientierten Programmierung zu beginnen, d.h. sich gleich mit Klassen und Objekten zu besch\u00e4ftigen. Das passiert h\u00e4ufig erst recht sp\u00e4t in der Programmierausbildung. Wir geben zun\u00e4chst einen groben \u00dcberblick und lernen dabei in kurzer Zeit viele neue Konzepte und Begriffe kennen. Aber keine Sorge, mit all diesen Konzepten besch\u00e4ftigen wir uns jeweils noch ganz ausf\u00fchrlich.","title":"BlueJ"},{"location":"bluej/#objekte-und-klassen","text":"Wenn wir uns die Welt betrachten, dann besteht diese aus lauter Objekten , die miteinander in Beziehung stehen. Man ganz konkret \u00fcber bestimmte Objekte sprechen: \u201edas ist ein sch\u00f6ner Stuhl\u201c \u201edas ist ein teurer Tisch\u201c \u201edas Auto ist blau\u201c oder ganz allgemein \u00fcber eine Klasse von Objekten: \u201eInformatikerInnen sind Nerds\u201c \u201eComputer machen immer, was sie wollen\u201c \u201edie Bahnen kommen immer zu sp\u00e4t\u201c In der Welt des objektorientierten Programmierens sind die Klassen die \"Muster\" oder die \"Bauanleitungen\" f\u00fcr konkrete Objekte . Mit Klassen beschreiben wir die allgemeinen Eigenschaften, die f\u00fcr alle Objekte dieser Klasse gelten. Klassen beschreiben eine Struktur der Objekte (das sind die sogenannten Objektvariablen ) und ein Verhalten dieser Objekte (das sind die sogenannten Objektmethoden ). Insgesamt sprechen wir bei der Struktur und dem Verhalten von den Eigenschaften einer Klasse. Eine Klasse ist ein Datentyp und jeder \"Wert\" 1 ist ein konkretes Objekt von diesem Typ. Von einer Klasse k\u00f6nnen wir beliebig viele Objekte erzeugen. Objekte werden aus Klassen erzeugt. Eine Klasse beschreibt die Art und Weise, den Aufbau von Objekten. Objekte sind die speziellen Instanzen einer allgemeinen Klasse. Ein typisches Beispiel ist Auto . Ein Auto kann fahren, hat eine Farbe, ist von einer bestimmten Marke, hat einen bestimmten Motor, eine bestimmte Anzahl von T\u00fcren und so weiter. Das sind alles Eigenschaften eines Autos. Diese Eigenschaften werden in einer Klasse definiert und beschreiben ein Auto im Allgemeinen. Davon gibt es dann konkrete Objekte: ein roter VW Golf mit 5 T\u00fcren, ein blauer Toyota mit 3 T\u00fcren usw. Eine Klasse beschreibt also alle m\u00f6glichen Objekte, die von dieser Klasse erstellt werden k\u00f6nnen. Die Eigenschaften der Objekte werden in Objektvariablen und Objektmethoden beschrieben. Beispiele daf\u00fcr zeigen zun\u00e4chst die folgenden Abbildungen:","title":"Objekte und Klassen"},{"location":"bluej/#objektvariablen","text":"In der Klasse Stuhl ist beschrieben, dass jeder Stuhl (jedes Stuhl -Objekt) eine Inventarnummer hat, in einem Raum steht, eine bestimmt Anzahl Beine hat und einen Status , der beschreibt, ob er frei oder besetzt ist. Diese Eigenschaften werden als Objektvariablen definiert. Jedes Objekt der Klasse Stuhl hat seinen eigenen Objektvariablen , n\u00e4mlich genau die vier. Das bedeutet, alle Objekte der Klasse Stuhl haben die gleichen Eigenschaften, aber die konkreten Werte dieser Objektvariablen sind von Stuhl(-Objekt) zu Stuhl(-Objekt) unterschiedlich. Vier konkrete Stuhl-Objekte stuhl1 , stuhl2 , stuhl3 und stuhl4 sind in der Abbildung dargestellt.","title":"Objektvariablen"},{"location":"bluej/#objektmethoden","text":"Jedes Objekt der Klasse Stuhl hat jeweils konkrete Werte f\u00fcr die Objektvariablen. Zum Beispiel hat das Objekt stuhl1 den Wert 1 f\u00fcr die Inventarnummer , den Wert 123 f\u00fcr den Raum , den Wert 4 f\u00fcr Anzahl Beine und den Wert frei f\u00fcr Status . Wie k\u00f6nnen diese Werte ge\u00e4ndert werden? Die Antwort ist: durch Objektmethoden . Objektmethoden beschreiben das Verhalten eines Objektes. Z.B. kann der Status dadurch ge\u00e4ndert werden, dass man sich auf den Stuhl setzt oder wieder aufsteht. Solche T\u00e4tigkeiten bzw. so ein Verhalten lassen sich durch Obejktmethoden beschreiben. Darin wird etwas getan und zwar haupts\u00e4chlich die Werte von Objektvariablen ge\u00e4ndert oder einfach ausgelesen. M\u00f6gliche Objektmethoden w\u00e4ren also aufstehen (den Status in frei \u00e4ndern), hinsetzen (den Status in besetzt \u00e4ndern), umziehen (den Raum \u00e4ndern), inventarisieren (die Inventarnummer auslesen), zusammenkrachen (die Anzahl Beine \u00e4ndern) usw.","title":"Objektmethoden"},{"location":"bluej/#ein-erstes-beispiel-mit-bluej","text":"Wir \u00f6ffnen BlueJ dann im Men\u00fc auf Project --> Open Project . Im examples -Ordner von BlueJ finden wir den Ordner shapes . Wir w\u00e4hlen den Ordner und klicken auf Open . Es erscheint: Klicken Sie den Button Compile .","title":"Ein erstes Beispiel mit BlueJ"},{"location":"bluej/#objekt-erzeugen","text":"Klicken Sie dann mit der rechten Maustaste auf das orangene K\u00e4stchen Circle und w\u00e4hlen aus dem Kontextmen\u00fc new Circle () Den Namen circle1 k\u00f6nnen Sie einfach mit Ok best\u00e4tigen. Sie haben soben Ihr erstes Objekt erzeugt! Das orangene K\u00e4stchen, auf das Sie mit der rechten Maus geklickt haben, repr\u00e4sentiert die Klasse Circle . Das rote K\u00e4stchen links unten mit dem Namen circle1 repr\u00e4sentiert ein Objekt dieser Klasse. Konvention: Klassennamen beginnen immer mit Gro\u00dfbuchstaben und Objektnamen immer mit einem kleinen Buchstaben.","title":"Objekt erzeugen"},{"location":"bluej/#methoden-aufrufen","text":"Klicken Sie nun mit der rechten Maustaste auf das rote K\u00e4stchen circle1 (also auf das Objekt) und w\u00e4hlen dann void makeVisible () aus. Es erscheint: makeVisible() ist eine Methode . Genauer gesagt, handelt es sich um eine Objektmethode . Als wir darauf geklickt haben, haben wir diese Methode aufgerufen . \u00dcbung Methoden aufrufen Rufen Sie (auch mehrmals) die Methoden makeLeft() , makeRight() , makeUp und makeDown() auf. Rufen Sie auch makeInvisible() und dann wieder makeVisible() auf. Methoden erkennen wir an den runden Klammern () hinter dem Namen. In diesen Klammern kann auch ein Wert stehen. Dazu kommen wir jetzt, zu den sogenannten Parametern .","title":"Methoden aufrufen"},{"location":"bluej/#parameter","text":"Nun rufen wir die Methode moveHorizontal(int distance) auf. Es erscheint ein Dialog: geben Sie in das Eingabefeld eine Zahl ein, z.B. 50 und klicken OK . Der Kreis bewegt sich horizontal um 50 Bildschirmpunkte nach rechts. Wir \u00fcbergeben dem Methodenaufruf einen Wert (hier: der Wert 50 ). Klicken Sie mit der rechten Maustaste auf das orangene K\u00e4stchen Circle1 (also auf die Klasse Circle ) und w\u00e4hlen Sie Open Editor . Es erscheint: Das Fenster, das sich \u00f6ffnet, ist der sogenannte Editor . Darin sehen wir die Implementierung der Klasse Circle . So sieht ein Java-Programm aus. Wir kommen zu den Details sp\u00e4ter. Zun\u00e4chst suchen wir den folgenden gelb hinterlegten Block (ab Zeile 81 2 ): /** * Move the circle horizontally by 'distance' pixels. */ public void moveHorizontal ( int distance ) { erase (); xPosition += distance ; draw (); } Bei den ersten drei Zeilen /** * Move the circle horizontally by 'distance' pixels. */ handelt es sich um einen Kommentar (genauer gesagt, um einen JavaDoc-Kommentar). Wir kommen bald zu Kommentaren. Jetzt geht es uns zun\u00e4chst nur um diese Zeile: public void moveHorizontal ( int distance ) Dies ist die sogenannte Signatur der Methode moveHorizontal . moveHorizontal ist der Name der Methode und distance ist der Name des Parameters der Methode. Vor dem Namen des Parameters steht ein Datentyp . In diesem Fall ist es der Datentyp int .","title":"Parameter"},{"location":"bluej/#datentypen","text":"int steht f\u00fcr Integer und bedeutet ganze Zahl (also auch negative Zahlen). Wir werden uns ausgiebig mit Datentypen besch\u00e4ftigen. In dem Beispiel int distance steht der Datentyp int daf\u00fcr, dass wir der Methode moveHorizontal bei dem Aufruf einen ganzzahligen Wert \u00fcbergeben m\u00fcssen. Rufen Sie die Methode moveHorizontal auf und \u00fcbergeben Ihr einen negativen Zahlenwert! Wenn wir uns die Java-Implementierung der Klasse Circle nochmal genauer anschauen, dann sehen wir, dass die Methoden entweder keinen Parameter haben: public Circle () public void makeVisible () public void makeInvisible () public void moveRight () public void moveLeft () public void moveUp () public void moveDown () private void draw () private void erase () , dann muss dem Aufruf der Methode kein Wert \u00fcbergeben werden. Oder die Methode erwartet einen Parameterwert und dieser Wert muss einer ganzen Zahl entsprechen: public void moveHorizontal ( int distance ) public void moveVertical ( int distance ) public void slowMoveHorizontal ( int distance ) public void slowMoveVertical ( int distance ) public void changeSize ( int newDiameter ) Au\u00dferdem gibt es noch eine Methode, die als Parameterwert einen String erwartet. String ist ebenfalls ein Datentyp. Dieser Datentyp steht aber nicht f\u00fcr ganze Zahlen, sondern f\u00fcr Zeichenketten . public void changeColor ( String newColor ) Zeichenketten ( String ) schreiben wir in Java in doppelten Anf\u00fchrungszeichen \"Zeichenkette\" . Rufen Sie die Methode changeColor auf und \u00fcbergeben Sie als Parameterwert \"red\" . Probieren Sie auch die Werte \"yellow\" , \"green\" , \"magenta\" und \"black\" aus. Fragen Was passiert, wenn Sie nur red schreiben? Was passiert, wenn Sie \"pink\" schreiben? Was passiert, wenn Sie \"blau\" schreiben? Was passiert, wenn Sie \"hallo\" schreiben?","title":"Datentypen"},{"location":"bluej/#mehrere-objekte","text":"Von unserer Klasse Circle haben wir bereits ein Objekt circle1 erzeugt. Von einer Klasse lassen sich beliebig viele Objekte erzeugen! Alle diese Objekte haben dieselben Eigenschaften! Das bedeutet, dass all diesen Objekten, die Sie erzeugen, die gleichen Objektmethoden zur Verf\u00fcgung stehen (und auch die gleichen Objektvariablen). Aufgabe Erzeugen Sie f\u00fcnf Objekte von der Klasse Circle . Weisen Sie allen Objekten unterschiedliche Farben zu! Sorgen Sie daf\u00fcr, dass sich die Objekte in der Darstellung nicht \u00fcberdecken! Wie Sie sehen, haben zwar alle Objekte dieselben Eigenschaften (dieselben Objektmethoden und dieselben Objektvariablen). Aber wir k\u00f6nnen ihnen jeweils unterschiedliche Werte zuweisen, so dass einige Circle -Objekte z.B. rot oder blau oder schwarz sind und auch jeweils andere Positionen haben. Wir schauen uns im Folgenden an, dass jedes Objekt einen eigenen Zustand hat.","title":"Mehrere Objekte"},{"location":"bluej/#der-zustand-eines-objektes","text":"Klicken Sie mit der rechten Maustaste auf ein Objekt und w\u00e4hlen Sie Inspect . Es \u00f6ffnet sich das folgende Fenster: Lassen Sie dieses Inspektionsfenster ge\u00f6ffnet und \u00e4ndern Sie die Farbe des Objektes. Was beobachten Sie im Inspektionsfenster? Das Inspektionsfenster zeigt den Zustand eines Objektes. Der Zustand wird durch die Werte der Objektvariablen beschrieben. Schauen wir uns die Java-Implementierung der Klasse Circle an, dann finden wir in den Zeilen 13-17 folgende Anweisungen: private int diameter ; private int xPosition ; private int yPosition ; private String color ; private boolean isVisible ; Das sind die Objektvariablen der Klasse Circle . Jedes Objekt der Klasse Circle besitzt seine eigenen Objektvariablen. Jede Variable hat einen Wert . Die Variablen diameter , xPosition und yPosition haben als Wert eine ganze Zahl. Diese Zahl gibt z.B. f\u00fcr diameter die Gr\u00f6\u00dfe des Umfanges des Kreises an. Der Wert f\u00fcr xPosition beschreibt den Wert auf der x-Koordinate und der Wert von yPosition beschreibt den Wert auf der y-Koordinate zur Darstellung des Kreises. Der Wert der Objektvariablen color beschreibt die Farbe des Kreises als Zeichenkette ( String ). Die Objektvariable isVisible ist von einem Datentyp, den wir noch nicht kennen: boolean . Diese Variable kann nur zwei verschiedene Werte annehmen: true (sichtbar) oder false (nicht sichtbar). Die Werte der Variablen k\u00f6nnen mithilfe der Objektmethoden ge\u00e4ndert werden. Fragen Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen color zu \u00e4ndern? Welche Methode m\u00fcssen Sie aufrufen, um den Wert der Variablen diameter zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen isVisible zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen xPosition zu \u00e4ndern? Welche Methode(n) m\u00fcssen Sie aufrufen, um den Wert der Variablen yPosition zu \u00e4ndern? Die Kombination der Werte aller Objektvariablen beschreibt den Zustand eines Objektes. Aufgabe Erzeugen Sie mehrere Objekte der Klasse Circle ! \u00d6ffnen Sie f\u00fcr alle Objekte jeweils das Inspektionsfenster. \u00c4ndern Sie f\u00fcr unterschiedliche Objekte die Werte von Objektvariablen durch Methodenaufrufe und beobachten Sie die jeweiligen Zustands\u00e4nderungen.","title":"Der Zustand eines Objektes"},{"location":"bluej/#zusammenfassung","text":"Wir haben viele neue Begriffe kennengelernt: Klassen und Objekte , Methoden , Methodenaufrufe , Parameter , Datentypen ( int , String , boolean ), Objektvariablen , Objektmethoden , Zustand eines Objektes. Das ist ganz sch\u00f6n viel auf einmal! Diese Begriffe werden wir in den kommenden Wochen verwenden und vertiefen. Zun\u00e4chst zum Abschluss noch eine \"kleine\" Aufgabe zum Entspannen. Zeichnen Sie dieses Bild: Success Wir kennen schon Klassen, Objekte, Objektvariablen, Objektmethoden, Parameter, einige Datentypen, k\u00f6nnen Objekte erzeugen und Objektmethoden aufrufen. Super! In der objektorientierten Programmierung unterscheiden wir sehr genau zwischen Objekten und Werten. Werte sind soetwas wie 4 , true , 5.5 usw. Solche Werte haben kein Verhalten. Objekte haben aber ein Verhalten (die Objektmethoden - siehe z.B. f\u00fcr String die Methoden charAt() , length() , substring() ). Wir werden sehr detailliert auf die Unterschiede zwischen Werten und Objekten eingehen. Die Datentypen, die wir erstellen, sind sogenannte Referenztypen . Eine Variable von so einem Referenztyp zeigt auf (referenziert) ein Objekt. \u21a9 Um sich die Zeilennummern anzeigen zu lassen, \u00f6ffnen Sie das BlueJ -Men\u00fc und w\u00e4hlen Preferences . Unter dem Reiter Editor finden Sie Display line numbers . Setzen Sie dort das H\u00e4kchen. \u21a9","title":"Zusammenfassung"},{"location":"hilfsklassen/","text":"N\u00fctzliche Klassen \u00b6 Auf diesen Abschnitt werden wir im Laufe des Semesters immer wieder zur\u00fcckgreifen. Wir werden die einzelnen Klassen nach und nach verwenden. Der Abschnitt muss (noch) nicht in G\u00e4nze gelesen und verstanden werden. In Java gibt es eine Vielzahl bereits existierender Klassen, auf die wir zugreifen k\u00f6nnen. Wir werden nach und nach einige davon kennenlernen - aber l\u00e4ngst nicht alle. Bis jetzt haben wir nur zwei Klassen direkt verwendet: die Klasse System , die uns eine Schnittstelle zu unserer Konsole (dem Standardausgabeger\u00e4t zur Verf\u00fcgung stellt - z.B. System.out.println() ) und die Klasse String , die einen Datentyp f\u00fcr Zeichenketten darstellt und daf\u00fcr auch n\u00fctzliche Methoden mitbringt, die wir uns hier mal genauer anschauen wollen. Beide Klassen geh\u00f6ren zum Paket java.lang . Dieses Paket muss nicht importiert werden, umn die Klassen daraus zu nutzen. Bei anderen Klassen, die wir im Folgenden betrachten, ist das teilweise anders. Die Klasse Scanner \u00b6 Wir k\u00f6nnen derzeit Ausgaben auf die Konsole schreiben. Wir k\u00f6nnen jedoch noch keine Eingaben t\u00e4tigen. Das wird sich mit der Verwendung der Klasse Scanner nun \u00e4ndern. Die Verwendung dieser Klasse durch uns erfolgt durch die Erzeugung eines Scanner - Objektes den Aufruf einer passenden Objektmethode , je nachdem, was wir einlesen wollen, ein int , ein double oder einen String . Erzeugen eines Scanner -Objektes \u00b6 Wir haben oben zwei begriffe verwendet, deren Bedeutung wir erst sp\u00e4ter kennenlernen: Objekt und Objektmethode . Das soll uns aber nicht aufhalten, einfach einmal ein Scanner -Objekt zu erzeugen: Scanner sc = new Scanner ( System . in ); Hierbei passiert folgendes: wir deklarieren uns eine Variable sc vom Datentyp Scanner , wir erzeugen mithilfe von new Scanner() ein neues Objekt vom Datentyp Scanner , wir \u00fcbergeben der Methode, die ein Scanner -Objekt erzeugt unser Standardeingabeger\u00e4t ( System.in ) - das ist die Konsole, d.h. wir wollen unsere Daten \u00fcber die Konsole einlesen wir weisen unser neues Objekt (genauer gesagt: eine Referenz auf unser neues Objekt) der Variablen sc zu Wenn Sie obige Anweisung z.B. in Ihre main() -Methode einf\u00fcgen, dann stellen Sie fest, dass beide Scanner rot unterstrichen sind. Die Fehlerausgabe ist Scanner cannot be resolved to a type . Das liegt daran, dass die Klasse Scanner nicht zum Standardpaket java.lang geh\u00f6rt, sondern wir sie erst importieren m\u00fcssen. Das lassen wir aber von unserer IDE erledigen. Wir w\u00e4hlen eines der vorgeschlagenen quick fixes aus, und zwar import Scanner (java.util) . Achten Sie darauf, dass dies nicht der erste Vorschlag f\u00fcr ein quick fix ist! Nachdem die entsprechende import -Anweisung ( import java.util.Scanner; ) eingef\u00fcgt wurde, ist die Fehlermeldung behoben. Das Programm k\u00f6nnte also so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 13 package themen.hilfsklassen ; import java.util.Scanner ; public class Hilfsklassen { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); } } Die import -Anweisung (Zeile 3 ) erfolgt au\u00dferhalb und vor der Klassendeklaration. Aufrufen der passenden Objektmethoden \u00b6 F\u00fcr ein solches Objekt vom Typ Scanner stehen eine Vielzahl von Methoden zur Verf\u00fcgung, von denen wir uns nur die folgenden anschauen wollen: next() : liest einen String ein nextInt() : liest ein int ein nextDouble() : liest ein double ein nextBoolean() : liest ein boolean ein Es sei erw\u00e4hnt, dass es auch noch nextLong() , nextFloat() , nextShort() usw. gibt. Der Aufruf einer solchen Objektmethode erfolgt stets nach dem Prinzip: referenzVariable.objektMethode () Das hei\u00dft die Variable, die eine Referenz auf das Objekt h\u00e4lt (bei uns sc ), ruft \u00fcber Punktnotation (mit einem . verbinden) die entsprechende Objektmethode auf. Wir betrachten Beispiele: 1 2 3 4 5 6 7 8 public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Geben Sie eine ganze Zahl ein: \" ); int ganzeZahl = sc . nextInt (); System . out . println ( ganzeZahl ); } In Zeile 6 sehen Sie den Aufruf der Methode nextInt() f\u00fcr das sc -Objekt, also sc.nextInt() . Die Methode nextInt() gibt die eingegebene Zahl zur\u00fcck, d.h. der Aufruf der Methode entspricht einer Zahl vom Datentyp int . Diese speichern wir in obigem Beispiel in der Variablen ganzeZahl vom Typ int . Wenn Sie auf der Konsole dann eine Zahl eingeben, sieht das so aus: Was passiert, wenn Sie keine Zahl eingeben? Dann wird eine sogenannte * Exception* geworfen. Eine Exception ist ein Fehler, der zur Laufzeit passiert. Wir werden bald lernen, wie man soclhe Exceptions abf\u00e4ngt, damit es nicht einen solchen \"Systemabsturz\" gibt. Derzeit m\u00fcssen wir damit noch leben. Eine solche fehlerhafte Eingabe w\u00fcrde so aussehenen: F\u00fcr diejenigen, die es interessiert, ist hier eine Methode, die einen solchen Fehlerfall abf\u00e4ngt. Das m\u00fcssen sie jetzt aber noch nicht verstehen - es ist, wie gesagt, nur f\u00fcr eventuelles Interesse: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package themen.hilfsklassen ; import java.util.InputMismatchException ; import java.util.Scanner ; public class Hilfsklassen { public static int ganzeZahlEinlesen ( String message ) { Scanner sc = new Scanner ( System . in ); int number = 0 ; boolean inputOk = false ; do { System . out . print ( message + \": \" ); try { number = sc . nextInt (); inputOk = true ; } catch ( InputMismatchException e ) { message = \"Sie m\u00fcssen eine Zahl eingeben\" ; sc . next (); } } while ( ! inputOk ); return number ; } public static void main ( String [] args ) { int ganzeZahl = ganzeZahlEinlesen ( \"Geben Sie eine Zahl ein\" ); System . out . println ( ganzeZahl ); } } Ein m\u00f6glicher Ablauf w\u00e4re dann wie folgt: Wir gehen erstmal davon aus, dass die Eingaben korrekt erfolgen und schauen uns noch weitere Beispiele an: public static void weitereBeispiele () { Scanner sc = new Scanner ( System . in ); System . out . print ( \"int Zahl : \" ); int intNumber = sc . nextInt (); System . out . println ( intNumber ); System . out . print ( \"double Zahl : \" ); double doubleNumber = sc . nextDouble (); System . out . println ( doubleNumber ); System . out . print ( \"boolean : \" ); boolean wahrheitswert = sc . nextBoolean (); System . out . println ( wahrheitswert ); System . out . print ( \"String : \" ); String zeichenkette = sc . next (); System . out . println ( zeichenkette ); } Ein Aufruf der Methode weitereBeispiele(); (z.B. in main() ) k\u00f6nnte dann so aussehen: Beachten Sie: Bei der Eingabe einer double -Zahl m\u00fcssen Sie anstelle des Punktes ein Komma eingeben. Das h\u00e4ngt mit den l\u00e4ndertypischen Einstellungen von Eclipse zusammen. (Bei manchen ist es vielleicht ein Punkt.) Wenn Sie ein String eingeben, dann wird bei der Methode next() nur der String bis zum ersten Leerzeichen eingelesen. (Das l\u00e4sst sich \u00e4ndern, aber darauf gehen wir hier nicht n\u00e4her ein.) Success Wir k\u00f6nnen jetzt Eingaben \u00fcber unsere Konsole t\u00e4tigen! Die Klasse Math \u00b6 Die Klasse Math enth\u00e4lt viele mathematische Funktionen als Methoden. Au\u00dferdem ist in ihr z.B. die Konstante PI definiert. Um die Klasse Math zu verwenden, m\u00fcssen wir sie nicht importieren, denn sie befindet sich im Paket java.lang . Wir m\u00fcssen auch kein Objekt der Klasse erzeugen, da alle Methoden dieser Klasse Klassenmethoden (also static sind). Um eine Methode dieser Klasse aufzurufen, setzen wir vor die Methode einfach Math. . Wir schauen uns Beispiele an: double nr1 = 16.0 ; double nr2 = Math . sqrt ( nr1 ); // Quadratwurzel double nr3 = Math . PI * 3.0 ; double nr4 = Math . abs ( - 12.0 ); // absoluter Betrag double nr5 = Math . floor ( 12.3456 ); // abgeschnitten -> 12 double nr6 = Math . floor ( 12.9876 ); // abgeschnitten -> 12 double nr7 = Math . floor ( - 12.3456 ); // abgeschnitten -> -13 double nr8 = Math . floor ( - 12.9876 ); // abgeschnitten -> -13 double nr9 = Math . pow ( 2 , 5 ); // 2 hoch 5 = 32 Beachten Sie, dass floor() nicht rundet, sondern die n\u00e4chste ganze Zahl angibt, die kleiner als der Parameterwert ist. Mithilfe der Math.random() -Methode k\u00f6nnen Sie sich au\u00dferdem double -Zufallszahlen aus dem Bereich 0.0 <= zufallszahl <1.0 erzeugen lassen. Wir werden das aber meistens mithilfe der folgenden Klasse Random erledigen. Alle Methoden der Klasse Math finden Sie hier . Die Klasse Random \u00b6 Mithilfe der Klasse Random k\u00f6nnen wir Zufallszahlen erzeugen. Bei der Klasse Random ist es \u00e4hnlich wie bei Scanner : wir erzeugen uns ein Random -Objekt, die Klasse befindet sich im Paket java.util , d.h. wir m\u00fcssen sie importieren, wir w\u00e4hlen die passende Methode aus, je nachdem, von welchem Datentyp unsere Zufallszahl sein soll Ein Random -Objekt erzeugen \u00b6 Wir erzwugen uns ein Random -Objekt wie folgt Random r = new Random (); Um die Klasse Random verwenden zu k\u00f6nnen, muss sie importiert werden. Hier ein Ausschnitt aus der Klasse, in der wir neben Random auch Scanner verwenden: 1 2 3 4 5 6 7 package themen.hilfsklassen ; import java.util.Random ; import java.util.Scanner ; public class Hilfsklassen { In Zeile 3 wird die Klasse Random importiert. Objektemethoden der Klasse Random \u00b6 Die Klasse Random bietet verschiedene Methoden, um Zufallswerte der einzelnen Datentypen zu generieren: nextDouble() : erzeugt eine double -Zahl (aus dem Bereich 0.0 inklusive bis 1.0 exclusive) nextFloat() : erzeugt eine float -Zahl (aus dem Bereich 0.0 inklusive bis 1.0 exclusive) nextLong() : erzeugt eine long -Zahl (aus (fast) dem Bereich gesamten Bereich von long ) nextBoolean() : erzeugt einen boolean -Wert zuf\u00e4llig ( true oder false ) Wir betrachten jedoch haupts\u00e4chlich die Methoden, die uns zuf\u00e4llig einen int -Wert liefern: nextInt() : erzeugt eine int -Zahl aus dem gesamten Wertebereich von int - also auch negative Zahlen, nextInt(int bound) : erzeugt eine int -Zahl aus dem Bereich 0 inklusive bis bound exclusive) nextInt() \u00b6 Schauen wir uns zun\u00e4chst nextInt() an. Wir implementieren eine Methode, die uns 10 Zufallszahlen mithilfe der Methode nextInt() erzeugt und auf die Konsole ausgibt: 1 2 3 4 5 6 7 8 9 public static void printIntRandomNumbers () { Random r = new Random (); for ( int i = 0 ; i < 10 ; i ++ ) { int randomNumber = r . nextInt (); System . out . println ( randomNumber ); } } In Zeile 6 sehen wir den Aufruf der Methode nextInt() . Die Referenzvariable r zeigt auf unser Random -Objekt. F\u00fcr die Referenzvariable wird mithilfe der Punktnotation die Methode nextInt() aufgerufen, also r.nextInt(); . Diese Methode gibt eine Zufallszahl zur\u00fcck, die wir in der Variablen randomNumber speichern. Ein Aufruf der Methode printIntRandomNumbers(); z.B. in main() kann zu folgender Ausgabe f\u00fchren (das sind Zufallszahlen, also jeder Aufruf liefert andere Werte): 1362288576 1801089219 -1573362027 56087730 1015233281 1341464232 2112804572 841838154 1460116224 -910734474 nextInt(int bound) \u00b6 Die Methode nextInt() existiert auch parametrisiert, d.h. wir k\u00f6nnen ihr einen Parameterwert (vom Datentyp int ) \u00fcbergeben. Dieser Wert muss positiv sein! Wenn nicht, dann wird eine IllegalArgumentException geworfen. Die Idee dieses Parameters ist zun\u00e4chst die, dass wir den Wertebereich einschr\u00e4nken, aus dem die Zufallszahlen erzeugt werden. Angenommen, wir \u00fcbergeben eine 6 , dann werden die Zufallszahlen aus dem Bereich 0 , 1 , 2 , 3 , 4 , 5 erzeugt. F\u00fcr nextInt(bound) gilt also, dass eine Zufallszahl aus dem Bereich 0 (inklusive) bis bound (exklusive) ( 0 <= zufZahl < bound ) erzeugt wird. Wir betrachten folgendes Beispiel: 1 2 3 4 5 6 7 8 9 10 public static void printIntRandomNumbers () { Random r = new Random (); int bound = 10 ; for ( int i = 0 ; i < 10 ; i ++ ) { int randomNumber = r . nextInt ( bound ); System . out . println ( randomNumber ); } } Wir haben die gleiche Methode wie oben, nur dass wir jetzt nicht nextInt() , sondern nextInt(bound) aufrufen (Zeile 7 ). bound ist vom Typ int und hat den Wert 10 (Zeile 4 ). Ein Aufruf der Methode printIntRandomNumbers(); z.B. in main() kann zu folgender Ausgabe f\u00fchren (das sind Zufallszahlen, also jeder Aufruf liefert andere Werte): 2 8 8 6 8 2 5 9 8 3 Angenommen, wir wollen einen W\u00fcrfel implementieren. Mit dem Aufruf nextInt(6) w\u00fcrden wir Zahlen zuf\u00e4llig aus dem Bereich [0, ..., 5] erzeugen. Das w\u00e4re es noch nicht ganz. Erst, wenn wir zu der erzeugten Zufallszahl jeweils eine 1 hinzuaddieren, \"w\u00fcrfeln\" wir Zahlen aus dem Bereich [1, ..., 6] . Ein W\u00fcrfel w\u00fcrde also so implementiert werden: Random r = new Random (); int wurf = r . nextInt ( 6 ) + 1 ; // zufaellig Zahlen 1 bis 6 Eine generelle Methode, um mithilfe der Methode nextInt(bound) einen beliebigen Bereich aus dem int -Wertebereich zuf\u00e4llig abzudecken, sehe z.B. wie folgt aus: 1 2 3 4 5 6 7 public static int getRandomNumber ( int fromInclusive , int toInclusive ) { Random r = new Random (); int bound = ( toInclusive - fromInclusive ) + 1 ; // +1 wegen toInclusive soll auch int randomNumber = r . nextInt ( bound ) + fromInclusive ; return randomNumber ; } Die Methode ist nicht besonders stabil. Wir m\u00fcssten eigentlich \u00fcberpr\u00fcfen, ob toInclusive gr\u00f6\u00dfer ist als fromInclusive , aber wir wollen hier zun\u00e4chst nur das Prinzip erl\u00e4utern. Wir \"testen\" unsere Methode und schauen mal, ob wir Zufallszahlen aus dem Bereich [90, ... , 99] erzeugen: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( 90 , 99 ) + \" \" ); } Eine m\u00f6gliche Ausgabe: 96 99 92 98 95 91 95 96 97 93 97 90 94 92 92 94 95 93 99 91 92 95 99 90 91 97 99 93 92 98 91 92 99 90 90 97 95 90 92 97 93 92 94 93 94 90 92 96 96 94 Noch ein \"Test\", diesmal Zahlen aus dem Bereich [-33 , ... , -10] : for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( - 33 , - 10 ) + \" \" ); } Eine m\u00f6gliche Ausgabe: -10 -31 -29 -29 -33 -11 -19 -15 -33 -22 -13 -15 -14 -10 -28 -27 -24 -19 -13 -26 -21 -10 -25 -16 -29 -28 -16 -18 -29 -15 -23 -26 -18 -25 -29 -19 -12 -23 -26 -22 -15 -26 -11 -16 -18 -22 -20 -12 -21 -25 Von [-10, ... , 10] geht auch: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( - 10 , - 10 ) + \" \" ); } und unser W\u00fcrfel klappt auch: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( 1 , 6 ) + \" \" ); } Die Klasse String \u00b6 Wir haben die Klasse String bereits bei den Datentypen betrachtet. Dort haben wir gesagt, dass String ein anderer Datentyp ist, als die Wertetypen int , boolean , double usw. Bei String handelt es sich um einen Referenztypen . Ein String ist eine Referenz auf ein Objekt. Wenn wir also so etwas haben: String str = \"Hallo FIW!\" ; dann ist str eine Referenzvariable , so wie z.B. r bei Random und sc bei Scanner . Wie bei Random und Scanner gibt es auch f\u00fcr String Methoden, die wir auf die Objekte anwenden k\u00f6nnen. Einige davon schauen wir uns im Folgenden an. Zun\u00e4chst untersuchen wir jedoch, was so ein String eigentlich intern ist. Bei einer Zeichenkette handelt es sich um ein Array aus einzelnen Zeichen, also char . Wir wissen noch nicht, was ein Array ist, aber wir bekommen hier eine Vorstellung davon. Angenommen, wir haben den obigen String ( \"Hallo FIW!\" ). Intern sieht der so aus: Ein String besteht also aus einzelnen Zeichen (vom Typ char ) und diese sind sogar automatisch \"nummeriert\". Wir haben einen sogenannten Index . Dieser Index ist eine ganze Zahl ( int ) und beginnt beim ersten Zeichen mit 0 und l\u00e4uft dann fortlaufend mit jedem Zeichen eins h\u00f6her. Betrachten wir unsere erste Methode f\u00fcr String: die Methode length() . Diese Methode gibt die L\u00e4nge eines Strings zur\u00fcck - in unserem Beispiel 10 . String str = \"Hallo FIW!\" ; System . out . println ( str . length ()); // 10 Sie k\u00f6nnen die Methode \u00fcber Punktnotation \u00fcbrigens auch direkt an das Literal anh\u00e4ngen, also so: System . out . println ( \"Hallo FIW!\" . length ()); // 10 das gilt f\u00fcr alle der folgenden Objektmethoden. Beachten Sie, dass L\u00e4nge ( length() ) eines Strings um 1 gr\u00f6\u00dfer ist als der gr\u00f6\u00dfte Indexwert. In der obigen Abbildung sehen wir, dass das Ausrufezeichen ( ! ) mit dem Index 9 nummeriert ist. Das liegt daran, dass der erste Index die 0 ist. Nun wollen wir den Index verwenden, also die \"Nummer\" jedes einzelnen Zeichens in einem String. Die Methode charAt(int index) liefrt das Zeichen eines Strings an dem Index index zur\u00fcck. Also z.B.: char c = \"Hallo FIW!\" . charAt ( 6 ); // 'F' System . out . println ( c ); // F Wir lassen uns einmal alle Zeichen einzeln eines Strings ausgeben. Dazu verwenden wir eine for -Schleife. Die Laufvariable nimmt alle Werte aus dem Index an, d.h. 0 bis kleiner als length() : String str = \"Hallo FIW!\" ; for ( int i = 0 ; i < str . length (); i ++ ) { char c = str . charAt ( i ); System . out . println ( c ); } Das erzeugt folgende Ausgabe: H a l l o F I W ! Verschl\u00fcsseln Wir wissen ja, dass char ein ganzzahliger Datentyp ist. Wir k\u00f6nnten unsere Zeichenkette jetzt verschl\u00fcsseln, indem wir einfach zu dem ASCII-Code des jeweiligen Zeichens eine 1 hinzuaddieren. Das machen wir mal: String str = \"Hallo FIW!\" ; System . out . println ( str ); // Hallo FIW! for ( int i = 0 ; i < str . length (); i ++ ) { char c = str . charAt ( i ); c ++ ; // naechstgroesserer ASCII-Code (um 1 addiert) System . out . print ( c ); // Ibmmp!GJX\" } Erzeugt folgende Ausgabe: Hallo FIW! Ibmmp!GJX \" Wir k\u00f6nnen auch einen bestimmten Index erfragen. Die Methode indexOf(char c) gibt den Index zur\u00fcck, an dem das Zeichen zum ersten Mal im String autaucht. Die Methode lastIndexOf(char c) gibt den Index zur\u00fcck, an dem das Zeichen zum letzten Mal im String autaucht. int first = \"Hallo FIW!\" . indexOf ( 'l' ); // 2 int last = \"Hallo FIW!\" . lastIndexOf ( 'l' ); // 3 System . out . println ( \"l zum ersten Mal : \" + first ); System . out . println ( \"l zum letzten Mal : \" + last ); Mithilfe des Index k\u00f6nnen wir auch Teile eines Strings extrahieren. Die Methode substring(int beginIndex) liefert den Teilstring beginnend mit dem Index beginIndex bis zum Ende des Strings zur\u00fcck. Die Methode substring(int beginIndex, int endIndex) liefert den Teilstring beginnend mit dem Index beginIndex (inklusive) bis zum Index endIndex (exklusive) zur\u00fcck. String substr1 = \"Hallo FIW!\" . substring ( 3 ); // lo FIW! String substr2 = \"Hallo FIW!\" . substring ( 3 , 7 ); // lo F System . out . println ( substr1 ); System . out . println ( substr2 ); Mithilfe der Methode toLowerCase() werden alle Buchstaben eines Strings in Kleinbuchstaben umgewandelt. Mithilfe der Methode toUpperCase() werden alle Buchstaben eines Strings in Gro\u00dfbuchstaben umgewandelt. String lower = \"Hallo FIW!\" . toLowerCase (); // hallo fiw! String upper = \"Hallo FIW!\" . toUpperCase (); // HALLO FIW! System . out . println ( lower ); System . out . println ( upper ); Um zwei Strings lexikographisch miteinander zu vergleichen, kann die Methode compareTo(String) verwendet werden. Diese gibt ein int zur\u00fcck. Wir betrachten dazu ein Beispiel: 1 2 3 int result1 = \"abc\" . compareTo ( \"abd\" ); // -1 int result2 = \"abd\" . compareTo ( \"abc\" ); // 1 int result3 = \"abc\" . compareTo ( \"abc\" ); // 0 In Zeile 1 ruft der String \"abc\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abd\" . Da \"abc\" \"kleiner\" ist als \"abd\" , ist der R\u00fcckgabewert negativ -1 . In Zeile 2 ruft der String \"abd\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abc\" . Da \"abd\" \"gr\u00f6\u00dfer\" ist als \"abc\" , ist der R\u00fcckgabewert positiv 1 . In Zeile 3 ruft der String \"abc\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abc\" . Da beide Strings gleich sind, ist der R\u00fcckgabewert 0 . Um einen Wert von einem Wertetypen (also die primitiven Datentypen int , boolean , double usw.) in einen String umzuwandeln, stehen die Klassenmethoden valueOf() zur Verf\u00fcgung. Der Zugriff auf eine solche Methode erfolgt mittels Punktschreibweise und dem Namen der Klasse, also String.valueOf() (es handelt sich um static Methoden). Die Umwandlung erfolgt also wie folgt: String si9 = String . valueOf ( 9 ); // int --> String String si123 = String . valueOf ( 123 ); // int --> String String sb = String . valueOf ( true ); // boolean --> String String sd = String . valueOf ( 5.5 ); // double --> String format() -Methode und printf() \u00b6 In der \u00dcbung 2 sollte das kleine 1x1 einaml als Liste und einmal als Matrix ausgegeben werden. Bei beiden war die Formatierung der Ausgabe nicht besonders sch\u00f6n, da die Zahlen unterschiedliche L\u00e4ngen hatten. Sch\u00f6ner w\u00e4re es gewesen, die Ausgabe der Zahlen rechtsb\u00fcndig zu gestalten. Das geht mit der System.out.printf() -Methode. Die printf() -Methode verwendet die format() -Methode von Strings zur Formatierung der Ausgabe. Wir schauen uns zun\u00e4chst ein einf\u00fchrendes Beispiel an: 1 2 String output = String . format ( \"in %s angemeldet : %d Studentinnen\" , \"FIW\" , 44 ); System . out . println ( output ); Die format() -Methode in Zeile 1 hat drei Parameter: einen Ausgabestring, der Platzhalter enth\u00e4lt einen String \"FIW\" und eine int -Zahl 44 Der Ausgabestring enth\u00e4lt sogenannte Platzhalter , n\u00e4mlich %s f\u00fcr einen String und %d f\u00fcr ein int . Anstelle dieser Platzhalter werden die nach dem Ausgabestring aufgelisteten Werte eingef\u00fcgt, also f\u00fcr %s wird \"FIW\" eingesetzt und f\u00fcr %d die 44 . Die Ausgabe sieht dann so aus: in FIW angemeldet : 44 Studentinnen Das ist zun\u00e4chst wenig spektakul\u00e4r. Hier zun\u00e4chst eine Tabelle mit den wichtigsten Platzhaltern: Platzhalter Eingabetyp Ausgabe (String) %d int/long/... ganze Zahl %f float/double Gleitkommazahl, Standardnotation %e float/double Gleitkommazahl, wiss. Notation %s String Zeichenkette %c char Buchstabe %n Zeilenumbruch Ein Beispiel sieht also so aus: Die eigentliche Formatierung erfolgt durch die Angabe der vorgesehenen Breite f\u00fcr einen Ausgabewert und ob dieser Wert rechtsb\u00fcndig oder linksb\u00fcndig dargestellt werden soll. Die allgemeine Syntax f\u00fcr einen solchen Platzhalter ist wie folgt: % [ Schalter ] [ Breite ] . [ Genauigkeit ] Typ Dabei sind: % : Formatierungsausdruck beginnt Schalter (optional): ver\u00e4ndert das Format der Ausgabe (Minuszeichen (-) = linksb\u00fcndige Ausgabe) Breite : Anzahl der ausgegebenen Zeichen Genauigkeit (optional): Nachkommastellen Typ : Ausgabetyp ( s (String): Zeichenkette kleingeschrieben, S : Zeichenkette gro\u00dfgeschrieben, d (decimal): Ganzzahl, f (floating-point): Nachkommazahl) Dazu ein Beispiel: public static void createTable ( int rows ) { Random r = new Random (); int number1 = 0 ; int number2 = 0 ; System . out . println ( \" a | b | a + b | a - b | a * b | a / b | a % b \" ); System . out . println ( \"----------------------------------------------------------------\" ); for ( int i = 0 ; i < rows ; i ++ ) { number1 = r . nextInt ( 100 ) + 1 ; number2 = r . nextInt ( 100 ) + 1 ; System . out . printf ( \"%4d | %4d | %5d | %5d |%7d | %5d | %4d %n\" , number1 , number2 , number1 + number2 , number1 - number2 , number1 * number2 , number1 / number2 , number1 % number2 ); } } Bei Aufruf von createTable(8); erreichen wir zum Beispiel folgende Ausgabe: a | b | a + b | a - b | a * b | a / b | a % b ---------------------------------------------------------------- 4 | 39 | 43 | -35 | 156 | 0 | 4 60 | 2 | 62 | 58 | 120 | 30 | 0 93 | 60 | 153 | 33 | 5580 | 1 | 33 8 | 68 | 76 | -60 | 544 | 0 | 8 80 | 82 | 162 | -2 | 6560 | 0 | 80 31 | 10 | 41 | 21 | 310 | 3 | 1 7 | 30 | 37 | -23 | 210 | 0 | 7 54 | 12 | 66 | 42 | 648 | 4 | 6 Die Zahlen erscheinen also alle geordnet untereinander und rechtsb\u00fcndig. Wie gesagt, System.out.printf() und String.format() funktionieren exakt gleich, da printf() format() verwendet. Weitere Beispiele f\u00fcr Schalter und ihre Breitenangaben: String output ; output = String . format ( \"|%10d|\" , 1234 ); // | 1234| output = String . format ( \"|%-10d|\" , 1234 ); // |1234 | output = String . format ( \"|%010d|\" , 1234 ); // |0000001234| output = String . format ( \"|%+10d|\" , 1234 ); // | +1234| output = String . format ( \"|%,10d|\" , 1234 ); // | 1.234| output = String . format ( \"|%10.2f|\" , 1234.567 ); // | 1234,57| output = String . format ( \"|%-10.2f|\" , 1234.567 ); // |1234,57 | output = String . format ( \"|%5.2f|\" , 1234.567 ); // |1234,57| output = String . format ( \"|%15s|\" , \"Hallo FIW!\" ); // | Hallo FIW!| output = String . format ( \"|%-15s|\" , \"Hallo FIW!\" ); // |Hallo FIW! | output = String . format ( \"|%.7s|\" , \"Hallo FIW!\" ); // |Hallo F| Unsere beiden Methoden des kleinen 1x1 aus \u00dcbung 2 h\u00e4tten dann auch eine sch\u00f6nere Ausgabe: public static void printTimesTables ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . printf ( \"%2d * %2d = %3d %n\" , faktor1 , faktor2 , produkt ); } System . out . println (); } } public static void printTimesMatrix ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . printf ( \"%4d\" , produkt ); } System . out . println (); } } N\u00e4mlich so: ----- Aufgabe 1 ------ 1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 1 * 4 = 4 1 * 5 = 5 1 * 6 = 6 1 * 7 = 7 1 * 8 = 8 1 * 9 = 9 1 * 10 = 10 2 * 1 = 2 2 * 2 = 4 2 * 3 = 6 2 * 4 = 8 2 * 5 = 10 2 * 6 = 12 2 * 7 = 14 2 * 8 = 16 2 * 9 = 18 2 * 10 = 20 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 3 * 4 = 12 3 * 5 = 15 3 * 6 = 18 3 * 7 = 21 3 * 8 = 24 3 * 9 = 27 3 * 10 = 30 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 4 * 10 = 40 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 5 * 6 = 30 5 * 7 = 35 5 * 8 = 40 5 * 9 = 45 5 * 10 = 50 6 * 1 = 6 6 * 2 = 12 6 * 3 = 18 6 * 4 = 24 6 * 5 = 30 6 * 6 = 36 6 * 7 = 42 6 * 8 = 48 6 * 9 = 54 6 * 10 = 60 7 * 1 = 7 7 * 2 = 14 7 * 3 = 21 7 * 4 = 28 7 * 5 = 35 7 * 6 = 42 7 * 7 = 49 7 * 8 = 56 7 * 9 = 63 7 * 10 = 70 8 * 1 = 8 8 * 2 = 16 8 * 3 = 24 8 * 4 = 32 8 * 5 = 40 8 * 6 = 48 8 * 7 = 56 8 * 8 = 64 8 * 9 = 72 8 * 10 = 80 9 * 1 = 9 9 * 2 = 18 9 * 3 = 27 9 * 4 = 36 9 * 5 = 45 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81 9 * 10 = 90 10 * 1 = 10 10 * 2 = 20 10 * 3 = 30 10 * 4 = 40 10 * 5 = 50 10 * 6 = 60 10 * 7 = 70 10 * 8 = 80 10 * 9 = 90 10 * 10 = 100 ----- Aufgabe 2 ------ 1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90 100 Formatierung von Gleikommazahlen \u00b6 Um Gleitkommazahlen in der Standardnotation (nicht wissenschaftliche Notation) formatiert auszugeben, wird der Platzhalter %f verwendet. Die allgemeine Syntax ist also % [ Schalter ] [ Breite ] . [ Genauigkeit ] f Der Schalter kann - sein, dann wird die Zahl linksb\u00fcndig dargestellt. Ist kein Schalter angegeben, erfolgt die Ausgabe rechtsb\u00fcndig. Die Breite beschreibt die gesamte Anzahl der Stellen f\u00fcr die Zahl. Die Breite enth\u00e4lt insbesondere auch eine Stelle f\u00fcr das Komma und die Anzahl der Stellen f\u00fcr die Genauigkeit . Die Genauigkeit gibt die Anzahl der Nachkommastellen an. Angenommen, der Plathalter lautet %7.2f . Dann werden insgesamt sieben Stellen f\u00fcr die gesamte Zahl reserviert, inklusive dem Komma und den 2 Nachkommastellen, also _ _ _ _ , _ _ Wenn die Gesamtl\u00e4nge beliebig ist, Sie aber nur genau 2 Nachkommastellen haben m\u00f6chten, dann k\u00f6nnen Sie auch %.2f als Platzhalter angeben. F\u00fcr eine Nachkommastelle %.1f . Die Nachkommastellen werden sogar gerundet. Hier nochmal einige Beispiele von oben nur f\u00fcr Gleikommazahlen: 1 2 3 4 System . out . printf ( \"|%10.2f|\" , 1234.567 ); // | 1234,57| System . out . printf ( \"|%-10.2f|\" , 1234.567 ); // |1234,57 | System . out . printf ( \"|%7.2f|\" , 1234.567 ); // |1234,57| System . out . printf ( \"|%5.2f|\" , 1234.567 ); // |1234,57| Beachten Sie auch das letzte Beispiel (Zeile 4 ). Es wurden nur insgesamt 5 Stellen f\u00fcr die gesamte Zahl reserviert. Davon ben\u00f6tigen wir alleine 2 Stellen f\u00fcr die Nachkommastellen und 1 Stelle f\u00fcr das Komma. Die Vorkommastellen h\u00e4tten also nur 2 Stellen Platz. Vorne wird die Zahl aber nie abgeschnitten. Sollte der reservierte Platz f\u00fcr die Vorkommastellen nicht ausreichen, wird der Vorkommabereich trotzdem vollst\u00e4ndig dargestellt. Es kann also trotz der Formatierung zu Verzerrungen in der Ausgabe kommen!","title":"Hilfsklassen"},{"location":"hilfsklassen/#nutzliche-klassen","text":"Auf diesen Abschnitt werden wir im Laufe des Semesters immer wieder zur\u00fcckgreifen. Wir werden die einzelnen Klassen nach und nach verwenden. Der Abschnitt muss (noch) nicht in G\u00e4nze gelesen und verstanden werden. In Java gibt es eine Vielzahl bereits existierender Klassen, auf die wir zugreifen k\u00f6nnen. Wir werden nach und nach einige davon kennenlernen - aber l\u00e4ngst nicht alle. Bis jetzt haben wir nur zwei Klassen direkt verwendet: die Klasse System , die uns eine Schnittstelle zu unserer Konsole (dem Standardausgabeger\u00e4t zur Verf\u00fcgung stellt - z.B. System.out.println() ) und die Klasse String , die einen Datentyp f\u00fcr Zeichenketten darstellt und daf\u00fcr auch n\u00fctzliche Methoden mitbringt, die wir uns hier mal genauer anschauen wollen. Beide Klassen geh\u00f6ren zum Paket java.lang . Dieses Paket muss nicht importiert werden, umn die Klassen daraus zu nutzen. Bei anderen Klassen, die wir im Folgenden betrachten, ist das teilweise anders.","title":"N\u00fctzliche Klassen"},{"location":"hilfsklassen/#die-klasse-scanner","text":"Wir k\u00f6nnen derzeit Ausgaben auf die Konsole schreiben. Wir k\u00f6nnen jedoch noch keine Eingaben t\u00e4tigen. Das wird sich mit der Verwendung der Klasse Scanner nun \u00e4ndern. Die Verwendung dieser Klasse durch uns erfolgt durch die Erzeugung eines Scanner - Objektes den Aufruf einer passenden Objektmethode , je nachdem, was wir einlesen wollen, ein int , ein double oder einen String .","title":"Die Klasse Scanner"},{"location":"hilfsklassen/#erzeugen-eines-scanner-objektes","text":"Wir haben oben zwei begriffe verwendet, deren Bedeutung wir erst sp\u00e4ter kennenlernen: Objekt und Objektmethode . Das soll uns aber nicht aufhalten, einfach einmal ein Scanner -Objekt zu erzeugen: Scanner sc = new Scanner ( System . in ); Hierbei passiert folgendes: wir deklarieren uns eine Variable sc vom Datentyp Scanner , wir erzeugen mithilfe von new Scanner() ein neues Objekt vom Datentyp Scanner , wir \u00fcbergeben der Methode, die ein Scanner -Objekt erzeugt unser Standardeingabeger\u00e4t ( System.in ) - das ist die Konsole, d.h. wir wollen unsere Daten \u00fcber die Konsole einlesen wir weisen unser neues Objekt (genauer gesagt: eine Referenz auf unser neues Objekt) der Variablen sc zu Wenn Sie obige Anweisung z.B. in Ihre main() -Methode einf\u00fcgen, dann stellen Sie fest, dass beide Scanner rot unterstrichen sind. Die Fehlerausgabe ist Scanner cannot be resolved to a type . Das liegt daran, dass die Klasse Scanner nicht zum Standardpaket java.lang geh\u00f6rt, sondern wir sie erst importieren m\u00fcssen. Das lassen wir aber von unserer IDE erledigen. Wir w\u00e4hlen eines der vorgeschlagenen quick fixes aus, und zwar import Scanner (java.util) . Achten Sie darauf, dass dies nicht der erste Vorschlag f\u00fcr ein quick fix ist! Nachdem die entsprechende import -Anweisung ( import java.util.Scanner; ) eingef\u00fcgt wurde, ist die Fehlermeldung behoben. Das Programm k\u00f6nnte also so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 13 package themen.hilfsklassen ; import java.util.Scanner ; public class Hilfsklassen { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); } } Die import -Anweisung (Zeile 3 ) erfolgt au\u00dferhalb und vor der Klassendeklaration.","title":"Erzeugen eines Scanner-Objektes"},{"location":"hilfsklassen/#aufrufen-der-passenden-objektmethoden","text":"F\u00fcr ein solches Objekt vom Typ Scanner stehen eine Vielzahl von Methoden zur Verf\u00fcgung, von denen wir uns nur die folgenden anschauen wollen: next() : liest einen String ein nextInt() : liest ein int ein nextDouble() : liest ein double ein nextBoolean() : liest ein boolean ein Es sei erw\u00e4hnt, dass es auch noch nextLong() , nextFloat() , nextShort() usw. gibt. Der Aufruf einer solchen Objektmethode erfolgt stets nach dem Prinzip: referenzVariable.objektMethode () Das hei\u00dft die Variable, die eine Referenz auf das Objekt h\u00e4lt (bei uns sc ), ruft \u00fcber Punktnotation (mit einem . verbinden) die entsprechende Objektmethode auf. Wir betrachten Beispiele: 1 2 3 4 5 6 7 8 public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Geben Sie eine ganze Zahl ein: \" ); int ganzeZahl = sc . nextInt (); System . out . println ( ganzeZahl ); } In Zeile 6 sehen Sie den Aufruf der Methode nextInt() f\u00fcr das sc -Objekt, also sc.nextInt() . Die Methode nextInt() gibt die eingegebene Zahl zur\u00fcck, d.h. der Aufruf der Methode entspricht einer Zahl vom Datentyp int . Diese speichern wir in obigem Beispiel in der Variablen ganzeZahl vom Typ int . Wenn Sie auf der Konsole dann eine Zahl eingeben, sieht das so aus: Was passiert, wenn Sie keine Zahl eingeben? Dann wird eine sogenannte * Exception* geworfen. Eine Exception ist ein Fehler, der zur Laufzeit passiert. Wir werden bald lernen, wie man soclhe Exceptions abf\u00e4ngt, damit es nicht einen solchen \"Systemabsturz\" gibt. Derzeit m\u00fcssen wir damit noch leben. Eine solche fehlerhafte Eingabe w\u00fcrde so aussehenen: F\u00fcr diejenigen, die es interessiert, ist hier eine Methode, die einen solchen Fehlerfall abf\u00e4ngt. Das m\u00fcssen sie jetzt aber noch nicht verstehen - es ist, wie gesagt, nur f\u00fcr eventuelles Interesse: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package themen.hilfsklassen ; import java.util.InputMismatchException ; import java.util.Scanner ; public class Hilfsklassen { public static int ganzeZahlEinlesen ( String message ) { Scanner sc = new Scanner ( System . in ); int number = 0 ; boolean inputOk = false ; do { System . out . print ( message + \": \" ); try { number = sc . nextInt (); inputOk = true ; } catch ( InputMismatchException e ) { message = \"Sie m\u00fcssen eine Zahl eingeben\" ; sc . next (); } } while ( ! inputOk ); return number ; } public static void main ( String [] args ) { int ganzeZahl = ganzeZahlEinlesen ( \"Geben Sie eine Zahl ein\" ); System . out . println ( ganzeZahl ); } } Ein m\u00f6glicher Ablauf w\u00e4re dann wie folgt: Wir gehen erstmal davon aus, dass die Eingaben korrekt erfolgen und schauen uns noch weitere Beispiele an: public static void weitereBeispiele () { Scanner sc = new Scanner ( System . in ); System . out . print ( \"int Zahl : \" ); int intNumber = sc . nextInt (); System . out . println ( intNumber ); System . out . print ( \"double Zahl : \" ); double doubleNumber = sc . nextDouble (); System . out . println ( doubleNumber ); System . out . print ( \"boolean : \" ); boolean wahrheitswert = sc . nextBoolean (); System . out . println ( wahrheitswert ); System . out . print ( \"String : \" ); String zeichenkette = sc . next (); System . out . println ( zeichenkette ); } Ein Aufruf der Methode weitereBeispiele(); (z.B. in main() ) k\u00f6nnte dann so aussehen: Beachten Sie: Bei der Eingabe einer double -Zahl m\u00fcssen Sie anstelle des Punktes ein Komma eingeben. Das h\u00e4ngt mit den l\u00e4ndertypischen Einstellungen von Eclipse zusammen. (Bei manchen ist es vielleicht ein Punkt.) Wenn Sie ein String eingeben, dann wird bei der Methode next() nur der String bis zum ersten Leerzeichen eingelesen. (Das l\u00e4sst sich \u00e4ndern, aber darauf gehen wir hier nicht n\u00e4her ein.) Success Wir k\u00f6nnen jetzt Eingaben \u00fcber unsere Konsole t\u00e4tigen!","title":"Aufrufen der passenden Objektmethoden"},{"location":"hilfsklassen/#die-klasse-math","text":"Die Klasse Math enth\u00e4lt viele mathematische Funktionen als Methoden. Au\u00dferdem ist in ihr z.B. die Konstante PI definiert. Um die Klasse Math zu verwenden, m\u00fcssen wir sie nicht importieren, denn sie befindet sich im Paket java.lang . Wir m\u00fcssen auch kein Objekt der Klasse erzeugen, da alle Methoden dieser Klasse Klassenmethoden (also static sind). Um eine Methode dieser Klasse aufzurufen, setzen wir vor die Methode einfach Math. . Wir schauen uns Beispiele an: double nr1 = 16.0 ; double nr2 = Math . sqrt ( nr1 ); // Quadratwurzel double nr3 = Math . PI * 3.0 ; double nr4 = Math . abs ( - 12.0 ); // absoluter Betrag double nr5 = Math . floor ( 12.3456 ); // abgeschnitten -> 12 double nr6 = Math . floor ( 12.9876 ); // abgeschnitten -> 12 double nr7 = Math . floor ( - 12.3456 ); // abgeschnitten -> -13 double nr8 = Math . floor ( - 12.9876 ); // abgeschnitten -> -13 double nr9 = Math . pow ( 2 , 5 ); // 2 hoch 5 = 32 Beachten Sie, dass floor() nicht rundet, sondern die n\u00e4chste ganze Zahl angibt, die kleiner als der Parameterwert ist. Mithilfe der Math.random() -Methode k\u00f6nnen Sie sich au\u00dferdem double -Zufallszahlen aus dem Bereich 0.0 <= zufallszahl <1.0 erzeugen lassen. Wir werden das aber meistens mithilfe der folgenden Klasse Random erledigen. Alle Methoden der Klasse Math finden Sie hier .","title":"Die Klasse Math"},{"location":"hilfsklassen/#die-klasse-random","text":"Mithilfe der Klasse Random k\u00f6nnen wir Zufallszahlen erzeugen. Bei der Klasse Random ist es \u00e4hnlich wie bei Scanner : wir erzeugen uns ein Random -Objekt, die Klasse befindet sich im Paket java.util , d.h. wir m\u00fcssen sie importieren, wir w\u00e4hlen die passende Methode aus, je nachdem, von welchem Datentyp unsere Zufallszahl sein soll","title":"Die Klasse Random"},{"location":"hilfsklassen/#ein-random-objekt-erzeugen","text":"Wir erzwugen uns ein Random -Objekt wie folgt Random r = new Random (); Um die Klasse Random verwenden zu k\u00f6nnen, muss sie importiert werden. Hier ein Ausschnitt aus der Klasse, in der wir neben Random auch Scanner verwenden: 1 2 3 4 5 6 7 package themen.hilfsklassen ; import java.util.Random ; import java.util.Scanner ; public class Hilfsklassen { In Zeile 3 wird die Klasse Random importiert.","title":"Ein Random-Objekt erzeugen"},{"location":"hilfsklassen/#objektemethoden-der-klasse-random","text":"Die Klasse Random bietet verschiedene Methoden, um Zufallswerte der einzelnen Datentypen zu generieren: nextDouble() : erzeugt eine double -Zahl (aus dem Bereich 0.0 inklusive bis 1.0 exclusive) nextFloat() : erzeugt eine float -Zahl (aus dem Bereich 0.0 inklusive bis 1.0 exclusive) nextLong() : erzeugt eine long -Zahl (aus (fast) dem Bereich gesamten Bereich von long ) nextBoolean() : erzeugt einen boolean -Wert zuf\u00e4llig ( true oder false ) Wir betrachten jedoch haupts\u00e4chlich die Methoden, die uns zuf\u00e4llig einen int -Wert liefern: nextInt() : erzeugt eine int -Zahl aus dem gesamten Wertebereich von int - also auch negative Zahlen, nextInt(int bound) : erzeugt eine int -Zahl aus dem Bereich 0 inklusive bis bound exclusive)","title":"Objektemethoden der Klasse Random"},{"location":"hilfsklassen/#nextint","text":"Schauen wir uns zun\u00e4chst nextInt() an. Wir implementieren eine Methode, die uns 10 Zufallszahlen mithilfe der Methode nextInt() erzeugt und auf die Konsole ausgibt: 1 2 3 4 5 6 7 8 9 public static void printIntRandomNumbers () { Random r = new Random (); for ( int i = 0 ; i < 10 ; i ++ ) { int randomNumber = r . nextInt (); System . out . println ( randomNumber ); } } In Zeile 6 sehen wir den Aufruf der Methode nextInt() . Die Referenzvariable r zeigt auf unser Random -Objekt. F\u00fcr die Referenzvariable wird mithilfe der Punktnotation die Methode nextInt() aufgerufen, also r.nextInt(); . Diese Methode gibt eine Zufallszahl zur\u00fcck, die wir in der Variablen randomNumber speichern. Ein Aufruf der Methode printIntRandomNumbers(); z.B. in main() kann zu folgender Ausgabe f\u00fchren (das sind Zufallszahlen, also jeder Aufruf liefert andere Werte): 1362288576 1801089219 -1573362027 56087730 1015233281 1341464232 2112804572 841838154 1460116224 -910734474","title":"nextInt()"},{"location":"hilfsklassen/#nextintint-bound","text":"Die Methode nextInt() existiert auch parametrisiert, d.h. wir k\u00f6nnen ihr einen Parameterwert (vom Datentyp int ) \u00fcbergeben. Dieser Wert muss positiv sein! Wenn nicht, dann wird eine IllegalArgumentException geworfen. Die Idee dieses Parameters ist zun\u00e4chst die, dass wir den Wertebereich einschr\u00e4nken, aus dem die Zufallszahlen erzeugt werden. Angenommen, wir \u00fcbergeben eine 6 , dann werden die Zufallszahlen aus dem Bereich 0 , 1 , 2 , 3 , 4 , 5 erzeugt. F\u00fcr nextInt(bound) gilt also, dass eine Zufallszahl aus dem Bereich 0 (inklusive) bis bound (exklusive) ( 0 <= zufZahl < bound ) erzeugt wird. Wir betrachten folgendes Beispiel: 1 2 3 4 5 6 7 8 9 10 public static void printIntRandomNumbers () { Random r = new Random (); int bound = 10 ; for ( int i = 0 ; i < 10 ; i ++ ) { int randomNumber = r . nextInt ( bound ); System . out . println ( randomNumber ); } } Wir haben die gleiche Methode wie oben, nur dass wir jetzt nicht nextInt() , sondern nextInt(bound) aufrufen (Zeile 7 ). bound ist vom Typ int und hat den Wert 10 (Zeile 4 ). Ein Aufruf der Methode printIntRandomNumbers(); z.B. in main() kann zu folgender Ausgabe f\u00fchren (das sind Zufallszahlen, also jeder Aufruf liefert andere Werte): 2 8 8 6 8 2 5 9 8 3 Angenommen, wir wollen einen W\u00fcrfel implementieren. Mit dem Aufruf nextInt(6) w\u00fcrden wir Zahlen zuf\u00e4llig aus dem Bereich [0, ..., 5] erzeugen. Das w\u00e4re es noch nicht ganz. Erst, wenn wir zu der erzeugten Zufallszahl jeweils eine 1 hinzuaddieren, \"w\u00fcrfeln\" wir Zahlen aus dem Bereich [1, ..., 6] . Ein W\u00fcrfel w\u00fcrde also so implementiert werden: Random r = new Random (); int wurf = r . nextInt ( 6 ) + 1 ; // zufaellig Zahlen 1 bis 6 Eine generelle Methode, um mithilfe der Methode nextInt(bound) einen beliebigen Bereich aus dem int -Wertebereich zuf\u00e4llig abzudecken, sehe z.B. wie folgt aus: 1 2 3 4 5 6 7 public static int getRandomNumber ( int fromInclusive , int toInclusive ) { Random r = new Random (); int bound = ( toInclusive - fromInclusive ) + 1 ; // +1 wegen toInclusive soll auch int randomNumber = r . nextInt ( bound ) + fromInclusive ; return randomNumber ; } Die Methode ist nicht besonders stabil. Wir m\u00fcssten eigentlich \u00fcberpr\u00fcfen, ob toInclusive gr\u00f6\u00dfer ist als fromInclusive , aber wir wollen hier zun\u00e4chst nur das Prinzip erl\u00e4utern. Wir \"testen\" unsere Methode und schauen mal, ob wir Zufallszahlen aus dem Bereich [90, ... , 99] erzeugen: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( 90 , 99 ) + \" \" ); } Eine m\u00f6gliche Ausgabe: 96 99 92 98 95 91 95 96 97 93 97 90 94 92 92 94 95 93 99 91 92 95 99 90 91 97 99 93 92 98 91 92 99 90 90 97 95 90 92 97 93 92 94 93 94 90 92 96 96 94 Noch ein \"Test\", diesmal Zahlen aus dem Bereich [-33 , ... , -10] : for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( - 33 , - 10 ) + \" \" ); } Eine m\u00f6gliche Ausgabe: -10 -31 -29 -29 -33 -11 -19 -15 -33 -22 -13 -15 -14 -10 -28 -27 -24 -19 -13 -26 -21 -10 -25 -16 -29 -28 -16 -18 -29 -15 -23 -26 -18 -25 -29 -19 -12 -23 -26 -22 -15 -26 -11 -16 -18 -22 -20 -12 -21 -25 Von [-10, ... , 10] geht auch: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( - 10 , - 10 ) + \" \" ); } und unser W\u00fcrfel klappt auch: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( 1 , 6 ) + \" \" ); }","title":"nextInt(int bound)"},{"location":"hilfsklassen/#die-klasse-string","text":"Wir haben die Klasse String bereits bei den Datentypen betrachtet. Dort haben wir gesagt, dass String ein anderer Datentyp ist, als die Wertetypen int , boolean , double usw. Bei String handelt es sich um einen Referenztypen . Ein String ist eine Referenz auf ein Objekt. Wenn wir also so etwas haben: String str = \"Hallo FIW!\" ; dann ist str eine Referenzvariable , so wie z.B. r bei Random und sc bei Scanner . Wie bei Random und Scanner gibt es auch f\u00fcr String Methoden, die wir auf die Objekte anwenden k\u00f6nnen. Einige davon schauen wir uns im Folgenden an. Zun\u00e4chst untersuchen wir jedoch, was so ein String eigentlich intern ist. Bei einer Zeichenkette handelt es sich um ein Array aus einzelnen Zeichen, also char . Wir wissen noch nicht, was ein Array ist, aber wir bekommen hier eine Vorstellung davon. Angenommen, wir haben den obigen String ( \"Hallo FIW!\" ). Intern sieht der so aus: Ein String besteht also aus einzelnen Zeichen (vom Typ char ) und diese sind sogar automatisch \"nummeriert\". Wir haben einen sogenannten Index . Dieser Index ist eine ganze Zahl ( int ) und beginnt beim ersten Zeichen mit 0 und l\u00e4uft dann fortlaufend mit jedem Zeichen eins h\u00f6her. Betrachten wir unsere erste Methode f\u00fcr String: die Methode length() . Diese Methode gibt die L\u00e4nge eines Strings zur\u00fcck - in unserem Beispiel 10 . String str = \"Hallo FIW!\" ; System . out . println ( str . length ()); // 10 Sie k\u00f6nnen die Methode \u00fcber Punktnotation \u00fcbrigens auch direkt an das Literal anh\u00e4ngen, also so: System . out . println ( \"Hallo FIW!\" . length ()); // 10 das gilt f\u00fcr alle der folgenden Objektmethoden. Beachten Sie, dass L\u00e4nge ( length() ) eines Strings um 1 gr\u00f6\u00dfer ist als der gr\u00f6\u00dfte Indexwert. In der obigen Abbildung sehen wir, dass das Ausrufezeichen ( ! ) mit dem Index 9 nummeriert ist. Das liegt daran, dass der erste Index die 0 ist. Nun wollen wir den Index verwenden, also die \"Nummer\" jedes einzelnen Zeichens in einem String. Die Methode charAt(int index) liefrt das Zeichen eines Strings an dem Index index zur\u00fcck. Also z.B.: char c = \"Hallo FIW!\" . charAt ( 6 ); // 'F' System . out . println ( c ); // F Wir lassen uns einmal alle Zeichen einzeln eines Strings ausgeben. Dazu verwenden wir eine for -Schleife. Die Laufvariable nimmt alle Werte aus dem Index an, d.h. 0 bis kleiner als length() : String str = \"Hallo FIW!\" ; for ( int i = 0 ; i < str . length (); i ++ ) { char c = str . charAt ( i ); System . out . println ( c ); } Das erzeugt folgende Ausgabe: H a l l o F I W ! Verschl\u00fcsseln Wir wissen ja, dass char ein ganzzahliger Datentyp ist. Wir k\u00f6nnten unsere Zeichenkette jetzt verschl\u00fcsseln, indem wir einfach zu dem ASCII-Code des jeweiligen Zeichens eine 1 hinzuaddieren. Das machen wir mal: String str = \"Hallo FIW!\" ; System . out . println ( str ); // Hallo FIW! for ( int i = 0 ; i < str . length (); i ++ ) { char c = str . charAt ( i ); c ++ ; // naechstgroesserer ASCII-Code (um 1 addiert) System . out . print ( c ); // Ibmmp!GJX\" } Erzeugt folgende Ausgabe: Hallo FIW! Ibmmp!GJX \" Wir k\u00f6nnen auch einen bestimmten Index erfragen. Die Methode indexOf(char c) gibt den Index zur\u00fcck, an dem das Zeichen zum ersten Mal im String autaucht. Die Methode lastIndexOf(char c) gibt den Index zur\u00fcck, an dem das Zeichen zum letzten Mal im String autaucht. int first = \"Hallo FIW!\" . indexOf ( 'l' ); // 2 int last = \"Hallo FIW!\" . lastIndexOf ( 'l' ); // 3 System . out . println ( \"l zum ersten Mal : \" + first ); System . out . println ( \"l zum letzten Mal : \" + last ); Mithilfe des Index k\u00f6nnen wir auch Teile eines Strings extrahieren. Die Methode substring(int beginIndex) liefert den Teilstring beginnend mit dem Index beginIndex bis zum Ende des Strings zur\u00fcck. Die Methode substring(int beginIndex, int endIndex) liefert den Teilstring beginnend mit dem Index beginIndex (inklusive) bis zum Index endIndex (exklusive) zur\u00fcck. String substr1 = \"Hallo FIW!\" . substring ( 3 ); // lo FIW! String substr2 = \"Hallo FIW!\" . substring ( 3 , 7 ); // lo F System . out . println ( substr1 ); System . out . println ( substr2 ); Mithilfe der Methode toLowerCase() werden alle Buchstaben eines Strings in Kleinbuchstaben umgewandelt. Mithilfe der Methode toUpperCase() werden alle Buchstaben eines Strings in Gro\u00dfbuchstaben umgewandelt. String lower = \"Hallo FIW!\" . toLowerCase (); // hallo fiw! String upper = \"Hallo FIW!\" . toUpperCase (); // HALLO FIW! System . out . println ( lower ); System . out . println ( upper ); Um zwei Strings lexikographisch miteinander zu vergleichen, kann die Methode compareTo(String) verwendet werden. Diese gibt ein int zur\u00fcck. Wir betrachten dazu ein Beispiel: 1 2 3 int result1 = \"abc\" . compareTo ( \"abd\" ); // -1 int result2 = \"abd\" . compareTo ( \"abc\" ); // 1 int result3 = \"abc\" . compareTo ( \"abc\" ); // 0 In Zeile 1 ruft der String \"abc\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abd\" . Da \"abc\" \"kleiner\" ist als \"abd\" , ist der R\u00fcckgabewert negativ -1 . In Zeile 2 ruft der String \"abd\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abc\" . Da \"abd\" \"gr\u00f6\u00dfer\" ist als \"abc\" , ist der R\u00fcckgabewert positiv 1 . In Zeile 3 ruft der String \"abc\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abc\" . Da beide Strings gleich sind, ist der R\u00fcckgabewert 0 . Um einen Wert von einem Wertetypen (also die primitiven Datentypen int , boolean , double usw.) in einen String umzuwandeln, stehen die Klassenmethoden valueOf() zur Verf\u00fcgung. Der Zugriff auf eine solche Methode erfolgt mittels Punktschreibweise und dem Namen der Klasse, also String.valueOf() (es handelt sich um static Methoden). Die Umwandlung erfolgt also wie folgt: String si9 = String . valueOf ( 9 ); // int --> String String si123 = String . valueOf ( 123 ); // int --> String String sb = String . valueOf ( true ); // boolean --> String String sd = String . valueOf ( 5.5 ); // double --> String","title":"Die Klasse String"},{"location":"hilfsklassen/#format-methode-und-printf","text":"In der \u00dcbung 2 sollte das kleine 1x1 einaml als Liste und einmal als Matrix ausgegeben werden. Bei beiden war die Formatierung der Ausgabe nicht besonders sch\u00f6n, da die Zahlen unterschiedliche L\u00e4ngen hatten. Sch\u00f6ner w\u00e4re es gewesen, die Ausgabe der Zahlen rechtsb\u00fcndig zu gestalten. Das geht mit der System.out.printf() -Methode. Die printf() -Methode verwendet die format() -Methode von Strings zur Formatierung der Ausgabe. Wir schauen uns zun\u00e4chst ein einf\u00fchrendes Beispiel an: 1 2 String output = String . format ( \"in %s angemeldet : %d Studentinnen\" , \"FIW\" , 44 ); System . out . println ( output ); Die format() -Methode in Zeile 1 hat drei Parameter: einen Ausgabestring, der Platzhalter enth\u00e4lt einen String \"FIW\" und eine int -Zahl 44 Der Ausgabestring enth\u00e4lt sogenannte Platzhalter , n\u00e4mlich %s f\u00fcr einen String und %d f\u00fcr ein int . Anstelle dieser Platzhalter werden die nach dem Ausgabestring aufgelisteten Werte eingef\u00fcgt, also f\u00fcr %s wird \"FIW\" eingesetzt und f\u00fcr %d die 44 . Die Ausgabe sieht dann so aus: in FIW angemeldet : 44 Studentinnen Das ist zun\u00e4chst wenig spektakul\u00e4r. Hier zun\u00e4chst eine Tabelle mit den wichtigsten Platzhaltern: Platzhalter Eingabetyp Ausgabe (String) %d int/long/... ganze Zahl %f float/double Gleitkommazahl, Standardnotation %e float/double Gleitkommazahl, wiss. Notation %s String Zeichenkette %c char Buchstabe %n Zeilenumbruch Ein Beispiel sieht also so aus: Die eigentliche Formatierung erfolgt durch die Angabe der vorgesehenen Breite f\u00fcr einen Ausgabewert und ob dieser Wert rechtsb\u00fcndig oder linksb\u00fcndig dargestellt werden soll. Die allgemeine Syntax f\u00fcr einen solchen Platzhalter ist wie folgt: % [ Schalter ] [ Breite ] . [ Genauigkeit ] Typ Dabei sind: % : Formatierungsausdruck beginnt Schalter (optional): ver\u00e4ndert das Format der Ausgabe (Minuszeichen (-) = linksb\u00fcndige Ausgabe) Breite : Anzahl der ausgegebenen Zeichen Genauigkeit (optional): Nachkommastellen Typ : Ausgabetyp ( s (String): Zeichenkette kleingeschrieben, S : Zeichenkette gro\u00dfgeschrieben, d (decimal): Ganzzahl, f (floating-point): Nachkommazahl) Dazu ein Beispiel: public static void createTable ( int rows ) { Random r = new Random (); int number1 = 0 ; int number2 = 0 ; System . out . println ( \" a | b | a + b | a - b | a * b | a / b | a % b \" ); System . out . println ( \"----------------------------------------------------------------\" ); for ( int i = 0 ; i < rows ; i ++ ) { number1 = r . nextInt ( 100 ) + 1 ; number2 = r . nextInt ( 100 ) + 1 ; System . out . printf ( \"%4d | %4d | %5d | %5d |%7d | %5d | %4d %n\" , number1 , number2 , number1 + number2 , number1 - number2 , number1 * number2 , number1 / number2 , number1 % number2 ); } } Bei Aufruf von createTable(8); erreichen wir zum Beispiel folgende Ausgabe: a | b | a + b | a - b | a * b | a / b | a % b ---------------------------------------------------------------- 4 | 39 | 43 | -35 | 156 | 0 | 4 60 | 2 | 62 | 58 | 120 | 30 | 0 93 | 60 | 153 | 33 | 5580 | 1 | 33 8 | 68 | 76 | -60 | 544 | 0 | 8 80 | 82 | 162 | -2 | 6560 | 0 | 80 31 | 10 | 41 | 21 | 310 | 3 | 1 7 | 30 | 37 | -23 | 210 | 0 | 7 54 | 12 | 66 | 42 | 648 | 4 | 6 Die Zahlen erscheinen also alle geordnet untereinander und rechtsb\u00fcndig. Wie gesagt, System.out.printf() und String.format() funktionieren exakt gleich, da printf() format() verwendet. Weitere Beispiele f\u00fcr Schalter und ihre Breitenangaben: String output ; output = String . format ( \"|%10d|\" , 1234 ); // | 1234| output = String . format ( \"|%-10d|\" , 1234 ); // |1234 | output = String . format ( \"|%010d|\" , 1234 ); // |0000001234| output = String . format ( \"|%+10d|\" , 1234 ); // | +1234| output = String . format ( \"|%,10d|\" , 1234 ); // | 1.234| output = String . format ( \"|%10.2f|\" , 1234.567 ); // | 1234,57| output = String . format ( \"|%-10.2f|\" , 1234.567 ); // |1234,57 | output = String . format ( \"|%5.2f|\" , 1234.567 ); // |1234,57| output = String . format ( \"|%15s|\" , \"Hallo FIW!\" ); // | Hallo FIW!| output = String . format ( \"|%-15s|\" , \"Hallo FIW!\" ); // |Hallo FIW! | output = String . format ( \"|%.7s|\" , \"Hallo FIW!\" ); // |Hallo F| Unsere beiden Methoden des kleinen 1x1 aus \u00dcbung 2 h\u00e4tten dann auch eine sch\u00f6nere Ausgabe: public static void printTimesTables ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . printf ( \"%2d * %2d = %3d %n\" , faktor1 , faktor2 , produkt ); } System . out . println (); } } public static void printTimesMatrix ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . printf ( \"%4d\" , produkt ); } System . out . println (); } } N\u00e4mlich so: ----- Aufgabe 1 ------ 1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 1 * 4 = 4 1 * 5 = 5 1 * 6 = 6 1 * 7 = 7 1 * 8 = 8 1 * 9 = 9 1 * 10 = 10 2 * 1 = 2 2 * 2 = 4 2 * 3 = 6 2 * 4 = 8 2 * 5 = 10 2 * 6 = 12 2 * 7 = 14 2 * 8 = 16 2 * 9 = 18 2 * 10 = 20 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 3 * 4 = 12 3 * 5 = 15 3 * 6 = 18 3 * 7 = 21 3 * 8 = 24 3 * 9 = 27 3 * 10 = 30 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 4 * 10 = 40 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 5 * 6 = 30 5 * 7 = 35 5 * 8 = 40 5 * 9 = 45 5 * 10 = 50 6 * 1 = 6 6 * 2 = 12 6 * 3 = 18 6 * 4 = 24 6 * 5 = 30 6 * 6 = 36 6 * 7 = 42 6 * 8 = 48 6 * 9 = 54 6 * 10 = 60 7 * 1 = 7 7 * 2 = 14 7 * 3 = 21 7 * 4 = 28 7 * 5 = 35 7 * 6 = 42 7 * 7 = 49 7 * 8 = 56 7 * 9 = 63 7 * 10 = 70 8 * 1 = 8 8 * 2 = 16 8 * 3 = 24 8 * 4 = 32 8 * 5 = 40 8 * 6 = 48 8 * 7 = 56 8 * 8 = 64 8 * 9 = 72 8 * 10 = 80 9 * 1 = 9 9 * 2 = 18 9 * 3 = 27 9 * 4 = 36 9 * 5 = 45 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81 9 * 10 = 90 10 * 1 = 10 10 * 2 = 20 10 * 3 = 30 10 * 4 = 40 10 * 5 = 50 10 * 6 = 60 10 * 7 = 70 10 * 8 = 80 10 * 9 = 90 10 * 10 = 100 ----- Aufgabe 2 ------ 1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90 100","title":"format()-Methode und printf()"},{"location":"hilfsklassen/#formatierung-von-gleikommazahlen","text":"Um Gleitkommazahlen in der Standardnotation (nicht wissenschaftliche Notation) formatiert auszugeben, wird der Platzhalter %f verwendet. Die allgemeine Syntax ist also % [ Schalter ] [ Breite ] . [ Genauigkeit ] f Der Schalter kann - sein, dann wird die Zahl linksb\u00fcndig dargestellt. Ist kein Schalter angegeben, erfolgt die Ausgabe rechtsb\u00fcndig. Die Breite beschreibt die gesamte Anzahl der Stellen f\u00fcr die Zahl. Die Breite enth\u00e4lt insbesondere auch eine Stelle f\u00fcr das Komma und die Anzahl der Stellen f\u00fcr die Genauigkeit . Die Genauigkeit gibt die Anzahl der Nachkommastellen an. Angenommen, der Plathalter lautet %7.2f . Dann werden insgesamt sieben Stellen f\u00fcr die gesamte Zahl reserviert, inklusive dem Komma und den 2 Nachkommastellen, also _ _ _ _ , _ _ Wenn die Gesamtl\u00e4nge beliebig ist, Sie aber nur genau 2 Nachkommastellen haben m\u00f6chten, dann k\u00f6nnen Sie auch %.2f als Platzhalter angeben. F\u00fcr eine Nachkommastelle %.1f . Die Nachkommastellen werden sogar gerundet. Hier nochmal einige Beispiele von oben nur f\u00fcr Gleikommazahlen: 1 2 3 4 System . out . printf ( \"|%10.2f|\" , 1234.567 ); // | 1234,57| System . out . printf ( \"|%-10.2f|\" , 1234.567 ); // |1234,57 | System . out . printf ( \"|%7.2f|\" , 1234.567 ); // |1234,57| System . out . printf ( \"|%5.2f|\" , 1234.567 ); // |1234,57| Beachten Sie auch das letzte Beispiel (Zeile 4 ). Es wurden nur insgesamt 5 Stellen f\u00fcr die gesamte Zahl reserviert. Davon ben\u00f6tigen wir alleine 2 Stellen f\u00fcr die Nachkommastellen und 1 Stelle f\u00fcr das Komma. Die Vorkommastellen h\u00e4tten also nur 2 Stellen Platz. Vorne wird die Zahl aber nie abgeschnitten. Sollte der reservierte Platz f\u00fcr die Vorkommastellen nicht ausreichen, wird der Vorkommabereich trotzdem vollst\u00e4ndig dargestellt. Es kann also trotz der Formatierung zu Verzerrungen in der Ausgabe kommen!","title":"Formatierung von Gleikommazahlen"},{"location":"ide/","text":"Integrated Developmemt Environment (IDE) \u00b6 Es gibt eine Vielzahl von Integrierten Entwicklungsumgebungen ( Integrated Developmemt Environment (IDE) ) f\u00fcr Java und viele davon sind auch wirklich gut und f\u00fcr die professionelle Entwicklung von Java-Anwendungen geeignet. Hervorzuheben sind z.B. eclipse , IntelliJ IDEA und Visual Studio Code (VSCode) . Sie sollten sich f\u00fcr eine der drei entscheiden. Es bleibt Ihnen \u00fcberlassen, welche IDE Sie w\u00e4hlen. Alle drei IDEs sind hervorragend geeignet. H\u00f6chstwahrscheinlich werden Sie sp\u00e4testens f\u00fcr WebTech zu IntelliJ IDEA oder VSCode wechseln, obwohl man auch dort Eclipse sehr gut verwenden kann. Der gro\u00dfe Pluspunkt von Eclipse ist, dass es sich um eine Open-Source-Community-Anwendung handelt, die alle Bed\u00fcrfnisse erf\u00fcllt. Grunds\u00e4tzlich ist es sehr gut, verschiedene IDEs auszuprobieren, bis Sie die IDE f\u00fcr sich entdecken, die Sie in Zukunft verwenden wollen. Probieren Sie es einfach aus. Ich werde Eclipse zum Zeigen der Implementierungen und in den Screenshots im Skript verwenden. Eclipse ist Open Source, wird von einer engagierten Community entwickelt und sehr weit auch im professionellen Umfeld verbreitet. Eclipse gibt es bereits seit 20 Jahren und kann hier heruntergeladen werden. Wenn Sie Eclipse f\u00fcr Ihre Java-Entwicklungen installieren wollen, dann w\u00e4hlen Sie bei der Installation die Eclipse IDE for Java Developers aus. Dabei wird auch das Java Development Kit (JDK) installiert und nach dem Start von Eclipse k\u00f6nnen Sie sofort losprogrammieren. Die aktuelle Version ist 2021-12 . W\u00e4hlen Sie beim ersten Start von Eclipse Ihren workspace aus. Der workspace ist der Ordner, in dem Sie Ihre Programme speichern. IntelliJ IDEA IntelliJ IDEA wird nun auch bereits seit \u00fcber 20 Jahren von der Firma JetBrains entwickelt, ist in Java geschrieben und war urspr\u00fcnglich f\u00fcr die reine Java-Entwicklung geplant, kann aber nun f\u00fcr die Programmierung mit vielen verschiedenen Programmiersprachen verwendet werden. Die Produktauswahl ist mittlerweile sehr vielf\u00e4ltig. Die Ultimate Version ist kostenpflichtig, kann jedoch von Studentinnen kostenlos verwendet werden. Dazu ist allerdings die Registrierung mit der ...htw-berlin.de -Adresse notwendig. Interessant, wenn auch leider teilweise kostenpflichtig, sind in diesem Zusammenhang auch die Angebote JetBrains Academy und IntelliJ IDEA Edu . VSCode setzt sich zunehmend immer mehr bei WebTech-Programmiererinnen durch, ist aber auch sehr geeignet f\u00fcr die Implementierung mit Java. Ein guter Startpunkt f\u00fcr die Java-Entwicklung mit VSCode findet sich hier . Folgen Sie dort den Links Install the Coding Pack for Java - ... und Install the Extension for Java . Das wirklich Tolle an VSCode ist, dass es sich um eine Webanwendung handelt (eine sogenannte progressive web app ). Sie l\u00e4uft also eigentlich im Browser, was man aber gar nicht merkt. Die Unterst\u00fctzung f\u00fcr die Java-Implementierung ist, wie auch bei Eclipse und IntelliJ , ausgezeichnet. Starten mit Eclipse \u00b6 Bei ersten Start von Eclipse werden Sie gefragt, wo Sie den workspace festlegen wollen. Der workspace ist der Ordner, in dem Sie Ihre Programme speichern. W\u00e4hlen Sie einen Ordner, in dem Sie alle Schreibrechte haben, z.B. Documents/HTW/Prog1/workspace . Sobald Eclipse ge\u00f6ffnet ist, k\u00f6nnen Sie ein Java Projekt erstellen. W\u00e4hlen Sie dazu File --> New --> Java Project . Im ersten Semester kommen Sie mit einem projekt aus, d.h. Sie k\u00f6nnen Ihr Java-Projekt z.B. WS21 nennen. Markieren auf der linken Seite (im Package Explorer ) das Projekt WS21 und w\u00e4hlen dann File --> New --> Package . Mit Paketen strukturieren wir Java-Projekte. Pakete k\u00f6nnen wir uns wie Ordner vorstellen (sind sie auch). Paketnamen werden kleingschrieben und mit einem Punkt getrennt. Wir geben f\u00fcr unser neues Package z.B. den Namen themen.eclipse an. Es entsteht ein ordner themen und darin ein Unterordner eclipse . Wenn Sie zuk\u00fcnftig weitere Themen bearbeiten, k\u00f6nnen Sie das dann im Package themen.unterthema machen (wobei unterthema f\u00fcr einen Themennamen steht). Wir markieren das Package themen.eclipse und w\u00e4hlen File --> New --> Class . Es \u00f6ffnet sich ein Eingabefenster: In dieses Fenster tragen wir den Namen unserer Klasse ein, z.B. QuickStart . Au\u00dferdem klicken wir das H\u00e4kchen dem dem Label public static void main(String[] args) an und klicken dann auf den Button Finish . Es erscheint unsere Klasse im Editor-Fenster: Die Klasse Quickstart wird in der folgenden Form erzeugt: 1 2 3 4 5 6 7 8 9 10 package themen.eclipse ; public class QuickStart { public static void main ( String [] args ) { // TODO Auto-generated method stub } } In Zeile 1 steht die package -Deklaration. Darin wird angegeben, dass sich unsere Klasse im Paket themen.eclipse befindet. Die zeilen 3-10 enthalten die Klasse QuickStart . Diese Klasse enth\u00e4lt eine einzige Methode, die main()-Methode . Die main() -Methode \u00b6 In BlueJ hatten wir immer eine Methode ausgew\u00e4hlt, die wir ausgef\u00fchrt haben. Von nun an ist es so, dass immer die main() -Methode ausgef\u00fchrt wird (automatisch durch Programmstart). Wenn wir also unser Programm \u00fcbersetzen und starten, wird genau die main() -Methode ausgef\u00fchrt - ohne dass wir ein Objekt der Klasse QuickStart erzeugen m\u00fcssen. Es wird nun immer eine Programmklasse geben, die die main() -Methode enth\u00e4lt. Ohne die main() -Methode kann auch nichts ausgef\u00fchrt werden. Dass wir von der Klasse kein Objekt erzeugen m\u00fcssen, um die main() -Methode zu starten, erkennen wir am Schl\u00fcsselwort static im Methodenkopf. Eine Methode, die als static deklariert wird, kann ausgef\u00fchrt werden, ohne ein Objekt der Klasse zu erzeugen. \u00dcbersetzen und Ausf\u00fchren des Programms \u00b6 Geben Sie in die main() -Methode syso ein, dr\u00fccken Sie Strg + Leer -Taste ( Control + Leer ) und dann Enter . Es erscheint System.out.println() . Erweitern Sie die Methode um die Ausgabe der Zeichenkette \"Hello FIW! : 1 2 3 4 5 6 7 8 9 10 package themen.eclipse ; public class QuickStart { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); } } W\u00e4hlen Sie dann Run --> Run oder klicken Sie auf den gr\u00fcnen runden Button mit dem wei\u00dfen Pfeil in der Werkzeugleiste . Das Programm wird compiliert und ausgef\u00fchrt. Es \u00f6ffnet sich unten das Konsolen -Fenster und dort erscheint Hello FIW! : Fertig. Sie haben Eclipse eingerichtet. Ordnerstruktur \u00b6 gehen Sie im Finder oder im Datei Explorer in den wiorkspace -Ordner. Darin sehen Sie den Ordner WS21 (das Java-Projekt). In dem WS21 gibt es einen bin - und einen src -Ordner. Im src -Ordner finden Sie den Ordner themen (ein package ) und darin den Ordner eclipse (ebenfalls ein package ). Darin liegt die QuickStart.java . Der bin -Ordner ist genauso aufgebaut, wie der src -Ordner, nur dass darin die *.class -Dateien gespeichert sind und nicht die *.java -Dateien. Die Ordnerstruktur zeigt nochmal, dass Pakete der Strukturierung unserer Dateien dienen.","title":"IDE (Eclipse)"},{"location":"ide/#integrated-developmemt-environment-ide","text":"Es gibt eine Vielzahl von Integrierten Entwicklungsumgebungen ( Integrated Developmemt Environment (IDE) ) f\u00fcr Java und viele davon sind auch wirklich gut und f\u00fcr die professionelle Entwicklung von Java-Anwendungen geeignet. Hervorzuheben sind z.B. eclipse , IntelliJ IDEA und Visual Studio Code (VSCode) . Sie sollten sich f\u00fcr eine der drei entscheiden. Es bleibt Ihnen \u00fcberlassen, welche IDE Sie w\u00e4hlen. Alle drei IDEs sind hervorragend geeignet. H\u00f6chstwahrscheinlich werden Sie sp\u00e4testens f\u00fcr WebTech zu IntelliJ IDEA oder VSCode wechseln, obwohl man auch dort Eclipse sehr gut verwenden kann. Der gro\u00dfe Pluspunkt von Eclipse ist, dass es sich um eine Open-Source-Community-Anwendung handelt, die alle Bed\u00fcrfnisse erf\u00fcllt. Grunds\u00e4tzlich ist es sehr gut, verschiedene IDEs auszuprobieren, bis Sie die IDE f\u00fcr sich entdecken, die Sie in Zukunft verwenden wollen. Probieren Sie es einfach aus. Ich werde Eclipse zum Zeigen der Implementierungen und in den Screenshots im Skript verwenden. Eclipse ist Open Source, wird von einer engagierten Community entwickelt und sehr weit auch im professionellen Umfeld verbreitet. Eclipse gibt es bereits seit 20 Jahren und kann hier heruntergeladen werden. Wenn Sie Eclipse f\u00fcr Ihre Java-Entwicklungen installieren wollen, dann w\u00e4hlen Sie bei der Installation die Eclipse IDE for Java Developers aus. Dabei wird auch das Java Development Kit (JDK) installiert und nach dem Start von Eclipse k\u00f6nnen Sie sofort losprogrammieren. Die aktuelle Version ist 2021-12 . W\u00e4hlen Sie beim ersten Start von Eclipse Ihren workspace aus. Der workspace ist der Ordner, in dem Sie Ihre Programme speichern. IntelliJ IDEA IntelliJ IDEA wird nun auch bereits seit \u00fcber 20 Jahren von der Firma JetBrains entwickelt, ist in Java geschrieben und war urspr\u00fcnglich f\u00fcr die reine Java-Entwicklung geplant, kann aber nun f\u00fcr die Programmierung mit vielen verschiedenen Programmiersprachen verwendet werden. Die Produktauswahl ist mittlerweile sehr vielf\u00e4ltig. Die Ultimate Version ist kostenpflichtig, kann jedoch von Studentinnen kostenlos verwendet werden. Dazu ist allerdings die Registrierung mit der ...htw-berlin.de -Adresse notwendig. Interessant, wenn auch leider teilweise kostenpflichtig, sind in diesem Zusammenhang auch die Angebote JetBrains Academy und IntelliJ IDEA Edu . VSCode setzt sich zunehmend immer mehr bei WebTech-Programmiererinnen durch, ist aber auch sehr geeignet f\u00fcr die Implementierung mit Java. Ein guter Startpunkt f\u00fcr die Java-Entwicklung mit VSCode findet sich hier . Folgen Sie dort den Links Install the Coding Pack for Java - ... und Install the Extension for Java . Das wirklich Tolle an VSCode ist, dass es sich um eine Webanwendung handelt (eine sogenannte progressive web app ). Sie l\u00e4uft also eigentlich im Browser, was man aber gar nicht merkt. Die Unterst\u00fctzung f\u00fcr die Java-Implementierung ist, wie auch bei Eclipse und IntelliJ , ausgezeichnet.","title":"Integrated Developmemt Environment (IDE)"},{"location":"ide/#starten-mit-eclipse","text":"Bei ersten Start von Eclipse werden Sie gefragt, wo Sie den workspace festlegen wollen. Der workspace ist der Ordner, in dem Sie Ihre Programme speichern. W\u00e4hlen Sie einen Ordner, in dem Sie alle Schreibrechte haben, z.B. Documents/HTW/Prog1/workspace . Sobald Eclipse ge\u00f6ffnet ist, k\u00f6nnen Sie ein Java Projekt erstellen. W\u00e4hlen Sie dazu File --> New --> Java Project . Im ersten Semester kommen Sie mit einem projekt aus, d.h. Sie k\u00f6nnen Ihr Java-Projekt z.B. WS21 nennen. Markieren auf der linken Seite (im Package Explorer ) das Projekt WS21 und w\u00e4hlen dann File --> New --> Package . Mit Paketen strukturieren wir Java-Projekte. Pakete k\u00f6nnen wir uns wie Ordner vorstellen (sind sie auch). Paketnamen werden kleingschrieben und mit einem Punkt getrennt. Wir geben f\u00fcr unser neues Package z.B. den Namen themen.eclipse an. Es entsteht ein ordner themen und darin ein Unterordner eclipse . Wenn Sie zuk\u00fcnftig weitere Themen bearbeiten, k\u00f6nnen Sie das dann im Package themen.unterthema machen (wobei unterthema f\u00fcr einen Themennamen steht). Wir markieren das Package themen.eclipse und w\u00e4hlen File --> New --> Class . Es \u00f6ffnet sich ein Eingabefenster: In dieses Fenster tragen wir den Namen unserer Klasse ein, z.B. QuickStart . Au\u00dferdem klicken wir das H\u00e4kchen dem dem Label public static void main(String[] args) an und klicken dann auf den Button Finish . Es erscheint unsere Klasse im Editor-Fenster: Die Klasse Quickstart wird in der folgenden Form erzeugt: 1 2 3 4 5 6 7 8 9 10 package themen.eclipse ; public class QuickStart { public static void main ( String [] args ) { // TODO Auto-generated method stub } } In Zeile 1 steht die package -Deklaration. Darin wird angegeben, dass sich unsere Klasse im Paket themen.eclipse befindet. Die zeilen 3-10 enthalten die Klasse QuickStart . Diese Klasse enth\u00e4lt eine einzige Methode, die main()-Methode .","title":"Starten mit Eclipse"},{"location":"ide/#die-main-methode","text":"In BlueJ hatten wir immer eine Methode ausgew\u00e4hlt, die wir ausgef\u00fchrt haben. Von nun an ist es so, dass immer die main() -Methode ausgef\u00fchrt wird (automatisch durch Programmstart). Wenn wir also unser Programm \u00fcbersetzen und starten, wird genau die main() -Methode ausgef\u00fchrt - ohne dass wir ein Objekt der Klasse QuickStart erzeugen m\u00fcssen. Es wird nun immer eine Programmklasse geben, die die main() -Methode enth\u00e4lt. Ohne die main() -Methode kann auch nichts ausgef\u00fchrt werden. Dass wir von der Klasse kein Objekt erzeugen m\u00fcssen, um die main() -Methode zu starten, erkennen wir am Schl\u00fcsselwort static im Methodenkopf. Eine Methode, die als static deklariert wird, kann ausgef\u00fchrt werden, ohne ein Objekt der Klasse zu erzeugen.","title":"Die main()-Methode"},{"location":"ide/#ubersetzen-und-ausfuhren-des-programms","text":"Geben Sie in die main() -Methode syso ein, dr\u00fccken Sie Strg + Leer -Taste ( Control + Leer ) und dann Enter . Es erscheint System.out.println() . Erweitern Sie die Methode um die Ausgabe der Zeichenkette \"Hello FIW! : 1 2 3 4 5 6 7 8 9 10 package themen.eclipse ; public class QuickStart { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); } } W\u00e4hlen Sie dann Run --> Run oder klicken Sie auf den gr\u00fcnen runden Button mit dem wei\u00dfen Pfeil in der Werkzeugleiste . Das Programm wird compiliert und ausgef\u00fchrt. Es \u00f6ffnet sich unten das Konsolen -Fenster und dort erscheint Hello FIW! : Fertig. Sie haben Eclipse eingerichtet.","title":"\u00dcbersetzen und Ausf\u00fchren des Programms"},{"location":"ide/#ordnerstruktur","text":"gehen Sie im Finder oder im Datei Explorer in den wiorkspace -Ordner. Darin sehen Sie den Ordner WS21 (das Java-Projekt). In dem WS21 gibt es einen bin - und einen src -Ordner. Im src -Ordner finden Sie den Ordner themen (ein package ) und darin den Ordner eclipse (ebenfalls ein package ). Darin liegt die QuickStart.java . Der bin -Ordner ist genauso aufgebaut, wie der src -Ordner, nur dass darin die *.class -Dateien gespeichert sind und nicht die *.java -Dateien. Die Ordnerstruktur zeigt nochmal, dass Pakete der Strukturierung unserer Dateien dienen.","title":"Ordnerstruktur"},{"location":"iteration/","text":"Iteration \u00b6 Die Iteration ist eine der drei Programmablaufstrukturen , die es gibt. Die Nacheinanderausf\u00fchrung von Anweisungen, die Sequenz ist einfach und wir benutzen es st\u00e4ndig. Die Selektion haben wir uns hier genauer angeschaut. Nun geht es um die letzte Programmstruktur, die wir kennenlernen, die Iteration . Unter einer Iteration verstehen wir die wiederholte Ausf\u00fchrung eines Anweisungsblocks. Die Programmkonstrukte, mit denen wir eine Iteration umsetzen, werden Schleifen genannt. Wir werden drei Schleifen kennenlernen: die for -Schleife und die while -Schleife. die do...while -Schleife Die for -Schleife \u00b6 Die for -Schleife verwenden wir, wenn wir eine oder mehrere Anweisungen abz\u00e4hlbar oft wiederholen wollen, wenn wir also die Anzahl der Ausf\u00fchrungen kennen. Die Idee bei der for -Schleife ist die, dass wir uns eine Laufvariable (typischerweise vom Datentyp int ) deklarieren und initialisieren ( INITIALISIERUNG ), eine Bedingung angeben, f\u00fcr welche Werte der Laufvariablen die Schleife wiederholt werden soll ( BEDINGUNG ) und wie sich der Wert der Laufvariablen nach jedem Schleifendurchlauf \u00e4ndern soll ( \u00c4NDERUNG ). Die allgemeine Syntax f\u00fcr eine solche Vorschleife sieht so aus: for ( INITIALISIERUNG ; BEDINGUNG ; \u00c4NDERUNG ) { /* * Anweisungsblock, der wiederholt * werden soll */ } Wir betrachten ein einfaches Beispiel: 1 2 3 4 for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); } Der Ablauf dieser Schleife sieht wie folgt aus: Zuerst wird die Laufvariable i deklariert und mit dem Wert 0 initialisiert. Das passiert genau ein Mal. Dann wird gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. Das passiert vor jedem Schleifendurchlauf. Wenn der Wert true ist, wird der Schleifenk\u00f6rper, also der Anweisungsblock ausgef\u00fchrt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 0 , also wird eine 0 auf die Konsole ausgegeben. Mehr Anweisungen gibt es nicht im Anweisungsblock, somit sind wir am Ende der Schleife. Nun wird der Wert von i ge\u00e4ndert. Dazu wird i++ ausgef\u00fchrt. Der Wert von i ist nun 1 . Nun wird erneut gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 1 , also wird eine 1 auf die Konsole ausgegeben. Nun wird wieder der Wert von i ge\u00e4ndert. Dazu wird i++ ausgef\u00fchrt. Der Wert von i ist nun 2 . Es wird erneut gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 2 , also wird eine 2 auf die Konsole ausgegeben. i++ \u2192 Wert von i ist 3 i<5 ist true \u2192 Anweisungsblock System.out.println(i); der Wert von i ist 3 \u2192 Ausgabe 3 i++ \u2192 Wert von i ist 4 i<5 ist true \u2192 Anweisungsblock System.out.println(i); der Wert von i ist 4 \u2192 Ausgabe 4 i++ \u2192 Wert von i ist 5 i<5 ist nun false \u2192 Deshalb wird der Anweisungsblock nicht mehr ausgef\u00fchrt! Wir verlassen die Schleife und f\u00fchren die n\u00e4chste Anweisung aus, die nach der Schleife kommt. Oberes Beispiel erzeugt also folgende Ausgabe auf der Konsole: 0 1 2 3 4 In den meisten for -Schleifen wird die Initialisierung wie oben aussehen, also eine Laufvariable (hier i ) wird auf 0 am Anfang gesetzt und die \u00c4nderung des Wertes erfolgt dann durch die Erh\u00f6hung des Wertes um 1 (hier i++ ). Das kann aber auch anders sein, z.B.: 1 2 3 4 for ( int i = 5 ; i > 0 ; i -- ) { System . out . println ( i ); } Hier ist der initiale Wert der Laufvariablen 5 . Die Bedingung pr\u00fcft, ob i gr\u00f6\u00dfer ist als 0 . nach jedem Schleifendurchlauf wird der Wert der Laufvriablen i um 1 reduziert. Es entsteht folgende Ausgabe: 5 4 3 2 1 F\u00fcr die \u00c4nderung des Wertes der Laufvariablen k\u00f6nnen Sie auch jeden der in verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren eingef\u00fchrten Operatoren verenden, z.B. for ( int i = 1 ; i < 10 ; i += 2 ) { System . out . println ( i ); // 1 3 5 7 9 } for ( int i = 1 ; i < 10 ; i *= 2 ) { System . out . println ( i ); // 1 2 4 8 } Deklaration von Variablen in der for -Schleife In dem oberen Beispiel ist die Laufvariable i zwei Mal deklariert, einmal f\u00fcr die erste for -Schleife und ein weiteres Mal f\u00fcr die zweite for -Schleife. Eigentlich hatten wir ja gesagt, dass eine Variable immer nur genau ein Mal deklariert wird. Korrekt ist es, dass eine Variable immer nur in dem Anweisungsblock existiert, in dem sie deklariert wird. Au\u00dferhalb dieses Anweisungsblockes existiert sie nicht. Wir hatten das auch schon bei Methoden erw\u00e4hnt. Dort hatten wir gesagt, dass die Variablen, die in zwei verschiedenen Methoden deklariert werden, miteinander nichts zu tun haben, sondern dass es sich dabei um verschiedene Variablen handelt. Wenn wir eine Variable innerhalb der for -Schleife deklarieren, dann existiert sie f\u00fcr die for -Schleife. Davor und danach existiert die Variable nicht (mehr). Deshalb m\u00fcssen wir i in der zweiten for -Schleife auch erneut deklarieren. Wir kommen darauf nochmal ausf\u00fchrlicher zu sprechen, wenn es um die Lebensdauer und Sichtbarkeit von Variablen geht. Weitere Beispiele f\u00fcr einfache for -Schleifen \u00b6 Wir betrachten noch einige Beispiele f\u00fcr einfache for -Schleifen, um uns mit dem Konzept weiter vertraut zu machen. Summe 1 bis n \u00b6 Ausgabe der Summe von 1 bis n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void computeSumFrom1ToN ( int n ) { int sum = 0 ; String s = \"1\" ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > 1 ) { s += \" + \" + i ; } sum = sum + i ; System . out . println ( s + \" = \" + sum ); } } In der Methode computeSumFrom1ToN(int n) wird die Summe von 1 + 2 + ... + n berechnet, wobei n als Parameterwert der Methode \u00fcbergeben wird. Jeder einzelne Schritt wird ausgegeben. Dazu wird ein String s erzeugt, der initial den Wert \"1\" hat. F\u00fcr jede weitere Addition kommt \" + 2\" , \" + 3\" usw. zu diesem String hinzu. Beachten Sie, dass wir die Variable s au\u00dferhalb der for -Schleife deklariert haben. W\u00e4re sie innerhalb der for -Schleife deklariert, dann w\u00fcrde sie bei jedem Schleifendurchlauf neu erzeugt werden. So wird ihr Wert bei jedem Schleifendurchlauf aktualisiert. Die Selektion wurde eingef\u00fcgt, damit beim ersten Schleifendurchlauf (f\u00fcr i==1 ) nichts an den String s angeh\u00e4ngt wird, sondern nur f\u00fcr alle weiteren Schleifendurchl\u00e4ufe. Beachten Sie auch, dass die Laufvariable i von 1 bis einschlie\u00dflich n l\u00e4uft und wir dadurch die Summe von 1 + 2 + ... + n erzeugen. Wird als Parameterwert eine Zahl kleiner als 1 \u00fcbergeben, erfolgt keine Ausgabe, denn dann ist die Bedingung 1<=n bereits vor dem ersten Schleifendurchlauf false . Ausgabe f\u00fcr den Aufruf computeSumFrom1ToN(10) 1 = 1 1 + 2 = 3 1 + 2 + 3 = 6 1 + 2 + 3 + 4 = 10 1 + 2 + 3 + 4 + 5 = 15 1 + 2 + 3 + 4 + 5 + 6 = 21 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55 Fakult\u00e4t von n \u00b6 Die Fakult\u00e4t von n ist definiert als n! = 1 * 2 * ... * n f\u00fcr alle Nat\u00fcrlichen Zahlen n>=1 . Wir schreiben uns daf\u00fcr eine Methode und \u00fcbergeben ein n : Fakult\u00e4t von n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public void fakultaetVonN ( int n ) { int product = 1 ; String s = \"!\" ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == 2 ) { s += \" = 1 * 2\" ; } else if ( i > 2 ) { s += \" * \" + i ; } product *= i ; System . out . println ( i + s + \" = \" + product ); } } In der Variablen product speichern wir das Produkt aus den Faktoren 1 * 2 * ... * n . beachten Sie, dass product am Anfang den Wert 1 haben muss, um nicht immer mit 0 zu multiplizieren und somit w\u00e4re das Produkt immer 0 . Anstelle von product *= i; h\u00e4tten wir auch product = product * i; schreiben k\u00f6nnen. Weil wir unseren Ausgabestring s noch ein wenig komplizierter gestaltet haben, ist hier sogar eine Fallunterscheidung zwischen i==2 und i>2) notwendig. Ausgabe f\u00fcr den Aufruf fakultaetVonN(8) 1 ! = 1 2 ! = 1 * 2 = 2 3 ! = 1 * 2 * 3 = 6 4 ! = 1 * 2 * 3 * 4 = 24 5 ! = 1 * 2 * 3 * 4 * 5 = 120 6 ! = 1 * 2 * 3 * 4 * 5 * 6 = 720 7 ! = 1 * 2 * 3 * 4 * 5 * 6 * 7 = 5040 8 ! = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 = 40320 Fibonacci-Folge \u00b6 \u00dcbung Fibonacci-Folge Schreiben Sie ein Programm, das die Fibonacci-Folge auf der Konsole ausgibt. Die ersten beiden Werte der Fibonacci-Folge sind 0 und 1 . Die Berechnung der Folgezahlen soll in einer Schleife gemacht werden. Eine Fibonacci-Folge sieht wie folgt aus: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \u2026 . Es gilt: eine Zahl n ist immer die Summe ihrer beiden Vorg\u00e4nger n-1 und n-2 . Verschachtelte for -Schleifen \u00b6 In den bisherigen Beispielen haben wir immer genau eine for -Schleife ben\u00f6tigt, da wir \"nur\" etwas aufaddiert oder aufmultipliziert haben, um eine eindimensionale Folge zu berechnen oder auszugeben. Wir wissen aber bereits, dass in dem Anweisungsblock des Schleifenk\u00f6rpers jede beliebige Kontrollstruktur vorkommen kann, also eine Sequenz und/oder eine Iteration und/oder eine Selektion. Selektion und Sequenz haben wir in unseren Beispielen bereits verwendet. Nun wollen wir auch noch eine Schleife innerhalb der Schleife untersuchen. Rechteck \u00b6 Angenommen, wir sollen ein Rechteck aus lauter * -zeichen auf die Konsole ausgeben und sowohl die Breite des Rechtecks als auch dessen H\u00f6he sind variabel. Am Ende soll also so ein Bild herauskommen: *********************** *********************** *********************** *********************** *********************** In diesem Beispiel ist die Breite 23 und die H\u00f6he 5 . Unsere \u00dcberlegungen sind zun\u00e4chst wie folgt: wir k\u00f6nnen nur zeilenweise ausgeben (spaltenweise geht nicht auf der Konsole) wir ben\u00f6tigen eine Schleife, um die 23 Sterne in einer Zeile auszugeben wir ben\u00f6tigen eine Schleife, um die 5 Zeilen auszugeben D.h. wir \u00fcberlegen uns zun\u00e4chst, wie wir eine Zeile ausgeben. Wir nehmen dazu an, wir haben eine int -Variable width , die uns die Breite des Rechtecks vorgibt (z.B. 23 ): 1 2 3 4 for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } Wir geben also in einer Schleife eine Anzahl width von Sternen aus. Beachten Sie, dass die Laufvariable col (f\u00fcr column) mit 0 initialisert wird. Deshalb ist die Schleifenbedingung col < width . H\u00e4tten wir col <= width geschrieben, w\u00fcrde ein Stern zu viel ausgegeben (au\u00dfer, wir h\u00e4tten col mit 1 initialisiert). Sie m\u00fcssen die Initialisierung und die Bedingung immer gut aufeinander abstimmen! dass wir zur Ausgabe print(\"*\") statt println(\"*\") verwenden, weil sonst nach jedem Stern ein Zeilenumbruch erfolgen w\u00fcrde, die Sterne also nicht nebeneinander sondern untereinander ausgegeben w\u00fcrden. Nun \u00fcberlegen wir uns, wie wir die Zeilen ausgeben. Dazu nehmen wir an, wir haben eine int -Variable height , die uns die H\u00f6he des Rechtecks vorgibt (z.B. 5 ): 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Wir geben also in einer Schleife eine Anzahl height von Zeilen aus. In jeder Zeile soll die Anzahl width von Sternen ausgegeben werden. Wir m\u00fcssen also die Schleife f\u00fcr die Sterne in die Schleife f\u00fcr die Zeilen einsetzen: 1 2 3 4 5 6 7 for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } } Jetzt haben wir nur noch ein kleines Problem. Nachdem wir unsere Zeile mit Sternen ausgegeben haben, steht der Kursor noch hinter dem zuletzt ausgegebenen Stern. Er sollte danach aber an den Anfang der neuen Zeile wandern. Wir m\u00fcssen also noch f\u00fcr einen Zeilenumbruch sorgen. das erledigen wir mit System.out.println(); . Diese Anweisung kommt nach der inneren Schleife in die \u00e4u\u00dfere Schleife. Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 public void printRectangle ( int width , int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } Die Zeilen 3-10 beschreiben die \u00e4u\u00dfere for -Schleife und die Zeilen 5-8 die innere for -Schleife. Wir \"laufen\" einmal durch den Beginn unseres Programms durch. Angenommen, unsere Methode wird mit der Anweisung printRectangle(23,5); aufgerufen, d.h. die Variable width bekommt den Wert 23 und die Variable height den Wert 5 zugewiesen. Die Laufvariable row bekommt initial den Wert 0 . 0 ist kleiner als 5 und somit ist die Bedingung row < height true . Wir betreten also den Anweisungsblock der \u00e4u\u00dferen Schleife. Die erste Anweisung in diesem Anweisungsblock ist die innere for -Schleife. Diese wird nun vollst\u00e4ndig abgearbeitet, d.h. die Laufvariable col nimmt alle Werte von 0 bis 22 an und gibt jedes Mal (also 23 Mal) einen * aus. Wenn der Wert von col auf 23 gesetzt wurde, ist die Bedingung col < width nicht mehr true sondern false und die Abarbeitung der Schleife ist beendet. Es wird Zeile 9 und somit ein Zeilenumbruch ausgef\u00fchrt. Dann wird der Wert von row um 1 erh\u00f6ht ( row++ ) und hat somit den Wert 1 . Die Bedingung row < height ist true und somit wird erneut der Anweisungsblock der \u00e4u\u00dferen Schleife ausgef\u00fchrt. Wieder ist die erste Anweisung in diesem Anweisungsblock die innere for -Schleife. Diese wird nun wieder vollst\u00e4ndig abgearbeitet, d.h. die Laufvariable col nimmt alle Werte von 0 bis 22 an und gibt jedes Mal (also 23 Mal) einen * aus. Wenn der Wert von col auf 23 gesetzt wurde, ist die Bedingung col < width nicht mehr true sondern false und die Abarbeitung der Schleife ist beendet. Es wird Zeile 9 und somit ein Zeilenumbruch ausgef\u00fchrt. Dann wird der Wert von row um 1 erh\u00f6ht ( row++ ) und hat somit den Wert 2 . Die Bedingung row < height ist true und somit wird erneut der Anweisungsblock der \u00e4u\u00dferen Schleife ausgef\u00fchrt. usw. bis der Wert von row 5 ist. Dann wird die \u00e4u\u00dfere for -Schleife verlassen und die Abarbeitung der Methode ist beendet. Wichtig ist, dass die innere Schleife jedes Mal vollst\u00e4ndig abgearbeitet wird, ehe der Zeilenumbruch erfolgt und dann der Wert von row erh\u00f6ht wird. Wir \u00e4ndern die Ausgabe unserer Methode mal ein wenig, um das Prinzip besser zu erkennen: 1 2 3 4 5 6 7 8 9 10 11 12 public void printRectangle ( int width , int height ) { for ( int row = 0 ; row < height ; row ++ ) { System . out . print ( \"(row = \" + row + \"): \" ); for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"[col = \" + col + \"]\" ); } System . out . println (); } } F\u00fcr den Aufruf der Methode printRectangle(10,5); erhalten wir dann folgende Ausgabe: ( row = 0 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 1 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 2 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 3 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 4 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] Durch die Verschachtelung der for -Schleife erzeugen wir somit eine 2-dimensionale Ausgabe. Die innere Schleife entwickelt die horizontale Dimension (eine Zeile mit width Sternen) und die \u00e4u\u00dfere for -Schleife entwickelt entwickelt die vertikale Dimension ( height viele Zeilen). Wir schauen uns noch ein Beispiel an. Nun ist die Bedingung der inneren Schleife vom Wert der Laufvariablen der \u00e4u\u00dferen Schleife abh\u00e4ngig. Dreieck \u00b6 Angenommen, wir wollen ein gleichschenkliges rechteckiges Dreieck erzeugen. Dazu \u00fcbergeben wir die H\u00f6he des Dreiecks als Wert. Angenommen, wir wollen ein Dreieck der H\u00f6he 7 , dann soll folgende Ausgabe erscheinen: * ** *** **** ***** ****** ******* Unsere \u00e4u\u00dfere Schleife wird sicherlich so aussehen, wie unsere \u00e4u\u00dfere Schleife beim Rechteck. Angenommen, unsere H\u00f6he ist in der Variablen height gespeichert, dann m\u00fcssen wir height viele Zeilen ausgeben: 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Daran hat sich also nichts ge\u00e4ndert, aber die innere Schleife sieht sicherlich anders aus, denn wir haben keine width -Variable mehr. Die Anzahl der Sterne in einer Zeile ist nicht konstant, sondern h\u00e4ngt davon ab, in welcher Zeile wir uns befinden: Zeile 1 : row == 0 : 1 Stern ausgeben Zeile 2 : row == 1 : 2 Sterne ausgeben Zeile 3 : row == 2 : 3 Sterne ausgeben Zeile 4 : row == 3 : 4 Sterne ausgeben Zeile 5 : row == 4 : 5 Sterne ausgeben Zeile 6 : row == 5 : 6 Sterne ausgeben Zeile 7 : row == 6 : 7 Sterne ausgeben Das bedeutet, die Bedingung der inneren Schleife muss sich \u00e4ndern. Sie muss abh\u00e4ngig sein vom Wert von row : 1 2 3 4 for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } Wenn row den Wert 0 hat, wird die Schleife 1 Mal durchlaufen, Wert 1 hat, wird die Schleife 2 Mal durchlaufen, Wert 2 hat, wird die Schleife 3 Mal durchlaufen, usw. Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 public void printTriangle ( int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } 2 Schleifen in einer Schleife \u00b6 Wir betrachten noch ein letztes Beispiel. Wir k\u00f6nnten Schleifen nat\u00fcrlich noch weiter verschachteln, also noch eine weitere Schleife in der inneren Schleife implementieren. Das ist m\u00f6glich, wird aber schnell un\u00fcbersichtlich. Prinzipiell ist die Verschachtelungstiefe aber unbegrenzt endlich. Stattdessen wollen wir uns in unserem letzten Beispiel aber einmal \u00fcberlegen, wie wir erneut ein gleichschenkliges rechtwinkliges Dreieck erzeugen k\u00f6nnten. Dieses Mal soll es aber nicht \"linksb\u00fcndig\", sondern \"rechtsb\u00fcndig\" sein, also so: * ** *** **** ***** ****** ******* Der Unterschied zum oberen Beispiel ist der, dass wir nun immer erst eine bestimmte Anzahl an Leerzeichen ausgeben m\u00fcssen, ehe wir den ersten Stern ausgeben. Dazu \u00fcberlegen wir uns wieder die Abh\u00e4ngigkeiten f\u00fcr ein Dreieck der H\u00f6he 7 : Zeile 1 : row == 0 : 6 Leerzeichen ausgeben + 1 Stern ausgeben ( height == 7 ) Zeile 2 : row == 1 : 5 Leerzeichen ausgeben + 2 Sterne ausgeben ( height == 7 ) Zeile 3 : row == 2 : 4 Leerzeichen ausgeben + 3 Sterne ausgeben ( height == 7 ) Zeile 4 : row == 3 : 3 Leerzeichen ausgeben + 4 Sterne ausgeben ( height == 7 ) Zeile 5 : row == 4 : 2 Leerzeichen ausgeben + 5 Sterne ausgeben ( height == 7 ) Zeile 6 : row == 5 : 1 Leerzeichen ausgeben + 6 Sterne ausgeben ( height == 7 ) Zeile 7 : row == 6 : 0 Leerzeichen ausgeben + 7 Sterne ausgeben ( height == 7 ) Die \u00e4u\u00dfere Schleife bleibt wieder so wie vorher: 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Allerdings ist die Ausgabe einer Zeile nun in 2 Aufgaben zerlegt. Zuerst eine bestimmte Anzahl von Leerzeichen ausgeben und dann eine bestimmte Anzahl von Sternen: 1 2 3 4 5 6 for ( int row = 0 ; row < height ; row ++ ) { // zuerst muss eine bestimmte Anzahl von Leerzeichen ausgegeben werden // dann wird eine bestimmte Anzahl von Sternen ausgegeben } F\u00fcr die Anzahl von Sternen haben wir bereits eine L\u00f6sung, die wir verwenden k\u00f6nnen: 1 2 3 4 for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } Diese Schleife k\u00f6nnen wir schonmal in unsere \u00e4u\u00dfere Schleife einsetzen: 1 2 3 4 5 6 7 8 9 for ( int row = 0 ; row < height ; row ++ ) { // zuerst muss eine bestimmte Anzahl von Leerzeichen ausgegeben werden for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } } So wie die Anzahl von Sternen abh\u00e4ngig von der Zeile ist, in der wir die Sterne ausgeben, so ist auch die Anzahl der Leerzeichen davon abh\u00e4ngig. Allerdings beginnen wir mit einem gr\u00f6\u00dferen Wert und werden dann immer kleiner (von 6 bis 0 bei der H\u00f6he height==7 ). Die Anzahl der auszugebenden Leerzeichen ist also einerseits abh\u00e4ngig von der Gesamth\u00f6he ( height ) und andererseits von der aktuellen Zeile row . Wir \u00fcberlegen uns, mit welchem Startwert wir beginnen: am Anfang wollen wir 6 Leerzeichen ausgeben, das sind height-1 viele. Danach ziehen wir von diesem Wert immer so viele ab, wie row gro\u00df ist, also erst -0 , dann -1 , dann -2 usw. Der Startwert ist also height -1 - row . In der letzten Zeile hat row den Wert 6 . Dann w\u00e4re unser Startwert height -1 - 6 == 7 - 1 - 6 == 0 . In der letzten Zeile wollen wir aber gar kein Leerzeichen mehr ausgeben, also muss dort schon unsere Bedingung false sein. Also setzen wir die Bedingung auf >0 . Die Schleife f\u00fcr die Ausgabe der Leerzeichen ist dann wie folgt: 1 2 3 4 for ( int spaces = height - 1 - row ; spaces > 0 ; spaces -- ) { System . out . print ( \" \" ); } F\u00fcr viele ist eine solche Schleife schwer zu lesen, da sich der Wert der Laufvariablen reduziert und die Ermittlung des Initialwertes gleich 2 Subtraktionen enth\u00e4lt. Wir haben ja bereits eingangs gesagt, dass eine solche Schleife auch \u00e4quivalent in anderer Form geschrieben werden kann. Das gleiche Ergebnis erhalten wir mit der folgenden Implementierung: 1 2 3 4 for ( int spaces = 1 ; spaces < height - row ; spaces ++ ) { System . out . print ( \" \" ); } \u00dcbung Schleife, initaile Werte und Bedingungen Warum sind die beiden oberen Schleifen identisch? Warum sind die beiden folgenden Schleifen nur fast identisch? Was ist der Unterschied in den Beispielen? 1 2 3 4 for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); } 1 2 3 4 for ( int i = 5 ; i > 0 ; i -- ) { System . out . println ( i ); } Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void printTriangleR ( int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int spaces = 1 ; spaces < height - row ; spaces ++ ) { System . out . print ( \" \" ); } for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } \u00dcbung linksb\u00fcndiges Dreieck Schreiben Sie die Methode printTriangle(int height) so um, dass bei z.B. printTriangle(7); nicht folgende Ausgabe ensteht: * ** *** **** ***** ****** ******* sondern folgende: * * * * * * * * * * * * * * * * * * * * * * * * * * * * \u00dcbung rechtsb\u00fcndiges Dreieck Schreiben Sie die Methode printTriangleR(int height) so um, dass bei z.B. printTriangleR(7); nicht folgende Ausgabe ensteht: * ** *** **** ***** ****** ******* sondern folgende: * * * * * * * * * * * * * * * * * * * * * * * * * * * * Success Wir haben for -Schleifen kennengelernt und k\u00f6nnen damit nun auch Iterationen implementieren. for -Schleifen verwenden wir, wenn wir einen Anweisungsblock eine bestimmte Anzahl oft wiederholt ausf\u00fchren m\u00f6chten. Wir haben auch for -Schleifen verschachtelt, um variabel in mehrere Dimensionen zu sein. und wir haben mehrere for -Schleifen innerhalb einer for -Schleife verwendet. Nun lernen wir noch zwei weitere Schleifen kennen. Die while -Schleife. \u00b6 W\u00e4hrend die Anzahl der Ausf\u00fchrungen einer for -Schleife von einem numerischen Wert festgelegt wird, ist die Anzahl der Ausf\u00fchrungen einer while -Schleife von einem logischen Ausdruck abh\u00e4ngig. Prinzipiell muss man jedoch sagen, dass es auch v\u00f6llig gen\u00fcgen w\u00fcrde, wenn man nur for -Schleifen oder nur while -Schleifen in einer Programmiersprache zur Verf\u00fcgung h\u00e4tte. Man kann mit beiden Schleifenarten (und sp\u00e4ter auch mit der do..while -Schleife) alle Iterationen implementieren, die programmierbar sind. Schauen wir uns zun\u00e4chst die allgemeine Syntax einer while -Schleife an: while ( BEDINGUNG ) { /* * Anweisungsblock, der wiederholt * werden soll */ } Eine while -Schleife ist also auf den ersten Blick weniger komplex als eine for -Schleife. Da wir aber gesagt haben, dass man mit beiden Schleifenarten die gleichen Programme umsetzen kann, schauen wir uns die ersten Beispiele der for -Schleife mal als while -Schleife an: 1 2 3 4 5 6 int i = 0 ; while ( i < 5 ) { System . out . println ( i ); i ++ ; } Diese while -Schleife macht genau das gleiche, wie unser erstes Beispiel f\u00fcr die for -Schleife. Es wird eine Variable i deklariert und mit 0 initialisiert. Als Bedingung unserer while -Schleife wird gepr\u00fcft, ob der Wert von i kleiner als 5 ist. Wenn ja, wird dieser Wert ausgegeben und der Wert von i um 1 erh\u00f6ht. Nun wird wieder gepr\u00fcft, ob der Wert von i immer noch kleiner als 5 ist. Wenn ja, wird der Wert ausgegeben und um 1 erh\u00f6ht usw. Es scheint zun\u00e4chst, als w\u00e4ren diese beiden Schleifenarten v\u00f6llig redundant. Was bedeutet es nun, dass eine for -Schleife von einer bestimmten Anzahl und eine while -Schleife von einer Bedingung abh\u00e4ngig ist? Sehen wir uns dazu nochmal unsere beiden Beispielalgorithmen vom Anfang an: der Euklidische Algrorithmus und die (3n+1)-Vermutung (Collatz-Problem) Die Beschreibung der Iteration beim Eukidischen Algorithmus war solange a ungleich b ist, wiederhole . Das bedeutet, dass die Bedingung f\u00fcr die Schleifenwiederholung a ungleich b ist. Nach wieviel Wiederholungen (also nach welcher Anzahl ) l\u00e4sst sich nicht sagen. Es l\u00e4sst sich aber leicht die Bedingung formulieren, die gelten soll, damit die Schleife erneut ausgef\u00fchrt wird, n\u00e4mlich (a!=b) . Das gleiche gilt f\u00fcr die (3n+1)-Vermutung. Dort lautet die Beschreibung der Iteration solange n ungleich 1 ist, wiederhole . Nach wieviel Wiederholungen (also nach welcher Anzahl ) l\u00e4sst sich vorher nicht sagen, aber die Bedingung daf\u00fcr, dass die Schleife erneut wiederholt werden soll, l\u00e4sst sich leicht formulieren, n\u00e4mlich (n!=1) . Implementierung des Euklidischen Algorithmus \u00b6 Mithilfe der while -Schleife implementieren wir nun mal beide Allgorithmen. Zuerst den Euklidischen Algorithmus: Berechnung des ggT nach Euklid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void berechneGGT ( int a , int b ) { while ( a != b ) { if ( a > b ) { a = a - b ; } else { b = b - a ; } } System . out . println ( \"ggT: \" + a ); } Die Ausgabe f\u00fcr z.B. berechneGGT(24, 40); ist 8 . Ver\u00e4nderung der Werte von Parametern in Methoden In unserer Methode zur Berechnung des gr\u00f6\u00dften gemeinsamen Teilers nach Euklid haben wir die Werte der Parameter a und b innerhalb unserer Methode ge\u00e4ndert (siehe a = a -b; und b = b - a; ). Das ist kein guter Stil! So haben wir z.B. nicht die M\u00f6glichkeit, am Ende der Methode eine Ausgabe der Form Der ggT von 24 und 40 ist 8. zu erstellen, da wir auf die Werte 24 (von a ) und 40 (von b ) keinen Zugriff mehr haben. Wir sollten uns angew\u00f6hnen, die Parameterwerte in Methoden nicht zu \u00e4ndern, sondern lieber mit Kopien der Werte zu rechnen. Sp\u00e4ter werden wir unsere Parameter als Konstanten definieren, dann ist eine \u00c4nderung gar nicht m\u00f6glich. Das folgende Beispiel zeigt eine bessere L\u00f6sung: Berechnung des ggT nach Euklid (ohne \u00c4nderung der Parameterwerte) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void berechneGGT ( int a , int b ) { int nr1 = a ; int nr2 = b ; while ( nr1 != nr2 ) { if ( nr1 > nr2 ) { nr1 = nr1 - nr2 ; } else { nr2 = nr2 - nr1 ; } } System . out . println ( \"Der ggT von \" + a + \" und \" + b + \" ist \" + nr1 ); } Die Ausgabe f\u00fcr z.B. berechneGGT(24, 40); ist nun Der ggT von 24 und 40 ist 8 . Implementierung der (3n+1)-Vermutung \u00b6 Mithilfe der while -Schleife k\u00f6nnen wir nun auch die (3n+1)-Vermutung (Collatz-Problem) geeignet implementieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void printCollatzFolge ( int n ) { int number = n ; while ( number != 1 ) { System . out . print ( number + \" \" ); if ( number % 2 == 0 ) { number = number / 2 ; } else { number = 3 * number + 1 ; } } System . out . println ( number ); } Auch hier kopieren wir zun\u00e4chst den Wert des Parameters, um diesen nicht zu \u00e4ndern. Mithilfe von number%2 == 0 pr\u00fcfen wir, ob number gerade oder ungerade ist. Ist number gerade, teilen wir den Wert durch 2 , ist number ungerade, multiplizieren wir den Wert mit 3 und addieren 1 , um jeweils den Nachfolger zu ermitteln. Solange dieser Nachfolger ungleich 1 ist, wird der n\u00e4chste Nachfolger berechnet usw. Die Ausf\u00fchrung der Methode mit z.B. printCollatzFolge(17); erzeugt folgende Ausgabe: 17 52 26 13 40 20 10 5 16 8 4 2 1 . Wir beginnen mit 17 . Diese Zahl ist ungerade, also ist der Nachfolger 52 . Diese Zahl und auch der Nachfolger 26 sind gerade. Der n\u00e4chste Nachfolger 13 ist ungerade, dann kommen drei gerade Zahlen 40 , 20 und 10 und erst dann wieder eine ungerade Zahl 5 . 16 ist dann aber schon eine Potenz von 2 und somit endet die Folge mit der 1 . \u00dcbungen while -Schleife Nat\u00fcrlich kann eine while -Schleife genau wie die for -Schleife verschachtelt werden. Implementieren Sie das Rechteck das linksb\u00fcndige Dreieck und das rechtsb\u00fcndige Dreieck mithilfe von verschachtelten while -Schleifen. Die do...while -Schleife \u00b6 Wir haben ja bereits bei den for - und while -Schleifen erw\u00e4hnt, dass eines der beiden Konzepte gen\u00fcgt h\u00e4tte, um alle Iterationen zu implementieren. Da man aber ganz gute Unterscheidungsm\u00f6glichkeiten hat, um sich entweder f\u00fcr die for -Schleife (bestimmte Anzahl) oder f\u00fcr die while -Schleife (bestimmte Bedingung) zu entscheiden, haben beide Schleifenarten ihre Berechtigungsexistenz. F\u00fcr die do ... while f\u00e4llt die Abgrenzung zur while -Schleife noch schwerer. Generell l\u00e4sst sich sagen, dass eine while -Schleife nicht unbedingt ausgef\u00fchrt werden muss (n\u00e4mlich dann, wenn die Bedingung bereits ganz zu Anfang schon false ist), eine do ... while -Schleife wird aber zumindest ein Mal ausgef\u00fchrt, da die Pr\u00fcfung der Bedingung erst nach dem Schleifendurchlauf erfolgt. Die allgemeine Syntax einer do ... while -Schleife ist wie folgt: do { /* * Anweisungsblock, der wiederholt * werden soll */ } while ( BEDINGUNG ); Beachten Sie das Semikolon hinter der Bedingung! Es gibt Beispiele f\u00fcr den sinnvollen Einsatz von do ... while -Schleifen, z.B. wenn innerhalb der Schleife eine Eingabe erfolgt und die Bedingung pr\u00fcft, ob es sich um eine korrekte Eingabe handelt. Wir werden uns aber zun\u00e4chst nicht weiter um diese Schleife k\u00fcmmern, da sie nicht wirklich notwendig ist und wir uns haupts\u00e4chlich mit for - und while -Schleifen besch\u00e4ftigen werden. break und continue \u00b6 break und continue In (fast) allen Java-B\u00fcchern liest man in dem Kapitel \u00fcber Schleifen auch davon, dass es die beiden Anweisungen break; und continue; gibt. Ich will hier gar nicht darauf eigehen, was diese beiden Anweisungen machen, nur so viel: sie springen aus Schleifen heraus. Solche Art von \"Spr\u00fcngen\" ( go to statements ) geh\u00f6ren nicht in moderne, gute Programme. Wir nutzen diese Anweisungen nicht!!! Stattdessen sei in diesem Zusammenhang ein ber\u00fchmtes Papier von Edsger W. Dijkstra empfohlen: Go To Statement Considered Harmful . Siehe dazu auch hier .","title":"Iteration"},{"location":"iteration/#iteration","text":"Die Iteration ist eine der drei Programmablaufstrukturen , die es gibt. Die Nacheinanderausf\u00fchrung von Anweisungen, die Sequenz ist einfach und wir benutzen es st\u00e4ndig. Die Selektion haben wir uns hier genauer angeschaut. Nun geht es um die letzte Programmstruktur, die wir kennenlernen, die Iteration . Unter einer Iteration verstehen wir die wiederholte Ausf\u00fchrung eines Anweisungsblocks. Die Programmkonstrukte, mit denen wir eine Iteration umsetzen, werden Schleifen genannt. Wir werden drei Schleifen kennenlernen: die for -Schleife und die while -Schleife. die do...while -Schleife","title":"Iteration"},{"location":"iteration/#die-for-schleife","text":"Die for -Schleife verwenden wir, wenn wir eine oder mehrere Anweisungen abz\u00e4hlbar oft wiederholen wollen, wenn wir also die Anzahl der Ausf\u00fchrungen kennen. Die Idee bei der for -Schleife ist die, dass wir uns eine Laufvariable (typischerweise vom Datentyp int ) deklarieren und initialisieren ( INITIALISIERUNG ), eine Bedingung angeben, f\u00fcr welche Werte der Laufvariablen die Schleife wiederholt werden soll ( BEDINGUNG ) und wie sich der Wert der Laufvariablen nach jedem Schleifendurchlauf \u00e4ndern soll ( \u00c4NDERUNG ). Die allgemeine Syntax f\u00fcr eine solche Vorschleife sieht so aus: for ( INITIALISIERUNG ; BEDINGUNG ; \u00c4NDERUNG ) { /* * Anweisungsblock, der wiederholt * werden soll */ } Wir betrachten ein einfaches Beispiel: 1 2 3 4 for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); } Der Ablauf dieser Schleife sieht wie folgt aus: Zuerst wird die Laufvariable i deklariert und mit dem Wert 0 initialisiert. Das passiert genau ein Mal. Dann wird gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. Das passiert vor jedem Schleifendurchlauf. Wenn der Wert true ist, wird der Schleifenk\u00f6rper, also der Anweisungsblock ausgef\u00fchrt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 0 , also wird eine 0 auf die Konsole ausgegeben. Mehr Anweisungen gibt es nicht im Anweisungsblock, somit sind wir am Ende der Schleife. Nun wird der Wert von i ge\u00e4ndert. Dazu wird i++ ausgef\u00fchrt. Der Wert von i ist nun 1 . Nun wird erneut gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 1 , also wird eine 1 auf die Konsole ausgegeben. Nun wird wieder der Wert von i ge\u00e4ndert. Dazu wird i++ ausgef\u00fchrt. Der Wert von i ist nun 2 . Es wird erneut gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 2 , also wird eine 2 auf die Konsole ausgegeben. i++ \u2192 Wert von i ist 3 i<5 ist true \u2192 Anweisungsblock System.out.println(i); der Wert von i ist 3 \u2192 Ausgabe 3 i++ \u2192 Wert von i ist 4 i<5 ist true \u2192 Anweisungsblock System.out.println(i); der Wert von i ist 4 \u2192 Ausgabe 4 i++ \u2192 Wert von i ist 5 i<5 ist nun false \u2192 Deshalb wird der Anweisungsblock nicht mehr ausgef\u00fchrt! Wir verlassen die Schleife und f\u00fchren die n\u00e4chste Anweisung aus, die nach der Schleife kommt. Oberes Beispiel erzeugt also folgende Ausgabe auf der Konsole: 0 1 2 3 4 In den meisten for -Schleifen wird die Initialisierung wie oben aussehen, also eine Laufvariable (hier i ) wird auf 0 am Anfang gesetzt und die \u00c4nderung des Wertes erfolgt dann durch die Erh\u00f6hung des Wertes um 1 (hier i++ ). Das kann aber auch anders sein, z.B.: 1 2 3 4 for ( int i = 5 ; i > 0 ; i -- ) { System . out . println ( i ); } Hier ist der initiale Wert der Laufvariablen 5 . Die Bedingung pr\u00fcft, ob i gr\u00f6\u00dfer ist als 0 . nach jedem Schleifendurchlauf wird der Wert der Laufvriablen i um 1 reduziert. Es entsteht folgende Ausgabe: 5 4 3 2 1 F\u00fcr die \u00c4nderung des Wertes der Laufvariablen k\u00f6nnen Sie auch jeden der in verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren eingef\u00fchrten Operatoren verenden, z.B. for ( int i = 1 ; i < 10 ; i += 2 ) { System . out . println ( i ); // 1 3 5 7 9 } for ( int i = 1 ; i < 10 ; i *= 2 ) { System . out . println ( i ); // 1 2 4 8 } Deklaration von Variablen in der for -Schleife In dem oberen Beispiel ist die Laufvariable i zwei Mal deklariert, einmal f\u00fcr die erste for -Schleife und ein weiteres Mal f\u00fcr die zweite for -Schleife. Eigentlich hatten wir ja gesagt, dass eine Variable immer nur genau ein Mal deklariert wird. Korrekt ist es, dass eine Variable immer nur in dem Anweisungsblock existiert, in dem sie deklariert wird. Au\u00dferhalb dieses Anweisungsblockes existiert sie nicht. Wir hatten das auch schon bei Methoden erw\u00e4hnt. Dort hatten wir gesagt, dass die Variablen, die in zwei verschiedenen Methoden deklariert werden, miteinander nichts zu tun haben, sondern dass es sich dabei um verschiedene Variablen handelt. Wenn wir eine Variable innerhalb der for -Schleife deklarieren, dann existiert sie f\u00fcr die for -Schleife. Davor und danach existiert die Variable nicht (mehr). Deshalb m\u00fcssen wir i in der zweiten for -Schleife auch erneut deklarieren. Wir kommen darauf nochmal ausf\u00fchrlicher zu sprechen, wenn es um die Lebensdauer und Sichtbarkeit von Variablen geht.","title":"Die for-Schleife"},{"location":"iteration/#weitere-beispiele-fur-einfache-for-schleifen","text":"Wir betrachten noch einige Beispiele f\u00fcr einfache for -Schleifen, um uns mit dem Konzept weiter vertraut zu machen.","title":"Weitere Beispiele f\u00fcr einfache for-Schleifen"},{"location":"iteration/#summe-1-bis-n","text":"Ausgabe der Summe von 1 bis n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void computeSumFrom1ToN ( int n ) { int sum = 0 ; String s = \"1\" ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > 1 ) { s += \" + \" + i ; } sum = sum + i ; System . out . println ( s + \" = \" + sum ); } } In der Methode computeSumFrom1ToN(int n) wird die Summe von 1 + 2 + ... + n berechnet, wobei n als Parameterwert der Methode \u00fcbergeben wird. Jeder einzelne Schritt wird ausgegeben. Dazu wird ein String s erzeugt, der initial den Wert \"1\" hat. F\u00fcr jede weitere Addition kommt \" + 2\" , \" + 3\" usw. zu diesem String hinzu. Beachten Sie, dass wir die Variable s au\u00dferhalb der for -Schleife deklariert haben. W\u00e4re sie innerhalb der for -Schleife deklariert, dann w\u00fcrde sie bei jedem Schleifendurchlauf neu erzeugt werden. So wird ihr Wert bei jedem Schleifendurchlauf aktualisiert. Die Selektion wurde eingef\u00fcgt, damit beim ersten Schleifendurchlauf (f\u00fcr i==1 ) nichts an den String s angeh\u00e4ngt wird, sondern nur f\u00fcr alle weiteren Schleifendurchl\u00e4ufe. Beachten Sie auch, dass die Laufvariable i von 1 bis einschlie\u00dflich n l\u00e4uft und wir dadurch die Summe von 1 + 2 + ... + n erzeugen. Wird als Parameterwert eine Zahl kleiner als 1 \u00fcbergeben, erfolgt keine Ausgabe, denn dann ist die Bedingung 1<=n bereits vor dem ersten Schleifendurchlauf false . Ausgabe f\u00fcr den Aufruf computeSumFrom1ToN(10) 1 = 1 1 + 2 = 3 1 + 2 + 3 = 6 1 + 2 + 3 + 4 = 10 1 + 2 + 3 + 4 + 5 = 15 1 + 2 + 3 + 4 + 5 + 6 = 21 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","title":"Summe 1 bis n"},{"location":"iteration/#fakultat-von-n","text":"Die Fakult\u00e4t von n ist definiert als n! = 1 * 2 * ... * n f\u00fcr alle Nat\u00fcrlichen Zahlen n>=1 . Wir schreiben uns daf\u00fcr eine Methode und \u00fcbergeben ein n : Fakult\u00e4t von n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public void fakultaetVonN ( int n ) { int product = 1 ; String s = \"!\" ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == 2 ) { s += \" = 1 * 2\" ; } else if ( i > 2 ) { s += \" * \" + i ; } product *= i ; System . out . println ( i + s + \" = \" + product ); } } In der Variablen product speichern wir das Produkt aus den Faktoren 1 * 2 * ... * n . beachten Sie, dass product am Anfang den Wert 1 haben muss, um nicht immer mit 0 zu multiplizieren und somit w\u00e4re das Produkt immer 0 . Anstelle von product *= i; h\u00e4tten wir auch product = product * i; schreiben k\u00f6nnen. Weil wir unseren Ausgabestring s noch ein wenig komplizierter gestaltet haben, ist hier sogar eine Fallunterscheidung zwischen i==2 und i>2) notwendig. Ausgabe f\u00fcr den Aufruf fakultaetVonN(8) 1 ! = 1 2 ! = 1 * 2 = 2 3 ! = 1 * 2 * 3 = 6 4 ! = 1 * 2 * 3 * 4 = 24 5 ! = 1 * 2 * 3 * 4 * 5 = 120 6 ! = 1 * 2 * 3 * 4 * 5 * 6 = 720 7 ! = 1 * 2 * 3 * 4 * 5 * 6 * 7 = 5040 8 ! = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 = 40320","title":"Fakult\u00e4t von n"},{"location":"iteration/#fibonacci-folge","text":"\u00dcbung Fibonacci-Folge Schreiben Sie ein Programm, das die Fibonacci-Folge auf der Konsole ausgibt. Die ersten beiden Werte der Fibonacci-Folge sind 0 und 1 . Die Berechnung der Folgezahlen soll in einer Schleife gemacht werden. Eine Fibonacci-Folge sieht wie folgt aus: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \u2026 . Es gilt: eine Zahl n ist immer die Summe ihrer beiden Vorg\u00e4nger n-1 und n-2 .","title":"Fibonacci-Folge"},{"location":"iteration/#verschachtelte-for-schleifen","text":"In den bisherigen Beispielen haben wir immer genau eine for -Schleife ben\u00f6tigt, da wir \"nur\" etwas aufaddiert oder aufmultipliziert haben, um eine eindimensionale Folge zu berechnen oder auszugeben. Wir wissen aber bereits, dass in dem Anweisungsblock des Schleifenk\u00f6rpers jede beliebige Kontrollstruktur vorkommen kann, also eine Sequenz und/oder eine Iteration und/oder eine Selektion. Selektion und Sequenz haben wir in unseren Beispielen bereits verwendet. Nun wollen wir auch noch eine Schleife innerhalb der Schleife untersuchen.","title":"Verschachtelte for-Schleifen"},{"location":"iteration/#rechteck","text":"Angenommen, wir sollen ein Rechteck aus lauter * -zeichen auf die Konsole ausgeben und sowohl die Breite des Rechtecks als auch dessen H\u00f6he sind variabel. Am Ende soll also so ein Bild herauskommen: *********************** *********************** *********************** *********************** *********************** In diesem Beispiel ist die Breite 23 und die H\u00f6he 5 . Unsere \u00dcberlegungen sind zun\u00e4chst wie folgt: wir k\u00f6nnen nur zeilenweise ausgeben (spaltenweise geht nicht auf der Konsole) wir ben\u00f6tigen eine Schleife, um die 23 Sterne in einer Zeile auszugeben wir ben\u00f6tigen eine Schleife, um die 5 Zeilen auszugeben D.h. wir \u00fcberlegen uns zun\u00e4chst, wie wir eine Zeile ausgeben. Wir nehmen dazu an, wir haben eine int -Variable width , die uns die Breite des Rechtecks vorgibt (z.B. 23 ): 1 2 3 4 for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } Wir geben also in einer Schleife eine Anzahl width von Sternen aus. Beachten Sie, dass die Laufvariable col (f\u00fcr column) mit 0 initialisert wird. Deshalb ist die Schleifenbedingung col < width . H\u00e4tten wir col <= width geschrieben, w\u00fcrde ein Stern zu viel ausgegeben (au\u00dfer, wir h\u00e4tten col mit 1 initialisiert). Sie m\u00fcssen die Initialisierung und die Bedingung immer gut aufeinander abstimmen! dass wir zur Ausgabe print(\"*\") statt println(\"*\") verwenden, weil sonst nach jedem Stern ein Zeilenumbruch erfolgen w\u00fcrde, die Sterne also nicht nebeneinander sondern untereinander ausgegeben w\u00fcrden. Nun \u00fcberlegen wir uns, wie wir die Zeilen ausgeben. Dazu nehmen wir an, wir haben eine int -Variable height , die uns die H\u00f6he des Rechtecks vorgibt (z.B. 5 ): 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Wir geben also in einer Schleife eine Anzahl height von Zeilen aus. In jeder Zeile soll die Anzahl width von Sternen ausgegeben werden. Wir m\u00fcssen also die Schleife f\u00fcr die Sterne in die Schleife f\u00fcr die Zeilen einsetzen: 1 2 3 4 5 6 7 for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } } Jetzt haben wir nur noch ein kleines Problem. Nachdem wir unsere Zeile mit Sternen ausgegeben haben, steht der Kursor noch hinter dem zuletzt ausgegebenen Stern. Er sollte danach aber an den Anfang der neuen Zeile wandern. Wir m\u00fcssen also noch f\u00fcr einen Zeilenumbruch sorgen. das erledigen wir mit System.out.println(); . Diese Anweisung kommt nach der inneren Schleife in die \u00e4u\u00dfere Schleife. Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 public void printRectangle ( int width , int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } Die Zeilen 3-10 beschreiben die \u00e4u\u00dfere for -Schleife und die Zeilen 5-8 die innere for -Schleife. Wir \"laufen\" einmal durch den Beginn unseres Programms durch. Angenommen, unsere Methode wird mit der Anweisung printRectangle(23,5); aufgerufen, d.h. die Variable width bekommt den Wert 23 und die Variable height den Wert 5 zugewiesen. Die Laufvariable row bekommt initial den Wert 0 . 0 ist kleiner als 5 und somit ist die Bedingung row < height true . Wir betreten also den Anweisungsblock der \u00e4u\u00dferen Schleife. Die erste Anweisung in diesem Anweisungsblock ist die innere for -Schleife. Diese wird nun vollst\u00e4ndig abgearbeitet, d.h. die Laufvariable col nimmt alle Werte von 0 bis 22 an und gibt jedes Mal (also 23 Mal) einen * aus. Wenn der Wert von col auf 23 gesetzt wurde, ist die Bedingung col < width nicht mehr true sondern false und die Abarbeitung der Schleife ist beendet. Es wird Zeile 9 und somit ein Zeilenumbruch ausgef\u00fchrt. Dann wird der Wert von row um 1 erh\u00f6ht ( row++ ) und hat somit den Wert 1 . Die Bedingung row < height ist true und somit wird erneut der Anweisungsblock der \u00e4u\u00dferen Schleife ausgef\u00fchrt. Wieder ist die erste Anweisung in diesem Anweisungsblock die innere for -Schleife. Diese wird nun wieder vollst\u00e4ndig abgearbeitet, d.h. die Laufvariable col nimmt alle Werte von 0 bis 22 an und gibt jedes Mal (also 23 Mal) einen * aus. Wenn der Wert von col auf 23 gesetzt wurde, ist die Bedingung col < width nicht mehr true sondern false und die Abarbeitung der Schleife ist beendet. Es wird Zeile 9 und somit ein Zeilenumbruch ausgef\u00fchrt. Dann wird der Wert von row um 1 erh\u00f6ht ( row++ ) und hat somit den Wert 2 . Die Bedingung row < height ist true und somit wird erneut der Anweisungsblock der \u00e4u\u00dferen Schleife ausgef\u00fchrt. usw. bis der Wert von row 5 ist. Dann wird die \u00e4u\u00dfere for -Schleife verlassen und die Abarbeitung der Methode ist beendet. Wichtig ist, dass die innere Schleife jedes Mal vollst\u00e4ndig abgearbeitet wird, ehe der Zeilenumbruch erfolgt und dann der Wert von row erh\u00f6ht wird. Wir \u00e4ndern die Ausgabe unserer Methode mal ein wenig, um das Prinzip besser zu erkennen: 1 2 3 4 5 6 7 8 9 10 11 12 public void printRectangle ( int width , int height ) { for ( int row = 0 ; row < height ; row ++ ) { System . out . print ( \"(row = \" + row + \"): \" ); for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"[col = \" + col + \"]\" ); } System . out . println (); } } F\u00fcr den Aufruf der Methode printRectangle(10,5); erhalten wir dann folgende Ausgabe: ( row = 0 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 1 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 2 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 3 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 4 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] Durch die Verschachtelung der for -Schleife erzeugen wir somit eine 2-dimensionale Ausgabe. Die innere Schleife entwickelt die horizontale Dimension (eine Zeile mit width Sternen) und die \u00e4u\u00dfere for -Schleife entwickelt entwickelt die vertikale Dimension ( height viele Zeilen). Wir schauen uns noch ein Beispiel an. Nun ist die Bedingung der inneren Schleife vom Wert der Laufvariablen der \u00e4u\u00dferen Schleife abh\u00e4ngig.","title":"Rechteck"},{"location":"iteration/#dreieck","text":"Angenommen, wir wollen ein gleichschenkliges rechteckiges Dreieck erzeugen. Dazu \u00fcbergeben wir die H\u00f6he des Dreiecks als Wert. Angenommen, wir wollen ein Dreieck der H\u00f6he 7 , dann soll folgende Ausgabe erscheinen: * ** *** **** ***** ****** ******* Unsere \u00e4u\u00dfere Schleife wird sicherlich so aussehen, wie unsere \u00e4u\u00dfere Schleife beim Rechteck. Angenommen, unsere H\u00f6he ist in der Variablen height gespeichert, dann m\u00fcssen wir height viele Zeilen ausgeben: 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Daran hat sich also nichts ge\u00e4ndert, aber die innere Schleife sieht sicherlich anders aus, denn wir haben keine width -Variable mehr. Die Anzahl der Sterne in einer Zeile ist nicht konstant, sondern h\u00e4ngt davon ab, in welcher Zeile wir uns befinden: Zeile 1 : row == 0 : 1 Stern ausgeben Zeile 2 : row == 1 : 2 Sterne ausgeben Zeile 3 : row == 2 : 3 Sterne ausgeben Zeile 4 : row == 3 : 4 Sterne ausgeben Zeile 5 : row == 4 : 5 Sterne ausgeben Zeile 6 : row == 5 : 6 Sterne ausgeben Zeile 7 : row == 6 : 7 Sterne ausgeben Das bedeutet, die Bedingung der inneren Schleife muss sich \u00e4ndern. Sie muss abh\u00e4ngig sein vom Wert von row : 1 2 3 4 for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } Wenn row den Wert 0 hat, wird die Schleife 1 Mal durchlaufen, Wert 1 hat, wird die Schleife 2 Mal durchlaufen, Wert 2 hat, wird die Schleife 3 Mal durchlaufen, usw. Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 public void printTriangle ( int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } }","title":"Dreieck"},{"location":"iteration/#2-schleifen-in-einer-schleife","text":"Wir betrachten noch ein letztes Beispiel. Wir k\u00f6nnten Schleifen nat\u00fcrlich noch weiter verschachteln, also noch eine weitere Schleife in der inneren Schleife implementieren. Das ist m\u00f6glich, wird aber schnell un\u00fcbersichtlich. Prinzipiell ist die Verschachtelungstiefe aber unbegrenzt endlich. Stattdessen wollen wir uns in unserem letzten Beispiel aber einmal \u00fcberlegen, wie wir erneut ein gleichschenkliges rechtwinkliges Dreieck erzeugen k\u00f6nnten. Dieses Mal soll es aber nicht \"linksb\u00fcndig\", sondern \"rechtsb\u00fcndig\" sein, also so: * ** *** **** ***** ****** ******* Der Unterschied zum oberen Beispiel ist der, dass wir nun immer erst eine bestimmte Anzahl an Leerzeichen ausgeben m\u00fcssen, ehe wir den ersten Stern ausgeben. Dazu \u00fcberlegen wir uns wieder die Abh\u00e4ngigkeiten f\u00fcr ein Dreieck der H\u00f6he 7 : Zeile 1 : row == 0 : 6 Leerzeichen ausgeben + 1 Stern ausgeben ( height == 7 ) Zeile 2 : row == 1 : 5 Leerzeichen ausgeben + 2 Sterne ausgeben ( height == 7 ) Zeile 3 : row == 2 : 4 Leerzeichen ausgeben + 3 Sterne ausgeben ( height == 7 ) Zeile 4 : row == 3 : 3 Leerzeichen ausgeben + 4 Sterne ausgeben ( height == 7 ) Zeile 5 : row == 4 : 2 Leerzeichen ausgeben + 5 Sterne ausgeben ( height == 7 ) Zeile 6 : row == 5 : 1 Leerzeichen ausgeben + 6 Sterne ausgeben ( height == 7 ) Zeile 7 : row == 6 : 0 Leerzeichen ausgeben + 7 Sterne ausgeben ( height == 7 ) Die \u00e4u\u00dfere Schleife bleibt wieder so wie vorher: 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Allerdings ist die Ausgabe einer Zeile nun in 2 Aufgaben zerlegt. Zuerst eine bestimmte Anzahl von Leerzeichen ausgeben und dann eine bestimmte Anzahl von Sternen: 1 2 3 4 5 6 for ( int row = 0 ; row < height ; row ++ ) { // zuerst muss eine bestimmte Anzahl von Leerzeichen ausgegeben werden // dann wird eine bestimmte Anzahl von Sternen ausgegeben } F\u00fcr die Anzahl von Sternen haben wir bereits eine L\u00f6sung, die wir verwenden k\u00f6nnen: 1 2 3 4 for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } Diese Schleife k\u00f6nnen wir schonmal in unsere \u00e4u\u00dfere Schleife einsetzen: 1 2 3 4 5 6 7 8 9 for ( int row = 0 ; row < height ; row ++ ) { // zuerst muss eine bestimmte Anzahl von Leerzeichen ausgegeben werden for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } } So wie die Anzahl von Sternen abh\u00e4ngig von der Zeile ist, in der wir die Sterne ausgeben, so ist auch die Anzahl der Leerzeichen davon abh\u00e4ngig. Allerdings beginnen wir mit einem gr\u00f6\u00dferen Wert und werden dann immer kleiner (von 6 bis 0 bei der H\u00f6he height==7 ). Die Anzahl der auszugebenden Leerzeichen ist also einerseits abh\u00e4ngig von der Gesamth\u00f6he ( height ) und andererseits von der aktuellen Zeile row . Wir \u00fcberlegen uns, mit welchem Startwert wir beginnen: am Anfang wollen wir 6 Leerzeichen ausgeben, das sind height-1 viele. Danach ziehen wir von diesem Wert immer so viele ab, wie row gro\u00df ist, also erst -0 , dann -1 , dann -2 usw. Der Startwert ist also height -1 - row . In der letzten Zeile hat row den Wert 6 . Dann w\u00e4re unser Startwert height -1 - 6 == 7 - 1 - 6 == 0 . In der letzten Zeile wollen wir aber gar kein Leerzeichen mehr ausgeben, also muss dort schon unsere Bedingung false sein. Also setzen wir die Bedingung auf >0 . Die Schleife f\u00fcr die Ausgabe der Leerzeichen ist dann wie folgt: 1 2 3 4 for ( int spaces = height - 1 - row ; spaces > 0 ; spaces -- ) { System . out . print ( \" \" ); } F\u00fcr viele ist eine solche Schleife schwer zu lesen, da sich der Wert der Laufvariablen reduziert und die Ermittlung des Initialwertes gleich 2 Subtraktionen enth\u00e4lt. Wir haben ja bereits eingangs gesagt, dass eine solche Schleife auch \u00e4quivalent in anderer Form geschrieben werden kann. Das gleiche Ergebnis erhalten wir mit der folgenden Implementierung: 1 2 3 4 for ( int spaces = 1 ; spaces < height - row ; spaces ++ ) { System . out . print ( \" \" ); } \u00dcbung Schleife, initaile Werte und Bedingungen Warum sind die beiden oberen Schleifen identisch? Warum sind die beiden folgenden Schleifen nur fast identisch? Was ist der Unterschied in den Beispielen? 1 2 3 4 for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); } 1 2 3 4 for ( int i = 5 ; i > 0 ; i -- ) { System . out . println ( i ); } Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void printTriangleR ( int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int spaces = 1 ; spaces < height - row ; spaces ++ ) { System . out . print ( \" \" ); } for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } \u00dcbung linksb\u00fcndiges Dreieck Schreiben Sie die Methode printTriangle(int height) so um, dass bei z.B. printTriangle(7); nicht folgende Ausgabe ensteht: * ** *** **** ***** ****** ******* sondern folgende: * * * * * * * * * * * * * * * * * * * * * * * * * * * * \u00dcbung rechtsb\u00fcndiges Dreieck Schreiben Sie die Methode printTriangleR(int height) so um, dass bei z.B. printTriangleR(7); nicht folgende Ausgabe ensteht: * ** *** **** ***** ****** ******* sondern folgende: * * * * * * * * * * * * * * * * * * * * * * * * * * * * Success Wir haben for -Schleifen kennengelernt und k\u00f6nnen damit nun auch Iterationen implementieren. for -Schleifen verwenden wir, wenn wir einen Anweisungsblock eine bestimmte Anzahl oft wiederholt ausf\u00fchren m\u00f6chten. Wir haben auch for -Schleifen verschachtelt, um variabel in mehrere Dimensionen zu sein. und wir haben mehrere for -Schleifen innerhalb einer for -Schleife verwendet. Nun lernen wir noch zwei weitere Schleifen kennen.","title":"2 Schleifen in einer Schleife"},{"location":"iteration/#die-while-schleife","text":"W\u00e4hrend die Anzahl der Ausf\u00fchrungen einer for -Schleife von einem numerischen Wert festgelegt wird, ist die Anzahl der Ausf\u00fchrungen einer while -Schleife von einem logischen Ausdruck abh\u00e4ngig. Prinzipiell muss man jedoch sagen, dass es auch v\u00f6llig gen\u00fcgen w\u00fcrde, wenn man nur for -Schleifen oder nur while -Schleifen in einer Programmiersprache zur Verf\u00fcgung h\u00e4tte. Man kann mit beiden Schleifenarten (und sp\u00e4ter auch mit der do..while -Schleife) alle Iterationen implementieren, die programmierbar sind. Schauen wir uns zun\u00e4chst die allgemeine Syntax einer while -Schleife an: while ( BEDINGUNG ) { /* * Anweisungsblock, der wiederholt * werden soll */ } Eine while -Schleife ist also auf den ersten Blick weniger komplex als eine for -Schleife. Da wir aber gesagt haben, dass man mit beiden Schleifenarten die gleichen Programme umsetzen kann, schauen wir uns die ersten Beispiele der for -Schleife mal als while -Schleife an: 1 2 3 4 5 6 int i = 0 ; while ( i < 5 ) { System . out . println ( i ); i ++ ; } Diese while -Schleife macht genau das gleiche, wie unser erstes Beispiel f\u00fcr die for -Schleife. Es wird eine Variable i deklariert und mit 0 initialisiert. Als Bedingung unserer while -Schleife wird gepr\u00fcft, ob der Wert von i kleiner als 5 ist. Wenn ja, wird dieser Wert ausgegeben und der Wert von i um 1 erh\u00f6ht. Nun wird wieder gepr\u00fcft, ob der Wert von i immer noch kleiner als 5 ist. Wenn ja, wird der Wert ausgegeben und um 1 erh\u00f6ht usw. Es scheint zun\u00e4chst, als w\u00e4ren diese beiden Schleifenarten v\u00f6llig redundant. Was bedeutet es nun, dass eine for -Schleife von einer bestimmten Anzahl und eine while -Schleife von einer Bedingung abh\u00e4ngig ist? Sehen wir uns dazu nochmal unsere beiden Beispielalgorithmen vom Anfang an: der Euklidische Algrorithmus und die (3n+1)-Vermutung (Collatz-Problem) Die Beschreibung der Iteration beim Eukidischen Algorithmus war solange a ungleich b ist, wiederhole . Das bedeutet, dass die Bedingung f\u00fcr die Schleifenwiederholung a ungleich b ist. Nach wieviel Wiederholungen (also nach welcher Anzahl ) l\u00e4sst sich nicht sagen. Es l\u00e4sst sich aber leicht die Bedingung formulieren, die gelten soll, damit die Schleife erneut ausgef\u00fchrt wird, n\u00e4mlich (a!=b) . Das gleiche gilt f\u00fcr die (3n+1)-Vermutung. Dort lautet die Beschreibung der Iteration solange n ungleich 1 ist, wiederhole . Nach wieviel Wiederholungen (also nach welcher Anzahl ) l\u00e4sst sich vorher nicht sagen, aber die Bedingung daf\u00fcr, dass die Schleife erneut wiederholt werden soll, l\u00e4sst sich leicht formulieren, n\u00e4mlich (n!=1) .","title":"Die while-Schleife."},{"location":"iteration/#implementierung-des-euklidischen-algorithmus","text":"Mithilfe der while -Schleife implementieren wir nun mal beide Allgorithmen. Zuerst den Euklidischen Algorithmus: Berechnung des ggT nach Euklid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void berechneGGT ( int a , int b ) { while ( a != b ) { if ( a > b ) { a = a - b ; } else { b = b - a ; } } System . out . println ( \"ggT: \" + a ); } Die Ausgabe f\u00fcr z.B. berechneGGT(24, 40); ist 8 . Ver\u00e4nderung der Werte von Parametern in Methoden In unserer Methode zur Berechnung des gr\u00f6\u00dften gemeinsamen Teilers nach Euklid haben wir die Werte der Parameter a und b innerhalb unserer Methode ge\u00e4ndert (siehe a = a -b; und b = b - a; ). Das ist kein guter Stil! So haben wir z.B. nicht die M\u00f6glichkeit, am Ende der Methode eine Ausgabe der Form Der ggT von 24 und 40 ist 8. zu erstellen, da wir auf die Werte 24 (von a ) und 40 (von b ) keinen Zugriff mehr haben. Wir sollten uns angew\u00f6hnen, die Parameterwerte in Methoden nicht zu \u00e4ndern, sondern lieber mit Kopien der Werte zu rechnen. Sp\u00e4ter werden wir unsere Parameter als Konstanten definieren, dann ist eine \u00c4nderung gar nicht m\u00f6glich. Das folgende Beispiel zeigt eine bessere L\u00f6sung: Berechnung des ggT nach Euklid (ohne \u00c4nderung der Parameterwerte) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void berechneGGT ( int a , int b ) { int nr1 = a ; int nr2 = b ; while ( nr1 != nr2 ) { if ( nr1 > nr2 ) { nr1 = nr1 - nr2 ; } else { nr2 = nr2 - nr1 ; } } System . out . println ( \"Der ggT von \" + a + \" und \" + b + \" ist \" + nr1 ); } Die Ausgabe f\u00fcr z.B. berechneGGT(24, 40); ist nun Der ggT von 24 und 40 ist 8 .","title":"Implementierung des Euklidischen Algorithmus"},{"location":"iteration/#implementierung-der-3n1-vermutung","text":"Mithilfe der while -Schleife k\u00f6nnen wir nun auch die (3n+1)-Vermutung (Collatz-Problem) geeignet implementieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void printCollatzFolge ( int n ) { int number = n ; while ( number != 1 ) { System . out . print ( number + \" \" ); if ( number % 2 == 0 ) { number = number / 2 ; } else { number = 3 * number + 1 ; } } System . out . println ( number ); } Auch hier kopieren wir zun\u00e4chst den Wert des Parameters, um diesen nicht zu \u00e4ndern. Mithilfe von number%2 == 0 pr\u00fcfen wir, ob number gerade oder ungerade ist. Ist number gerade, teilen wir den Wert durch 2 , ist number ungerade, multiplizieren wir den Wert mit 3 und addieren 1 , um jeweils den Nachfolger zu ermitteln. Solange dieser Nachfolger ungleich 1 ist, wird der n\u00e4chste Nachfolger berechnet usw. Die Ausf\u00fchrung der Methode mit z.B. printCollatzFolge(17); erzeugt folgende Ausgabe: 17 52 26 13 40 20 10 5 16 8 4 2 1 . Wir beginnen mit 17 . Diese Zahl ist ungerade, also ist der Nachfolger 52 . Diese Zahl und auch der Nachfolger 26 sind gerade. Der n\u00e4chste Nachfolger 13 ist ungerade, dann kommen drei gerade Zahlen 40 , 20 und 10 und erst dann wieder eine ungerade Zahl 5 . 16 ist dann aber schon eine Potenz von 2 und somit endet die Folge mit der 1 . \u00dcbungen while -Schleife Nat\u00fcrlich kann eine while -Schleife genau wie die for -Schleife verschachtelt werden. Implementieren Sie das Rechteck das linksb\u00fcndige Dreieck und das rechtsb\u00fcndige Dreieck mithilfe von verschachtelten while -Schleifen.","title":"Implementierung der (3n+1)-Vermutung"},{"location":"iteration/#die-dowhile-schleife","text":"Wir haben ja bereits bei den for - und while -Schleifen erw\u00e4hnt, dass eines der beiden Konzepte gen\u00fcgt h\u00e4tte, um alle Iterationen zu implementieren. Da man aber ganz gute Unterscheidungsm\u00f6glichkeiten hat, um sich entweder f\u00fcr die for -Schleife (bestimmte Anzahl) oder f\u00fcr die while -Schleife (bestimmte Bedingung) zu entscheiden, haben beide Schleifenarten ihre Berechtigungsexistenz. F\u00fcr die do ... while f\u00e4llt die Abgrenzung zur while -Schleife noch schwerer. Generell l\u00e4sst sich sagen, dass eine while -Schleife nicht unbedingt ausgef\u00fchrt werden muss (n\u00e4mlich dann, wenn die Bedingung bereits ganz zu Anfang schon false ist), eine do ... while -Schleife wird aber zumindest ein Mal ausgef\u00fchrt, da die Pr\u00fcfung der Bedingung erst nach dem Schleifendurchlauf erfolgt. Die allgemeine Syntax einer do ... while -Schleife ist wie folgt: do { /* * Anweisungsblock, der wiederholt * werden soll */ } while ( BEDINGUNG ); Beachten Sie das Semikolon hinter der Bedingung! Es gibt Beispiele f\u00fcr den sinnvollen Einsatz von do ... while -Schleifen, z.B. wenn innerhalb der Schleife eine Eingabe erfolgt und die Bedingung pr\u00fcft, ob es sich um eine korrekte Eingabe handelt. Wir werden uns aber zun\u00e4chst nicht weiter um diese Schleife k\u00fcmmern, da sie nicht wirklich notwendig ist und wir uns haupts\u00e4chlich mit for - und while -Schleifen besch\u00e4ftigen werden.","title":"Die do...while-Schleife"},{"location":"iteration/#break-und-continue","text":"break und continue In (fast) allen Java-B\u00fcchern liest man in dem Kapitel \u00fcber Schleifen auch davon, dass es die beiden Anweisungen break; und continue; gibt. Ich will hier gar nicht darauf eigehen, was diese beiden Anweisungen machen, nur so viel: sie springen aus Schleifen heraus. Solche Art von \"Spr\u00fcngen\" ( go to statements ) geh\u00f6ren nicht in moderne, gute Programme. Wir nutzen diese Anweisungen nicht!!! Stattdessen sei in diesem Zusammenhang ein ber\u00fchmtes Papier von Edsger W. Dijkstra empfohlen: Go To Statement Considered Harmful . Siehe dazu auch hier .","title":"break und continue"},{"location":"methoden/","text":"Methoden \u00b6 Bis jetzt haben wir unseren Programmcode immer in genau eine Methode geschrieben (z.B. printObjectState() . Das wird auf Dauer viel zu un\u00fcbersichtlich. Au\u00dferdem versto\u00dfen wir so gegen zwei wichtige Prinzipien der Programmierung: dem Single Responsibility Principle (SRP) und Don't repeat yourself (DRY) . Die urspr\u00fcngliche Formulierung des SRP stammt von Robert C. Martin . Wir k\u00f6nnen uns als wesentliche Prinzipien schonmal merken, dass eine Variable genau eine Bedeutung haben soll und niemals f\u00fcr verschiedene Bedeutungen benutzt werden sollte (zwei Bedeutungen: zwei Variablen) und eine Methode genau eine Sache erledigen sollte. Zun\u00e4chst schauen wir uns an, was eine Methode \u00fcberhaupt ist und wie wir sie definieren und verwenden. Angenommen, wir haben eine Methode in der folgenden Form: public class Methods { public void myMethod () { int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 summand1 = 5 ; summand2 = 9 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 5 + 9 = 14 summand1 = - 115 ; summand2 = 999 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // -115 + 999 = 884 } } In dieser myMethod() -Methode machen wir drei Mal das Gleiche, wir addieren 2 Summanden und geben das Ergebnis der Berechnung aus. Wir sehen insbesondere doppelten (sogar dreifachen) Code, d.h. wir wiederholen uns. Au\u00dferdem geben die vergebenen Namen nur an, wof\u00fcr die Variablen da sind, aber es gibt keine namentliche Beschreibung von dem, WAS wir tun. Methodendefinition \u00b6 Das wollen wir \u00e4ndern und lagern den sich wiederholenden Code in eine Methode aus. Diese Methode nennen wir add() : 1 2 3 4 5 public void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } Betrachten wir diese Definition einer Methode genauer: In Zeile 1 sehen wir den Methodenkopf : Das Schl\u00fcsselwort public besagt, dass diese Methode von allen anderen Klassen (die wir noch nicht haben) aufgerufen werden kann. Es handelt sich um eine \u00f6ffentliche Methode. Wir gehen darauf genauer ein, wenn wir uns mit Sichtbarkeitsmodifizierern besch\u00e4ftigen. Das Schl\u00fcsselwort void steht daf\u00fcr, dass der Aufruf unserer Methode keinen Wert hat, d.h. der Aufruf dieser Methode ist eine Anweisung ohne Nebeneffekt. Wenn die Methode einen Wert haben soll, dann wird hier ein Datentyp eingetragen (sehen wir im n\u00e4chsten Beispiel). add ist der Methodenname. Hier gelten die Bedingungen, die wir an Bezeichner in Java haben. Methodennamen beginnen stets mit einem Kleinbuchstaben. Nach dem Methodennamen kommen runde Klammern und darin sogenannte Parameter . Parameter sind Variablen. Parameter werden in der Methodendefinition deklariert, aber nicht initialisiert. Parameter werden beim Aufruf der Methode initialisiert. In den Zeilen 2-5 steht der Methodenk\u00f6rper : Der Methodenk\u00f6rper ist ein Anweisungsblock. Er beginnt mit einer \u00f6ffnenden geschweiften Klammer { (Zeile 2 ) und endet mit einer schlie\u00dfenden geschweiften Klammer } (Zeile 5 ). Innerhalb dieses Anweisungsblocks k\u00f6nnen beliebig viele Anweisungen stehen. In Zeile 3 wird unter Verwendung der Werte der Variablen (Parameter) summand1 und summand2 eine Summe gebildet und in der Variablen summe vom Typ int gespeichert. Die Werte der Parameter und der Summe werden in Zeile 4 geeignet auf die Konsole ausgegeben. Die Definition einer Methode erfolgt immer innerhalb einer Klasse und au\u00dferhalb jeder anderen Methode. Methodenaufruf \u00b6 In der myMethod() -Methode wird unsere Methode nun aufgerufen. Wichtig ist es zu beachten, dass wir exakt den gleichen Namen f\u00fcr die Methode verwenden, wie in der Methodendefinition angegeben (Gro\u00df- und Kleinschreibung beachten!) und dass der Methode in den runden Klammern Werte f\u00fcr die Parameter \u00fcbergeben werden. Dabei m\u00fcssen die Anzahl der Parameter und der jeweilige Typ der Parameter mit dem Aufruf \u00fcbereinstimmen. Hier nochmal die gesamte Klasse Methods mit den Aufrufen der add() -Methode in myMethod() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Methods { public void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } public void myMethod () { add ( 3 , 4 ); add ( 5 , 9 ); add ( - 115 , 999 ); } } In der myMethod() -Methode wird nun drei Mal unsere neue add() -Methode aufgerufen. Bei jedem Aufruf werden Werte f\u00fcr die Parameter \u00fcbergeben. Der Aufruf der Methode entspricht einer Anweisung (Semikolon am Ende). Der Aufruf der add() -Methode entspricht keinem Ausdruck, da der Aufruf dieser Methode ohne Wert ist. Dies liegt daran, dass in der Methodendefinition angegeben wurde, dass der Wert der Methode void ist - also kein Wert, kein Typ. Beachten Sie, dass in der Klasse Methods nun zwei Methoden definiert sind, myMethod() und add() . Wenn wir die myMethod() -Methode aufrufen, wird sie ausgef\u00fchrt. Das bedeutet, dass alle Anweisungen, die in der myMethod() -Methode definiert wurden, sequentiell abgearbeitet werden. Es wird also nacheinander drei Mal die add() -Methode aufgerufen und ausgef\u00fchrt. Damit die add() -Methode \u00fcberhaupt ausgef\u00fchrt wird, muss sie aufgerufen werden. Beachte Wird add() nirgends aufgerufen, wird sie auch niemals ausgef\u00fchrt. Die Definition der Methode allein sorgt noch nicht f\u00fcr dessen Ausf\u00fchrung! Ausf\u00fchrung des Programms im Detail \u00b6 Wir schauen uns die Ausf\u00fchrung des obigen Programms nochmal im Detail an, um die Aufrufe genauer zu analysieren: Wir rufen die myMethod() -Methode auf (Zeile 9 ). Die erste Anweisung in der myMethod() -Methode ist add(3,4); (Zeile 11 ). Dadurch wird die add() -Methode aufgerufen (Zeile 3 ). Durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 3 und int summand2 = 4 (Zeile 3 ). Die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 7 . (Zeile 5 ). Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ergibt sich aus: summand1 + \" + \" ist ein Konkatenation; das Ergebnis ist \"3 + \" . \"3 + \" + summand2 ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4\" . \"3 + 4\" + \" = \" ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = \" . \"3 + 4 = \" + summe ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = 7\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur myMethod() -Methode gegangen. Die n\u00e4chste Anweisung in der myMethod() -Methode ist add(5,9); (Zeile 12 ). Dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ). Durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 5 und int summand2 = 9 (Zeile 3 ). Die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 14 . (Zeile 5 ). Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"5 + 9 = 14\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur myMethod() -Methode gegangen. Die n\u00e4chste Anweisung in der myMethod() -Methode ist add(-115,999); (Zeile 13 ). Dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ). Durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = -115 und int summand2 = 999 (Zeile 3 ). Die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 884 . (Zeile 5 ). Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"-115 + 999 = 884\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur myMethod() -Methode gegangen. In der myMethod() -Methode gibt es keine weitere Anweisung mehr. Der Aufruf dieser Methode ist beendet. Methode gibt einen Wert zur\u00fcck \u00b6 Unsere Methode add() hat keinen Wert zur\u00fcckgegeben. Das wurde im Methodenkopf festgelegt, wo wir mit void definiert haben, dass der Aufruf der Methode keinem Wert entspricht. Dies ist typisch f\u00fcr Methoden, die etwas auf die Konsole ausgeben. Alle Methoden, deren Aufgabe es ist, etwas auszugeben, sind (sollten sein) vom R\u00fcckgabetyp 1 void . Jetzt erstellen wir eine Methode computeSum() , die das gleiche macht wie add() , aber mit dem Unterschied, dass diese Methode nichts auf die Konsole ausgibt, sondern die Summe der beiden Parameter an den Aufrufer der Methode zur\u00fcckgibt . Die Definition dieser Methode sieht dann so aus: 1 2 3 4 5 public int computeSum ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; return summe ; } Zwei ganz wesentliche Unterschiede zur Definition von add() fallen auf: Diese Methode hat einen R\u00fcckgabetyp ( int ). Dort, wo bei add() noch void stand, steht bei computeSum() im Methodenkopf int . Damit wird festgelegt, dass der Aufruf der Methode einem Wert entspricht, welcher vom Typ int ist. Der Aufruf dieser Methode ist somit ein Ausdruck! Die letzte Anweisung der Methode computeSum() ist eine Anweisung, die mit dem Schl\u00fcsselwort return beginnt. Jede Methode, die einen R\u00fcckgabetyp hat (also genau nicht void ), muss ein solches return enthalten. Dieses return muss die letzte Anweisung in der Methode sein und es muss einen Wert zur\u00fcckgeben, der von dem Typ ist, der f\u00fcr die Methode als R\u00fcckgabetyp definiert wurde. Hier ist es der Wert von summe . summe ist vom Typ int und somit ist return summe; korrekt, da die Methode ja ein int zur\u00fcckgeben soll. Aufruf einer Methode, die einen Wert zur\u00fcckgibt \u00b6 Unsere Methode computeSum() k\u00f6nnte nun in der myMethod() -Methode wie folgt aufgerufen werden: computeSum ( 3 , 4 ); // korrekt, aber sinnlos Ein solcher Aufruf macht aber gar keinen Sinn, weil die Methode selbst ja z.B. nichts ausgibt und somit hat diese Methode gar keinen Effekt. Sinnvoll eingesetzt werden kann eine solche Methode nur als Ausdruck, z.B.: int sum = computeSum ( 3 , 4 ); // sum wird mit dem Wert 7 initialisiert System . out . println ( computeSum ( 5 , 9 )); // es wird 14 ausgegeben Der Aufruf der Methode ist somit ein arithmetischer Ausdruck und kann auch als solcher behandelt werden, z.B. mit anderen arithmetischen Ausdr\u00fccken mittels arithmetischer Operatoren zu einem weiteren arithmetischen Ausdruck verkn\u00fcpft werden. Hier noch weitere Beispiele f\u00fcr Methoden mit R\u00fcckgabe (hier R\u00fcckgabe vom Typ boolean ): public boolean areEqual ( int nr1 , int nr2 ) { return ( nr1 == nr2 ); } public boolean isDivider ( int nr1 , int nr2 ) { return ( nr1 % nr2 == 0 ); } Sie k\u00f6nnen auch Methoden in Methoden aufrufen. Nehmen wir die beiden Methoden areEqual(int, int) und isDivider(int, int) und angenommen, wir wollen f\u00fcr 2 int -Zahlen pr\u00fcfen, ob die eine Teiler der anderen ist, aber beide sollen nicht gleich sein, dann k\u00f6nnen wir folgende Methode schreiben: public boolean isDividerButNotEqual ( int nr1 , int nr2 ) { return ( isDivider ( nr1 , nr2 ) && ! areEqual ( nr1 , nr2 )); } Das schauen wir uns einmal genauer an: wir definieren wieder eine Methode wie gehabt: wir vergeben einen Namen ( isDividerButNotEqual ) und wir legen fest, dass bei Aufruf der Methode zwei int -Werte \u00fcbergeben werden m\u00fcssen ( (int nr1, int nr2) ). als R\u00fcckgabetyp definieren wir boolean , denn wir wollen ja pr\u00fcfen, ob sich die beiden ganzzahlig teilen, aber nicht gleich sind innerhalb der Methode rufen wir die Methode isDivider(nr1, nr2) auf und \u00fcbergeben dabei unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht einem boole'schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr2 Teiler von nr1 ist und false sonst - also, wenn nicht) au\u00dferdem rufen wir die Methode areEqual(nr1, nr2) auf und \u00fcbergeben dabei ebenfalls unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht ebenfalls einem boole'schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr1 und nr2 gleich sind und false sonst - also, wenn nicht) wir wollen aber pr\u00fcfen, ob sie nicht gleich sind, also schreiben wir !areEqual(nr1, nr2) - also die Negation dieses Ausdrucks wir wollen pr\u00fcfen, ob isDivider(nr1, nr2) UND NICHT areEqual(nr1, nr2) , also isDivider(nr1, nr2) UND !areEqual(nr1, nr2) , also isDivider(nr1, nr2) && !areEqual(nr1, nr2) diesen Wert geben wir zur\u00fcck 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isEven(int number) , die ein true zur\u00fcckgibt, wenn number gerade ist und sonst false . 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isOdd(int number) , die ein true zur\u00fcckgibt, wenn number ungerade ist und sonst false . Dieses Mal verwenden Sie aber die Methode isEven() , um den richtigen Wert zu ermitteln. Success Wir k\u00f6nnen uns nun Methoden selber definieren. Die Definition von Methoden erfolgt innerhalb der Klasse, aber au\u00dferhalb jeder anderen Methode. Eine Methode kann entweder keinen Wert zur\u00fcckgeben. Dann ist der \"R\u00fcckgabetyp\" 1 void . Eine solche void -Methode gibt typischerweise etwas auf die Konsole aus. Oder die Methode gibt einen Wert zur\u00fcck. Dann wird der Datentyp dieses Wertes im Methodenkopf der Methodendefinition angegeben. Die R\u00fcckgabe des Wertes erfolgt durch return . Die return -Anweisung muss die letzte Anweisung in der Methode sein. Der Aufruf einer solchen Methode entspricht dann einem Ausdruck. Einer Methode k\u00f6nnen beliebig viele Parameter \u00fcbergeben werden. Diese lokalen Variablen werden im Methodenkopf in den runden Klammern durch Komma getrennt deklariert. Bei Aufruf der Methode m\u00fcssen diesen Variablen Werte \u00fcbergeben werden (Anzahl und Datentypen m\u00fcssen bei Methodenaufruf passen). void ist kein Datentyp! Man sagt aber, dass Methoden, die keinen Wert zur\u00fcckliefern, vom R\u00fcckgabetyp void sind. Ganz korrekt ist das also nicht, aber es fehlt ein besserer Ausdruck daf\u00fcr. \u21a9 \u21a9","title":"Methoden"},{"location":"methoden/#methoden","text":"Bis jetzt haben wir unseren Programmcode immer in genau eine Methode geschrieben (z.B. printObjectState() . Das wird auf Dauer viel zu un\u00fcbersichtlich. Au\u00dferdem versto\u00dfen wir so gegen zwei wichtige Prinzipien der Programmierung: dem Single Responsibility Principle (SRP) und Don't repeat yourself (DRY) . Die urspr\u00fcngliche Formulierung des SRP stammt von Robert C. Martin . Wir k\u00f6nnen uns als wesentliche Prinzipien schonmal merken, dass eine Variable genau eine Bedeutung haben soll und niemals f\u00fcr verschiedene Bedeutungen benutzt werden sollte (zwei Bedeutungen: zwei Variablen) und eine Methode genau eine Sache erledigen sollte. Zun\u00e4chst schauen wir uns an, was eine Methode \u00fcberhaupt ist und wie wir sie definieren und verwenden. Angenommen, wir haben eine Methode in der folgenden Form: public class Methods { public void myMethod () { int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 summand1 = 5 ; summand2 = 9 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 5 + 9 = 14 summand1 = - 115 ; summand2 = 999 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // -115 + 999 = 884 } } In dieser myMethod() -Methode machen wir drei Mal das Gleiche, wir addieren 2 Summanden und geben das Ergebnis der Berechnung aus. Wir sehen insbesondere doppelten (sogar dreifachen) Code, d.h. wir wiederholen uns. Au\u00dferdem geben die vergebenen Namen nur an, wof\u00fcr die Variablen da sind, aber es gibt keine namentliche Beschreibung von dem, WAS wir tun.","title":"Methoden"},{"location":"methoden/#methodendefinition","text":"Das wollen wir \u00e4ndern und lagern den sich wiederholenden Code in eine Methode aus. Diese Methode nennen wir add() : 1 2 3 4 5 public void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } Betrachten wir diese Definition einer Methode genauer: In Zeile 1 sehen wir den Methodenkopf : Das Schl\u00fcsselwort public besagt, dass diese Methode von allen anderen Klassen (die wir noch nicht haben) aufgerufen werden kann. Es handelt sich um eine \u00f6ffentliche Methode. Wir gehen darauf genauer ein, wenn wir uns mit Sichtbarkeitsmodifizierern besch\u00e4ftigen. Das Schl\u00fcsselwort void steht daf\u00fcr, dass der Aufruf unserer Methode keinen Wert hat, d.h. der Aufruf dieser Methode ist eine Anweisung ohne Nebeneffekt. Wenn die Methode einen Wert haben soll, dann wird hier ein Datentyp eingetragen (sehen wir im n\u00e4chsten Beispiel). add ist der Methodenname. Hier gelten die Bedingungen, die wir an Bezeichner in Java haben. Methodennamen beginnen stets mit einem Kleinbuchstaben. Nach dem Methodennamen kommen runde Klammern und darin sogenannte Parameter . Parameter sind Variablen. Parameter werden in der Methodendefinition deklariert, aber nicht initialisiert. Parameter werden beim Aufruf der Methode initialisiert. In den Zeilen 2-5 steht der Methodenk\u00f6rper : Der Methodenk\u00f6rper ist ein Anweisungsblock. Er beginnt mit einer \u00f6ffnenden geschweiften Klammer { (Zeile 2 ) und endet mit einer schlie\u00dfenden geschweiften Klammer } (Zeile 5 ). Innerhalb dieses Anweisungsblocks k\u00f6nnen beliebig viele Anweisungen stehen. In Zeile 3 wird unter Verwendung der Werte der Variablen (Parameter) summand1 und summand2 eine Summe gebildet und in der Variablen summe vom Typ int gespeichert. Die Werte der Parameter und der Summe werden in Zeile 4 geeignet auf die Konsole ausgegeben. Die Definition einer Methode erfolgt immer innerhalb einer Klasse und au\u00dferhalb jeder anderen Methode.","title":"Methodendefinition"},{"location":"methoden/#methodenaufruf","text":"In der myMethod() -Methode wird unsere Methode nun aufgerufen. Wichtig ist es zu beachten, dass wir exakt den gleichen Namen f\u00fcr die Methode verwenden, wie in der Methodendefinition angegeben (Gro\u00df- und Kleinschreibung beachten!) und dass der Methode in den runden Klammern Werte f\u00fcr die Parameter \u00fcbergeben werden. Dabei m\u00fcssen die Anzahl der Parameter und der jeweilige Typ der Parameter mit dem Aufruf \u00fcbereinstimmen. Hier nochmal die gesamte Klasse Methods mit den Aufrufen der add() -Methode in myMethod() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Methods { public void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } public void myMethod () { add ( 3 , 4 ); add ( 5 , 9 ); add ( - 115 , 999 ); } } In der myMethod() -Methode wird nun drei Mal unsere neue add() -Methode aufgerufen. Bei jedem Aufruf werden Werte f\u00fcr die Parameter \u00fcbergeben. Der Aufruf der Methode entspricht einer Anweisung (Semikolon am Ende). Der Aufruf der add() -Methode entspricht keinem Ausdruck, da der Aufruf dieser Methode ohne Wert ist. Dies liegt daran, dass in der Methodendefinition angegeben wurde, dass der Wert der Methode void ist - also kein Wert, kein Typ. Beachten Sie, dass in der Klasse Methods nun zwei Methoden definiert sind, myMethod() und add() . Wenn wir die myMethod() -Methode aufrufen, wird sie ausgef\u00fchrt. Das bedeutet, dass alle Anweisungen, die in der myMethod() -Methode definiert wurden, sequentiell abgearbeitet werden. Es wird also nacheinander drei Mal die add() -Methode aufgerufen und ausgef\u00fchrt. Damit die add() -Methode \u00fcberhaupt ausgef\u00fchrt wird, muss sie aufgerufen werden. Beachte Wird add() nirgends aufgerufen, wird sie auch niemals ausgef\u00fchrt. Die Definition der Methode allein sorgt noch nicht f\u00fcr dessen Ausf\u00fchrung!","title":"Methodenaufruf"},{"location":"methoden/#ausfuhrung-des-programms-im-detail","text":"Wir schauen uns die Ausf\u00fchrung des obigen Programms nochmal im Detail an, um die Aufrufe genauer zu analysieren: Wir rufen die myMethod() -Methode auf (Zeile 9 ). Die erste Anweisung in der myMethod() -Methode ist add(3,4); (Zeile 11 ). Dadurch wird die add() -Methode aufgerufen (Zeile 3 ). Durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 3 und int summand2 = 4 (Zeile 3 ). Die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 7 . (Zeile 5 ). Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ergibt sich aus: summand1 + \" + \" ist ein Konkatenation; das Ergebnis ist \"3 + \" . \"3 + \" + summand2 ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4\" . \"3 + 4\" + \" = \" ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = \" . \"3 + 4 = \" + summe ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = 7\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur myMethod() -Methode gegangen. Die n\u00e4chste Anweisung in der myMethod() -Methode ist add(5,9); (Zeile 12 ). Dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ). Durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 5 und int summand2 = 9 (Zeile 3 ). Die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 14 . (Zeile 5 ). Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"5 + 9 = 14\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur myMethod() -Methode gegangen. Die n\u00e4chste Anweisung in der myMethod() -Methode ist add(-115,999); (Zeile 13 ). Dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ). Durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = -115 und int summand2 = 999 (Zeile 3 ). Die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 884 . (Zeile 5 ). Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"-115 + 999 = 884\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur myMethod() -Methode gegangen. In der myMethod() -Methode gibt es keine weitere Anweisung mehr. Der Aufruf dieser Methode ist beendet.","title":"Ausf\u00fchrung des Programms im Detail"},{"location":"methoden/#methode-gibt-einen-wert-zuruck","text":"Unsere Methode add() hat keinen Wert zur\u00fcckgegeben. Das wurde im Methodenkopf festgelegt, wo wir mit void definiert haben, dass der Aufruf der Methode keinem Wert entspricht. Dies ist typisch f\u00fcr Methoden, die etwas auf die Konsole ausgeben. Alle Methoden, deren Aufgabe es ist, etwas auszugeben, sind (sollten sein) vom R\u00fcckgabetyp 1 void . Jetzt erstellen wir eine Methode computeSum() , die das gleiche macht wie add() , aber mit dem Unterschied, dass diese Methode nichts auf die Konsole ausgibt, sondern die Summe der beiden Parameter an den Aufrufer der Methode zur\u00fcckgibt . Die Definition dieser Methode sieht dann so aus: 1 2 3 4 5 public int computeSum ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; return summe ; } Zwei ganz wesentliche Unterschiede zur Definition von add() fallen auf: Diese Methode hat einen R\u00fcckgabetyp ( int ). Dort, wo bei add() noch void stand, steht bei computeSum() im Methodenkopf int . Damit wird festgelegt, dass der Aufruf der Methode einem Wert entspricht, welcher vom Typ int ist. Der Aufruf dieser Methode ist somit ein Ausdruck! Die letzte Anweisung der Methode computeSum() ist eine Anweisung, die mit dem Schl\u00fcsselwort return beginnt. Jede Methode, die einen R\u00fcckgabetyp hat (also genau nicht void ), muss ein solches return enthalten. Dieses return muss die letzte Anweisung in der Methode sein und es muss einen Wert zur\u00fcckgeben, der von dem Typ ist, der f\u00fcr die Methode als R\u00fcckgabetyp definiert wurde. Hier ist es der Wert von summe . summe ist vom Typ int und somit ist return summe; korrekt, da die Methode ja ein int zur\u00fcckgeben soll.","title":"Methode gibt einen Wert zur\u00fcck"},{"location":"methoden/#aufruf-einer-methode-die-einen-wert-zuruckgibt","text":"Unsere Methode computeSum() k\u00f6nnte nun in der myMethod() -Methode wie folgt aufgerufen werden: computeSum ( 3 , 4 ); // korrekt, aber sinnlos Ein solcher Aufruf macht aber gar keinen Sinn, weil die Methode selbst ja z.B. nichts ausgibt und somit hat diese Methode gar keinen Effekt. Sinnvoll eingesetzt werden kann eine solche Methode nur als Ausdruck, z.B.: int sum = computeSum ( 3 , 4 ); // sum wird mit dem Wert 7 initialisiert System . out . println ( computeSum ( 5 , 9 )); // es wird 14 ausgegeben Der Aufruf der Methode ist somit ein arithmetischer Ausdruck und kann auch als solcher behandelt werden, z.B. mit anderen arithmetischen Ausdr\u00fccken mittels arithmetischer Operatoren zu einem weiteren arithmetischen Ausdruck verkn\u00fcpft werden. Hier noch weitere Beispiele f\u00fcr Methoden mit R\u00fcckgabe (hier R\u00fcckgabe vom Typ boolean ): public boolean areEqual ( int nr1 , int nr2 ) { return ( nr1 == nr2 ); } public boolean isDivider ( int nr1 , int nr2 ) { return ( nr1 % nr2 == 0 ); } Sie k\u00f6nnen auch Methoden in Methoden aufrufen. Nehmen wir die beiden Methoden areEqual(int, int) und isDivider(int, int) und angenommen, wir wollen f\u00fcr 2 int -Zahlen pr\u00fcfen, ob die eine Teiler der anderen ist, aber beide sollen nicht gleich sein, dann k\u00f6nnen wir folgende Methode schreiben: public boolean isDividerButNotEqual ( int nr1 , int nr2 ) { return ( isDivider ( nr1 , nr2 ) && ! areEqual ( nr1 , nr2 )); } Das schauen wir uns einmal genauer an: wir definieren wieder eine Methode wie gehabt: wir vergeben einen Namen ( isDividerButNotEqual ) und wir legen fest, dass bei Aufruf der Methode zwei int -Werte \u00fcbergeben werden m\u00fcssen ( (int nr1, int nr2) ). als R\u00fcckgabetyp definieren wir boolean , denn wir wollen ja pr\u00fcfen, ob sich die beiden ganzzahlig teilen, aber nicht gleich sind innerhalb der Methode rufen wir die Methode isDivider(nr1, nr2) auf und \u00fcbergeben dabei unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht einem boole'schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr2 Teiler von nr1 ist und false sonst - also, wenn nicht) au\u00dferdem rufen wir die Methode areEqual(nr1, nr2) auf und \u00fcbergeben dabei ebenfalls unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht ebenfalls einem boole'schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr1 und nr2 gleich sind und false sonst - also, wenn nicht) wir wollen aber pr\u00fcfen, ob sie nicht gleich sind, also schreiben wir !areEqual(nr1, nr2) - also die Negation dieses Ausdrucks wir wollen pr\u00fcfen, ob isDivider(nr1, nr2) UND NICHT areEqual(nr1, nr2) , also isDivider(nr1, nr2) UND !areEqual(nr1, nr2) , also isDivider(nr1, nr2) && !areEqual(nr1, nr2) diesen Wert geben wir zur\u00fcck 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isEven(int number) , die ein true zur\u00fcckgibt, wenn number gerade ist und sonst false . 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isOdd(int number) , die ein true zur\u00fcckgibt, wenn number ungerade ist und sonst false . Dieses Mal verwenden Sie aber die Methode isEven() , um den richtigen Wert zu ermitteln. Success Wir k\u00f6nnen uns nun Methoden selber definieren. Die Definition von Methoden erfolgt innerhalb der Klasse, aber au\u00dferhalb jeder anderen Methode. Eine Methode kann entweder keinen Wert zur\u00fcckgeben. Dann ist der \"R\u00fcckgabetyp\" 1 void . Eine solche void -Methode gibt typischerweise etwas auf die Konsole aus. Oder die Methode gibt einen Wert zur\u00fcck. Dann wird der Datentyp dieses Wertes im Methodenkopf der Methodendefinition angegeben. Die R\u00fcckgabe des Wertes erfolgt durch return . Die return -Anweisung muss die letzte Anweisung in der Methode sein. Der Aufruf einer solchen Methode entspricht dann einem Ausdruck. Einer Methode k\u00f6nnen beliebig viele Parameter \u00fcbergeben werden. Diese lokalen Variablen werden im Methodenkopf in den runden Klammern durch Komma getrennt deklariert. Bei Aufruf der Methode m\u00fcssen diesen Variablen Werte \u00fcbergeben werden (Anzahl und Datentypen m\u00fcssen bei Methodenaufruf passen). void ist kein Datentyp! Man sagt aber, dass Methoden, die keinen Wert zur\u00fcckliefern, vom R\u00fcckgabetyp void sind. Ganz korrekt ist das also nicht, aber es fehlt ein besserer Ausdruck daf\u00fcr. \u21a9 \u21a9","title":"Aufruf einer Methode, die einen Wert zur\u00fcckgibt"},{"location":"methodenstack/","text":"Methodenstack \u00b6 Programme und die dazugeh\u00f6rigen Variablen (und deren Werte) befinden sich zur Ausf\u00fchrung im Arbeitsspeicher. Der Speicher ist in Bl\u00f6cke (Bytes) unterteilt, die jeweils adressierbar sind. So k\u00f6nnte alles jeweils eine Adresse zugeordnet werden und mit einer komplexen Adressverwaltung lie\u00dfen sich die Einzelteile ansprechen. Das ist jedoch viel zu aufwendig und inperformant. Deshalb werden Speichermodelle verwendet, die die Verwaltung der Programmteile erleichtern. Ein solches Speichermodell ist der Stack ( Stapelspeicher ). Bei einem Stack gilt das Last in first out (LIFO) Prinzip, also das, was zuletzt in den Stack kam, muss auch als erstes wieder hinaus. tats\u00e4chlich gibt es nur ganz wenige Funktionalit\u00e4ten, um einen solchen Stack zu verwalten: push : Element oben auf den Stack hinzuf\u00fcgen pop : Element von oben aus dem Stack entfernen top (manchmal auch peek genannt): auf oberes Element zugreifen (lesen, aber im Stack belassen) Folgende Abbildung stellt diese Methoden grafisch dar: F\u00fcr einen solchen Stack gibt es jetzt nur drei M\u00f6glichkeiten: Element E kann gelesen werden (aber im Stack belassen) - top Element E kann aus dem Stack entfernt werden - pop ein neues Element (z.B. F ) kann zum Stack hinzugef\u00fcgt werden - push (dann kann auch E nicht mehr gelesen werden; so wie bereits A - D ) Abarbeitung von Methoden \u00b6 Wir betrachten das Speichermodell Stack , weil die Abarbeitung von Methoden nach diesem Prinzip funktioniert. Methoden, die abgearbeitet (aufgerufen) werden, werden in einem solchen Stack angeordnet. Wir betrachten ein Beispiel: Methodenstack.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Methodenstack { public void a ( int vaa ) { int vab = 1 ; System . out . println ( \"+--a() --> vaa = \" + vaa + \" vab = \" + vab ); b ( vaa , vab ); } public void b ( int vba , int vbb ) { System . out . println ( \"+----b() --> vba = \" + vba + \" vbb = \" + vbb ); System . out . println (); } public void start () { for ( int va = 0 ; va < 3 ; va ++ ) { System . out . println ( \"start() --> va = \" + va ); a ( va ); } } } In diesem Beispiel gibt es drei Methoden: die start() -Methode mit der Variablen va , die a() -Methode mit den Variablen vaa und vab und die b() -Methode mit den Variablen vba und vbb . Die start() -Methode ruft die Methode a() auf und die a() -Methode ruft die b() -Methode auf. Die Ausgabe des Programms ist wie folgt: start () --> va = 0 +--a () --> vaa = 0 vab = 1 +----b () --> vba = 0 vbb = 1 start () --> va = 1 +--a () --> vaa = 1 vab = 1 +----b () --> vba = 1 vbb = 1 start () --> va = 2 +--a () --> vaa = 2 vab = 1 +----b () --> vba = 2 vbb = 1 Die start() -Methode ruft also drei Mal (innerhalb der Schleife) die a() -Methode auf, welche wiederum die b() -Methode aufruft. Bei dem Aufruf von Methoden passiert folgendes: bei jedem Methodenaufruf wird eine Methodeninstanz auf den Stack gelegt eine Methodeninstanz sind alle zur Laufzeit ver\u00e4nderlichen Daten, die zur Methode geh\u00f6ren (Parameter und lokale Variablen) nach Abarbeitung der Methode (oft durch return - muss aber nicht, wie in unserem Beispiel) wird die Methodeninstanz wieder aus dem Stack entfernt (und somit auch alle dazu geh\u00f6renden Daten (Parameter, lokale Variablen und deren Werte)) In unserem Beispiel passiert also folgendes: Die start() -Methode wird ausgef\u00fchrt; die Variable va wird erzeugt und bekommt den Wert 0 . Die start() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 0 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 0 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von start() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 1 . Die Variable va hat nun den Wert 1 . Die start() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 1 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 1 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von start() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 2 . Die Variable va hat nun den Wert 2 . Die start() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 2 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 2 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von start() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 3 . Die Bedingung der Schleife va<3 ist somit false . Die Schleife wird verlassen, keine weitere Anweisung in start() . Die Abarbeitung des Programms ist zu Ende. Alles, was mit der start() -Methode zu tun hat, insb. Variable va wird aus dem Speicher gel\u00f6scht. Lebensdauer und Sichtbarkeit von lokalen Variablen \u00b6 Die Variablen, die wir bis jetzt verwendet haben, wurden in Methoden deklariert oder in Anweisungsbl\u00f6cken, die in Methoden liegen (z.B. in for -Schleifen). Bei solchen Variablen sprechen wir von lokalen Variablen. Wir werden sp\u00e4ter noch globale Variablen kennenlernen. Zun\u00e4chst interessieren uns aber nur die lokalen Variablen. Das obige Beispiel zeigt, dass lokale Variablen, also solche, die in Methoden deklariert werden, nur so lange existieren , wie diese Methode ausgef\u00fchrt wird. Generell gilt: Eine Variable existiert in dem Anweisungsblock, in dem sie deklariert wurde, solange dieser Anweisungsblock ausgef\u00fchrt wird. Schauen wir uns dazu die Situationen in dem oberen Beispiel an: Die Variable va wird in der start() -Methode deklariert. Die start() -Methode wird die ganze Zeit ausgef\u00fchrt. Also existiert auch die Variable va die gesamte Zeit des Programmablaufs. Die Variablen vaa und vab werden in der a() -Methode deklariert. Sie existieren immer nur dann, wenn die a() -Methode ausgef\u00fchrt wird. In unserem Beispiel existieren die Variablen vaa und vab also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollst\u00e4ndig gel\u00f6scht). Da die Methode a() die Methode b() aufruft, existieren die Variablen vaa und vab auch w\u00e4hrend der Ausf\u00fchrung von b() , da zur Zeit der Ausf\u00fchrung von b() ja auch a() ausgef\u00fchrt wird (und start() ). Die Variablen vba und vbb werden in der b() -Methode deklariert. Sie existieren immer nur dann, wenn die b() -Methode ausgef\u00fchrt wird. In unserem Beispiel existieren die Variablen vba und vbb also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollst\u00e4ndig gel\u00f6scht). Die Lebensdauer eine Variable wird somit von der Ausf\u00fchrungsdauer des Anweisungsblockes bestimmt, in dem die Variable deklariert wurde. Lebensdauer Es ist eine g\u00e4ngige Praxis, alle Variablen, die man in einer Methode verwenden m\u00f6chte, am Anfang der Methode zu deklarieren. Erstens sieht man dann, welche Variablen innerhalb der Methode alle verwendet werden und zweitens kann man diese Variablen in allen Anweisungsbl\u00f6cken innerhalb der Methode verwenden. Einzige Ausnahme stellen Laufvariablen der for -Schleifen dar. Diese werden h\u00e4ufig direkt in der for -Schleife deklariert ( for(int i=0, i<10; i++){} ). Sie existieren dann aber auch nur in dieser for -Schleife! Au\u00dferhalb der for -Schleife existiert diese Variable dann nicht (mehr)! Das bedeutet auch, dass wenn Sie diese Variable in einer anderen for -Schleife verwenden wollen, m\u00fcssen Sie sie dort erneut deklarieren. Unter Sichtbarkeit einer Variablen versteht man die M\u00f6glichkeit, auf diese Variable zuzugreifen (also ihr entweder einen neuen Wert zuzuweisen oder ihren Wert auszulesen). Generell gilt: Eine lokale Variable ist in dem Anweisungsblock sichtbar, in dem sie deklariert wird und in allen Anweisungsbl\u00f6cken, die sich in diesem Anweisungsblock befinden. Au\u00dferhalb des Anweisungsblockes, in dem die Variable deklariert wurde, ist die Variable nicht sichtbar. Das hei\u00dft f\u00fcr unser Beispiel, dass die Variable va nur in der start() -Methode sichtbar ist (also nur dort auf sie zugegriffen werden kann/sie nur dort verwendet werden kann), die Variablen vaa und vab nur in der a() -Methode verwendet werden k\u00f6nnen (sichtbar sind) und die Variablen vba und vbb nur in b() . Sichtbarkeit Der Vorteil dieser lokalen Sichtbarkeit besteht darin, dass man sich z.B. keine Sorgen machen muss, ob eine gleichnamige Variable evtl. bereits in einer anderen Methode deklariert wurde. Eine Variable darf ja immer nur einmal deklariert werden. Da alle anderen Variablen aber nicht in der eigenen Methode sichtbar sind, gibt es keinerlei Konflikte mit anderen lokalen Variablen. Die lokalen Variablen aus anderen Methoden haben mit den Variablen aus der eigenen Methode gar nichts zu tun. Au\u00dferdem ist es auch nicht m\u00f6glich, einfach Werte von Variablen aus anderen Methoden zu schreiben oder zu lesen. Das w\u00fcrde ansonsten gro\u00dfe Sicherheitsprobleme mit sich bringen und man k\u00f6nnte Programme auch leicht zum Absturz bringen. Werte- vs. Referenztypen \u00b6 Es ist ganz wichtig, zu verstehen, dass es ganz wesentliche Unterschiede zwischen Werte- und Referenztypen gibt. Einige der Unterschiede sind in der folgenden Tabelle aufgelistet: Wertetypen Referenztypen Beispiele int , double , boolean , char , long , float , byte , short String , Point , Triangle , Circle , Adresse , System , ... neue erzeugbar? nein ja - einfach eigene Klasse erstellen Was ist der \"Wert\" einer Variablen? ein Wert ( 5 , true , 1.234 , 'a' , ...) die Referenz auf ein Objekt Manipulation von Werten mit Operatoren ( + , == , && , ...) mit Methoden variable1 = variable2; Kopie des Wertes ( variable1 hat den Wert und variable2 hat den Wert) Kopie der Referenz auf das Objekt (beide Variablen zeigen auf das gleiche Objekt) Insbesondere den letzten Punkt wollen wir uns genauer anschauen. Zun\u00e4chst Wertetypen. Angenommen, wir haben folgende Anweisungen: int a = 5 ; int b = a ; Nach Abarbeitung dieser Anweisungen hat sowohl die Variable a den Wert 5 als auch die Variable b . Wenn wir nun a=6; setzen, dann hat a den Wert 6 und b immer noch den Wert 5 . Der Wert einer Variablen von einem Wertetyp kann sich nur durch den Zuweisungsoperator = \u00e4ndern! Folgende Abbildung zeigt die Verwaltung der beiden int -Variablen a und b im Speicher: Die Zahlen in den K\u00e4stchen unter a und b stehen f\u00fcr Speicheradressen. Das Gute an Java ist, dass wir uns um solche Adressen nicht k\u00fcmmern m\u00fcssen. Wir greifen auf die Werte von a und b einfach \u00fcber die Variablennamen a und b zu. Die Speicherdressen interessieren uns dabei (zum Gl\u00fcck) gar nicht. Wichtig ist, dass jede Variable ihren eigenen Wert hat. Wenn wir den Wert von a \u00e4ndern, \u00e4ndert sich nur der Wert von a , wenn wir den Wert von b \u00e4ndern, \u00e4ndert sich nur der Wert von b . Dabei ist ganz egal, ob b den Wert 5 durch die Wertzuweisung b=5; erhalten hat oder durch b=a; , wobei a den Wert 5 hatte. Anders ist es bei Referenzvariablen, also bei Variablen, die von einem Referenztyp sind. Nehmen wir z.B. unsere Klasse Point und f\u00fchren folgende Anweisungen aus: Point p1 = new Point ( 3 , 4 ); Point p2 = p1 ; Hier gibt es genau ein Objekt, n\u00e4mlich das Objekt, in dem die Objektvariablen x und y den Wert 3 bzw. 4 haben. Die beiden Variablen p1 und p2 referenzieren das gleiche Objekt, d.h. sie zeigen darauf. Die folgende Abbildung verdeutlicht diesen Fall: Beide Variablen p1 und p2 zeigen auf dasselbe Objekt. Es gibt ja auch nur ein Objekt. Ein Objekt kann nur durch new und die Angabe des Konstruktors erzeugt werden. Das passiert hier genau einmal. W\u00e4hrend also bei int b = a; eine Kopie des Wertes erfolgt, erfolgt bei Point p2 = p1; eine Kopie der Referenz (aber keine Kopie des Objektes!). Wichtig ist jetzt noch zu wissen, dass wir auf die Objekteigenschaften des Point -Objektes sowohl \u00fcber die Referenz p1 als auch \u00fcber die Referenz p2 zugreifen k\u00f6nnen, d.h. dass z.B. p1.print() und p2.print() exakt die gleiche print() -Methode aufrufen, n\u00e4mlich die des obigen Point -Objektes. Sowohl p1.getX() als auch p2.getX() geben 3 zur\u00fcck, da sie den Wert derselben Objektvariablen x abfragen. Wenn mehrere Referenzen auf dasselbe Objekt existieren, ist es egal, \u00fcber welche Referenz wir auf die Objekteigenschaften zugreifen; es handelt sich um genau ein Objekt (mit mehreren Referenzen darauf). Wir m\u00fcssen nun also wissen, dass bei den folgenden Anweisungen int a = 5 ; int b = a ; b = 4 ; System . out . println ( a ); der Wert von a ausgegeben wird und der ist 5 , denn es gibt genau eine Wertzuweisung f\u00fcr a und das ist a=5; . Es spielt gar keine Rolle, ob b seinen Wert zwischendurch \u00e4ndert oder nicht - bei der Anweisung b = a; ist der Wert 5 kopiert worden und der Wert von a ist danach v\u00f6llig unabh\u00e4ngig von b und umgedreht. Wir m\u00fcssen nun auch wissen, dass bei den folgenden Anweisungen Point p1 = new Point ( 3 , 4 ); Point p2 = p1 ; p2 . translate ( 1 , 2 ); System . out . println ( p1 . getX ()); der Wert der Objektvariablen x des einen Objektes ausgegeben wird, das existiert. Durch die translate() -Methode ist der x -Wert des Objektes nun 4 (und der y -Wert ist 6 ). Das hei\u00dft, es wird eine 4 ausgegeben. Dabei ist v\u00f6llig egal, ob die translate() -Methode \u00fcber die Referenz p1 oder \u00fcber die Referenz p2 aufgerufen wird und es ist auch v\u00f6llig egal, ob die print() -Methode \u00fcber die Referenz p1 oder \u00fcber die Referenz p2 aufgerufen wird. Beide referenzieren dasselbe Objekt. Arrays sind (auch) Objekte! \u00b6 Schauen wir uns folgenden Fall an: int [] a1 = { 3 , 4 }; int [] a2 = a1 ; a2 [ 1 ] = 5 ; System . out . println ( a1 [ 1 ] ); Arrays sind (auch) Objekte. Also haben wir hier den gleichen Fall, wie bene bei Point . Auch referenzieren sowohl a1 als auch a2 dasselbe Array (es gibt ja nur eins). Wenn wir also \u00fcber die Referenz a2 den zweiten Wert im Array auf 5 setzen und wir danach \u00fcber die Referenz a1 den zweiten Wert dieses Array auslesen, dann ist er 5 . Sie werden sich jetzt sicherlich fragen, warum wir uns \u00fcberhaupt Kopien der Referenzen machen - das ist doch nur verwirrend. Die Antwort ist, dass dieser Fall sogar sehr oft vorkommt, n\u00e4mlich immer genau dann, wenn wir Referenzen von Objekten als Parameter \u00fcbergeben. Schauen wir uns folgendes Beispiel an: 1 2 3 4 5 6 7 8 9 public static void swap ( int [] arr , int index1 , int index2 ) { if ( index1 >= 0 && index1 < arr . length && index2 >= 0 && index2 < arr . length ) { int tmp = arr [ index1 ] ; arr [ index1 ] = arr [ index2 ] ; arr [ index2 ] = tmp ; } } Diese Methode implementiert das Vertauschen zweier Elemente in einem int -Array. So, wie wir es z.B. in vielen Sortieralgorithmen ben\u00f6tigen. Die Werte der Elemente an den Indizes index1 und index2 werden miteinander getauscht. Wir speichern den einen Wert zwischen, damit wir ihn nicht \u00fcberschreiben. Es wird vorab gepr\u00fcft, ob die beiden Indizes index1 und index2 \u00fcberhaupt im Array arr existieren. Angenommen, wir haben nun in der start() -Methode (oder einer anderen Methode) folgende Anweisungen 1 2 3 4 5 6 int [] a1 = { 1 , 2 , 3 , 4 , 5 }; swap ( a1 , 0 , 1 ); // Uebergabe der Referenz auf das Array for ( int i = 0 ; i < a1 . length ; i ++ ) { System . out . println ( a1 [ i ] + \" \" ); } , dann ist die Ausgabe 2 1 3 4 5 Wir \u00fcbergeben bei Aufruf der Methode swap(a1, 0, 1); die Referenz auf das Array und in der Methode wird die lokale Variable arr mit genau dieser Referenz initialisiert, d.h. es existieren dann zwei Referenzen auf das Array! Die Referenz arr innnerhalb der swap() -Methode und die Referenz a1 innerhalb der start() -Methode. Zwei Referenzen, aber nur ein Objekt! L\u00f6sen Sie die folgenden \u00dcbungsaufgaben durch \u00dcberlegen! Was wird ausgegeben? (start() wird ausgef\u00fchrt) public void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } public void start () { int a = 3 ; int b = 4 ; swap ( a , b ); System . out . println ( a ); } Was wird ausgegeben? I.java public class I { private int o ; public I ( int o ) { this . o = o ; } public int getO () { return this . o ; } public void add1 () { o ++ ; } } TestI.java public void doSomething ( I i2 ) { i2 . add1 (); } public void start () { I i1 = new I ( 1 ); I i2 = i1 ; i2 . add1 (); I i3 = i1 ; doSomething ( i3 ); System . out . println ( i1 . getO ()); System . out . println ( i2 . getO ()); System . out . println ( i3 . getO ()); } Das \"Leben\" der Objekte \u00b6 Wir haben uns bereits eingehend mit der Lebensdauer und der Sichtbarkeit von lokalen Variablen besch\u00e4ftigt. Es ist dabei \u00fcbrigens gaz egal, ob es sich um Variablen von einem Werte- oder einem Referenztyp handelt. Auf die Lebensdauer und Sichtbarkeit hat das keinen Einfluss. Wir wissen auch bereits, dass Objektvariablen f\u00fcr jeweils ein Objekt existieren. Die Lebensdauer einer Objektvariablen entspricht also der Lebensdauer ihres Objektes. Wir wissen auch \u00fcber die Sichtbarkeit der Objektvariablen Bescheid, denn sie sind in der gesamten Klasse sichtbar, in der sie deklariert werden, also auch in allen Methoden dieser Klasse. Ob sie dar\u00fcber hinaus auch \u00fcber eine Referenz auf ein Objekt in anderen Klassen sichtbar sind, h\u00e4ngt vom Sichtbarkeitsmodifizierer ab. Normalerweise nicht, denn wir deklarieren alle Objektvariablen als private . Wir wollen nun untersuchen, wie lange Objekte existieren. Wir wissen bereits, dass ihre Existenz mit der Anweisung new gefolgt vom Konstruktor beginnt. Wir haben gelernt, dass Methoden in einem sogenannten Stack abgearbeitet werden und dass in diesem Stack auch die lokalen Variablen existieren - und zwar so lange, so lange die Methode abgearbeitet wird, also im Stack existiert. Sichtbar sind jedoch nur die lokalen Variablen, die zur Methode geh\u00f6ren, die im Stack ganz oben liegt, also gerade abgearbeitet wird. Objekte werden nicht im Stack abgelegt. Der Speicherbereich f\u00fcr Objekte nennt sich Heap . Wir wollen auf die Speicherstruktur des Heap gar nicht weiter eingehen, wichtig ist nur, dass bei Erzeugung eines Objektes Speicherplatz im Heap f\u00fcr das Objekt reserviert wird. Die Gr\u00f6\u00dfe des reservierten Speicherplatzes bestimmt der Konstruktor und ist von den Objektvariablen des Objektes abh\u00e4ngig, also von der Gr\u00f6\u00dfe und der Anzahl der Objektvariablen 1 . Die Objektvariablen existieren auf dem Heap. Lebt das Objekt nicht mehr, wird der Speicherplatz auf dem Heap (automatisch) freigegeben. Wir wissen, wann Objekte anfangen, zu existieren (wenn sie erzeugt werden), aber wann h\u00f6ren Sie auf, zu existieren? Wir betrachten \"das Leben\" eines Objektes am Beispiel eines Point -Objektes: Objekt-Referenz deklarieren public void start () { Point p1 ; } Damit ist bereits eine Referenz mit dem Namen p1 auf ein Point -Objekt definiert. Das Objekt existiert aber noch gar nicht! Aber es sind schonmal 64Bit im Heap reserviert. Die (Referenz-)Variable p1 ist eine lokale Variable der Methode start() . p1 ist nur in der start() -Methode sichtbar, sie existiert so lange, solange start() ausgef\u00fchrt wird und sie existiert im Stack . Objekt erzeugen public void start () { Point p1 = new Point ( 3 , 4 ); } Jetzt existiert ein Point -Objekt! Es wird im Heap abgelegt. Insbesondere werden die Objektvariablen x und y im Heap abgelegt und bekommen die Werte 3 und 4 . Jetzt gibt es eine Referenzvariable p1 im Stack und ein Objekt mit Objektvariablen im Heap. Durch den Zuweisungsoperator = werden die beiden miteinander verbunden, d.h p1 zeigt jetzt auf das Point -Objekt. An dieser Stelle ist es schonmal sinnvoll zu betonen, dass die einzige M\u00f6glichkeit, auf das Point -Objekt zuzugreifen, derzeit \u00fcber die p1 -Variable existiert. G\u00e4be es diese Variable nicht, h\u00e4tten wir keinen Zugriff auf das Objekt! Ein weiteres Objekt und eine Referenz darauf erzeugen Wir erzeugen zur Veranschaulichung ein weiteres Objekt und die Referenzvariable p2 , die darauf zeigt. public void start () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 3 , 4 ); } Jetzt existieren zwei Point -Objekte im Heap und zwei Referenzvariablen p1 und p2 , die jeweils auf eines der beiden Objekte zeigen. p1 und p2 sind lokale Variablen der start() -Methode und existieren im Stack. Beachten Sie, dass die beiden Objekte zwar Objektvariablen haben, die gleiche Werte aufweisen, aber es handelt sich um zwei (verschiedene) Objekte! Eine weitere Referenz erzeugen Jetzt erzeugen wir noch eine weitere Referenz auf das erste Point -Objekt. Wir nennen die Referenzvariable p3 . public void start () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 3 , 4 ); Point p3 = p1 ; } Diese Situation l\u00e4sst sich so veranschaulichen: Auf das erste Objekt existieren also gleich zwei Referenzen. \u00dcber beide Referenzen kann mittels Punktnotation auf das Objekt (dessen Objekteigenschaften) zugegriffen werden. Es ist also egal, ob man p1 oder p3 schreibt, beide zeigen auf das gleiche Objekt. Eine Referenz \u00e4ndern Wir \u00e4ndern nun die soeben erstellte Referenz und lassen sie nun auf das zweite Objekt zeigen: public void start () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 3 , 4 ); Point p3 = p1 ; p3 = p2 ; } p3 darf nat\u00fcrlich nicht erneut deklariert werden. Wir kopieren die Referenz von p2 nach p3 . p3 zeigt damit nun auf das zweite Objekt. Nun zeigen p2 und p3 auf dasselbe Objekt. Nun ist es also egal, ob man p2 oder p3 schreibt, beide zeigen auf dasselbe - das \"zweite\" - Objekt. Auf das \"erste\" Objekt zeigt nur noch p1 . Eine weitere Referenz \u00e4ndern Nun lassen wir auch noch p1 auf das zweite Objekt zeigen. public void start () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 3 , 4 ); Point p3 = p1 ; p3 = p2 ; p1 = p2 ; // exakt gleich zu p1 = p3; } Die nun entstandene Situation l\u00e4sst sich wie folgt veranschaulichen: Der entscheidende Punkt ist nun der, dass es auf das erste Objekt keine Referenz mehr gibt. Damit ist das Objekt f\u00fcr uns verloren - wir haben keinen Zugriff mehr darauf! Was passiert mit einem solchen Objekt? Es wird aus dem Speicher gel\u00f6scht. Dies erfolgt automatisch. Die Laufzeitumgebung erkennt solche Objekte, auf die keine Referenz mehr zeigt. Die sogenannte Garbage Collection gibt diesen Speicher wieder f\u00fcr die weitere Verwendung frei. In Java m\u00fcssen wir uns - im Gegensatz zu anderen Programmiersprachen - nicht um die Speicherfreigabe k\u00fcmmern. Das erfolgt im Hintergrund und ganz automatisch. Neben der \u00c4nderung einer Referenz kann eine Referenzvariable auch aufh\u00f6ren, zu existieren und damit ist ein Objekt ohne Referenz. Das folgende Beispiel zeigt einen solchen Fall: public void createPoint () { Point p = new Point ( 3 , 4 ); } public void start () { createPoint (); } In der start() -Methode wird die createPoint() -Methode aufgerufen. Darin wird eine Referenz p erzeugt und ein Point -Objekt. p zeigt auf dieses Objekt. Sobald die Methode abgearbeitet ist und verlassen wird, h\u00f6rt die lokale Variable p jedoch auf zu existieren. Sie wird aus dem Stack gel\u00f6scht. Somit ist das Point -Objekt im Heap ohne eine Referenz und muss von der Garbage Collection entsorgt werden. Erweitern Sie obiges Programm so, dass eine Referenz auf das Point -Objekt nicht verloren geht Der null -Wert \u00b6 Zeigt eine Referenzvariable auf kein Objekt, so ist ihr Wert null . Beispiel: public void start () { Point p1 ; // p1 hat den Wert null } Die Referenzvariable p1 vom Typ Point existiert bereits, aber es existiert (noch) kein Point -Objekt, auf das sie zeigt. Somit ist der \"Wert\" der Referenzvariable p1 null . Referenzvariablen k\u00f6nnen auch explizit auf null gesetzt werden: public void start () { Point p1 = new Point ( 3 , 4 ); // Point-Objekt existiert, p1 zeigt auf das Point-Objekt p1 = null ; // p1 zeigt auf kein Objekt (mehr) - das Point-Objekt wird von der GC entsorgt } Im oberen Beispiel wurde die p1 -Referenzvariable vom Typ Point deklariert und ein Point -Objekt. Die p1 -Variable referenziert (zeigt auf) das Point -Objekt. Danach wird p1 explizit der \"Wert\" null zugeordnet. Die p1 -Variable zeigt auf kein Point -Objekt mehr. Da das Point -Objekt nun keine Referenz mehr auf sich hat (und somit nicht mehr verwendet werden kann), wird es durch die Garbage Collection entsorgt. Referenzvergleiche mit == \u00b6 Wir kennen den Operator == als logischen Vergleichsoperator von Werten, z.B. k\u00f6nnen wir int -Werte damit vergleichen oder char -Werte oder boolean -Werte usw. Der Vergleichsoperator == kann auch f\u00fcr Referenzvergleiche verwendet werden, aber Achtung! , es handelt sich dann ausschlie\u00dflich um Referenzvergleiche und nicht um eine Gleichheit von Objekten (dazu verwenden wir sp\u00e4ter equals() ). Beispiele: public void start () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 3 , 4 ); Point p3 = p1 ; System . out . println ( p1 == p2 ); // false - nicht die gleiche Referenz (zwei verschiedene Objekte) System . out . println ( p1 == p3 ); // true - die gleiche Referenz (ein Objekt) Point p4 ; System . out . println ( p4 == null ); // true - keine Referenz auf ein Objekt System . out . println ( p1 != null ); // true - Referenz auf ein Objekt, deshalb ungleich null } Es ist eigentlich ung\u00fcnstig, den Gleichheitsoperator == von Werten auch f\u00fcr Referenzen zu verwenden, da dies am Anfang verwirrend sein kann. Wichtig ist, dass der \"Wert\" einer Referenz die Referenz(-adresse) auf ein Objekt ist. Haben zwei Referenzvariablen den gleichen \"Wert\", dann zeigen sie auf dasselbe Objekt (und somit ist == true ). Der Gleichheitsoperator == pr\u00fcft nicht die Gleichheit von Objekten (z.B. beide x -variablen 3 und beide y -Variablen 4 - das erledigen wir sp\u00e4ter, indem wir die equals() -Methode \u00fcberschreiben)! Wird der Vergleichsoperator == f\u00fcr Referenztypen verwendet, so wird nur die Gleichheit von Referenzen verglichen, nicht aber die Gleichheit von Objekten! Success Wir haben zwei Aspekte diskutiert, die beide sehr wichtig f\u00fcr das Verst\u00e4ndnis der objektorientierten Programmierung sind. Einerseits den Unterschied zwischen Werte- und Referenztypen und andererseits, dass ein Objekt aufh\u00f6rt, zu existieren, sobald es keine Referenz mehr gibt, die auf dieses Objekt zeigt. Insbesondere das Verst\u00e4ndnis \u00fcber den Unterschied zwischen Werte- und Referenztypen ist wirklich wichtig, um die Konzepte der objektorientierten Programmierung gut verstehen zu k\u00f6nnen! Ein Point -Objekt besteht z.B. aus zwei int -Variablen ( x und y ) und ben\u00f6tigt somit 2 x 32Bit, also 64Bit. \u21a9","title":"Methodenstack"},{"location":"methodenstack/#methodenstack","text":"Programme und die dazugeh\u00f6rigen Variablen (und deren Werte) befinden sich zur Ausf\u00fchrung im Arbeitsspeicher. Der Speicher ist in Bl\u00f6cke (Bytes) unterteilt, die jeweils adressierbar sind. So k\u00f6nnte alles jeweils eine Adresse zugeordnet werden und mit einer komplexen Adressverwaltung lie\u00dfen sich die Einzelteile ansprechen. Das ist jedoch viel zu aufwendig und inperformant. Deshalb werden Speichermodelle verwendet, die die Verwaltung der Programmteile erleichtern. Ein solches Speichermodell ist der Stack ( Stapelspeicher ). Bei einem Stack gilt das Last in first out (LIFO) Prinzip, also das, was zuletzt in den Stack kam, muss auch als erstes wieder hinaus. tats\u00e4chlich gibt es nur ganz wenige Funktionalit\u00e4ten, um einen solchen Stack zu verwalten: push : Element oben auf den Stack hinzuf\u00fcgen pop : Element von oben aus dem Stack entfernen top (manchmal auch peek genannt): auf oberes Element zugreifen (lesen, aber im Stack belassen) Folgende Abbildung stellt diese Methoden grafisch dar: F\u00fcr einen solchen Stack gibt es jetzt nur drei M\u00f6glichkeiten: Element E kann gelesen werden (aber im Stack belassen) - top Element E kann aus dem Stack entfernt werden - pop ein neues Element (z.B. F ) kann zum Stack hinzugef\u00fcgt werden - push (dann kann auch E nicht mehr gelesen werden; so wie bereits A - D )","title":"Methodenstack"},{"location":"methodenstack/#abarbeitung-von-methoden","text":"Wir betrachten das Speichermodell Stack , weil die Abarbeitung von Methoden nach diesem Prinzip funktioniert. Methoden, die abgearbeitet (aufgerufen) werden, werden in einem solchen Stack angeordnet. Wir betrachten ein Beispiel: Methodenstack.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Methodenstack { public void a ( int vaa ) { int vab = 1 ; System . out . println ( \"+--a() --> vaa = \" + vaa + \" vab = \" + vab ); b ( vaa , vab ); } public void b ( int vba , int vbb ) { System . out . println ( \"+----b() --> vba = \" + vba + \" vbb = \" + vbb ); System . out . println (); } public void start () { for ( int va = 0 ; va < 3 ; va ++ ) { System . out . println ( \"start() --> va = \" + va ); a ( va ); } } } In diesem Beispiel gibt es drei Methoden: die start() -Methode mit der Variablen va , die a() -Methode mit den Variablen vaa und vab und die b() -Methode mit den Variablen vba und vbb . Die start() -Methode ruft die Methode a() auf und die a() -Methode ruft die b() -Methode auf. Die Ausgabe des Programms ist wie folgt: start () --> va = 0 +--a () --> vaa = 0 vab = 1 +----b () --> vba = 0 vbb = 1 start () --> va = 1 +--a () --> vaa = 1 vab = 1 +----b () --> vba = 1 vbb = 1 start () --> va = 2 +--a () --> vaa = 2 vab = 1 +----b () --> vba = 2 vbb = 1 Die start() -Methode ruft also drei Mal (innerhalb der Schleife) die a() -Methode auf, welche wiederum die b() -Methode aufruft. Bei dem Aufruf von Methoden passiert folgendes: bei jedem Methodenaufruf wird eine Methodeninstanz auf den Stack gelegt eine Methodeninstanz sind alle zur Laufzeit ver\u00e4nderlichen Daten, die zur Methode geh\u00f6ren (Parameter und lokale Variablen) nach Abarbeitung der Methode (oft durch return - muss aber nicht, wie in unserem Beispiel) wird die Methodeninstanz wieder aus dem Stack entfernt (und somit auch alle dazu geh\u00f6renden Daten (Parameter, lokale Variablen und deren Werte)) In unserem Beispiel passiert also folgendes: Die start() -Methode wird ausgef\u00fchrt; die Variable va wird erzeugt und bekommt den Wert 0 . Die start() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 0 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 0 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von start() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 1 . Die Variable va hat nun den Wert 1 . Die start() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 1 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 1 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von start() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 2 . Die Variable va hat nun den Wert 2 . Die start() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 2 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 2 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von start() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 3 . Die Bedingung der Schleife va<3 ist somit false . Die Schleife wird verlassen, keine weitere Anweisung in start() . Die Abarbeitung des Programms ist zu Ende. Alles, was mit der start() -Methode zu tun hat, insb. Variable va wird aus dem Speicher gel\u00f6scht.","title":"Abarbeitung von Methoden"},{"location":"methodenstack/#lebensdauer-und-sichtbarkeit-von-lokalen-variablen","text":"Die Variablen, die wir bis jetzt verwendet haben, wurden in Methoden deklariert oder in Anweisungsbl\u00f6cken, die in Methoden liegen (z.B. in for -Schleifen). Bei solchen Variablen sprechen wir von lokalen Variablen. Wir werden sp\u00e4ter noch globale Variablen kennenlernen. Zun\u00e4chst interessieren uns aber nur die lokalen Variablen. Das obige Beispiel zeigt, dass lokale Variablen, also solche, die in Methoden deklariert werden, nur so lange existieren , wie diese Methode ausgef\u00fchrt wird. Generell gilt: Eine Variable existiert in dem Anweisungsblock, in dem sie deklariert wurde, solange dieser Anweisungsblock ausgef\u00fchrt wird. Schauen wir uns dazu die Situationen in dem oberen Beispiel an: Die Variable va wird in der start() -Methode deklariert. Die start() -Methode wird die ganze Zeit ausgef\u00fchrt. Also existiert auch die Variable va die gesamte Zeit des Programmablaufs. Die Variablen vaa und vab werden in der a() -Methode deklariert. Sie existieren immer nur dann, wenn die a() -Methode ausgef\u00fchrt wird. In unserem Beispiel existieren die Variablen vaa und vab also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollst\u00e4ndig gel\u00f6scht). Da die Methode a() die Methode b() aufruft, existieren die Variablen vaa und vab auch w\u00e4hrend der Ausf\u00fchrung von b() , da zur Zeit der Ausf\u00fchrung von b() ja auch a() ausgef\u00fchrt wird (und start() ). Die Variablen vba und vbb werden in der b() -Methode deklariert. Sie existieren immer nur dann, wenn die b() -Methode ausgef\u00fchrt wird. In unserem Beispiel existieren die Variablen vba und vbb also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollst\u00e4ndig gel\u00f6scht). Die Lebensdauer eine Variable wird somit von der Ausf\u00fchrungsdauer des Anweisungsblockes bestimmt, in dem die Variable deklariert wurde. Lebensdauer Es ist eine g\u00e4ngige Praxis, alle Variablen, die man in einer Methode verwenden m\u00f6chte, am Anfang der Methode zu deklarieren. Erstens sieht man dann, welche Variablen innerhalb der Methode alle verwendet werden und zweitens kann man diese Variablen in allen Anweisungsbl\u00f6cken innerhalb der Methode verwenden. Einzige Ausnahme stellen Laufvariablen der for -Schleifen dar. Diese werden h\u00e4ufig direkt in der for -Schleife deklariert ( for(int i=0, i<10; i++){} ). Sie existieren dann aber auch nur in dieser for -Schleife! Au\u00dferhalb der for -Schleife existiert diese Variable dann nicht (mehr)! Das bedeutet auch, dass wenn Sie diese Variable in einer anderen for -Schleife verwenden wollen, m\u00fcssen Sie sie dort erneut deklarieren. Unter Sichtbarkeit einer Variablen versteht man die M\u00f6glichkeit, auf diese Variable zuzugreifen (also ihr entweder einen neuen Wert zuzuweisen oder ihren Wert auszulesen). Generell gilt: Eine lokale Variable ist in dem Anweisungsblock sichtbar, in dem sie deklariert wird und in allen Anweisungsbl\u00f6cken, die sich in diesem Anweisungsblock befinden. Au\u00dferhalb des Anweisungsblockes, in dem die Variable deklariert wurde, ist die Variable nicht sichtbar. Das hei\u00dft f\u00fcr unser Beispiel, dass die Variable va nur in der start() -Methode sichtbar ist (also nur dort auf sie zugegriffen werden kann/sie nur dort verwendet werden kann), die Variablen vaa und vab nur in der a() -Methode verwendet werden k\u00f6nnen (sichtbar sind) und die Variablen vba und vbb nur in b() . Sichtbarkeit Der Vorteil dieser lokalen Sichtbarkeit besteht darin, dass man sich z.B. keine Sorgen machen muss, ob eine gleichnamige Variable evtl. bereits in einer anderen Methode deklariert wurde. Eine Variable darf ja immer nur einmal deklariert werden. Da alle anderen Variablen aber nicht in der eigenen Methode sichtbar sind, gibt es keinerlei Konflikte mit anderen lokalen Variablen. Die lokalen Variablen aus anderen Methoden haben mit den Variablen aus der eigenen Methode gar nichts zu tun. Au\u00dferdem ist es auch nicht m\u00f6glich, einfach Werte von Variablen aus anderen Methoden zu schreiben oder zu lesen. Das w\u00fcrde ansonsten gro\u00dfe Sicherheitsprobleme mit sich bringen und man k\u00f6nnte Programme auch leicht zum Absturz bringen.","title":"Lebensdauer und Sichtbarkeit von lokalen Variablen"},{"location":"methodenstack/#werte-vs-referenztypen","text":"Es ist ganz wichtig, zu verstehen, dass es ganz wesentliche Unterschiede zwischen Werte- und Referenztypen gibt. Einige der Unterschiede sind in der folgenden Tabelle aufgelistet: Wertetypen Referenztypen Beispiele int , double , boolean , char , long , float , byte , short String , Point , Triangle , Circle , Adresse , System , ... neue erzeugbar? nein ja - einfach eigene Klasse erstellen Was ist der \"Wert\" einer Variablen? ein Wert ( 5 , true , 1.234 , 'a' , ...) die Referenz auf ein Objekt Manipulation von Werten mit Operatoren ( + , == , && , ...) mit Methoden variable1 = variable2; Kopie des Wertes ( variable1 hat den Wert und variable2 hat den Wert) Kopie der Referenz auf das Objekt (beide Variablen zeigen auf das gleiche Objekt) Insbesondere den letzten Punkt wollen wir uns genauer anschauen. Zun\u00e4chst Wertetypen. Angenommen, wir haben folgende Anweisungen: int a = 5 ; int b = a ; Nach Abarbeitung dieser Anweisungen hat sowohl die Variable a den Wert 5 als auch die Variable b . Wenn wir nun a=6; setzen, dann hat a den Wert 6 und b immer noch den Wert 5 . Der Wert einer Variablen von einem Wertetyp kann sich nur durch den Zuweisungsoperator = \u00e4ndern! Folgende Abbildung zeigt die Verwaltung der beiden int -Variablen a und b im Speicher: Die Zahlen in den K\u00e4stchen unter a und b stehen f\u00fcr Speicheradressen. Das Gute an Java ist, dass wir uns um solche Adressen nicht k\u00fcmmern m\u00fcssen. Wir greifen auf die Werte von a und b einfach \u00fcber die Variablennamen a und b zu. Die Speicherdressen interessieren uns dabei (zum Gl\u00fcck) gar nicht. Wichtig ist, dass jede Variable ihren eigenen Wert hat. Wenn wir den Wert von a \u00e4ndern, \u00e4ndert sich nur der Wert von a , wenn wir den Wert von b \u00e4ndern, \u00e4ndert sich nur der Wert von b . Dabei ist ganz egal, ob b den Wert 5 durch die Wertzuweisung b=5; erhalten hat oder durch b=a; , wobei a den Wert 5 hatte. Anders ist es bei Referenzvariablen, also bei Variablen, die von einem Referenztyp sind. Nehmen wir z.B. unsere Klasse Point und f\u00fchren folgende Anweisungen aus: Point p1 = new Point ( 3 , 4 ); Point p2 = p1 ; Hier gibt es genau ein Objekt, n\u00e4mlich das Objekt, in dem die Objektvariablen x und y den Wert 3 bzw. 4 haben. Die beiden Variablen p1 und p2 referenzieren das gleiche Objekt, d.h. sie zeigen darauf. Die folgende Abbildung verdeutlicht diesen Fall: Beide Variablen p1 und p2 zeigen auf dasselbe Objekt. Es gibt ja auch nur ein Objekt. Ein Objekt kann nur durch new und die Angabe des Konstruktors erzeugt werden. Das passiert hier genau einmal. W\u00e4hrend also bei int b = a; eine Kopie des Wertes erfolgt, erfolgt bei Point p2 = p1; eine Kopie der Referenz (aber keine Kopie des Objektes!). Wichtig ist jetzt noch zu wissen, dass wir auf die Objekteigenschaften des Point -Objektes sowohl \u00fcber die Referenz p1 als auch \u00fcber die Referenz p2 zugreifen k\u00f6nnen, d.h. dass z.B. p1.print() und p2.print() exakt die gleiche print() -Methode aufrufen, n\u00e4mlich die des obigen Point -Objektes. Sowohl p1.getX() als auch p2.getX() geben 3 zur\u00fcck, da sie den Wert derselben Objektvariablen x abfragen. Wenn mehrere Referenzen auf dasselbe Objekt existieren, ist es egal, \u00fcber welche Referenz wir auf die Objekteigenschaften zugreifen; es handelt sich um genau ein Objekt (mit mehreren Referenzen darauf). Wir m\u00fcssen nun also wissen, dass bei den folgenden Anweisungen int a = 5 ; int b = a ; b = 4 ; System . out . println ( a ); der Wert von a ausgegeben wird und der ist 5 , denn es gibt genau eine Wertzuweisung f\u00fcr a und das ist a=5; . Es spielt gar keine Rolle, ob b seinen Wert zwischendurch \u00e4ndert oder nicht - bei der Anweisung b = a; ist der Wert 5 kopiert worden und der Wert von a ist danach v\u00f6llig unabh\u00e4ngig von b und umgedreht. Wir m\u00fcssen nun auch wissen, dass bei den folgenden Anweisungen Point p1 = new Point ( 3 , 4 ); Point p2 = p1 ; p2 . translate ( 1 , 2 ); System . out . println ( p1 . getX ()); der Wert der Objektvariablen x des einen Objektes ausgegeben wird, das existiert. Durch die translate() -Methode ist der x -Wert des Objektes nun 4 (und der y -Wert ist 6 ). Das hei\u00dft, es wird eine 4 ausgegeben. Dabei ist v\u00f6llig egal, ob die translate() -Methode \u00fcber die Referenz p1 oder \u00fcber die Referenz p2 aufgerufen wird und es ist auch v\u00f6llig egal, ob die print() -Methode \u00fcber die Referenz p1 oder \u00fcber die Referenz p2 aufgerufen wird. Beide referenzieren dasselbe Objekt.","title":"Werte- vs. Referenztypen"},{"location":"methodenstack/#arrays-sind-auch-objekte","text":"Schauen wir uns folgenden Fall an: int [] a1 = { 3 , 4 }; int [] a2 = a1 ; a2 [ 1 ] = 5 ; System . out . println ( a1 [ 1 ] ); Arrays sind (auch) Objekte. Also haben wir hier den gleichen Fall, wie bene bei Point . Auch referenzieren sowohl a1 als auch a2 dasselbe Array (es gibt ja nur eins). Wenn wir also \u00fcber die Referenz a2 den zweiten Wert im Array auf 5 setzen und wir danach \u00fcber die Referenz a1 den zweiten Wert dieses Array auslesen, dann ist er 5 . Sie werden sich jetzt sicherlich fragen, warum wir uns \u00fcberhaupt Kopien der Referenzen machen - das ist doch nur verwirrend. Die Antwort ist, dass dieser Fall sogar sehr oft vorkommt, n\u00e4mlich immer genau dann, wenn wir Referenzen von Objekten als Parameter \u00fcbergeben. Schauen wir uns folgendes Beispiel an: 1 2 3 4 5 6 7 8 9 public static void swap ( int [] arr , int index1 , int index2 ) { if ( index1 >= 0 && index1 < arr . length && index2 >= 0 && index2 < arr . length ) { int tmp = arr [ index1 ] ; arr [ index1 ] = arr [ index2 ] ; arr [ index2 ] = tmp ; } } Diese Methode implementiert das Vertauschen zweier Elemente in einem int -Array. So, wie wir es z.B. in vielen Sortieralgorithmen ben\u00f6tigen. Die Werte der Elemente an den Indizes index1 und index2 werden miteinander getauscht. Wir speichern den einen Wert zwischen, damit wir ihn nicht \u00fcberschreiben. Es wird vorab gepr\u00fcft, ob die beiden Indizes index1 und index2 \u00fcberhaupt im Array arr existieren. Angenommen, wir haben nun in der start() -Methode (oder einer anderen Methode) folgende Anweisungen 1 2 3 4 5 6 int [] a1 = { 1 , 2 , 3 , 4 , 5 }; swap ( a1 , 0 , 1 ); // Uebergabe der Referenz auf das Array for ( int i = 0 ; i < a1 . length ; i ++ ) { System . out . println ( a1 [ i ] + \" \" ); } , dann ist die Ausgabe 2 1 3 4 5 Wir \u00fcbergeben bei Aufruf der Methode swap(a1, 0, 1); die Referenz auf das Array und in der Methode wird die lokale Variable arr mit genau dieser Referenz initialisiert, d.h. es existieren dann zwei Referenzen auf das Array! Die Referenz arr innnerhalb der swap() -Methode und die Referenz a1 innerhalb der start() -Methode. Zwei Referenzen, aber nur ein Objekt! L\u00f6sen Sie die folgenden \u00dcbungsaufgaben durch \u00dcberlegen! Was wird ausgegeben? (start() wird ausgef\u00fchrt) public void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } public void start () { int a = 3 ; int b = 4 ; swap ( a , b ); System . out . println ( a ); } Was wird ausgegeben? I.java public class I { private int o ; public I ( int o ) { this . o = o ; } public int getO () { return this . o ; } public void add1 () { o ++ ; } } TestI.java public void doSomething ( I i2 ) { i2 . add1 (); } public void start () { I i1 = new I ( 1 ); I i2 = i1 ; i2 . add1 (); I i3 = i1 ; doSomething ( i3 ); System . out . println ( i1 . getO ()); System . out . println ( i2 . getO ()); System . out . println ( i3 . getO ()); }","title":"Arrays sind (auch) Objekte!"},{"location":"methodenstack/#das-leben-der-objekte","text":"Wir haben uns bereits eingehend mit der Lebensdauer und der Sichtbarkeit von lokalen Variablen besch\u00e4ftigt. Es ist dabei \u00fcbrigens gaz egal, ob es sich um Variablen von einem Werte- oder einem Referenztyp handelt. Auf die Lebensdauer und Sichtbarkeit hat das keinen Einfluss. Wir wissen auch bereits, dass Objektvariablen f\u00fcr jeweils ein Objekt existieren. Die Lebensdauer einer Objektvariablen entspricht also der Lebensdauer ihres Objektes. Wir wissen auch \u00fcber die Sichtbarkeit der Objektvariablen Bescheid, denn sie sind in der gesamten Klasse sichtbar, in der sie deklariert werden, also auch in allen Methoden dieser Klasse. Ob sie dar\u00fcber hinaus auch \u00fcber eine Referenz auf ein Objekt in anderen Klassen sichtbar sind, h\u00e4ngt vom Sichtbarkeitsmodifizierer ab. Normalerweise nicht, denn wir deklarieren alle Objektvariablen als private . Wir wollen nun untersuchen, wie lange Objekte existieren. Wir wissen bereits, dass ihre Existenz mit der Anweisung new gefolgt vom Konstruktor beginnt. Wir haben gelernt, dass Methoden in einem sogenannten Stack abgearbeitet werden und dass in diesem Stack auch die lokalen Variablen existieren - und zwar so lange, so lange die Methode abgearbeitet wird, also im Stack existiert. Sichtbar sind jedoch nur die lokalen Variablen, die zur Methode geh\u00f6ren, die im Stack ganz oben liegt, also gerade abgearbeitet wird. Objekte werden nicht im Stack abgelegt. Der Speicherbereich f\u00fcr Objekte nennt sich Heap . Wir wollen auf die Speicherstruktur des Heap gar nicht weiter eingehen, wichtig ist nur, dass bei Erzeugung eines Objektes Speicherplatz im Heap f\u00fcr das Objekt reserviert wird. Die Gr\u00f6\u00dfe des reservierten Speicherplatzes bestimmt der Konstruktor und ist von den Objektvariablen des Objektes abh\u00e4ngig, also von der Gr\u00f6\u00dfe und der Anzahl der Objektvariablen 1 . Die Objektvariablen existieren auf dem Heap. Lebt das Objekt nicht mehr, wird der Speicherplatz auf dem Heap (automatisch) freigegeben. Wir wissen, wann Objekte anfangen, zu existieren (wenn sie erzeugt werden), aber wann h\u00f6ren Sie auf, zu existieren? Wir betrachten \"das Leben\" eines Objektes am Beispiel eines Point -Objektes: Objekt-Referenz deklarieren public void start () { Point p1 ; } Damit ist bereits eine Referenz mit dem Namen p1 auf ein Point -Objekt definiert. Das Objekt existiert aber noch gar nicht! Aber es sind schonmal 64Bit im Heap reserviert. Die (Referenz-)Variable p1 ist eine lokale Variable der Methode start() . p1 ist nur in der start() -Methode sichtbar, sie existiert so lange, solange start() ausgef\u00fchrt wird und sie existiert im Stack . Objekt erzeugen public void start () { Point p1 = new Point ( 3 , 4 ); } Jetzt existiert ein Point -Objekt! Es wird im Heap abgelegt. Insbesondere werden die Objektvariablen x und y im Heap abgelegt und bekommen die Werte 3 und 4 . Jetzt gibt es eine Referenzvariable p1 im Stack und ein Objekt mit Objektvariablen im Heap. Durch den Zuweisungsoperator = werden die beiden miteinander verbunden, d.h p1 zeigt jetzt auf das Point -Objekt. An dieser Stelle ist es schonmal sinnvoll zu betonen, dass die einzige M\u00f6glichkeit, auf das Point -Objekt zuzugreifen, derzeit \u00fcber die p1 -Variable existiert. G\u00e4be es diese Variable nicht, h\u00e4tten wir keinen Zugriff auf das Objekt! Ein weiteres Objekt und eine Referenz darauf erzeugen Wir erzeugen zur Veranschaulichung ein weiteres Objekt und die Referenzvariable p2 , die darauf zeigt. public void start () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 3 , 4 ); } Jetzt existieren zwei Point -Objekte im Heap und zwei Referenzvariablen p1 und p2 , die jeweils auf eines der beiden Objekte zeigen. p1 und p2 sind lokale Variablen der start() -Methode und existieren im Stack. Beachten Sie, dass die beiden Objekte zwar Objektvariablen haben, die gleiche Werte aufweisen, aber es handelt sich um zwei (verschiedene) Objekte! Eine weitere Referenz erzeugen Jetzt erzeugen wir noch eine weitere Referenz auf das erste Point -Objekt. Wir nennen die Referenzvariable p3 . public void start () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 3 , 4 ); Point p3 = p1 ; } Diese Situation l\u00e4sst sich so veranschaulichen: Auf das erste Objekt existieren also gleich zwei Referenzen. \u00dcber beide Referenzen kann mittels Punktnotation auf das Objekt (dessen Objekteigenschaften) zugegriffen werden. Es ist also egal, ob man p1 oder p3 schreibt, beide zeigen auf das gleiche Objekt. Eine Referenz \u00e4ndern Wir \u00e4ndern nun die soeben erstellte Referenz und lassen sie nun auf das zweite Objekt zeigen: public void start () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 3 , 4 ); Point p3 = p1 ; p3 = p2 ; } p3 darf nat\u00fcrlich nicht erneut deklariert werden. Wir kopieren die Referenz von p2 nach p3 . p3 zeigt damit nun auf das zweite Objekt. Nun zeigen p2 und p3 auf dasselbe Objekt. Nun ist es also egal, ob man p2 oder p3 schreibt, beide zeigen auf dasselbe - das \"zweite\" - Objekt. Auf das \"erste\" Objekt zeigt nur noch p1 . Eine weitere Referenz \u00e4ndern Nun lassen wir auch noch p1 auf das zweite Objekt zeigen. public void start () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 3 , 4 ); Point p3 = p1 ; p3 = p2 ; p1 = p2 ; // exakt gleich zu p1 = p3; } Die nun entstandene Situation l\u00e4sst sich wie folgt veranschaulichen: Der entscheidende Punkt ist nun der, dass es auf das erste Objekt keine Referenz mehr gibt. Damit ist das Objekt f\u00fcr uns verloren - wir haben keinen Zugriff mehr darauf! Was passiert mit einem solchen Objekt? Es wird aus dem Speicher gel\u00f6scht. Dies erfolgt automatisch. Die Laufzeitumgebung erkennt solche Objekte, auf die keine Referenz mehr zeigt. Die sogenannte Garbage Collection gibt diesen Speicher wieder f\u00fcr die weitere Verwendung frei. In Java m\u00fcssen wir uns - im Gegensatz zu anderen Programmiersprachen - nicht um die Speicherfreigabe k\u00fcmmern. Das erfolgt im Hintergrund und ganz automatisch. Neben der \u00c4nderung einer Referenz kann eine Referenzvariable auch aufh\u00f6ren, zu existieren und damit ist ein Objekt ohne Referenz. Das folgende Beispiel zeigt einen solchen Fall: public void createPoint () { Point p = new Point ( 3 , 4 ); } public void start () { createPoint (); } In der start() -Methode wird die createPoint() -Methode aufgerufen. Darin wird eine Referenz p erzeugt und ein Point -Objekt. p zeigt auf dieses Objekt. Sobald die Methode abgearbeitet ist und verlassen wird, h\u00f6rt die lokale Variable p jedoch auf zu existieren. Sie wird aus dem Stack gel\u00f6scht. Somit ist das Point -Objekt im Heap ohne eine Referenz und muss von der Garbage Collection entsorgt werden. Erweitern Sie obiges Programm so, dass eine Referenz auf das Point -Objekt nicht verloren geht","title":"Das \"Leben\" der Objekte"},{"location":"methodenstack/#der-null-wert","text":"Zeigt eine Referenzvariable auf kein Objekt, so ist ihr Wert null . Beispiel: public void start () { Point p1 ; // p1 hat den Wert null } Die Referenzvariable p1 vom Typ Point existiert bereits, aber es existiert (noch) kein Point -Objekt, auf das sie zeigt. Somit ist der \"Wert\" der Referenzvariable p1 null . Referenzvariablen k\u00f6nnen auch explizit auf null gesetzt werden: public void start () { Point p1 = new Point ( 3 , 4 ); // Point-Objekt existiert, p1 zeigt auf das Point-Objekt p1 = null ; // p1 zeigt auf kein Objekt (mehr) - das Point-Objekt wird von der GC entsorgt } Im oberen Beispiel wurde die p1 -Referenzvariable vom Typ Point deklariert und ein Point -Objekt. Die p1 -Variable referenziert (zeigt auf) das Point -Objekt. Danach wird p1 explizit der \"Wert\" null zugeordnet. Die p1 -Variable zeigt auf kein Point -Objekt mehr. Da das Point -Objekt nun keine Referenz mehr auf sich hat (und somit nicht mehr verwendet werden kann), wird es durch die Garbage Collection entsorgt.","title":"Der null-Wert"},{"location":"methodenstack/#referenzvergleiche-mit","text":"Wir kennen den Operator == als logischen Vergleichsoperator von Werten, z.B. k\u00f6nnen wir int -Werte damit vergleichen oder char -Werte oder boolean -Werte usw. Der Vergleichsoperator == kann auch f\u00fcr Referenzvergleiche verwendet werden, aber Achtung! , es handelt sich dann ausschlie\u00dflich um Referenzvergleiche und nicht um eine Gleichheit von Objekten (dazu verwenden wir sp\u00e4ter equals() ). Beispiele: public void start () { Point p1 = new Point ( 3 , 4 ); Point p2 = new Point ( 3 , 4 ); Point p3 = p1 ; System . out . println ( p1 == p2 ); // false - nicht die gleiche Referenz (zwei verschiedene Objekte) System . out . println ( p1 == p3 ); // true - die gleiche Referenz (ein Objekt) Point p4 ; System . out . println ( p4 == null ); // true - keine Referenz auf ein Objekt System . out . println ( p1 != null ); // true - Referenz auf ein Objekt, deshalb ungleich null } Es ist eigentlich ung\u00fcnstig, den Gleichheitsoperator == von Werten auch f\u00fcr Referenzen zu verwenden, da dies am Anfang verwirrend sein kann. Wichtig ist, dass der \"Wert\" einer Referenz die Referenz(-adresse) auf ein Objekt ist. Haben zwei Referenzvariablen den gleichen \"Wert\", dann zeigen sie auf dasselbe Objekt (und somit ist == true ). Der Gleichheitsoperator == pr\u00fcft nicht die Gleichheit von Objekten (z.B. beide x -variablen 3 und beide y -Variablen 4 - das erledigen wir sp\u00e4ter, indem wir die equals() -Methode \u00fcberschreiben)! Wird der Vergleichsoperator == f\u00fcr Referenztypen verwendet, so wird nur die Gleichheit von Referenzen verglichen, nicht aber die Gleichheit von Objekten! Success Wir haben zwei Aspekte diskutiert, die beide sehr wichtig f\u00fcr das Verst\u00e4ndnis der objektorientierten Programmierung sind. Einerseits den Unterschied zwischen Werte- und Referenztypen und andererseits, dass ein Objekt aufh\u00f6rt, zu existieren, sobald es keine Referenz mehr gibt, die auf dieses Objekt zeigt. Insbesondere das Verst\u00e4ndnis \u00fcber den Unterschied zwischen Werte- und Referenztypen ist wirklich wichtig, um die Konzepte der objektorientierten Programmierung gut verstehen zu k\u00f6nnen! Ein Point -Objekt besteht z.B. aus zwei int -Variablen ( x und y ) und ben\u00f6tigt somit 2 x 32Bit, also 64Bit. \u21a9","title":"Referenzvergleiche mit =="},{"location":"object/","text":"Die Klasse Object \u00b6 Die Klasse java.lang.Object ist die Basisklasse (Elternklasse) aller in Java existierenden Klassen. Object wird h\u00e4ufig auch als die Mutter aller Klassen in Java bezeichnet. Eine Klasse kann entweder explizit von einer anderen Klasse erben (mithilfe von extends ) oder sie erbt implizit von der Klasse Object . Das bedeutet, dass jede Klasse von der Klasse Object erbt. Betrachten wir nochmal zur Wiederholung unsere Vererbungshierarchie aus dem vorherigen Abschnitt Vererbung : Dort hatten wir zun\u00e4chst die Klasse Viereck erstellt, die explizit von keiner Klasse geerbt hat. Viereck erbt somit implizit von Object . Die Klasse Rechteck erbt von Viereck und somit auch von Object . Die Klasse Quadrat erbt von Rechteck und somit auch von Viereck und somit auch von Object . Wenn wir uns nun noch daran erinnern, dass wir beim Erstellen der Konstruktoren gesagt haben, dass bei der Objekterzeugung auch immer ein Objekt der Elternklasse erzeugt wird, dann bedeutet das, dass f\u00fcr jedes Objekt auch immer ein Objekt der Klasse Object erzeugt wird. Wenn wir uns nun auch noch daran erinnern, dass in einer Vererbungshierarchie immer die is-a -Relation ( ist ein ) gilt (jedes Rechteck ist ein Viereck , jedes Quadrat ist ein Rechteck ist ein Viereck ), dann gilt dass jedes Objekt auch ein Objekt vom Typ Object ist. Das bedeutet insbesondere, dass jedes Objekt alle Objekteigenschaften (Objektmethoden) der Klasse Object geerbt hat. Jedes Objekt (egal von welchem Referenztyp) ist auch ein Objekt vom Typ Object und hat alle Objektmethoden von Object geerbt. Objektmethoden von Object \u00b6 Jedes Objekt in Java hat also automatisch die Methoden von Object geerbt. Einige davon betrachten wir nun etwas genauer: Objektmethode von Object Bedeutung getClass() gibt den Laufzeittyp der Klasse zur\u00fcck toString() gibt einen String zur\u00fcck \u2192 sollte in jeder Klasse \u00fcberschrieben werden, um eine geeignete textuelle Beschreibung der Objekte zu haben equals(Object) f\u00fcr den Vergleich zweier Objekte \u2192 sollte in jeder Klasse \u00fcberschrieben werden, um Gleichheit von Objekten zu beschreiben (default: Referenzvergleich) hashCode() gibt einen HashCode (ein int ) f\u00fcr ein Objekt zur\u00fcck, wird ben\u00f6tigt zum Einsortieren in hashbasierten Containern \u2192 sp\u00e4ter in Collections clone() gibt eine Kopie (einen Clone) des Objektes zur\u00fcck wait() , notify() , notifyAll() f\u00fcr Threads \u2192 machen wir viel sp\u00e4ter finalize() f\u00fcr die Garbage Collection \u2192 ist seit Java 9 deprecated Die Objektmethoden aus den letzten beiden Zeilen der Tabelle betrachten wir hier nicht weiter. Die anderen Objektmethoden werden im Folgenden genauer untersucht. Wir beginnen mit getClass() . Die Objektmethode getClass() \u00b6 Angenommen, wir haben die Klassen Viereck , Rechteck und Quadrat aus dem vorherigen Kapitel Vererbung gegeben: Viereck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Viereck { protected int a , b , c , d ; // Seiten public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; } public int umfang () { return this . a + this . b + this . c + this . d ; } public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . println ( \" Umfang des Vierecks : \" + this . umfang ()); } } Rechteck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Rechteck extends Viereck { public Rechteck ( int laenge , int breite ) { super ( laenge , breite , laenge , breite ); // Aufruf des Konstruktors von Viereck } /* * neue Objektmethode * spezielle Eigenschaft fuer Rechteck * gilt nicht f\u00fcr Viereck * */ public int flaecheninhalt () { return this . a * this . b ; // Zugriff moeglich wegen protected in Viereck } @Override public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . print ( \" Umfang des Rechtecks : \" + this . umfang ()); System . out . println ( \" Flaecheninhalt des Rechtecks : \" + this . flaecheninhalt ()); } } Quadrat.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Quadrat extends Rechteck { Quadrat ( int seite ) { super ( seite , seite ); // Aufruf des Konstruktors von Rechteck } @Override public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . print ( \" Umfang des Quadrats : \" + this . umfang ()); System . out . println ( \" Flaecheninhalt des Quadrats : \" + this . flaecheninhalt ()); } } Wenn wir nun in z.B. einer main() -Methode folgende Anweisungen haben: 1 2 3 Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); Rechteck r1 = new Rechteck ( 10 , 20 ); Quadrat q1 = new Quadrat ( 30 ); , dann wissen wir, dass v1 vom Typ Viereck ist, r1 vom Typ Rechteck und q1 vom Typ Quadrat . Die Deklarationen dieser Variablen geben den sogenannten Compilertyp an. Und tats\u00e4chlich haben wir ja im obigen Fall auch die dazu passenden Objekte erzeugt, die genau dem jeweiligen Typ entsprechen. Wenn wir nun also jeweils die getClass() -Methode aufrufen, dann bekommen wir die jeweiligen Typen zur\u00fcckgegeben: 1 2 3 4 5 6 Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); Rechteck r1 = new Rechteck ( 10 , 20 ); Quadrat q1 = new Quadrat ( 30 ); System . out . println ( v1 . getClass ()); // von Object geerbt System . out . println ( r1 . getClass ()); // von Viereck -> Object geerbt System . out . println ( q1 . getClass ()); // von Rechteck -> Viereck -> Object geerbt Die Ausgaben sind: class Viereck class Rechteck class Quadrat Wichtig: getClass() gibt jedoch nicht den Compilertyp , sondern den Laufzeittyp zur\u00fcck. Compilertyp vs. Laufzeittyp \u00b6 Was sind Compiler- und Laufzeittypen ? Compilertyp wissen wir schon. Bei der Deklaration einer Variablen geben wir den Compilertypen der Variablen an. Was wir aber auch wissen, ist, dass jedes Rechteck ist auch ein Viereck . Das erlaubt uns, auch Folgendes zu schreiben: 1 Viereck v = new Rechteck ( 10 , 20 ); Jetzt ist v vom (Compiler-)Typ Viereck , aber vom Laufzeittyp Rechteck . Die Referenzvariable v zeigt auf ein Rechteck -Objekt. Mit getClass() erfragen wir den Laufzeittyp , d.h. 1 2 Viereck v = new Rechteck ( 10 , 20 ); // Compilertyp von v ist Viereck System . out . println ( v . getClass ()); // Laufzeittyp von v ist Rechteck erzeugt die Ausgabe class themen.vererbung.Rechteck Wir k\u00f6nnen also auch soetwas machen: 1 2 3 4 5 6 7 8 Viereck [] va = new Viereck [ 3 ] ; va [ 0 ] = new Viereck ( 10 , 20 , 30 , 40 ); // Compilertyp von va[0] ist Viereck, Laufzeittyp ist Viereck va [ 1 ] = new Rechteck ( 10 , 20 ); // Compilertyp von va[1] ist Viereck, Laufzeittyp ist Rechteck va [ 2 ] = new Quadrat ( 15 ); // Compilertyp von va[2] ist Viereck, Laufzeittyp ist Quadrat System . out . println ( va [ 0 ] . getClass ()); // Viereck System . out . println ( va [ 1 ] . getClass ()); // Rechteck System . out . println ( va [ 2 ] . getClass ()); // Quadrat Das bedeutet auch, dass sogar soetwas m\u00f6glich ist: 1 2 3 4 5 6 7 Object o1 = new Viereck ( 10 , 20 , 30 , 40 ); // Compilertyp von o1 ist Object, Laufzeittyp ist Viereck Object o2 = new Rechteck ( 10 , 20 ); // Compilertyp von o2 ist Object, Laufzeittyp ist Rechteck Object o3 = new Quadrat ( 15 ); // Compilertyp von o3 ist Object, Laufzeittyp ist Quadrat System . out . println ( o1 . getClass ()); // Viereck System . out . println ( o2 . getClass ()); // Rechteck System . out . println ( o3 . getClass ()); // Quadrat Der Compilertyp einer (Referenz-)Variablen wird durch die Deklaration bestimmt. Der Laufzeittyp wird bestimmt durch das konkrete Objekt, auf das die Referenzvariable zeigt. Welche Objektmethoden anwendbar? - Typecast \u00b6 Wenn wir schonmal bei der Unterscheidung zwischen Compilertyp und Laufzeittyp sind, dann k\u00f6nnen wir gleich der Frage nachgehen, welche Objektmethoden anwendbar sind. Erinnern wir uns dazu nochmal an die Erweiterung der Klasse Rechteck . Dort hatten wir eine Objektmethode flaecheninhalt() definiert, die in der Klasse Viereck nicht existiert. Wir hatten folgenden Fall: 1 2 3 4 Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); // System.out.println(v1.flaecheninhalt()); // flaecheninhalt() existiert f\u00fcr Viereck nicht Rechteck r1 = new Rechteck ( 10 , 20 ); System . out . println ( r1 . flaecheninhalt ()); // flaecheninhalt() existiert f\u00fcr Rechteck (=200) Wenn wir nun 1 Viereck v = new Rechteck ( 10 , 20 ); haben, v also den Compilertyp Viereck hat und den Laufzeittyp Rechteck . K\u00f6nnen wir dann 1 System . out . println ( v . flaecheninhalt ()); // Fehler! aufrufen? Die Antwort ist nein! Das ist auch insofern logisch, als dass dieser Aufruf ja bereits zum Compilezeit m\u00f6glich sein muss. Dem Typ Viereck steht diese Methode aber nicht zur Verf\u00fcgung. Das geht also nicht. Was wir aber in diesem Fall machen k\u00f6nnen, ist eine explizite Typkonvertierung . 1 2 3 Viereck v = new Rechteck ( 10 , 20 ); Rechteck r = ( Rechteck ) v ; // geht, weil der Laufzeittyp Rechteck ist System . out . println ( r . flaecheninhalt ()); // geht, weil der Compilertyp von r Rechteck ist Nochmal im Detail: In Zeile 1 definieren wir eine Referenzvariable v vom Compilertyp Viereck . In Zeile 2 definieren wir eine Referenzvariable r vom Compilertyp Rechteck . Weil r vom Compilertyp Rechteck ist, k\u00f6nnen wir f\u00fcr r die Objektmethode flaecheninhalt() aufrufen (f\u00fcr v nicht!). Dass die Typkonvertierung in Zeile 2 auch tats\u00e4chlich gelingt, liegt (zur Laufzeit ) daran, dass der Laufzeittyp von v Rechteck ist. W\u00e4re das nicht der Fall, w\u00fcrde die Typkonvertierung scheitern - aber erst zur Laufzeit (mit einer ClassCastException ). instanceof vs. getClass() \u00b6 Wie gesagt, ermitteln wir mit getClass() den Laufzeittypen einer Referenzvariablen. Daf\u00fcr gibt es auch noch ein anderes Schl\u00fcsselwort in Java, n\u00e4mlich instanceof . Das ist ein Operator, mit dessen Hilfe wir einen Vergleich mit Typen anstellen k\u00f6nnen. Zun\u00e4chst ein Beispiel: 1 2 3 4 5 Viereck v = new Viereck ( 10 , 20 , 30 , 40 ); if ( v instanceof Viereck ) { System . out . println ( \"v ist vom Typ Viereck\" ); } In Zeile 2 sehen wir die Anwendung des instanceof -Operators. Er gibt ein boolean zur\u00fcck, je nachdem die Variable vom angegebenen Typen ist oder nicht. Der obige Code erzeugt also die Ausgabe v ist vom Typ Viereck auf der Konsole. Angenommen, wir haben nun folgendes Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Object o = new Quadrat ( 15 ); // Compilertyp Object, Laufzeittyp Quadrat if ( o instanceof Object ) // true { System . out . println ( \"o ist vom Typ Object\" ); } if ( o instanceof Viereck ) // true { System . out . println ( \"o ist vom Typ Viereck\" ); } if ( o instanceof Rechteck ) // true { System . out . println ( \"o ist vom Typ Rechteck\" ); } if ( o instanceof Quadrat ) // true { System . out . println ( \"o ist vom Typ Quadrat\" ); } , dann sind alle Bedingungen true , d.h. es wird folgende Ausgabe erzeugt: o ist vom Typ Object o ist vom Typ Viereck o ist vom Typ Rechteck o ist vom Typ Quadrat instanceof pr\u00fcft also jeden m\u00f6glichen Laufzeittyp (wir wissen ja, dass ein Objekt vom Typ Quadrat ist ein Objekt vom Typ Rechteck ist ein Objekt vom Typ Viereck ist ein Objekt vom Typ Object ). Das gleiche gilt auch f\u00fcr: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Quadrat q = new Quadrat ( 15 ); // Compilertyp Quadrat, Laufzeittyp Quadrat if ( q instanceof Object ) // true { System . out . println ( \"q ist vom Typ Object\" ); } if ( q instanceof Viereck ) // true { System . out . println ( \"q ist vom Typ Viereck\" ); } if ( q instanceof Rechteck ) // true { System . out . println ( \"q ist vom Typ Rechteck\" ); } if ( q instanceof Quadrat ) // true { System . out . println ( \"q ist vom Typ Quadrat\" ); } , dann sind alle Bedingungen true , d.h. es wird folgende Ausgabe erzeugt: q ist vom Typ Object q ist vom Typ Viereck q ist vom Typ Rechteck q ist vom Typ Quadrat Die Methode getClass() liefert also den konkretesten (speziellsten) Laufzeittypen zur\u00fcck. Mit instanceof k\u00f6nnen alle Laufzeittypen abgefragt werden. F\u00fcr eine beliebige Variable var , egal welchen Referenztyps, gilt immer, dass var instanceof Object true ergibt, d.h. jede Referenzvariable ist immer auch vom (Laufzeit-)Typ Object . Die Objektmethode toString() \u00b6 In jeder Klasse, die wir erstellen, erben wir von Object die Objektmethode toString() . Wenden wir diese Methode also einmal f\u00fcr unsere Klasse Viereck an: 1 2 Viereck v = new Viereck ( 10 , 20 , 30 , 40 ); System . out . println ( v . toString ()); Dann erhalten wir eine etwas kryptische Ausgabe: Viereck@279f2327 wobei Viereck f\u00fcr die Klasse steht und @279f2327 scheint irgendeine Referenzadresse zu sein. Interessant an der toString() -Methode ist, dass wir die gleiche Ausgabe auch dann erzielen, wenn wir nur 1 2 Viereck v = new Viereck ( 10 , 20 , 30 , 40 ); System . out . println ( v ); aufrufen, also der Methode System.out.println() nur v und nicht v.toString() \u00fcbergeben. Das liegt daran, dass System.out.println() \u00fcberladen ist und - unter anderem - die beiden Implementierungen System . out . println ( String s ) {} System . out . println ( Object o ) {} existieren. Wenn wir System.out.println(v.toString()); aufrufen, wird die Implementierung von System.out.println(String s) {} verwendet (der String s wird ausgegeben). Wenn wir System.out.println(v); aufrufen, wird die Implementierung von System.out.println(Object o) {} verwendet und dabei wird n\u00e4mlich System.out.println(o.toString()); aufgerufen. Wenn wir nun also die Methode toString() \u00fcberschreiben (ist ja von Object geerbt), dann gewinnen wir zwei Effekte: wir erstellen eine textuelle Repr\u00e4ssentation unserer Objekte und wir m\u00fcssen System.out.println() nur noch die Referenzvariable ref auf unser Obejkt \u00fcbergeben (und nicht ref.toString() ) Erweitern wir also die Klasse Viereck um eine Implementierung der toString() -Methode: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Viereck { protected int a , b , c , d ; // Seiten public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; } public int umfang () { return this . a + this . b + this . c + this . d ; } public void print () { System . out . print ( this . toString ()); // siehe unten System . out . println ( \" Umfang des Vierecks : \" + this . umfang ()); } @Override public String toString () { return \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ; } } Wir verwenden auch hier die @Override -Annotation, um dem Compiler zu sagen, dass wir die toString() -Methode von Object \u00fcberschreiben wollen (nicht, dass wir z.B. ausversehen tostring() schreiben und somit eine neue Objektmethode erstellen). In der toString() -Methode implementieren wir eine geeignete Repr\u00e4sentation des Objektes (hier die Seitenl\u00e4ngen des Vierecks). Nun erzeugen die Anweisungen 1 2 Viereck v = new Viereck ( 10 , 20 , 30 , 40 ); System . out . println ( v ); // entspricht System.out.println(v.toString()); eine deutlich bessere Ausgabe, n\u00e4mlich [ a = 10 , b = 20 , c = 30 , d = 40 ] Wir sollten uns angew\u00f6hnen, die toString() -Methode immer , d.h. in allen Klassen, die wir erstellen, zu \u00fcberschreiben! Die Objektmethode equals() \u00b6 Wir wiederholen zun\u00e4chst nochmal in K\u00fcrze den Abschnitt \u00fcber Referenzvergleiche von Objekten . Angenommen, wir haben folgende Vierecke: Viereck v3 = new Viereck ( 10 , 20 , 30 , 40 ); Viereck v4 = new Viereck ( 10 , 20 , 30 , 40 ); System . out . println ( v3 == v4 ); // Referenzvergleich!! false - zwei Objekte Wir k\u00f6nnten auf die Idee kommen, dass v3==v4 true ergibt, weil f\u00fcr uns die beiden Objekte von Viereck gleich sind. Aber woher soll der Compiler oder die Laufzeitumgebung wissen , dass diese Viereck -Objekte gleich sind? Der Operator == vergleicht nur die Referenzen und ist false , wenn die Referenzen auf zwei verschiedene Objekte zeigen. Mithilfe der equals() -Methode k\u00f6nnen wir definieren, wann Objekte der Klasse gleich sein sollen. Wir k\u00f6nnen aber nicht den Operator == \u00fcberschreiben. Dieser bleibt f\u00fcr Referenztypen immer ein Referenzvergleich! Wir wollen unsere Klasse Viereck also um eine equals() -Methode erweitern und in dieser equals() -Methode festlegen, wann zwei Viereck -Objekte gleich sein sollen (wenn ihre Seitenl\u00e4ngen gleich sind). Wir versuchen folgendes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Viereck { protected int a , b , c , d ; // Seiten public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; } public int umfang () { return this . a + this . b + this . c + this . d ; } public void print () { System . out . print ( this . toString ()); // siehe unten System . out . println ( \" Umfang des Vierecks : \" + this . umfang ()); } @Override public String toString () { return \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ; } @Override public boolean equals ( Viereck v ) { // Implementierung von equals() } } Das f\u00fchrt leider zu einem Fehler. Der Compiler beschwert sich dar\u00fcber, dass wir die geerbte equals() -Methode so gar nicht \u00fcberschreiben. Tats\u00e4chlich erben wir nicht equals(Viereck v) , sondern equals(Object o) (woher sollte Object auch Viereck kennen?). Wir m\u00fcssen also folgende Methode \u00fcberschreiben: @Override public boolean equals ( Object o ) { // Implementierung von equals() } Nat\u00fcrlich erwarten wir, dass sich das aufrufende Viereck mit einem anderen Viereck vergleicht. Die Methode ist aber so implementiert, dass jedes beliebige Objekt als Parameter \u00fcbergeben werden kann. Theoretisch w\u00e4re also z.B. folgender Aufruf m\u00f6glich: Viereck v = new Viereck ( 10 , 20 , 30 , 40 ); Point p = new Point ( 3 , 4 ); Systems . out . println ( v . equals ( p )); Das soll nat\u00fcrlich false ergeben. Die Implementierung von equals(Object o) muss folgende Bedingungen erf\u00fcllen: Null-Akzeptanz: f\u00fcr jede Referenz x ungleich null liefert x.equals(null) den Wert false Reflexivit\u00e4t: f\u00fcr jede Referenz x ungleich null liefert x.equals(x) den Wert true Symmetrie: wenn x.equals(y) true ergibt, dann muss auch y.equals(x) true ergeben (und umgedreht) Transitivit\u00e4t: wenn x.equals(y) und y.equals(z) jeweils true ergeben, dann muss auch x.equals(z) true ergeben Konsistenz: der Aufruf x.equals(y) muss immer den gleichen Wert ergeben Das h\u00f6rt sich komplizierter an, als es ist. Wir werden sehen, dass wir bei der Implementierung von equals(Object o) immer gleich vorgehen. Wir f\u00fchren zun\u00e4chst ein paar Pr\u00fcfungen durch: pr\u00fcfen, ob null -Referenzen vorliegen \u2192 (wenn ja, dann false ) pr\u00fcfen, ob keine identischen Objekte verglichen werden (dasselbe Objekt vergleicht sich mit sich selbst) \u2192 (wenn ja, dann true ) pr\u00fcfen, ob Objekte des gew\u00fcnschten Typs verglichen werden \u2192 (wenn nein, dann false ) 1 2 3 4 5 6 7 8 9 10 11 12 @Override public boolean equals ( Object other ) { if ( other == null ) return false ; // Null-Akzeptanz if ( this == other ) return true ; // Reflexivit\u00e4t if ( this . getClass () != other . getClass ()) return false ; // ungleiche Typen // wenn wir hier die Methode noch nicht verlassen haben, dann // wissen wir, dass other vom Typ Viereck ist und auf ein // Viereck-Objekt zeigt } in Zeile 4 pr\u00fcfen wir, ob das als Parameter \u00fcbergebene Objekt \u00fcberhaupt existiert. Wenn nicht (Referenz null ), geben wir false zur\u00fcck. in Zeile 5 pr\u00fcfen wir, ob das aufrufende Objekt dasselbe ist, wie das als Parameter \u00fcbergebene Objekt (vergleich mit sich selbst). Wenn ja, geben wir true zur\u00fcck. in Zeile 6 pr\u00fcfen wir, ob das aufrufende Objekt und das als Parameter \u00fcbergebene Objekt den gleichen Typ haben (also hier Viereck ). Wenn nicht, geben wir false zur\u00fcck. Wenn diese Pr\u00fcfungen alle false waren, dann wissen wir danach, dass other vom (Laufzeit-)Typ Viereck ist und auf ein Viereck -Objekt zeigt. Nun k\u00f6nnen wir den eigentlichen Objektvergleich durchf\u00fchren. Dazu m\u00fcssen wir jedoch other in den Typ Viereck konvertieren: da beide Objekte vom gleichen Typ sind ( Viereck ), kann das Objekt aus dem Parameter in den vergleichenden Typ umgewandelt werden (z.B. Object nach Viereck ) dann k\u00f6nnen wir die Eigenschaften vergleichen, die f\u00fcr die \u201eGleichheit\u201c relevant sind (z.B. radius bei Circle , kontonummer bei Konto , a und b bei Rectangle usw. - hier: die vier Seiten des Vierecks a , b , c und d ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Override public boolean equals ( Object other ) { if ( other == null ) return false ; // Null-Akzeptanz if ( this == other ) return true ; // Reflexivit\u00e4t if ( this . getClass () != other . getClass ()) return false ; // ungleiche Typen // wenn wir hier die Methode noch nicht verlassen haben, dann // wissen wir, dass other vom Typ Viereck ist und auf ein // Viereck-Objekt zeigt // jetzt kommt der eigentliche Objektvergleich auf Gleichheit // damit wir ueberhaupt auf die Objektvariablen a, b, c, d von other // zugreifen k\u00f6nnen, muessen wir es nach Viereck konvertieren Viereck otherV = ( Viereck ) other ; return this . a == otherV . a && this . b == otherV . b && this . c == otherV . c && this . d == otherV . d ; } in Zeile 15 f\u00fchren wir eine explizite Typkonvertierung durch. Wir wissen an dieser Stelle ja bereits (aus Zeile 6 ), dass es sich bei other um den Laufzeittyp Viereck handelt. Die Konvertierung klappt also. Weil other den Compilertyp Object hat, k\u00f6nnen wir f\u00fcr other nicht auf die Objektvariablen a , b , c , d zugreifen. Wir m\u00fcssen also konvertieren. in Zeile 16 f\u00fchren wir dann den eigentlichen Vergleich durch. Hier vergleichen wir die Seiten miteinander. Wir ber\u00fccksichtigen nicht, dass Vierecke auch gedreht gleich sein k\u00f6nnen. Das ist Auslegungssache und Ihre Entscheidung, wann Objekte tats\u00e4chlich gleich sein sollen. Jetzt k\u00f6nnen wir die Gleichheit von zwei Viereck -Objekten mithilfe von equals() ermitteln: Viereck v3 = new Viereck ( 10 , 20 , 30 , 40 ); Viereck v4 = new Viereck ( 10 , 20 , 30 , 40 ); Viereck v5 = new Viereck ( 11 , 22 , 33 , 44 ); System . out . println ( v3 . equals ( v4 )); // true System . out . println ( v3 . equals ( v3 )); // true System . out . println ( v4 . equals ( v3 )); // true System . out . println ( v3 . equals ( v5 )); // false System . out . println ( v3 . equals ( null )); // false Success Mithilfe der equals() -Methode haben wir eine einheitliche M\u00f6glichkeit, die Gleichheit von Objekten zu definieren. Die Implementierung der equals() -Methode folgt immer dem gleichen Schema. Wir f\u00fchren zun\u00e4chst die drei Pr\u00fcfungen auf Null-Akzeptanz, Reflexivit\u00e4t und ungleiche Typen aus, konvertieren other dann in unseren Klassentyp und f\u00fchren den eigentlichen Vergleich auf Gleichheit der Objekte durch. Wir sollten equals() , wie auch toString() , von nun an f\u00fcr alle unsere Klassen implmentieren. Die Objektmethode hashCode() \u00b6 Die Idee der hashCode() -Methode besteht darin, ein Objekt durch eine ganze Zahl zu rep\u00e4sentieren. Diese Zahl wird verwendet, um Objekte in sogenannte hashbasierte Container einzusortieren. Das sind Datenstrukturen, in denen viele Objekte gespeichert werden und die Speicherung \u00fcber einen Hashwert verteilt wird. Wir werden solche hashbasierten Container im 2. Semester kennenlernen, wenn wir uns mit Collections besch\u00e4ftigen. Zum jetzigen Stand k\u00fcmmern wir uns um diese Methode nicht weiter, wollen sie aber doch immer genau dann \u00fcberschreiben, wenn wir die equals() -Methode implementieren. Es soll folgendes gelten: Wenn zwei Objekte laut equals() -Methode gleich sind, dann erzeugen sie auch den gleichen Hashcode mit der hashCode() -Methode. Es soll also gelten: wenn x.equals(y)==true , dann x.hashCode()==y.hashCode() . Wenn wir also die equals() -Methode \u00fcberschreiben, dann \u00fcberschreiben wir auch die hashCode() -Methode, um die genannte Bedingung zu erf\u00fcllen. Da wir f\u00fcr das Viereck die Seitenl\u00e4ngen verwendet haben, um die Gleichheit von zwei Vierecken zu definieren, k\u00f6nnen wir diese Seitenl\u00e4ngen auch verwenden, um einen HashCode zu erzeugen: @Override public int hashCode () { return this . a + this . b + this . c + this . d ; } Mit dieser Implementierung ist gegeben, dass zwei Vierecke, die laut equals() -Methode gleich sind (haben die gleichen Seitenl\u00e4ngen), auch den gleichen HashCode haben. Es muss (zum Gl\u00fcck) nicht gelten, dass zwei Vierecke, die laut equals() -Methode ungleich sind, einen unterschiedlichen HashCode haben m\u00fcssen. Die Objektmethode clone() \u00b6 Die Objektmethode clone() liefert einen identischen Clone (eine identische Kopie) des aufrufenden Objektes zur\u00fcck. Wir wollen uns an dieser Stelle gar nicht weiter detailliert um clone() k\u00fcmmern. Wir kommen darauf zur\u00fcck, wenn wir im 2. Semester Interfaces kennenlernen. Die Methode clone() ist auch nicht unumstritten - das aber nur zur Information, wie auch ein Beispiel f\u00fcr die folgende m\u00f6gliche Implementierung der Methode in der Klasse Viereck . @Override protected Object clone () { return new Viereck ( this . a , this . b , this . c , this . d ); } Das dient nur zum Verst\u00e4ndinis der Idee von clone() . Im Gegensatz zu toString() und equals() (und also auch hashCode() ) werden wir clone() nicht so oft \u00fcberschreiben. Success Wir haben mit Object die Mutter aller Klassen in Java kennengelernt. Jede Klasse in Java erbt (implizit) von Object . Jede Referenzvariable ist somit (auch) vom Laufzeittyp Object . F\u00fcr alle Klassen, die wir in Zukunft schreiben, werden wir die Objektmethoden toString() und equals() (und also auch hashCode() ) \u00fcberschreiben. Polymorphie \u00b6 Polymorphie geh\u00f6rt neben der Datenkapselung und der Vererbung zu den wesentlichen Konzepten der objektorientierten Programmierung. Die Grundidee der Polymorphie ist, dass es verschiedene Methoden gibt, die gleich hei\u00dfen und dass entweder der Compiler (statisch) oder die Laufzeitumgebung (dynamisch) ausw\u00e4hlt, welche dieser Methoden ausgef\u00fchrt wird. Man unterscheidet zwischen statischer und dynamischer Polymorphie . Statische Polymorphie \u00b6 Statische Polymorphie haben wir in Verbindung mit dem \u00dcberladen von Methoden . Der Compiler kann (an der Methodensignatur) erkennen, welche Methode aufgerufen wird. Angenommen, wir haben folgende Methoden: public void printArray ( int [] arr ) { // Ausgabe eines int[]-Arrays } public void printArray ( char [] arr ) { // Ausgabe eines char[]-Arrays } public void printArray ( double [] arr ) { // Ausgabe eines double[]-Arrays } public void printArray ( String [] arr ) { // Ausgabe eines String[]-Arrays } public void printArray ( Object [] arr ) { // Ausgabe eines Object[]-Arrays } , dann wird durch den Typs des als Parameter \u00fcbergebenen Arrays klar, welche dieser Methoden aufgerufen wird. Es wird also unter vielen Implementierungen durch den Compiler die \"richtige\" ausgew\u00e4hlt. Dynamische Polymorphie \u00b6 Dynamische Polymorphie wird durch Vererbung und insbesondere durch das \u00dcberschreiben von Methoden erm\u00f6glicht. Wir betrachten folgendes Beispiel - gegeben sind drei Klassen Base , Sub und SubSub : 1 2 3 4 5 6 7 public class Base { public void methodBase () { System . out . println ( \"Base\" ); } } 1 2 3 4 5 6 7 8 public class Sub extends Base { @Override public void methodBase () { System . out . println ( \"Sub\" ); } } 1 2 3 4 5 6 7 8 public class SubSub extends Sub { @Override public void methodBase () { System . out . println ( \"SubSub\" ); } } Die Klasse Sub erbt von Base und die Klasse SubSub erbt von Sub . In beiden Kindklassen wird die Methode methodBase() \u00fcberschrieben, die in Base erstmalig definiert wird. Angenommen, wir haben nun folgende main() -Methode: 1 2 3 4 5 6 7 8 9 10 11 public void main () { Base [] base = new Base [ 3 ] ; base [ 0 ] = new Base (); // Compilertyp Base, Laufzeittyp Base base [ 1 ] = new Sub (); // Compilertyp Base, Laufzeittyp Sub base [ 2 ] = new SubSub (); // Compilertyp Base, Laufzeittyp SubSub base [ 0 ] . methodBase (); // Base base [ 1 ] . methodBase (); // Sub base [ 2 ] . methodBase (); // SubSub } Wir erstellen uns also ein Array, deren Elemente vom Compilertyp Base sind. Das erste Element ist eine Referenz auf ein Base -Objekt, das zweite Element ist eine Referenz auf ein Sub -Objekt und das dritte zeigt auf ein SubSub -Objekt. F\u00fcr alle drei Referenzvariablen wird nun die methodBase() -Methode aufgerufen. Es werden folgende Ausgaben erzeugt: Base Sub SubSub Das bedeutet, dass die Laufzeitumgebung von Java die speziellstm\u00f6gliche Implementierung der Methode ausw\u00e4hlt. Mit speziellstm\u00f6glich ist gemeint, dass die Implementierung des speziellsten Laufzeittypen ausgew\u00e4hlt wird. In der Vererbungshierarchie SubSub \u2192 Sub \u2192 Base ist SubSub der speziellste Typ, Sub ist spezieller als Base , aber allgemeiner als Sub und Base ist allgemeiner als Sub und erst recht als SubSub . Der speziellste Laufzeittyp von base[0] ist Base und somit wird die methodBase() -Implementierung der Klasse Base verwendet. Der speziellste Laufzeittyp von base[1] ist Sub und somit wird die methodBase() -Implementierung der Klasse Sub verwendet. Der speziellste Laufzeittyp von base[2] ist SubSub und somit wird die methodBase() -Implementierung der Klasse SubSub verwendet. Success Polymorphie ist ein tolles Konzept der objektorientierten Programmierung. Der Nutzen von Polymorphie wird uns jetzt noch nicht vollst\u00e4ndig deutlich. Wir werden aber immer wieder darauf hinweisen, wenn wir Polymorphie im Einsatz sehen. Vielleicht erkennen Sie ja jetzt besser, warum z.B. die Methode System.out.println(Object o) so funktioniert. Sp\u00e4testens, wenn wir Interfaces behandeln, kommen wir auf dieses Konzept zur\u00fcck.","title":"Object"},{"location":"object/#die-klasse-object","text":"Die Klasse java.lang.Object ist die Basisklasse (Elternklasse) aller in Java existierenden Klassen. Object wird h\u00e4ufig auch als die Mutter aller Klassen in Java bezeichnet. Eine Klasse kann entweder explizit von einer anderen Klasse erben (mithilfe von extends ) oder sie erbt implizit von der Klasse Object . Das bedeutet, dass jede Klasse von der Klasse Object erbt. Betrachten wir nochmal zur Wiederholung unsere Vererbungshierarchie aus dem vorherigen Abschnitt Vererbung : Dort hatten wir zun\u00e4chst die Klasse Viereck erstellt, die explizit von keiner Klasse geerbt hat. Viereck erbt somit implizit von Object . Die Klasse Rechteck erbt von Viereck und somit auch von Object . Die Klasse Quadrat erbt von Rechteck und somit auch von Viereck und somit auch von Object . Wenn wir uns nun noch daran erinnern, dass wir beim Erstellen der Konstruktoren gesagt haben, dass bei der Objekterzeugung auch immer ein Objekt der Elternklasse erzeugt wird, dann bedeutet das, dass f\u00fcr jedes Objekt auch immer ein Objekt der Klasse Object erzeugt wird. Wenn wir uns nun auch noch daran erinnern, dass in einer Vererbungshierarchie immer die is-a -Relation ( ist ein ) gilt (jedes Rechteck ist ein Viereck , jedes Quadrat ist ein Rechteck ist ein Viereck ), dann gilt dass jedes Objekt auch ein Objekt vom Typ Object ist. Das bedeutet insbesondere, dass jedes Objekt alle Objekteigenschaften (Objektmethoden) der Klasse Object geerbt hat. Jedes Objekt (egal von welchem Referenztyp) ist auch ein Objekt vom Typ Object und hat alle Objektmethoden von Object geerbt.","title":"Die Klasse Object"},{"location":"object/#objektmethoden-von-object","text":"Jedes Objekt in Java hat also automatisch die Methoden von Object geerbt. Einige davon betrachten wir nun etwas genauer: Objektmethode von Object Bedeutung getClass() gibt den Laufzeittyp der Klasse zur\u00fcck toString() gibt einen String zur\u00fcck \u2192 sollte in jeder Klasse \u00fcberschrieben werden, um eine geeignete textuelle Beschreibung der Objekte zu haben equals(Object) f\u00fcr den Vergleich zweier Objekte \u2192 sollte in jeder Klasse \u00fcberschrieben werden, um Gleichheit von Objekten zu beschreiben (default: Referenzvergleich) hashCode() gibt einen HashCode (ein int ) f\u00fcr ein Objekt zur\u00fcck, wird ben\u00f6tigt zum Einsortieren in hashbasierten Containern \u2192 sp\u00e4ter in Collections clone() gibt eine Kopie (einen Clone) des Objektes zur\u00fcck wait() , notify() , notifyAll() f\u00fcr Threads \u2192 machen wir viel sp\u00e4ter finalize() f\u00fcr die Garbage Collection \u2192 ist seit Java 9 deprecated Die Objektmethoden aus den letzten beiden Zeilen der Tabelle betrachten wir hier nicht weiter. Die anderen Objektmethoden werden im Folgenden genauer untersucht. Wir beginnen mit getClass() .","title":"Objektmethoden von Object"},{"location":"object/#die-objektmethode-getclass","text":"Angenommen, wir haben die Klassen Viereck , Rechteck und Quadrat aus dem vorherigen Kapitel Vererbung gegeben: Viereck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Viereck { protected int a , b , c , d ; // Seiten public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; } public int umfang () { return this . a + this . b + this . c + this . d ; } public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . println ( \" Umfang des Vierecks : \" + this . umfang ()); } } Rechteck.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Rechteck extends Viereck { public Rechteck ( int laenge , int breite ) { super ( laenge , breite , laenge , breite ); // Aufruf des Konstruktors von Viereck } /* * neue Objektmethode * spezielle Eigenschaft fuer Rechteck * gilt nicht f\u00fcr Viereck * */ public int flaecheninhalt () { return this . a * this . b ; // Zugriff moeglich wegen protected in Viereck } @Override public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . print ( \" Umfang des Rechtecks : \" + this . umfang ()); System . out . println ( \" Flaecheninhalt des Rechtecks : \" + this . flaecheninhalt ()); } } Quadrat.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Quadrat extends Rechteck { Quadrat ( int seite ) { super ( seite , seite ); // Aufruf des Konstruktors von Rechteck } @Override public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . print ( \" Umfang des Quadrats : \" + this . umfang ()); System . out . println ( \" Flaecheninhalt des Quadrats : \" + this . flaecheninhalt ()); } } Wenn wir nun in z.B. einer main() -Methode folgende Anweisungen haben: 1 2 3 Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); Rechteck r1 = new Rechteck ( 10 , 20 ); Quadrat q1 = new Quadrat ( 30 ); , dann wissen wir, dass v1 vom Typ Viereck ist, r1 vom Typ Rechteck und q1 vom Typ Quadrat . Die Deklarationen dieser Variablen geben den sogenannten Compilertyp an. Und tats\u00e4chlich haben wir ja im obigen Fall auch die dazu passenden Objekte erzeugt, die genau dem jeweiligen Typ entsprechen. Wenn wir nun also jeweils die getClass() -Methode aufrufen, dann bekommen wir die jeweiligen Typen zur\u00fcckgegeben: 1 2 3 4 5 6 Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); Rechteck r1 = new Rechteck ( 10 , 20 ); Quadrat q1 = new Quadrat ( 30 ); System . out . println ( v1 . getClass ()); // von Object geerbt System . out . println ( r1 . getClass ()); // von Viereck -> Object geerbt System . out . println ( q1 . getClass ()); // von Rechteck -> Viereck -> Object geerbt Die Ausgaben sind: class Viereck class Rechteck class Quadrat Wichtig: getClass() gibt jedoch nicht den Compilertyp , sondern den Laufzeittyp zur\u00fcck.","title":"Die Objektmethode getClass()"},{"location":"object/#compilertyp-vs-laufzeittyp","text":"Was sind Compiler- und Laufzeittypen ? Compilertyp wissen wir schon. Bei der Deklaration einer Variablen geben wir den Compilertypen der Variablen an. Was wir aber auch wissen, ist, dass jedes Rechteck ist auch ein Viereck . Das erlaubt uns, auch Folgendes zu schreiben: 1 Viereck v = new Rechteck ( 10 , 20 ); Jetzt ist v vom (Compiler-)Typ Viereck , aber vom Laufzeittyp Rechteck . Die Referenzvariable v zeigt auf ein Rechteck -Objekt. Mit getClass() erfragen wir den Laufzeittyp , d.h. 1 2 Viereck v = new Rechteck ( 10 , 20 ); // Compilertyp von v ist Viereck System . out . println ( v . getClass ()); // Laufzeittyp von v ist Rechteck erzeugt die Ausgabe class themen.vererbung.Rechteck Wir k\u00f6nnen also auch soetwas machen: 1 2 3 4 5 6 7 8 Viereck [] va = new Viereck [ 3 ] ; va [ 0 ] = new Viereck ( 10 , 20 , 30 , 40 ); // Compilertyp von va[0] ist Viereck, Laufzeittyp ist Viereck va [ 1 ] = new Rechteck ( 10 , 20 ); // Compilertyp von va[1] ist Viereck, Laufzeittyp ist Rechteck va [ 2 ] = new Quadrat ( 15 ); // Compilertyp von va[2] ist Viereck, Laufzeittyp ist Quadrat System . out . println ( va [ 0 ] . getClass ()); // Viereck System . out . println ( va [ 1 ] . getClass ()); // Rechteck System . out . println ( va [ 2 ] . getClass ()); // Quadrat Das bedeutet auch, dass sogar soetwas m\u00f6glich ist: 1 2 3 4 5 6 7 Object o1 = new Viereck ( 10 , 20 , 30 , 40 ); // Compilertyp von o1 ist Object, Laufzeittyp ist Viereck Object o2 = new Rechteck ( 10 , 20 ); // Compilertyp von o2 ist Object, Laufzeittyp ist Rechteck Object o3 = new Quadrat ( 15 ); // Compilertyp von o3 ist Object, Laufzeittyp ist Quadrat System . out . println ( o1 . getClass ()); // Viereck System . out . println ( o2 . getClass ()); // Rechteck System . out . println ( o3 . getClass ()); // Quadrat Der Compilertyp einer (Referenz-)Variablen wird durch die Deklaration bestimmt. Der Laufzeittyp wird bestimmt durch das konkrete Objekt, auf das die Referenzvariable zeigt.","title":"Compilertyp vs. Laufzeittyp"},{"location":"object/#welche-objektmethoden-anwendbar-typecast","text":"Wenn wir schonmal bei der Unterscheidung zwischen Compilertyp und Laufzeittyp sind, dann k\u00f6nnen wir gleich der Frage nachgehen, welche Objektmethoden anwendbar sind. Erinnern wir uns dazu nochmal an die Erweiterung der Klasse Rechteck . Dort hatten wir eine Objektmethode flaecheninhalt() definiert, die in der Klasse Viereck nicht existiert. Wir hatten folgenden Fall: 1 2 3 4 Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); // System.out.println(v1.flaecheninhalt()); // flaecheninhalt() existiert f\u00fcr Viereck nicht Rechteck r1 = new Rechteck ( 10 , 20 ); System . out . println ( r1 . flaecheninhalt ()); // flaecheninhalt() existiert f\u00fcr Rechteck (=200) Wenn wir nun 1 Viereck v = new Rechteck ( 10 , 20 ); haben, v also den Compilertyp Viereck hat und den Laufzeittyp Rechteck . K\u00f6nnen wir dann 1 System . out . println ( v . flaecheninhalt ()); // Fehler! aufrufen? Die Antwort ist nein! Das ist auch insofern logisch, als dass dieser Aufruf ja bereits zum Compilezeit m\u00f6glich sein muss. Dem Typ Viereck steht diese Methode aber nicht zur Verf\u00fcgung. Das geht also nicht. Was wir aber in diesem Fall machen k\u00f6nnen, ist eine explizite Typkonvertierung . 1 2 3 Viereck v = new Rechteck ( 10 , 20 ); Rechteck r = ( Rechteck ) v ; // geht, weil der Laufzeittyp Rechteck ist System . out . println ( r . flaecheninhalt ()); // geht, weil der Compilertyp von r Rechteck ist Nochmal im Detail: In Zeile 1 definieren wir eine Referenzvariable v vom Compilertyp Viereck . In Zeile 2 definieren wir eine Referenzvariable r vom Compilertyp Rechteck . Weil r vom Compilertyp Rechteck ist, k\u00f6nnen wir f\u00fcr r die Objektmethode flaecheninhalt() aufrufen (f\u00fcr v nicht!). Dass die Typkonvertierung in Zeile 2 auch tats\u00e4chlich gelingt, liegt (zur Laufzeit ) daran, dass der Laufzeittyp von v Rechteck ist. W\u00e4re das nicht der Fall, w\u00fcrde die Typkonvertierung scheitern - aber erst zur Laufzeit (mit einer ClassCastException ).","title":"Welche Objektmethoden anwendbar? - Typecast"},{"location":"object/#instanceof-vs-getclass","text":"Wie gesagt, ermitteln wir mit getClass() den Laufzeittypen einer Referenzvariablen. Daf\u00fcr gibt es auch noch ein anderes Schl\u00fcsselwort in Java, n\u00e4mlich instanceof . Das ist ein Operator, mit dessen Hilfe wir einen Vergleich mit Typen anstellen k\u00f6nnen. Zun\u00e4chst ein Beispiel: 1 2 3 4 5 Viereck v = new Viereck ( 10 , 20 , 30 , 40 ); if ( v instanceof Viereck ) { System . out . println ( \"v ist vom Typ Viereck\" ); } In Zeile 2 sehen wir die Anwendung des instanceof -Operators. Er gibt ein boolean zur\u00fcck, je nachdem die Variable vom angegebenen Typen ist oder nicht. Der obige Code erzeugt also die Ausgabe v ist vom Typ Viereck auf der Konsole. Angenommen, wir haben nun folgendes Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Object o = new Quadrat ( 15 ); // Compilertyp Object, Laufzeittyp Quadrat if ( o instanceof Object ) // true { System . out . println ( \"o ist vom Typ Object\" ); } if ( o instanceof Viereck ) // true { System . out . println ( \"o ist vom Typ Viereck\" ); } if ( o instanceof Rechteck ) // true { System . out . println ( \"o ist vom Typ Rechteck\" ); } if ( o instanceof Quadrat ) // true { System . out . println ( \"o ist vom Typ Quadrat\" ); } , dann sind alle Bedingungen true , d.h. es wird folgende Ausgabe erzeugt: o ist vom Typ Object o ist vom Typ Viereck o ist vom Typ Rechteck o ist vom Typ Quadrat instanceof pr\u00fcft also jeden m\u00f6glichen Laufzeittyp (wir wissen ja, dass ein Objekt vom Typ Quadrat ist ein Objekt vom Typ Rechteck ist ein Objekt vom Typ Viereck ist ein Objekt vom Typ Object ). Das gleiche gilt auch f\u00fcr: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Quadrat q = new Quadrat ( 15 ); // Compilertyp Quadrat, Laufzeittyp Quadrat if ( q instanceof Object ) // true { System . out . println ( \"q ist vom Typ Object\" ); } if ( q instanceof Viereck ) // true { System . out . println ( \"q ist vom Typ Viereck\" ); } if ( q instanceof Rechteck ) // true { System . out . println ( \"q ist vom Typ Rechteck\" ); } if ( q instanceof Quadrat ) // true { System . out . println ( \"q ist vom Typ Quadrat\" ); } , dann sind alle Bedingungen true , d.h. es wird folgende Ausgabe erzeugt: q ist vom Typ Object q ist vom Typ Viereck q ist vom Typ Rechteck q ist vom Typ Quadrat Die Methode getClass() liefert also den konkretesten (speziellsten) Laufzeittypen zur\u00fcck. Mit instanceof k\u00f6nnen alle Laufzeittypen abgefragt werden. F\u00fcr eine beliebige Variable var , egal welchen Referenztyps, gilt immer, dass var instanceof Object true ergibt, d.h. jede Referenzvariable ist immer auch vom (Laufzeit-)Typ Object .","title":"instanceof vs. getClass()"},{"location":"object/#die-objektmethode-tostring","text":"In jeder Klasse, die wir erstellen, erben wir von Object die Objektmethode toString() . Wenden wir diese Methode also einmal f\u00fcr unsere Klasse Viereck an: 1 2 Viereck v = new Viereck ( 10 , 20 , 30 , 40 ); System . out . println ( v . toString ()); Dann erhalten wir eine etwas kryptische Ausgabe: Viereck@279f2327 wobei Viereck f\u00fcr die Klasse steht und @279f2327 scheint irgendeine Referenzadresse zu sein. Interessant an der toString() -Methode ist, dass wir die gleiche Ausgabe auch dann erzielen, wenn wir nur 1 2 Viereck v = new Viereck ( 10 , 20 , 30 , 40 ); System . out . println ( v ); aufrufen, also der Methode System.out.println() nur v und nicht v.toString() \u00fcbergeben. Das liegt daran, dass System.out.println() \u00fcberladen ist und - unter anderem - die beiden Implementierungen System . out . println ( String s ) {} System . out . println ( Object o ) {} existieren. Wenn wir System.out.println(v.toString()); aufrufen, wird die Implementierung von System.out.println(String s) {} verwendet (der String s wird ausgegeben). Wenn wir System.out.println(v); aufrufen, wird die Implementierung von System.out.println(Object o) {} verwendet und dabei wird n\u00e4mlich System.out.println(o.toString()); aufgerufen. Wenn wir nun also die Methode toString() \u00fcberschreiben (ist ja von Object geerbt), dann gewinnen wir zwei Effekte: wir erstellen eine textuelle Repr\u00e4ssentation unserer Objekte und wir m\u00fcssen System.out.println() nur noch die Referenzvariable ref auf unser Obejkt \u00fcbergeben (und nicht ref.toString() ) Erweitern wir also die Klasse Viereck um eine Implementierung der toString() -Methode: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Viereck { protected int a , b , c , d ; // Seiten public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; } public int umfang () { return this . a + this . b + this . c + this . d ; } public void print () { System . out . print ( this . toString ()); // siehe unten System . out . println ( \" Umfang des Vierecks : \" + this . umfang ()); } @Override public String toString () { return \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ; } } Wir verwenden auch hier die @Override -Annotation, um dem Compiler zu sagen, dass wir die toString() -Methode von Object \u00fcberschreiben wollen (nicht, dass wir z.B. ausversehen tostring() schreiben und somit eine neue Objektmethode erstellen). In der toString() -Methode implementieren wir eine geeignete Repr\u00e4sentation des Objektes (hier die Seitenl\u00e4ngen des Vierecks). Nun erzeugen die Anweisungen 1 2 Viereck v = new Viereck ( 10 , 20 , 30 , 40 ); System . out . println ( v ); // entspricht System.out.println(v.toString()); eine deutlich bessere Ausgabe, n\u00e4mlich [ a = 10 , b = 20 , c = 30 , d = 40 ] Wir sollten uns angew\u00f6hnen, die toString() -Methode immer , d.h. in allen Klassen, die wir erstellen, zu \u00fcberschreiben!","title":"Die Objektmethode toString()"},{"location":"object/#die-objektmethode-equals","text":"Wir wiederholen zun\u00e4chst nochmal in K\u00fcrze den Abschnitt \u00fcber Referenzvergleiche von Objekten . Angenommen, wir haben folgende Vierecke: Viereck v3 = new Viereck ( 10 , 20 , 30 , 40 ); Viereck v4 = new Viereck ( 10 , 20 , 30 , 40 ); System . out . println ( v3 == v4 ); // Referenzvergleich!! false - zwei Objekte Wir k\u00f6nnten auf die Idee kommen, dass v3==v4 true ergibt, weil f\u00fcr uns die beiden Objekte von Viereck gleich sind. Aber woher soll der Compiler oder die Laufzeitumgebung wissen , dass diese Viereck -Objekte gleich sind? Der Operator == vergleicht nur die Referenzen und ist false , wenn die Referenzen auf zwei verschiedene Objekte zeigen. Mithilfe der equals() -Methode k\u00f6nnen wir definieren, wann Objekte der Klasse gleich sein sollen. Wir k\u00f6nnen aber nicht den Operator == \u00fcberschreiben. Dieser bleibt f\u00fcr Referenztypen immer ein Referenzvergleich! Wir wollen unsere Klasse Viereck also um eine equals() -Methode erweitern und in dieser equals() -Methode festlegen, wann zwei Viereck -Objekte gleich sein sollen (wenn ihre Seitenl\u00e4ngen gleich sind). Wir versuchen folgendes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Viereck { protected int a , b , c , d ; // Seiten public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; } public int umfang () { return this . a + this . b + this . c + this . d ; } public void print () { System . out . print ( this . toString ()); // siehe unten System . out . println ( \" Umfang des Vierecks : \" + this . umfang ()); } @Override public String toString () { return \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ; } @Override public boolean equals ( Viereck v ) { // Implementierung von equals() } } Das f\u00fchrt leider zu einem Fehler. Der Compiler beschwert sich dar\u00fcber, dass wir die geerbte equals() -Methode so gar nicht \u00fcberschreiben. Tats\u00e4chlich erben wir nicht equals(Viereck v) , sondern equals(Object o) (woher sollte Object auch Viereck kennen?). Wir m\u00fcssen also folgende Methode \u00fcberschreiben: @Override public boolean equals ( Object o ) { // Implementierung von equals() } Nat\u00fcrlich erwarten wir, dass sich das aufrufende Viereck mit einem anderen Viereck vergleicht. Die Methode ist aber so implementiert, dass jedes beliebige Objekt als Parameter \u00fcbergeben werden kann. Theoretisch w\u00e4re also z.B. folgender Aufruf m\u00f6glich: Viereck v = new Viereck ( 10 , 20 , 30 , 40 ); Point p = new Point ( 3 , 4 ); Systems . out . println ( v . equals ( p )); Das soll nat\u00fcrlich false ergeben. Die Implementierung von equals(Object o) muss folgende Bedingungen erf\u00fcllen: Null-Akzeptanz: f\u00fcr jede Referenz x ungleich null liefert x.equals(null) den Wert false Reflexivit\u00e4t: f\u00fcr jede Referenz x ungleich null liefert x.equals(x) den Wert true Symmetrie: wenn x.equals(y) true ergibt, dann muss auch y.equals(x) true ergeben (und umgedreht) Transitivit\u00e4t: wenn x.equals(y) und y.equals(z) jeweils true ergeben, dann muss auch x.equals(z) true ergeben Konsistenz: der Aufruf x.equals(y) muss immer den gleichen Wert ergeben Das h\u00f6rt sich komplizierter an, als es ist. Wir werden sehen, dass wir bei der Implementierung von equals(Object o) immer gleich vorgehen. Wir f\u00fchren zun\u00e4chst ein paar Pr\u00fcfungen durch: pr\u00fcfen, ob null -Referenzen vorliegen \u2192 (wenn ja, dann false ) pr\u00fcfen, ob keine identischen Objekte verglichen werden (dasselbe Objekt vergleicht sich mit sich selbst) \u2192 (wenn ja, dann true ) pr\u00fcfen, ob Objekte des gew\u00fcnschten Typs verglichen werden \u2192 (wenn nein, dann false ) 1 2 3 4 5 6 7 8 9 10 11 12 @Override public boolean equals ( Object other ) { if ( other == null ) return false ; // Null-Akzeptanz if ( this == other ) return true ; // Reflexivit\u00e4t if ( this . getClass () != other . getClass ()) return false ; // ungleiche Typen // wenn wir hier die Methode noch nicht verlassen haben, dann // wissen wir, dass other vom Typ Viereck ist und auf ein // Viereck-Objekt zeigt } in Zeile 4 pr\u00fcfen wir, ob das als Parameter \u00fcbergebene Objekt \u00fcberhaupt existiert. Wenn nicht (Referenz null ), geben wir false zur\u00fcck. in Zeile 5 pr\u00fcfen wir, ob das aufrufende Objekt dasselbe ist, wie das als Parameter \u00fcbergebene Objekt (vergleich mit sich selbst). Wenn ja, geben wir true zur\u00fcck. in Zeile 6 pr\u00fcfen wir, ob das aufrufende Objekt und das als Parameter \u00fcbergebene Objekt den gleichen Typ haben (also hier Viereck ). Wenn nicht, geben wir false zur\u00fcck. Wenn diese Pr\u00fcfungen alle false waren, dann wissen wir danach, dass other vom (Laufzeit-)Typ Viereck ist und auf ein Viereck -Objekt zeigt. Nun k\u00f6nnen wir den eigentlichen Objektvergleich durchf\u00fchren. Dazu m\u00fcssen wir jedoch other in den Typ Viereck konvertieren: da beide Objekte vom gleichen Typ sind ( Viereck ), kann das Objekt aus dem Parameter in den vergleichenden Typ umgewandelt werden (z.B. Object nach Viereck ) dann k\u00f6nnen wir die Eigenschaften vergleichen, die f\u00fcr die \u201eGleichheit\u201c relevant sind (z.B. radius bei Circle , kontonummer bei Konto , a und b bei Rectangle usw. - hier: die vier Seiten des Vierecks a , b , c und d ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Override public boolean equals ( Object other ) { if ( other == null ) return false ; // Null-Akzeptanz if ( this == other ) return true ; // Reflexivit\u00e4t if ( this . getClass () != other . getClass ()) return false ; // ungleiche Typen // wenn wir hier die Methode noch nicht verlassen haben, dann // wissen wir, dass other vom Typ Viereck ist und auf ein // Viereck-Objekt zeigt // jetzt kommt der eigentliche Objektvergleich auf Gleichheit // damit wir ueberhaupt auf die Objektvariablen a, b, c, d von other // zugreifen k\u00f6nnen, muessen wir es nach Viereck konvertieren Viereck otherV = ( Viereck ) other ; return this . a == otherV . a && this . b == otherV . b && this . c == otherV . c && this . d == otherV . d ; } in Zeile 15 f\u00fchren wir eine explizite Typkonvertierung durch. Wir wissen an dieser Stelle ja bereits (aus Zeile 6 ), dass es sich bei other um den Laufzeittyp Viereck handelt. Die Konvertierung klappt also. Weil other den Compilertyp Object hat, k\u00f6nnen wir f\u00fcr other nicht auf die Objektvariablen a , b , c , d zugreifen. Wir m\u00fcssen also konvertieren. in Zeile 16 f\u00fchren wir dann den eigentlichen Vergleich durch. Hier vergleichen wir die Seiten miteinander. Wir ber\u00fccksichtigen nicht, dass Vierecke auch gedreht gleich sein k\u00f6nnen. Das ist Auslegungssache und Ihre Entscheidung, wann Objekte tats\u00e4chlich gleich sein sollen. Jetzt k\u00f6nnen wir die Gleichheit von zwei Viereck -Objekten mithilfe von equals() ermitteln: Viereck v3 = new Viereck ( 10 , 20 , 30 , 40 ); Viereck v4 = new Viereck ( 10 , 20 , 30 , 40 ); Viereck v5 = new Viereck ( 11 , 22 , 33 , 44 ); System . out . println ( v3 . equals ( v4 )); // true System . out . println ( v3 . equals ( v3 )); // true System . out . println ( v4 . equals ( v3 )); // true System . out . println ( v3 . equals ( v5 )); // false System . out . println ( v3 . equals ( null )); // false Success Mithilfe der equals() -Methode haben wir eine einheitliche M\u00f6glichkeit, die Gleichheit von Objekten zu definieren. Die Implementierung der equals() -Methode folgt immer dem gleichen Schema. Wir f\u00fchren zun\u00e4chst die drei Pr\u00fcfungen auf Null-Akzeptanz, Reflexivit\u00e4t und ungleiche Typen aus, konvertieren other dann in unseren Klassentyp und f\u00fchren den eigentlichen Vergleich auf Gleichheit der Objekte durch. Wir sollten equals() , wie auch toString() , von nun an f\u00fcr alle unsere Klassen implmentieren.","title":"Die Objektmethode equals()"},{"location":"object/#die-objektmethode-hashcode","text":"Die Idee der hashCode() -Methode besteht darin, ein Objekt durch eine ganze Zahl zu rep\u00e4sentieren. Diese Zahl wird verwendet, um Objekte in sogenannte hashbasierte Container einzusortieren. Das sind Datenstrukturen, in denen viele Objekte gespeichert werden und die Speicherung \u00fcber einen Hashwert verteilt wird. Wir werden solche hashbasierten Container im 2. Semester kennenlernen, wenn wir uns mit Collections besch\u00e4ftigen. Zum jetzigen Stand k\u00fcmmern wir uns um diese Methode nicht weiter, wollen sie aber doch immer genau dann \u00fcberschreiben, wenn wir die equals() -Methode implementieren. Es soll folgendes gelten: Wenn zwei Objekte laut equals() -Methode gleich sind, dann erzeugen sie auch den gleichen Hashcode mit der hashCode() -Methode. Es soll also gelten: wenn x.equals(y)==true , dann x.hashCode()==y.hashCode() . Wenn wir also die equals() -Methode \u00fcberschreiben, dann \u00fcberschreiben wir auch die hashCode() -Methode, um die genannte Bedingung zu erf\u00fcllen. Da wir f\u00fcr das Viereck die Seitenl\u00e4ngen verwendet haben, um die Gleichheit von zwei Vierecken zu definieren, k\u00f6nnen wir diese Seitenl\u00e4ngen auch verwenden, um einen HashCode zu erzeugen: @Override public int hashCode () { return this . a + this . b + this . c + this . d ; } Mit dieser Implementierung ist gegeben, dass zwei Vierecke, die laut equals() -Methode gleich sind (haben die gleichen Seitenl\u00e4ngen), auch den gleichen HashCode haben. Es muss (zum Gl\u00fcck) nicht gelten, dass zwei Vierecke, die laut equals() -Methode ungleich sind, einen unterschiedlichen HashCode haben m\u00fcssen.","title":"Die Objektmethode hashCode()"},{"location":"object/#die-objektmethode-clone","text":"Die Objektmethode clone() liefert einen identischen Clone (eine identische Kopie) des aufrufenden Objektes zur\u00fcck. Wir wollen uns an dieser Stelle gar nicht weiter detailliert um clone() k\u00fcmmern. Wir kommen darauf zur\u00fcck, wenn wir im 2. Semester Interfaces kennenlernen. Die Methode clone() ist auch nicht unumstritten - das aber nur zur Information, wie auch ein Beispiel f\u00fcr die folgende m\u00f6gliche Implementierung der Methode in der Klasse Viereck . @Override protected Object clone () { return new Viereck ( this . a , this . b , this . c , this . d ); } Das dient nur zum Verst\u00e4ndinis der Idee von clone() . Im Gegensatz zu toString() und equals() (und also auch hashCode() ) werden wir clone() nicht so oft \u00fcberschreiben. Success Wir haben mit Object die Mutter aller Klassen in Java kennengelernt. Jede Klasse in Java erbt (implizit) von Object . Jede Referenzvariable ist somit (auch) vom Laufzeittyp Object . F\u00fcr alle Klassen, die wir in Zukunft schreiben, werden wir die Objektmethoden toString() und equals() (und also auch hashCode() ) \u00fcberschreiben.","title":"Die Objektmethode clone()"},{"location":"object/#polymorphie","text":"Polymorphie geh\u00f6rt neben der Datenkapselung und der Vererbung zu den wesentlichen Konzepten der objektorientierten Programmierung. Die Grundidee der Polymorphie ist, dass es verschiedene Methoden gibt, die gleich hei\u00dfen und dass entweder der Compiler (statisch) oder die Laufzeitumgebung (dynamisch) ausw\u00e4hlt, welche dieser Methoden ausgef\u00fchrt wird. Man unterscheidet zwischen statischer und dynamischer Polymorphie .","title":"Polymorphie"},{"location":"object/#statische-polymorphie","text":"Statische Polymorphie haben wir in Verbindung mit dem \u00dcberladen von Methoden . Der Compiler kann (an der Methodensignatur) erkennen, welche Methode aufgerufen wird. Angenommen, wir haben folgende Methoden: public void printArray ( int [] arr ) { // Ausgabe eines int[]-Arrays } public void printArray ( char [] arr ) { // Ausgabe eines char[]-Arrays } public void printArray ( double [] arr ) { // Ausgabe eines double[]-Arrays } public void printArray ( String [] arr ) { // Ausgabe eines String[]-Arrays } public void printArray ( Object [] arr ) { // Ausgabe eines Object[]-Arrays } , dann wird durch den Typs des als Parameter \u00fcbergebenen Arrays klar, welche dieser Methoden aufgerufen wird. Es wird also unter vielen Implementierungen durch den Compiler die \"richtige\" ausgew\u00e4hlt.","title":"Statische Polymorphie"},{"location":"object/#dynamische-polymorphie","text":"Dynamische Polymorphie wird durch Vererbung und insbesondere durch das \u00dcberschreiben von Methoden erm\u00f6glicht. Wir betrachten folgendes Beispiel - gegeben sind drei Klassen Base , Sub und SubSub : 1 2 3 4 5 6 7 public class Base { public void methodBase () { System . out . println ( \"Base\" ); } } 1 2 3 4 5 6 7 8 public class Sub extends Base { @Override public void methodBase () { System . out . println ( \"Sub\" ); } } 1 2 3 4 5 6 7 8 public class SubSub extends Sub { @Override public void methodBase () { System . out . println ( \"SubSub\" ); } } Die Klasse Sub erbt von Base und die Klasse SubSub erbt von Sub . In beiden Kindklassen wird die Methode methodBase() \u00fcberschrieben, die in Base erstmalig definiert wird. Angenommen, wir haben nun folgende main() -Methode: 1 2 3 4 5 6 7 8 9 10 11 public void main () { Base [] base = new Base [ 3 ] ; base [ 0 ] = new Base (); // Compilertyp Base, Laufzeittyp Base base [ 1 ] = new Sub (); // Compilertyp Base, Laufzeittyp Sub base [ 2 ] = new SubSub (); // Compilertyp Base, Laufzeittyp SubSub base [ 0 ] . methodBase (); // Base base [ 1 ] . methodBase (); // Sub base [ 2 ] . methodBase (); // SubSub } Wir erstellen uns also ein Array, deren Elemente vom Compilertyp Base sind. Das erste Element ist eine Referenz auf ein Base -Objekt, das zweite Element ist eine Referenz auf ein Sub -Objekt und das dritte zeigt auf ein SubSub -Objekt. F\u00fcr alle drei Referenzvariablen wird nun die methodBase() -Methode aufgerufen. Es werden folgende Ausgaben erzeugt: Base Sub SubSub Das bedeutet, dass die Laufzeitumgebung von Java die speziellstm\u00f6gliche Implementierung der Methode ausw\u00e4hlt. Mit speziellstm\u00f6glich ist gemeint, dass die Implementierung des speziellsten Laufzeittypen ausgew\u00e4hlt wird. In der Vererbungshierarchie SubSub \u2192 Sub \u2192 Base ist SubSub der speziellste Typ, Sub ist spezieller als Base , aber allgemeiner als Sub und Base ist allgemeiner als Sub und erst recht als SubSub . Der speziellste Laufzeittyp von base[0] ist Base und somit wird die methodBase() -Implementierung der Klasse Base verwendet. Der speziellste Laufzeittyp von base[1] ist Sub und somit wird die methodBase() -Implementierung der Klasse Sub verwendet. Der speziellste Laufzeittyp von base[2] ist SubSub und somit wird die methodBase() -Implementierung der Klasse SubSub verwendet. Success Polymorphie ist ein tolles Konzept der objektorientierten Programmierung. Der Nutzen von Polymorphie wird uns jetzt noch nicht vollst\u00e4ndig deutlich. Wir werden aber immer wieder darauf hinweisen, wenn wir Polymorphie im Einsatz sehen. Vielleicht erkennen Sie ja jetzt besser, warum z.B. die Methode System.out.println(Object o) so funktioniert. Sp\u00e4testens, wenn wir Interfaces behandeln, kommen wir auf dieses Konzept zur\u00fcck.","title":"Dynamische Polymorphie"},{"location":"objekte/","text":"Klassen und Objekte \u00b6 Wir haben bereits grob die Begriffe Klassen und Objekte kennengelernt. Nun wollen wir das Verst\u00e4ndnis daf\u00fcr vertiefen. Dazu erstellen wir uns unsere erste \"richtige\" eigene Klasse. Ein erster eigener Datentyp Adresse \u00b6 Wir erstellen uns ein neues BlueJ-Projekt und nennen es adresse . Darin erstellen wir eine neue Klasse Adresse . Wir l\u00f6schen alles aus dieser Klasse, so dass nur Adresse.java 1 2 3 4 public class Adresse { } \u00fcbrig bleibt. Von dieser Klasse erzeugen wir uns eine Testklasse - BlueJ nennt sie AdresseTest . Ein Doppelklick auf das gr\u00fcne Rechteck der Testklasse \u00f6ffnet den Editor und zeigt AdresseTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class Adresse { import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; /** * The test class AdresseTest. * * @author (your name) * @version (a version number or a date) */ public class AdresseTest { /** * Default constructor for test class AdresseTest */ public AdresseTest () { } /** * Sets up the test fixture. * * Called before every test case method. */ @BeforeEach public void setUp () { } /** * Tears down the test fixture. * * Called after every test case method. */ @AfterEach public void tearDown () { } } } In diese Testklasse f\u00fcgen wir eine Methode testAdresse() wie folgt hinzu: AdresseTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; /** * The test class AdresseTest. * * @author (your name) * @version (a version number or a date) */ public class AdresseTest { /** * Default constructor for test class AdresseTest */ public AdresseTest () { } @Test public void testAdresse () { Adresse adresse1 ; } /** * Sets up the test fixture. * * Called before every test case method. */ @BeforeEach public void setUp () { } /** * Tears down the test fixture. * * Called after every test case method. */ @AfterEach public void tearDown () { } } Wir wollen uns zun\u00e4chst um diese Testklasse nicht weiter k\u00fcmmern und ignorieren auch zun\u00e4chst den gesamten Rest. Um Platz zu sparen, zeigen wir von nun an immer nur noch die testAdresse() -Methode. In dieser Methode sehen wir aber bereits die Deklaration einer Variablen adresse1 vom Typ Adresse . Das bedeutet, dass unser neuer Datentyp Adresse bereits zur Verf\u00fcgung steht und wir ihn verwenden k\u00f6nnen. Wir haben unseren ersten eigenen Datentyp erstellt! Eigenschaften definieren \u00b6 Unser Datentyp Adresse hat noch keine Eigenschaften. Als erstes definieren wir uns Objektvariablen f\u00fcr unsere Klasse: Adresse.java 1 2 3 4 5 6 7 8 9 public class Adresse { // --- Objektvariablen ----- public String strasse ; public int nummer ; public int postleitzahl ; public String wohnort ; } Die Struktur aller Objekte unserer Klasse sieht also wie folgt aus. Jedes Objekt vom Typ Adresse hat eine eigene Variable strasse (vom Typ String ), eine eigene Variable nummer (vom Typ int ), eine eigene Variable postleitzahl (vom Typ int ), eine eigene Variable wohnort (vom Typ String ). Objektvariablen sind global! \u00b6 Bis jetzt hatten wir unsere Variablen immer lokal in einer Methode deklariert. Diese Variablen waren nur in der Methode sichtbar und existierten auch nur in der Methode, in der sie deklariert wurden. Siehe dazu Sichtbarkeit und Lebensdauer von lokalen Variablen . Objektvariablen sind in der Klasse deklariert, nicht in einer Methode - sie sind global . Objektvariablen sind deshalb in der gesamten Klasse sichtbar, d.h. es kann in der gesamten Klasse daruf zugegriffen werden (in jeder Methode der Klasse). Objektvariablen existieren f\u00fcr ein konkretes Objekt. Jedes Objekt hat seine eigenen Objektvariablen. Diese existieren f\u00fcr das Objekt also so lange, solange das Objekt existiert. Objektvariablen sind global und sind in allen Methoden der Klasse sichtbar, d.h. es kann in allen Methoden der Klasse auf die Objektvariablen zugegriffen werden. Objektmethode hinzuf\u00fcgen \u00b6 Jetzt wollen wir auch noch ein Verhalten implementieren und definieren uns dazu eine Objektmethode : Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Adresse { // --- Objektvariablen ----- public String strasse ; public int nummer ; public int postleitzahl ; public String wohnort ; // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } } Objekte erzeugen - der Konstruktor \u00b6 Wir haben jetzt einen \"Bauplan\" f\u00fcr alle Objekte vom Datentyp Adresse erzeugt. Nun wollen wir nach diesem Bauplan Objekte von der Klasse (vom Datentyp) Adresse erzeugen. Das geschieht mithilfe des Konstruktors . der Konstruktor einer Klasse hei\u00dft genau wie die Klasse selbst, ist aber eine Methode (z.B. Adresse() ) Um ein Objekt der Klasse zu erzeugen, verwenden wir das Schl\u00fcsselwort new und rufen dann den Konstruktor der Klasse auf: new Klassenname(); Wir erzeugen in der testAdresse() -Methode der Testklasse zwei Objekte der Klasse Adresse : AdresseTest.java 21 22 23 24 25 26 @Test public void testAdresse () { Adresse adresse1 = new Adresse (); Adresse adresse2 = new Adresse (); } Das generelle Vorgehen bei der Erzeugung eines Objektes zeigt die folgende Abbildung: Wir haben nun zwei Objekte vom Typ Adresse erstellt. Die Referenzvariable adresse1 zeigt auf das erste Objekt (Sie k\u00f6nnen auch sagen, dass adresse1 der Name des ersten Objektes ist) und die Referenzvariable adresse2 zeigt auf das zweite Objekt. Jedes dieser beiden Objekte hat seine eigenen Objektvariablen strasse , nummer , postleitzahl und wohnort und seine eigene Objektmethode getAdresse() . Wir werden jetzt auf diese Eigenschaften zugreifen. Zugriff auf Objekteigenschaften - Punktnotation \u00b6 Auf die Eigenschaften eines Objektes k\u00f6nnen wir \u00fcber die Referenzvariable mittels Punktnotation zugreifen. Die Syntax ist also wie folgt: referenzVariable.eigenschaft Wir verwenden die Punktnotation f\u00fcr unsere Objekte vom Typ Adresse , um ihnen Werte f\u00fcr die Objektvariablen zuzuweisen und jeweils auf die Objektmethode zuzugreifen: AdresseTest.java 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Test public void testAdresse () { Adresse adresse1 = new Adresse (); Adresse adresse2 = new Adresse (); adresse1 . strasse = \"Wilhelminenhofstr.\" ; adresse1 . nummer = 75 ; adresse1 . postleitzahl = 12459 ; adresse1 . wohnort = \"Berlin\" ; adresse2 . strasse = \"Treskowallee\" ; adresse2 . nummer = 8 ; adresse2 . postleitzahl = 10318 ; adresse2 . wohnort = \"Berlin\" ; System . out . println ( adresse1 . getAdresse ()); System . out . println ( adresse2 . getAdresse ()); } Wir weisen also den jeweiligen Objektvariablen der beiden Objekte Werte zu und geben diese jeweils mithilfe der getAdresse() -Methode aus. Es ist ganz wichtig, zu verstehen, dass jedes Objekt seine eigenen Objektvariablen und seine eigenen Objektmethoden hat. Zugriff auf diese Variablen und Methoden gibt es stets nur \u00fcber ein Objekt! Die Ausgabe f\u00fcr obiges Beispiel sieht so aus: Wilhelminenhofstr. 75 in 12459 Berlin Treskowallee 8 in 10318 Berlin Alle Objekte werden also nach dem gleichen \"Bauplan\" erstellt. Alle Objekte vom Typ Adresse haben die Eigenschaften: strasse , nummer , postleitzahl , wohnort und getAdresse() Wenn wir die Klasse Adresse \u00e4ndern, dann \u00e4ndern sich auch die Eigenschaften entsprechend f\u00fcr alle Objekte dieser Klasse. Datenkapselung (Information Hiding) - das Schl\u00fcsselwort private \u00b6 Ein wesentlicher Grundsatz der objektorientierten Programmierung ist das Prinzip der Datenkapselung (auch data hiding oder information hiding genannt). Dieses Prinzip dient dem Datenschutz. Wir wollen vermeiden, dass Unbefugte die Struktur (die Daten) unserer Objekte kennen und Unbefugte die Daten \u00e4ndern k\u00f6nnen, ohne dass wir es erlauben. Angenommen, Sie haben eine Klasse Konto und es w\u00e4re m\u00f6glich, ganz einfach auf ihre pin zuzugreifen. Das w\u00e4re fatal. Bereits der lesende Zugriff darauf k\u00f6nnte sch\u00e4dlich sein, aber genau so \u00e4rgerlich w\u00e4re es, wenn die pin einfach durch Fremde ge\u00e4ndert werden k\u00f6nnte. Wir wollen deshalb sowohl den lesenden als auch den schreibenden Zugriff auf unsere Daten (auf unsere Objektvariablen) verbieten. Dazu deklarieren wir unsere Objektvariablen als private : Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Adresse { // --- Objektvariablen ----- private String strasse ; // Zugriff nur innerhalb der Klasse private int nummer ; // Zugriff nur innerhalb der Klasse private int postleitzahl ; // Zugriff nur innerhalb der Klasse private String wohnort ; // Zugriff nur innerhalb der Klasse // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } } Wir haben die Sichtbarkeit der Objektvariablen in unserer Klasse ge\u00e4ndert. Vorher waren die Objektvariablen als public deklariert. Das f\u00fchrte dazu, dass sie von allen anderen Klassen gelesen und geschrieben werden konnten (z.B. von unserer Testklasse AdresseTest ). Indem wir die Variablen als private deklarieren, ist der Zugriff darauf au\u00dferhalb unserer Klasse nicht mehr m\u00f6glich. Wenn wir uns jetzt unsere Testklasse AdresseTest anschauen, dann sehen wir Fehler: Die Testklasse l\u00e4sst sich nun nicht mehr compilieren und ausf\u00fchren. Auch lesende Zugriffe, z.B. System.out.println(adresse1.wohnort); sind nicht mehr m\u00f6glich. Beachten Sie aber, dass wir weiterhin die Methode getAdresse() aufrufen k\u00f6nnen. Sie ist als public deklariert und deshalb in anderen Klassen durch Adresse -Objekte ausf\u00fchrbar. Wir k\u00f6nnten auch die Methode als private deklarieren, dann w\u00fcrde auch sie nicht mehr ausf\u00fchrbar in anderen Klassen sein. Auf eine als private deklarierte Variable kann au\u00dferhalb der Klasse, in der sie deklariert ist, nicht zugegriffen werden. Eine als private deklarierte Methode kann au\u00dferhalb der Klasse, in der sie definiert ist, nicht ausgef\u00fchrt (aufgerufen) werden. Wie k\u00f6nnen wir unseren Objektvariablen aber nun Werte zuweisen? Daf\u00fcr gibt es zwei Antworten durch einen parametrisierten Konstruktor und durch sogenannte Getter Wir betrachten zun\u00e4chst den parametrisierten Konstruktor. Ein eigener Konstruktor \u00b6 Wir haben einen Konstruktor bereits kennengelernt. Ein Konstruktor ist eine Methode, die genau wie die Klasse hei\u00dft (also auch gro\u00dfgeschrieben) und mit runden Klammern. Wir haben den Konstruktor auch bereits verwendet, n\u00e4mlich zur Erzeugung von Objekten (genau daf\u00fcr ist er auch da). Betrachten wir nochmal die beiden Aufrufe: Adresse adresse1 = new Adresse (); // Aufruf des Standardkonstruktors Adresse adresse2 = new Adresse (); // Aufruf des Standardkonstruktors Wir konnten die Objekte vom Typ Adresse mithilfe des Konstrutors Adresse() erzeugen. Dies ist ein sogenannter Standardkonstruktor , denn er existiert automatisch f\u00fcr jede neue Klasse (f\u00fcr jeden Datentyp), die wir erstellen. Jetzt wollen wir aber einen eigenen Konstruktor definieren, den wir in Zukunft zur Erzeugung unserer Adresse -Objekte verwenden wollen. In unserem neuen Konstruktor wollen wir n\u00e4mlich bereits Werte als Parameter \u00fcbergeben, die f\u00fcr die Initialisierung der Objektvariablen verwendet werden sollen. Wir erweitern unsere Klasse Adresse um einen solchen Konstruktor: Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Adresse { // --- Objektvariablen ----- private String strasse ; // Zugriff nur innerhalb der Klasse private int nummer ; // Zugriff nur innerhalb der Klasse private int postleitzahl ; // Zugriff nur innerhalb der Klasse private String wohnort ; // Zugriff nur innerhalb der Klasse // --- Konstruktor --------- public Adresse ( String str , int nr , int plz , String ort ) { strasse = str ; nummer = nr ; postleitzahl = plz ; wohnort = ort ; } // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } } In den Zeilen 10-16 haben wir einen solchen Konstruktor hinzugef\u00fcgt. Wir \u00fcbergeben dem Konstruktor vier Parameterwerte. Diese Werte werden verwendet, um unsere Objektvariablen zu initialisieren. Der Konstruktor wird aufgerufen, um ein neues Objekt zu erzeugen. Wir verwenden ihn hinter dem Schl\u00fcsselwort new . Bei der Definition eines solchen Konstruktors sind zwei Dinge zu beachten: Der Konstruktor hei\u00dft exakt wie die Klasse (also auch Gro\u00dfschreibung beachten). Der Konstruktor hat keinen R\u00fcckgabetyp (auch nicht void ). Die Aufgabe eines Konstruktors ist einzig und allein Objekte der Klasse zu erzeugen. Die \"R\u00fcckgabe\" eines solchen Konstruktors ist also ein Objekt der Klasse. Theoretisch w\u00e4re der R\u00fcckhgabetyp hier also Adresse . Aber wie gesagt, bei der Definition eines Konstruktors gibt man keinen R\u00fcckgabetyp an! Wenn wir uns nun erneut die Testklasse AdresseTest anschauen, dann sind durch die Definition eines eigenen Konstruktors weitere Fehler hinzugekommen: Dadurch, dass wir einen eigenen Konstruktor geschrieben haben, existiert der Standardkonstruktor Adresse() nicht mehr. Wir m\u00fcssen (und wollen ja auch) nun unseren eigenen Konstruktor verwenden, um Objekte zu erzeugen. Wir passen die Testklasse AdresseTest entsprechend an: AdresseTest.java 1 2 3 4 5 6 7 8 9 @Test public void testAdresse () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); System . out . println ( adresse1 . getAdresse ()); System . out . println ( adresse2 . getAdresse ()); } In den Zeilen 4 und 5 verwenden wir nun den eigenen Konstruktor und \u00fcbergeben die Werte f\u00fcr die Objektvariablen als Parameter. Bei der Erzeugung der Objekte werden die Objektvariablen nun gleich initialisiert. Der direkte Zugriff auf die Objektvariablen wurde entfernt, da dieser aufgrund der private -Deklaration nicht mehr m\u00f6glich ist. Die Ausgaben in Zeilen 7 und 8 zeigen aber, dass die Objekte die entsprechenden Werte enthalten: Wilhelminenhofstr. 75 in 12459 Berlin Treskowallee 8 in 10318 Berlin Die Objekte erhalten somit gleich bei der Erzeugung alle Werte f\u00fcr die Objektvariablen und es ist nun auch nicht mehr m\u00f6glich, diese Werte zu \u00e4ndern. Ein direkter Zugriff auf die Objektvariablen ist nicht m\u00f6glich. Die einzigen Wertzuweisungen finden im Konstruktor statt. Objekte, deren Werte nicht mehr ge\u00e4ndert werden k\u00f6nnen, hei\u00dfen immutable objects ( unver\u00e4nderliche Objekte ). Sehr h\u00e4ufig ist es w\u00fcnschenswert, dass Objekte immutable sind - das vermeidet Fehler. Wir kommen (sehr viel sp\u00e4ter) nochmal darauf zu sprechen. Die einzige Schnittstelle (also die M\u00f6glichkeiten anderer Klassen unseren neuen Datentyp Adresse zu nutzen) unserer Klasse besteht nun aus zwei Methoden: dem Konstruktor zum Erzeugen eines Objektes und der Methode getAdresse() . Wenn wir aber z.B. nur den wohnort wissen wollen, dann ist es derzeit noch nicht m\u00f6glich. Wir wollen deshalb den lesenden Zugriff auf unsere Objektvariablen erlauben und definieren uns daf\u00fcr sogenannte Getter . getXXX() -Methoden - Getter \u00b6 Da die Objektvariablen alle als private deklariert sind, ist au\u00dferhalb der Klasse Adresse kein Zugriff auf diese Variablen m\u00f6glich. Wir k\u00f6nnen ihnen weder Werte zuweisen, noch deren Werte auslesen. Wir haben bereits gesagt, dass dies ein Feature der objektorientierten Programmierung ist, ein solches information hiding einfach durchf\u00fchren zu k\u00f6nnen. Wir k\u00f6nnen jetzt steuern, ob und wie der Zugriff doch m\u00f6glich sein soll. Wenn man bspw. den lesenden Zugriff erlauben m\u00f6chte, dann definiert man sich innerhalb der Klasse sogenannte get -Methoden ( Getter ). Eine solche get -methode gibt den Wert einer Objektvariablen zur\u00fcck. Es wird somit ein lesender Zugriff auf den Wert der Variablen erm\u00f6glicht. F\u00fcr unsere Klasse schreiben wir uns nun f\u00fcr jede Objektvariable einen eigenen Getter: getWohnort() gibt den Wert von wohnort zur\u00fcck, ist also vom R\u00fcckgabetyp String getPostleitzahl() gibt den Wert von postleitzahl zur\u00fcck, ist also vom R\u00fcckgabetyp int getStrasse() gibt den Wert von strasse zur\u00fcck, ist also vom R\u00fcckgabetyp String getNummer() gibt den Wert von nummer zur\u00fcck, ist also vom R\u00fcckgabetyp int Unsere Klasse Adresse sieht nun wie folgt aus: Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class Adresse { // --- Objektvariablen ----- private String strasse ; private int nummer ; private int postleitzahl ; private String wohnort ; // --- Konstruktor --------- public Adresse ( String str , int nr , int plz , String ort ) { strasse = str ; nummer = nr ; postleitzahl = plz ; wohnort = ort ; } // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } public String getStrasse () { return strasse ; } public int getNummer () { return nummer ; } public int getPostleitzahl () { return postleitzahl ; } public String getWohnort () { return wohnort ; } } Unsere Schnittstelle hat sich also erweitert. Es sind jetzt auch mehr Methoden unserer Klasse Adresse nutzbar. Wir probieren die Methoden in unserer Testklasse AdresseTest aus: AdresseTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testAdresse () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); System . out . println ( adresse1 . getAdresse ()); System . out . println ( adresse2 . getAdresse ()); System . out . println ( \"Strasse Nr : \" + adresse1 . getStrasse () + \" \" + adresse1 . getNummer ()); System . out . println ( \"PLZ Wohnort : \" + adresse1 . getPostleitzahl () + \" \" + adresse1 . getWohnort ()); System . out . println ( \"Strasse Nr : \" + adresse2 . getStrasse () + \" \" + adresse1 . getNummer ()); System . out . println ( \"PLZ Wohnort : \" + adresse2 . getPostleitzahl () + \" \" + adresse1 . getWohnort ()); } Beachten Sie, dass der Aufruf unserer get -Methoden auch wieder nur f\u00fcr konkrete Objekte erfolgen kann, hier also f\u00fcr adresse1 und adresse2 . Wir greifen also wieder mittels Punktnotation auf diese Methoden zu. Wir sehen, dass wir nun mithilfe der Getter lesenden Zugriff auf die Objektvariablen haben - in der Testklasse AdresseTest k\u00f6nnen also die einzelnen Werte der Objektvariablen der jeweiligen Adresse -Objekte ausgelesen werden. Success Wir haben unseren ersten eigenen Datentyp erstellt! Wir haben dazu eine Klasse geschrieben. Die Klasse enth\u00e4lt Objektvariablen und Objektmethoden. Wir haben mithilfe des Schl\u00fcsselwortes new und dem Aufruf eines Konstruktors Objekte dieser Klasse erzeugt. \u00dcber die Punktnotation k\u00f6nnen wir auf die Objektmethoden zugreifen und diese ausf\u00fchren. Wir haben au\u00dferdem das Schl\u00fcsselwort private kennengelernt. Auf Objektvariablen und Objektmethoden, die als private deklariert sind, kann au\u00dferhalb der Klasse nicht zugegriffen werden. Um doch einen lesenden Zugriff auf die Werte der Objektvariablen zu erm\u00f6glichen, haben wir Getter definiert. Wir wollen jetzt das Neuerlernte an weiteren Beispielen festigen. Eine weiterer Datentyp Point \u00b6 Angenommen, wir wollen in einem kartesischen Koordinatensystem einen Punkt beschreiben, also soetwas wie in der folgenden Abbildung: Um uns eine eigene Klasse f\u00fcr Point zu schreiben, \u00fcberlegen wir uns zun\u00e4chst, was die allgemeine Struktur eines solchen Punktes ist. Das ist recht leicht aus der oberen Abbildung zu erkennen: ein Punkt wird durch zwei int -Werte x und y beschrieben. Dieses werden also unsere Objektvariablen: Point.java 1 2 3 4 5 6 public class Point { // --- Objektvariablen ----- private int x ; private int y ; } Wir setzen die Objektvariablen nun gleich auf private . Wenn keine zwingenden Gr\u00fcnde dagegen sprechen (und das ist fast nie der Fall), deklarieren wir unsere Objektvariablen stets als private , um dem Prinzip des information hiding zu entsprechen. Hier nochmal eine \u00dcbersicht der bisherigen Begriffe und Bedeutungen: Wir erstellen uns auch gleich einen parametrisierten Konstruktor, um den Objektvariablen bereits beim Erzeugen der Objekte ihre Werte zuzuweisen: Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Point { // --- Objektvariablen ----- private int x ; private int y ; // --- Konstruktor --------- public Point ( int px , int py ) { x = px ; y = py ; } } Wie wir bereits wissen, hei\u00dft der Konstruktor exakt wie die Klasse und hat keinen R\u00fcckgabetyp (auch nicht void ). Achten Sie darauf, dass die Parameter (derzeit noch) anders hei\u00dfen, als die Objektvariablen. Wir haben ansonsten innerhalb des Konstruktors einen Namenskonflikt. Diesen werden wir aufl\u00f6sen, wenn wir das Schl\u00fcsselwort this kennenlernen. In unserer Testklasse (Testklasse PointTest erzeugen und Testmethode testPoint() anlegen) k\u00f6nnen wir uns nun einige Point -Objekte erzeugen: PointTest.java 1 2 3 4 5 6 7 8 @Test public void testPoint () { Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); Point p3 = new Point ( 4 , 6 ); Point p4 = new Point ( 5 , 3 ); } Wir erstellen uns also vier Point -Objekte. Die Variablen p1 , p2 , p3 und p4 referenzieren jeweils ein Point -Objekt und sind vom Typ Point . Wir k\u00f6nnen uns die vier Objekte wie folgt veranschaulichen: Jedes Point -Objekt hat also seine eigenen Objektvariablen mit den dazugeh\u00f6rigen Werten. Getter und eine print() -Methode f\u00fcr Point \u00b6 Wir wollen jetzt, dass au\u00dferhalb der Klasse die Werte von x und y ausgelesen werden k\u00f6nnen. Dazu definieren wir uns Getter, also eine getX() - und eine getY() -Methode. Au\u00dferdem wollen wir eine print() -Methode zur Klasse Point hinzuf\u00fcgen, um die Werte von x und y auf die Konsole auszugeben. Die Klasse Point sieht nun so aus: Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Point { // --- Objektvariablen ----------- private int x ; private int y ; // --- Konstruktor --------------- public Point ( int px , int py ) { x = px ; y = py ; } // --- Getter -------------------- public int getX () { return x ; } public int getY () { return y ; } // --- weitere Objektmethoden ---- public void print () { System . out . println ( \"[ x=\" + x + \", y=\" + y + \" ]\" ); } } Wir testen die neuerstellten Objektmethoden in unserer Testklasse PointTest : PointTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test public void testPoint () { Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); Point p3 = new Point ( 4 , 6 ); Point p4 = new Point ( 5 , 3 ); System . out . println ( \" p1 : ( \" + p1 . getX () + \", \" + p1 . getY () + \" )\" ); System . out . println ( \" p2 : ( \" + p2 . getX () + \", \" + p2 . getY () + \" )\" ); System . out . println ( \" p3 : ( \" + p3 . getX () + \", \" + p3 . getY () + \" )\" ); System . out . println ( \" p4 : ( \" + p4 . getX () + \", \" + p4 . getY () + \" )\" ); p1 . print (); p2 . print (); p3 . print (); p4 . print (); } Wir greifen also wieder \u00fcber die jeweilige Referenzvariable p1 , p2 , p3 bzw. p4 \u00fcber Punktnotation auf die Objektmethoden zu. Beachten Sie, dass - genau wie f\u00fcr die Objektvariablen - auch bei den Objektmethoden jedes Objekt \"seine eigene\" Objektmethode hat. p1.getX() gibt also genau den x -Wert des Objektes aus, auf das p1 zeigt ( 1 ) und p2.getX() gibt also genau den x -Wert des Objektes aus, auf das p2 zeigt ( 2 ). Die print() -Methode gibt genau die x - und y -Werte des Objektes aus, das die print() -Methode aufgerufen hat. Unsere vier Objekte k\u00f6nnen wir uns nun also so veranschaulichen: Die Ausgabe sieht so aus: p1 : ( 1 , 2 ) p2 : ( 2 , 4 ) p3 : ( 4 , 6 ) p4 : ( 5 , 3 ) [ x = 1 , y = 2 ] [ x = 2 , y = 4 ] [ x = 4 , y = 6 ] [ x = 5 , y = 3 ] Wir erstellen eine weitere Objektmethode f\u00fcr die Klasse Point , um einen Punkt zu verschieben. Objektmethode translate() f\u00fcr Point \u00b6 Wir wollen einen Punkt um ein deltaX nach links oder rechts und um ein deltaY nach oben oder unten verschieben: Angenommen, unser Punkt ist, wie in der obigen Abbildung gezeigt, bei x=1 und y=2 und er soll um deltaX=4 nach rechts und um deltaY=3 nach oben verschoben werden, dann ist er nach translate(4,3) bei x=5 und y=5 . Wir implementieren die Objektmethode in der Klasse Point wie folgt: public void translate ( int deltaX , int deltaY ) { x = x + deltaX ; y = y + deltaY ; } Beachten Sie, dass der R\u00fcckgabetyp void ist. Das hatten wir bisher immer nur bei Methoden, in denen eine Ausgabe auf die Konsole erfolgte. Bei Objektmethoden wird dies nun h\u00e4ufig vorkommen. In der Methode translate() werden die Werte von den Objektvariablen x und y neu gesetzt. Sie ergeben sich hier aus den alten Werten von x und y und der Addition mit deltaX bzw. deltaY . Beachten Sie auch, dass die Werte von deltaX und deltaY negativ sein k\u00f6nnen. Dann wird der Punkt nach links bzw. nach unten verschoben. Im Ergebnis der Ausf\u00fchrung der Methode translate() haben die Objektvariablen des Objektes, das diese Methode aufgerufen hat, neue Werte. Wir testen das in unserer Testklasse PointTest : PointTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testPoint () { /* hier gekuerzt - siehe oben */ /* die Erzeugung der Objekte muss bleiben */ /* Testen der Getter und print() kann auch bleiben */ p1 . print (); // [ x=1, y=2 ] p1 . translate ( 4 , 3 ); p1 . print (); // [ x=5, y=5 ] p4 . print (); // [ x=5, y=3 ] p4 . translate ( - 3 , - 1 ); p4 . print (); // [ x=2, y=2 ] } Vergleiche mit anderen Objekten gleichen Typs \u00b6 Angenommen, ein Punkt m\u00f6chte \"wissen\", ob er selbst weiter links positioniert ist, als ein anderer Punkt. Dann muss er seinen eigenen x -Wert mit dem x -Wert des anderen Punktes vergleichen. Wenn wir daf\u00fcr eine Objektmethode schreiben wollen, dann m\u00fcssen wir den anderen Punkt als Parameter \u00fcbergeben. Das ist kein Problem: public boolean isLeft ( Point otherPoint ) { return ( x < otherPoint . x ); } Wir \u00fcbergeben der Objektmethode ein Objekt vom Typ Point . Wir wissen, dass jedes Point -Objekt folgende Eigenschaften hat: x , y , getX() , getY() , print() und translate() Auf diese Eigenschaften k\u00f6nnen wir nat\u00fcrlich auch innerhalb der Klasse \u00fcber die Punktnotation zugreifen. Hierbei ist anzumerken, dass wir innerhalb der Klasse auch direkt auf die x - und y -variablen zugreifen k\u00f6nnen. Der Sichtbarkeitsmodifizierer private besagt nur, dass wir nicht au\u00dferhalb der Klasse auf die Objektvariablen zugreifen k\u00f6nnen. Innerhalb der Klasse ist der direkte Zugriff erlaubt! Wir h\u00e4tten aber auch \u00fcber die getX() -Methode den Wert von x von otherPoint auslesen k\u00f6nnen. Wir erweitern um die Methoden isRight() , isAbove() , isBelow() . Die gesamte Klasse Point sieht dann so aus: Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class Point { // --- Objektvariablen ----------- private int x ; private int y ; // --- Konstruktor --------------- public Point ( int px , int py ) { x = px ; y = py ; } // --- Getter -------------------- public int getX () { return x ; } public int getY () { return y ; } // --- weitere Objektmethoden ---- public void print () { System . out . println ( \"[ x=\" + x + \", y=\" + y + \" ]\" ); } public void translate ( int deltaX , int deltaY ) { x = x + deltaX ; y = y + deltaY ; } public boolean isLeft ( Point otherPoint ) { return ( x < otherPoint . x ); } public boolean isRight ( Point otherPoint ) { return ( x > otherPoint . x ); } public boolean isAbove ( Point otherPoint ) { return ( y > otherPoint . y ); } public boolean isBelow ( Point otherPoint ) { return ( y < otherPoint . y ); } } Wir testen die Methoden in unserer Testklasse: PointTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Test public void testPoint () { Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); Point p3 = new Point ( 4 , 6 ); Point p4 = new Point ( 5 , 3 ); System . out . println ( \" p1 : ( \" + p1 . getX () + \", \" + p1 . getY () + \" )\" ); System . out . println ( \" p2 : ( \" + p2 . getX () + \", \" + p2 . getY () + \" )\" ); System . out . println ( \" p3 : ( \" + p3 . getX () + \", \" + p3 . getY () + \" )\" ); System . out . println ( \" p4 : ( \" + p4 . getX () + \", \" + p4 . getY () + \" )\" ); p1 . print (); p2 . print (); p3 . print (); p4 . print (); p1 . print (); // [ x=1, y=2 ] p1 . translate ( 4 , 3 ); p1 . print (); // [ x=5, y=5 ] p4 . print (); // [ x=5, y=3 ] p4 . translate ( - 3 , - 1 ); p4 . print (); // [ x=2, y=2 ] System . out . println ( \"p1 links von p2 ? \" + p1 . isLeft ( p2 )); // p1.x=5 > p2.x=2 System . out . println ( \"p1 rechts von p2 ? \" + p1 . isRight ( p2 )); System . out . println ( \"p3 ueber p4 ? \" + p3 . isAbove ( p4 )); // p3.y=6 > p4.y=2 System . out . println ( \"p3 unter p4 ? \" + p3 . isBelow ( p4 )); } Beachten Sie, dass es immer ein Objekt gibt, das die Methode aufruft und ein Objekt, das der Methode als Parameter \u00fcbergeben wird. Beispielsweise ist bei p1.isLeft(p2) das Point -Objekt p1 das aufrufende Objekt und das Point -Objekt p2 das Objekt, das der Methode als Parameter\"wert\" \u00fcbergeben wird. p1 vergleicht sich also selbst mit p2 . Da der x -Wert von p1 5 ist und der x -Wert von p2 ist 2 ergibt p1.isLeft(p2) false . Der Aufruf p2.isLeft(p1) w\u00fcrde dann true ergeben. Success Wir haben einen weiteren Datentyp erstellt, n\u00e4mlich Point . In diesem beispiel gibt es eine Methode translate() , in der die Werte der Objektvariablen x und y ge\u00e4ndert werden. Objekte vom Typ Point sind somit nicht immutable (unver\u00e4nderlich). Der R\u00fcckgabetyp solcher Objektmethoden, die die Werte von Objektvariablen \u00e4ndern, ist typischerweise void . Wir haben au\u00dferdem Objektmethoden definiert, in denen sich das aufrufende Objekt mit einem anderen Objekt gleichen Typs vergleicht. Der Vergleich erfolgt \u00fcber die Werte der Objektvariablen sowohl des aufrufenden Objektes, als auch der Werte der Objektvariablen des Objektes, mit dem verglichen wird (das als Parameter \u00fcbergeben wird). Wir festigen unserer neuen Erkenntnisse an noch einem weiteren Beispiel: Ein weiterer Datentyp Circle \u00b6 Wir erstellen uns einen Datentyp, der einen Kreis repr\u00e4sentiert. Wir nennen den Datentyp Circle . Ein Kreis ist durch seinen radius eindeutig beschrieben. Wir k\u00f6nnten als Objektvariable auch den Durchmesser diameter w\u00e4hlen, das bleibt sich gleich und ist eine eigene Programmierentscheidung. Wir sollten aber keinesfalls radius und diameter als Objekteigenschaften w\u00e4hlen, da es ansonsten zu Inkonsistenten kommen k\u00f6nnte - angenommen, radius h\u00e4tte den Wert 5 und diameter den Wert 11 , das w\u00e4re inkonsistent und w\u00fcrde nicht passen. Vielmehr kann der Durchmesser aus dem Radius berechnet werden. Wir implementieren also: Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double pRadius ) { radius = pRadius ; } // ----- Getter der Objektvariablen ----- public double getRadius () { return radius ; } // ----- weitere Objektmethoden --------- public double getDiameter () { return 2.0 * radius ; } public void print () { System . out . println ( \"Radius : \" + radius ); System . out . println ( \"Durchmesser : \" + getDiameter ()); // Aufruf Objektmethode } } Die Objektvariable radius ist wieder als private deklariert - es gibt keinen Grund, dies nicht zu tun. Wir erlauben aber den lesenden Zugriff darauf durch die Erstellung der getRadius() -Methode, die public ist. Au\u00dferdem berechnen wir auch noch den Durchmesser und geben ihn mit der getDiameter() -Methode zur\u00fcck. Beachten Sie, dass sowohl radius als auch getDiameter() vom Typ double sind. Damit wir die Werte auch ausgeben, haben wir eine print() -Methode erstellt. Beachten Sie, dass wir in der print() -Methode die Objektmethode getDiameter() aufrufen. Wir testen den Datentyp Circle in einer Testklasse CircleTest : CircleTest.java 1 2 3 4 5 6 7 8 9 10 @Test public void testCircle () { Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 3.5 ); c1 . print (); System . out . println (); c2 . print (); } Es werden folgende Ausgaben erzeugt: Radius : 5 .0 Durchmesser : 10 .0 Radius : 3 .5 Durchmesser : 7 .0 F\u00fcr einen Kreis k\u00f6nnen wir auch noch den Umfang circumference() und den Fl\u00e4cheninhalt area() berechnen und verwenden dazu die Konstante PI aus der Math -Klasse (siehe Die Klasse Math ). Mit den Ergebnissen der circumference() - und der area() -Methode erweitern wir auch die Ausgabe in print() : Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double pRadius ) { radius = pRadius ; } // ----- Getter der Objektvariablen ----- public double getRadius () { return radius ; } // ----- weitere Objektmethoden --------- public double getDiameter () { return 2.0 * radius ; } public void print () { System . out . println ( \"Radius : \" + radius ); System . out . println ( \"Durchmesser : \" + getDiameter ()); // Aufruf Objektmethode System . out . println ( \"Umfang : \" + circumference ()); // Aufruf Objektmethode System . out . println ( \"Flaecheninhalt : \" + area ()); // Aufruf Objektmethode } public double circumference () { return Math . PI * getDiameter (); } public double area () { return Math . PI * radius * radius ; } } Das erneute Ausf\u00fchren der Testklasse (in der Testklasse nichts ge\u00e4ndert, aber die print() -Methode wurde ge\u00e4ndert) ergibt: Radius : 5 .0 Durchmesser : 10 .0 Umfang : 31 .41592653589793 Flaecheninhalt : 78 .53981633974483 Radius : 3 .5 Durchmesser : 7 .0 Umfang : 21 .991148575128552 Flaecheninhalt : 38 .48451000647496 Zur Wiederholung und Festigung wollen wir auch hier zwei Circle -Objekte miteinander vergleichen. Auch hier gibt es immer ein aufrufendes Circle -Objekt und ein Circle -Objekt, das als Parameter \u00fcbergeben wird. Wir schreiben drei Methoden, die jeweils ein boolean zur\u00fcckgeben: isSmaller() , isBigger() , isEqual() : Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double pRadius ) { radius = pRadius ; } // ----- Getter der Objektvariablen ----- public double getRadius () { return radius ; } // ----- weitere Objektmethoden --------- public double getDiameter () { return 2.0 * radius ; } public void print () { System . out . println ( \"Radius : \" + radius ); System . out . println ( \"Durchmesser : \" + getDiameter ()); // Aufruf Objektmethode System . out . println ( \"Umfang : \" + circumference ()); // Aufruf Objektmethode System . out . println ( \"Flaecheninhalt : \" + area ()); // Aufruf Objektmethode } public double circumference () { return Math . PI * getDiameter (); } public double area () { return Math . PI * radius * radius ; } public boolean isSmaller ( Circle c ) { return ( radius < c . radius ); } public boolean isBigger ( Circle c ) { return ( radius > c . radius ); } public boolean isEqual ( Circle c ) { return ! isSmaller ( c ) && ! isBigger ( c ); } } In der isEqual() -Methode h\u00e4tten wir nat\u00fcrlich auch return radius==c.radius; schreiben k\u00f6nnen. Aber wir wollten hier nochmal die Verwendung von Objektmethoden innerhalb der Klasse zeigen. Die Testklasse CircleTest CircleTest.java 1 2 3 4 5 6 7 8 9 10 @Test public void testCircle () { Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 3.5 ); c1 . print (); System . out . println (); c2 . print (); } erzeugt folgende Ausgaben (nur die Vergleiche): bash c1 groesser als c2 ? true c1 kleiner als c2 ? false c1 gleich c2 ? false c2 groesser als c1 ? false c2 kleiner als c1 ? true c2 gleich c1 ? false c1 groesser als c1 ? false c1 kleiner als c1 ? false c1 gleich c1 ? true Beachten Sie, dass im dritten Vergleichsblock das c1 -Objekt mit sich selbst verglichen wird. Auch das ist ohne Probleme m\u00f6glich (aber normalerweise sinnlos). Success Wir haben in diesem dritten Beispiel die ersten Erkenntnisse \u00fcber das objektorientierte Programmieren wiederholt und gefestigt. In der Klasse Circle haben wir insbesondere h\u00e4ufiger die Objektmethoden innerhalb der Klasse aufgerufen. Die Einf\u00fchrung in die objektorientierte Programmierung ist hiermit zun\u00e4chst beendet. Beim n\u00e4chsten Mal werden wir mehrere Konstruktoren in der Klasse definieren, wir werden eigene Datentypen in neuen Datentypen verwenden und das Schl\u00fcsselwort this kennenlernen. Viel Spa\u00df beim \u00dcben ! Die Klassen Adresse , Point , Circle und Testklasse` Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class Adresse { // --- Objektvariablen ----- private String strasse ; private int nummer ; private int postleitzahl ; private String wohnort ; // --- Konstruktor --------- public Adresse ( String str , int nr , int plz , String ort ) { strasse = str ; nummer = nr ; postleitzahl = plz ; wohnort = ort ; } // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } public String getStrasse () { return strasse ; } public int getNummer () { return nummer ; } public int getPostleitzahl () { return postleitzahl ; } public String getWohnort () { return wohnort ; } } Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class Point { // --- Objektvariablen ----------- private int x ; private int y ; // --- Konstruktor --------------- public Point ( int px , int py ) { x = px ; y = py ; } // --- Getter -------------------- public int getX () { return x ; } public int getY () { return y ; } // --- weitere Objektmethoden ---- public void print () { System . out . println ( \"[ x=\" + x + \", y=\" + y + \" ]\" ); } public void translate ( int deltaX , int deltaY ) { x = x + deltaX ; y = y + deltaY ; } public boolean isLeft ( Point otherPoint ) { return ( x < otherPoint . x ); } public boolean isRight ( Point otherPoint ) { return ( x > otherPoint . x ); } public boolean isAbove ( Point otherPoint ) { return ( y > otherPoint . y ); } public boolean isBelow ( Point otherPoint ) { return ( y < otherPoint . y ); } } Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double pRadius ) { radius = pRadius ; } // ----- Getter der Objektvariablen ----- public double getRadius () { return radius ; } // ----- weitere Objektmethoden --------- public double getDiameter () { return 2.0 * radius ; } public void print () { System . out . println ( \"Radius : \" + radius ); System . out . println ( \"Durchmesser : \" + getDiameter ()); // Aufruf Objektmethode System . out . println ( \"Umfang : \" + circumference ()); // Aufruf Objektmethode System . out . println ( \"Flaecheninhalt : \" + area ()); // Aufruf Objektmethode System . out . println (); } public double circumference () { return Math . PI * getDiameter (); } public double area () { return Math . PI * radius * radius ; } public boolean isSmaller ( Circle c ) { return ( radius < c . radius ); } public boolean isBigger ( Circle c ) { return ( radius > c . radius ); } public boolean isEqual ( Circle c ) { return ! isSmaller ( c ) && ! isBigger ( c ); } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; public class Testklasse { @Test public void testAll () { // Tests fuer Adresse System . out . printf ( \"%n%n ---------------- Testen des Datentyps Adresse ------------------ %n%n\" ); Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); System . out . println ( adresse1 . getAdresse ()); System . out . println ( adresse2 . getAdresse ()); System . out . println ( \"Strasse Nr : \" + adresse1 . getStrasse () + \" \" + adresse1 . getNummer ()); System . out . println ( \"PLZ Wohnort : \" + adresse1 . getPostleitzahl () + \" \" + adresse1 . getWohnort ()); System . out . println ( \"Strasse Nr : \" + adresse2 . getStrasse () + \" \" + adresse1 . getNummer ()); System . out . println ( \"PLZ Wohnort : \" + adresse2 . getPostleitzahl () + \" \" + adresse1 . getWohnort ()); // Tests fuer Point System . out . printf ( \"%n%n ---------------- Testen des Datentyps Point ------------------ %n%n\" ); Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); Point p3 = new Point ( 4 , 6 ); Point p4 = new Point ( 5 , 3 ); System . out . println ( \" p1 : ( \" + p1 . getX () + \", \" + p1 . getY () + \" )\" ); System . out . println ( \" p2 : ( \" + p2 . getX () + \", \" + p2 . getY () + \" )\" ); System . out . println ( \" p3 : ( \" + p3 . getX () + \", \" + p3 . getY () + \" )\" ); System . out . println ( \" p4 : ( \" + p4 . getX () + \", \" + p4 . getY () + \" )\" ); p1 . print (); p2 . print (); p3 . print (); p4 . print (); p1 . print (); // [ x=1, y=2 ] p1 . translate ( 4 , 3 ); p1 . print (); // [ x=5, y=5 ] p4 . print (); // [ x=5, y=3 ] p4 . translate ( - 3 , - 1 ); p4 . print (); // [ x=2, y=2 ] System . out . println ( \"p1 links von p2 ? \" + p1 . isLeft ( p2 )); // p1.x=5 > p2.x=2 System . out . println ( \"p1 rechts von p2 ? \" + p1 . isRight ( p2 )); System . out . println ( \"p3 ueber p4 ? \" + p3 . isAbove ( p4 )); // p3.y=6 > p4.y=2 System . out . println ( \"p3 unter p4 ? \" + p3 . isBelow ( p4 )); // Tests fuer Circle System . out . printf ( \"%n%n ---------------- Testen des Datentyps Circle ------------------ %n%n\" ); Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 3.5 ); c1 . print (); System . out . println (); c2 . print (); System . out . println ( \"c1 groesser als c2 ? \" + c1 . isBigger ( c2 )); System . out . println ( \"c1 kleiner als c2 ? \" + c1 . isSmaller ( c2 )); System . out . println ( \"c1 gleich c2 ? \" + c1 . isEqual ( c2 )); System . out . println (); System . out . println ( \"c2 groesser als c1 ? \" + c2 . isBigger ( c1 )); System . out . println ( \"c2 kleiner als c1 ? \" + c2 . isSmaller ( c1 )); System . out . println ( \"c2 gleich c1 ? \" + c2 . isEqual ( c1 )); System . out . println (); System . out . println ( \"c1 groesser als c1 ? \" + c1 . isBigger ( c1 )); System . out . println ( \"c1 kleiner als c1 ? \" + c1 . isSmaller ( c1 )); System . out . println ( \"c1 gleich c1 ? \" + c1 . isEqual ( c1 )); System . out . println (); } } Klassen und Objekte II \u00b6 Wir machen weiter mit eigenen Datentypen und erstellen uns Objekte, die von diesen Typen sind. Wir werden im Folgenden eigene Datentypen in neuen Datentypen verwenden, mehrere Konstruktoren in der Klasse definieren, in Methoden Objekte erzeugen und diese auch zur\u00fcckgeben und das Schl\u00fcsselwort this kennenlernen. Eigene Datentypen in eigenen Datentypen verwenden \u00b6 Wir beginnen damit, eigene Datentypen in neuen Datentypen zu verwenden, da dies eine gute Wiederholung ist. Angenommen, wir haben unsere Klasse Adresse in einem BlueJ-Projekt erstellt. In diesem Projekt erstellen wir uns eine neue Klasse Person mit folgenden Objektvariablen: name vom Typ String , vorname vom Typ String und adresse vom Typ Adresse . Wir f\u00fcgen auch gleich noch den Konstruktor hinzu und bereiten die print() -Methode vor: Person.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Person { // ------- Objektvariablen ----------- private String name ; private String vorname ; private Adresse adresse ; // ------- Konstruktor ----------- public Person ( String pName , String pVorname , Adresse pAdresse ) { name = pName ; vorname = pVorname ; adresse = pAdresse ; } // ------- Objektmethoden ----------- public void print () { // wie sieht die Ausgabe aus? // wie kann ich die Adresse ausgeben? } } In Zeile 6 verwenden wir die von uns geschriebene Klasse Adresse . der Konstruktor (Zeilen 9-14 ) sieht aus, wie erwartet. Wir initialisieren alle Objektvariablen mit den als Parameter \u00fcbergebenen Werten. in den Zeilen 17-21 haben wir auch schon die print() -Methode vorbereitet. Darin wollen wir alle Informationen \u00fcber das jeweilige Person -Objekt ausgeben. F\u00fcr name und vorname ist das sicherlich einfach. Aber wie kommen wir an die Informationen von adresse ? Wir erstellen uns in einer Testklasse zun\u00e4chst Objekte der Klasse Person . Person -Objekte erzeugen \u00b6 Um Objekte von Person erstellen zu k\u00f6nnen, ben\u00f6tigen wir Objekte des Typs Adresse , da diese dem Konstruktor als Parameter \u00fcbergeben werden m\u00fcssen. Beachten Sie auch hier, dass wir die Klasse Adresse dazu aus dem package themen.objekte importieren. Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Testklasse { public void main () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , adresse1 ); Person max = new Person ( \"Mustermann\" , \"Max\" , adresse2 ); } } Objektmethoden aufrufen \u00b6 Zun\u00e4chst erweitern wir unsere print() -Methode in Person : print() in Person.java erweitern 20 21 22 23 24 25 // ------- Objektmethoden ----------- public void print () { System . out . println ( vorname + \" \" + name ); // wie kann ich die Adresse ausgeben? } In der Testklasse rufen wir die print() -Methode f\u00fcr die beiden Person -Objekte auf: main() in Testklasse.java erweitern 8 9 10 11 12 13 14 15 16 17 18 public void main () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , adresse1 ); Person max = new Person ( \"Mustermann\" , \"Max\" , adresse2 ); maria . print (); max . print (); } Die Ausgabe erfolgt wie gew\u00fcnscht: Maria Musterfrau Max Mustermann Wie k\u00f6nnen wir nun auch die Adressen von maria und max ausgeben? Die Antwort ist: mithilfe der Objektmethoden von Adresse . Schauen wir uns die Objektmethoden von Adresse nochmal an (siehe auch hier ): Objektmethoden von Adresse.java 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } public String getStrasse () { return strasse ; } public int getNummer () { return nummer ; } public int getPostleitzahl () { return postleitzahl ; } public String getWohnort () { return wohnort ; } Alle diese Methoden sind public und k\u00f6nnen von allen Klassen aufgerufen werden. Wir nutzen in der print() -Methode von Person die Objektmethode getAdresse() von Adresse , k\u00f6nnten aber auch alle anderen Objektmethoden verwenden. print() in Person.java erweitern 20 21 22 23 24 25 // ------- Objektmethoden ----------- public void print () { // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse() System . out . println ( vorname + \" \" + name + \" wohnt in \" + adresse . getAdresse ()); } Erneutes Ausf\u00fchren der Testklasse erzeugt nun folgende Ausgabe: Maria Musterfrau wohnt in Wilhelminenhofstr. 75 in 12459 Berlin Max Mustermann wohnt in Treskowallee 8 in 10318 Berlin Die Objekteigenschaft adresse der Klasse Person ist vom Typ Adresse. Um ein Objekt der Klasse Person zu erzeugen, muss dem Konstruktor der Klasse Person ein Objekt der Klasse Adresse \u00fcbergeben werden - das erwartet der Konstruktor als Parameter. Jedes Objekt vom Typ Person \"besitzt\" somit ein eigenes Objekt von Typ Adresse , welches in adresse gespeichert ist. F\u00fcr dieses Objekt k\u00f6nnen alle Objekteigenschaften aus Adresse aufgerufen werden (z.B. auch getStrasse() , getNummer() , getPostleitzahl() und getWohnort() ). Getter f\u00fcr Person erzeugen \u00b6 Wir erstellen uns f\u00fcr die Klasse Person getter (also getXXX() -Methoden) f\u00fcr die Objektvariablen: Person.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Person { // ------- Objektvariablen ----------- private String name ; private String vorname ; private Adresse adresse ; // ------- Konstruktor ----------- public Person ( String pName , String pVorname , Adresse pAdresse ) { name = pName ; vorname = pVorname ; adresse = pAdresse ; } // ------- Objektmethoden ----------- public void print () { // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse() System . out . println ( vorname + \" \" + name + \" wohnt in \" + adresse . getAdresse ()); } public String getName () { return name ; } public String getVorname () { return vorname ; } public Adresse getAdresse () { return adresse ; } } Die Implementierungen der Getter sind so, wie wir sie bereits kennen. Wir nennen die Methoden get und h\u00e4ngen jeweils in camel-case -Schreibweise den Namen der Objektvariablen an, also getName() , getVorname() und getAdrese() . Der R\u00fcckgabetyp der Methode entspricht stets dem Typ der Variablen, also f\u00fcr name und vorname ist der R\u00fcckgabetyp der Methoden getName() und getVorname() jeweils String und der R\u00fcckgabetyp von getAdresse() ist wie der Typ von adresse , n\u00e4mlich Adresse . Wir betrachten nun besonders die Methode getAdresse() der Klasse Person und rufen diese in der Testklasse auf. main() in Testklasse.java erweitern 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void main () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , adresse1 ); Person max = new Person ( \"Mustermann\" , \"Max\" , adresse2 ); maria . print (); max . print (); Adresse mariasAdresse = maria . getAdresse (); // getAdresse() von Person Adresse maxAdresse = max . getAdresse (); // getAdresse() von Person System . out . println ( mariasAdresse . getAdresse ()); // getAdresse() von Adresse System . out . println ( maxAdresse . getAdresse ()); // getAdresse() von Adresse } In Zeile 12 rufen wir die soeben erstelle Methode getAdresse() f\u00fcr das Person -Objekt maria auf. Die R\u00fcckgabe dieser Objektmethode ist die adresse von maria , also ein Objekt vom Typ Adresse , welches wir in der Referenzvariablen mariasAdresse vom Typ Adresse speichern. In Zeile 13 passiert das gleiche mit dem Person -Obejkt max . In der Variablen maxAdresse vom Typ Adresse ist nun das Adresse -Objekt von max gespeichert. f\u00fcr diese beiden Adresse -Objekte k\u00f6nnen wir nun alle Objektmethoden aus Adresse aufrufen. In Zeile 15 wird z.B. die getAdresse() -Methode des Objektes mariasAdresse aufgerufen und in Zeile 16 die getAdresse() -Methode des Adresse -Objektes maxAdresse . Beachten Sie, dass es zwei Methoden mit dem gleichen Namen gibt! Es existiert eine getAdresse() -Methode f\u00fcr den Datentyp Adresse . Diese Methode kann von Objekten des Typs Adresse aufegrufen werden und gibt einen String zur\u00fcck. Au\u00dferdem gibt es eine getAdresse() -Methode f\u00fcr den Datentyp Person . Diese kann von Objekten des Datentyps Person aufgerufen werden und gibt eine Adresse zur\u00fcck. Aneinanderreihung von Aufrufen von Objektmethoden \u00b6 Wir h\u00e4tten in der main() -Methode der Testklasse auch folgende Anweisungen ausf\u00fchren k\u00f6nnen: main() in Testklasse.java erweitern 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public void main () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , adresse1 ); Person max = new Person ( \"Mustermann\" , \"Max\" , adresse2 ); maria . print (); max . print (); Adresse mariasAdresse = maria . getAdresse (); // getAdresse() von Person Adresse maxAdresse = max . getAdresse (); // getAdresse() von Person System . out . println ( mariasAdresse . getAdresse ()); // getAdresse() von Adresse System . out . println ( maxAdresse . getAdresse ()); // getAdresse() von Adresse // ginge auch System . out . println ( maria . getAdresse (). getAdresse ()); // getAdresse() von Person und von Adresse System . out . println ( max . getAdresse (). getAdresse ()); // getAdresse() von Person und von Adresse } Die Anweisung maria.getAdresse() gibt, wie gesagt, ein Adresse -Objekt zur\u00fcck. Wir m\u00fcssen dieses Objekt nicht zwingend zwischenspeichern (so, wie in Zeile 12 ), sondern k\u00f6nnen auch gleich f\u00fcr dieses Objekt eine Objektmethode aufrufen, n\u00e4mlich z.B. die Methode getAdresse() des Typs Adresse , welche einen String zur\u00fcckgibt, der durch println() ausgegeben wird. Das gleiche passiert in Zeile 20 mit dem Person -Objekt max , f\u00fcr das zun\u00e4chst die getAdresse() -Methode aus Person aufgerufen wird, welche ein Adresse -Objekt zur\u00fcckgibt und f\u00fcr diese Adresse -Objekt wird die Objektmethode getAdresse() des Typs Adresse aufgerufen. Wir sehen bereits an diesem einfachen Beispiel, dass eine solche Hintereinanderreihung von Aufrufen von Objektmethoden leicht f\u00fcr Verwirrung Sorgen kann und schwer zu verstehen ist. Hier kommt noch gesondert hinzu, dass verschiedene Methoden gleich hei\u00dfen. Eine solche Hintereinanderreihung von Objektmethoden sollten wir m\u00f6glichst vermeiden. Wir k\u00f6nnten unserer Person -Klasse z.B. eine Methode getAdresseString() hinzuf\u00fcgen, die uns die Adresse als String zur\u00fcckgibt: Person.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class Person { // ------- Objektvariablen ----------- private String name ; private String vorname ; private Adresse adresse ; // ------- Konstruktor ----------- public Person ( String pName , String pVorname , Adresse pAdresse ) { name = pName ; vorname = pVorname ; adresse = pAdresse ; } // ------- Objektmethoden ----------- public void print () { // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse() System . out . println ( vorname + \" \" + name + \" wohnt in \" + adresse . getAdresse ()); } public String getName () { return name ; } public String getVorname () { return vorname ; } public Adresse getAdresse () { return adresse ; } public String getAdresseString () { return adresse . getAdresse (); } } Dann k\u00f6nnten wir in der main() -Methode der Testklasse main() in Testklasse.java erweitern 21 22 23 24 25 26 27 public void main () { /* gekuerzt - siehe oben */ System . out . println ( maria . getAdresseString ()); System . out . println ( max . getAdresseString ()); } die neue Objektmethode aus Person aufrufen und bek\u00e4men die Adresse als String zur\u00fcck. Das Schl\u00fcsselwort this \u00b6 Wir wissen jetzt schon, dass Objektmethoden immer nur von Objekten aufgerufen werden k\u00f6nnen. Wir k\u00f6nnen z.B. nicht einfach nur getAdresseString() aus der Klasse Person aufrufen, sondern ben\u00f6tigen ein Objekt der Klasse Person , welches die Objektmethode aufruft. Objektmethoden k\u00f6nnen nur von einem Objekt aufgerufen werden! In dem obigen Beispiel hatten wir z.B. die Objekte maria und max vom Typ Person , die beide jeweils (f\u00fcr sich) die Objektmethode getAdresseString() aufgerufen haben. Wenn wir uns also den Aufruf einer Objektmethode anschauen, dann wissen wir auch immer: Wenn eine Objektmethode aufgerufen wird, dann immer durch genau ein konkretes Objekt. Innerhalb der Klasse Person wissen wir nicht, von welchem konkreten Objekt eine Objektmethode aufgerufen wird. Die Referenzvariablen max und maria sind z.B. innerhalb der Klasse Person nicht sichtbar (es sind lokale Variablen der main() -Methode von Testklasse ). Wir wissen aber, dass es ein aufrufendes Objekt gibt (denn nur f\u00fcr ein konkretes Objekt kann eine Objektmethode aufgerufen werden). Dieses konkrete Objekt k\u00f6nnen wir innerhalb der Klasse referenzieren - das machen wir mit dem Schl\u00fcsselwort this . this steht also f\u00fcr das konkrete Objekt, das die Methode (gerade) aufruft. this ist das aufrufende Objekt. Schauen wir uns zur Wiederholung nochmal die Klasse Circle an. In der dazugeh\u00f6rigen Testklasse hatten wir zwei Objekte der Klasse Circle erstellt und diese Objekte haben Objektmethoden aufgerufen: Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Testklasse { public void main () { Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 3.5 ); c1 . print (); System . out . println (); c2 . print (); System . out . println ( \"c1 groesser als c2 ? \" + c1 . isBigger ( c2 )); System . out . println ( \"c1 kleiner als c2 ? \" + c1 . isSmaller ( c2 )); System . out . println ( \"c1 gleich c2 ? \" + c1 . isEqual ( c2 )); System . out . println (); } } In den Zeilen 6 und 7 werden die beiden Circle -Objekte erzeugt. In Zeile 9 ruft das c1 -Objekt die print() -Methode auf und in Zeile 11 ruft das c2 -Objekt die print() -Methode auf. Innerhalb der Klasse w\u00e4re dann this einmal das c1 -Objekt (n\u00e4mlich bei c1.print() ) und ein anderes Mal ist this das c2 -Objekt, n\u00e4mlich bei c2.print() . Bei den Aufrufen c1.isBigger(c2) , c1.isSmaller(c2) und c1.isEqual(c2) ist das aufrufende Objekt immer c1 . Wozu ben\u00f6tigen wir this \u00fcberhaupt? Bis jetzt kamen wir ohne this aus. Aber schauen wir uns nur einmal den Konstruktor von Circle an: Circle.java 1 2 3 4 5 6 7 8 9 10 11 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double pRadius ) { radius = pRadius ; } } Im Konstruktor wird die Objektvariable radius mit dem Wert des Parameters pRadius initialisiert. Die Objektvariable radius ist global , d.h. wir haben in jeder Methode der Klasse Zugriff auf diese Variable. Objektvariablen werden innerhalb der Klasse (nicht innerhalb einer Methode) deklariert und sind deshalb in dem gesamten Anweisungsblock der Klasse, also in der gesamten Klasse sichtbar. Wir k\u00f6nnen in allen Methoden der Klasse auf die Objektvariablen zugreifen. Der Parameter pRadius ist eine lokale Variable. Diese Variable wird in der Methode deklariert und ist auch nur dort sichtbar. Sie existiert auch nur, solange die Methode ausgef\u00fchrt wird. Was passiert aber, wenn wir den Parameter genau wir die Objektvariable nennen? Circle.java 1 2 3 4 5 6 7 8 9 10 11 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double radius ) // Parameter heisst wie die Objektvariable { radius = radius ; // Achtung!!! nur Parameter sichtbar - sogenanntes shadowing!!! } } Wenn der Parameter genau so hei\u00dft, wie die Objektvariable, gibt es einen Namenskonflikt. Wir k\u00f6nnen in der Methode auf die Objektvariable zugreifen (sie ist ja global), es gibt aber auch eine lokale Variable mit dem gleichen Namen radius . Woher soll der Compiler (oder die Laufzeitumgebung) nun wissen, ob wir die Objektvariable radius meinen oder die lokale Variable radius ? Tats\u00e4chlich, stehen in der Anweisung radius = radius; in Zeile 9 beide radius f\u00fcr den Parameter, d.h. wir weisen dem Parameter radius dort den Wert des Parameters radius zu. Das ist erstens nicht gewollte und zweitens unsinnig. Die Objektvariable radius wird durch den Parameter radius \u00fcberschattet - sogenanntes shadowing . Wenn wir in diesem Falle die Objektvariable radius meinen, dann m\u00fcssen wir this.radius schreiben. Mit this. k\u00f6nnen wir innerhalb der Klasse auf alle Objekteigenschaften (Objektvariablen und Objektmethoden) zugreifen. Die korrekte Implementierung des Konstruktors lautet also: Circle.java 1 2 3 4 5 6 7 8 9 10 11 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double radius ) // Parameter heisst wie die Objektvariable { this . radius = radius ; // Objektvariable = Parameterwert; } } Jetzt wird der Objektvariablen this.radius der Wert des Parameters radius zugewiesen. Ab jetzt referenzieren wir alle Objekteigenschaften innerhalb der Klasse mit this ! Wir passen zun\u00e4chst die Implementierung von Circle an: Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double radius ) // Parameter heisst wie die Objektvariable { this . radius = radius ; // hier muss this } // ----- Getter der Objektvariablen ----- public double getRadius () { return this . radius ; // hier kann this - sollte ab jetzt aber immer } // ----- weitere Objektmethoden --------- public double getDiameter () { return 2.0 * this . radius ; } public void print () { System . out . println ( \"Radius : \" + this . radius ); System . out . println ( \"Durchmesser : \" + this . getDiameter ()); // Aufruf Objektmethode System . out . println ( \"Umfang : \" + this . circumference ()); // Aufruf Objektmethode System . out . println ( \"Flaecheninhalt : \" + this . area ()); // Aufruf Objektmethode System . out . println (); } public double circumference () { return Math . PI * this . getDiameter (); } public double area () { return Math . PI * this . radius * this . radius ; } public boolean isSmaller ( Circle c ) { return ( this . radius < c . radius ); } public boolean isBigger ( Circle c ) { return ( this . radius > c . radius ); } public boolean isEqual ( Circle c ) { return ! this . isSmaller ( c ) && ! this . isBigger ( c ); } } Wir sehen, dass wir \u00fcberall dort, wo wir auf Objekteigenschaften zugreifen, die Referenz this. davor gesetzt haben. das sollten wir von un ab in Zukunft auch immer so handhaben, da der Code dann leichter erweiterbar ist (wir m\u00fcssen uns nicht darum k\u00fcmmern, ob eine neue lokale Variable eventuell genau so hei\u00dft, wie eine Objektvariable) und er ist auch besser lesbar, denn wir k\u00f6nnen leichter zwischen Methoden anderer Klassen und eigenen unterscheiden. Betrachten wir die Implementierung der Methode isSmaller() nochmal genauer: public boolean isSmaller ( Circle c ) { return ( this . radius < c . radius ); } Angenommen, wir haben, wie oben in dem Beispiel, in der main() -Methode den Aufruf c1.isSmaller(c2) . Dann ist c1 das aufrufende Objekt dieser Objektmethode und steht innerhalb der Klasse f\u00fcr das this . Das Objekt c2 wird als Parameter \u00fcbergeben und steht in der Implementierung f\u00fcr das Objekt c der Klasse Circle . Innerhalb der Methode werden die Werte von radius vom aufrufenden Objekt this und vom Parameter c miteinander verglichen. Wir passen auch unsere Klasse Person entsprechend an: Person.java mit this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class Person { // ------- Objektvariablen ----------- private String name ; private String vorname ; private Adresse adresse ; // ------- Konstruktor ----------- public Person ( String name , String vorname , Adresse adresse ) { this . name = name ; this . vorname = vorname ; this . adresse = adresse ; } // ------- Objektmethoden ----------- public void print () { // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse() System . out . println ( this . vorname + \" \" + this . name + \" wohnt in \" + this . adresse . getAdresse ()); } public String getName () { return this . name ; } public String getVorname () { return this . vorname ; } public Adresse getAdresse () { return this . adresse ; } public String getAdresseString () { return this . adresse . getAdresse (); } } Insbesondere innerhalb der Methode getAdresseString() erkennen wir gut, dass wir darin nicht auf die getAdresse() -Methode von Person zugreifen, sondern auf die getAdresse() -Methode von Adresse . Wir haben auch die Parameter des Konstruktors anegpasst, denn es ist v\u00f6llig \u00fcblich, die Parameter so zu nennen, wie die Objektvariablen, die damit initialisiert werden sollen. Aber dann muss vor den Objektvariablen auch jeweils this. stehen! Integrieren Sie auch in den Klassen Adresse und Point die this. -Referenz! Mehrere Konstruktoren \u00b6 Es kann vorkommen, dass wir gar nicht allen Objektvariablen einen Wert im Konstruktor \u00fcbergeben wollen. Wenn wir f\u00fcr eine Objektvariable keinen Wert im Konstruktor \u00fcbergeben, dann soll dieser Objektvariablen ein Standardwert zugewiesen werden. Ein einfaches Beispiel w\u00e4re, dass wir f\u00fcr unsere Klasse Circle einen Konstruktor haben, dem ein Wert f\u00fcr radius \u00fcbergeben wird und einen Konstruktor, der parameterlos ist, dem also kein Wert f\u00fcr radius \u00fcbergeben wird. In diesem Fall soll radius den Wert 1.0 annhmen, also der Einheitskreis sein. Diese Anforderung erf\u00fcllen wir, indem wir zwei Konstruktoren definieren: Circle.java mit zwei Konstruktoren 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktoren ---------------- public Circle ( double radius ) // Parameter heisst wie die Objektvariable { this . radius = radius ; // hier muss this } public Circle () // parameterlos { this . radius = 1.0 ; // Standardwert - Einheitskreis } /* alle anderen Methoden bleiben, wie sie sind - siehe oben */ } Jetzt k\u00f6nnen Objekte von Circle sowohl unter Verwendung des parametrisierten Konstruktors, als auch unter Verwendung des parameterlosen Konstruktors erzeugt werden: Testklasse.java - Auszug main()-Methode Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 3.5 ); Circle c3 = new Circle (); // parameterloser Konstruktor - Einheitskreis c1 . print (); c2 . print (); c3 . print (); ergibt folgende Ausgabe: Radius : 5 .0 Durchmesser : 10 .0 Umfang : 31 .41592653589793 Flaecheninhalt : 78 .53981633974483 Radius : 3 .5 Durchmesser : 7 .0 Umfang : 21 .991148575128552 Flaecheninhalt : 38 .48451000647496 Radius : 1 .0 Durchmesser : 2 .0 Umfang : 6 .283185307179586 Flaecheninhalt : 3 .141592653589793 Das Prinzip, das hierbei angewendet wird, nennt sich \u00dcberladen von Methoden . \u00dcberladen von Methoden \u00b6 Wir hatten dieses Prinzip auch bereits in \u00dcbung 4 angewendet, wo wir zwei print() -Methoden erstellt hatten. Die eine print() -Methode hat ein char[] als Parameter erwartet und die andere ein int[] . Das \u00dcberladen von Methoden erfolgt immer dann, wenn Methoden gleichen Namens existieren. Wichtig ist, dass sich diese Methoden in ihrer Parameterliste unterscheiden. Was bedeutet, dass sich Parameterlisten von Methoden unterscheiden? Methoden haben eine unterschiedliche Parameterliste , wenn sich die Anzahl der Parameter unterscheidet oder wenn sich die Typen bzw. die Typreihenfolge der Parameter unterscheiden. Angenommen, unsere Methode hei\u00dft method , dann haben folgende Methoden eine unterschiedliche Parmaterliste: method(int number) // nur ein Parameter method(int nr1, int nr2) // zwei Parameter int, int method(double nr1, double nr2) // zwei Parameter double, double method(int nr1, double nr2) // zwei Parameter int, double method(double nr1, int nr2) // zwei parameter double, int Die Methode method w\u00e4re also in diesem Fall (wenn es jeweils noch passende Implementierungen dazu gibt), f\u00fcnf Mal \u00fcberladen . Dem Compiler muss beim Aufruf klar sein, welche der jeweiligen Methoden er aufrufen muss. Das ist durch unterschiedliche Parameterlisten gegeben. Folgende Beispiele zeigen dies: method(3.0, 3); // ruft Methode 5. auf method(3, 3); // ruft Methode 2. auf method(3.0, 3.0); // ruft Methode 3. auf method(3); // ruft Methode 1. auf method(3, 3.0); // ruft Methode 4. auf Die Namen der Parameter spielen keine Rolle. Beispielsweise w\u00e4re method(int number1, int number2) ein Dopplung zu Methode 2. Das programm lie\u00dfe sich gar nicht \u00fcbersetzen. Auch der R\u00fcckgabetyp wird nicht zur Unterscheidung der Methodensignatur hinzugezogen. Die beiden Methoden int method(int nr1, int nr2) und double method(int nr1, int nr2) w\u00e4ren ebenfalls eine Dopplung. Woher soll der Compiler beim Aufruf von z.B. method(3, 3); wissen, welche der beiden Methoden ausgef\u00fchrt werden soll, die die ein int zur\u00fcckgibt oder die, die ein double zur\u00fcckgibt. Zur Methodensignatur geh\u00f6ren der Name der Methode und die Parameterliste. F\u00fcr alle Methoden einer Klasse m\u00fcssen sich deren Methodensignaturen unterscheiden, also entweder deren Namen oder deren Parameterlisten. Mehrere Konstruktoren in Point \u00b6 F\u00fcr unsere Klasse Point wollen wir ebenfalls mehrere Konstruktoren definieren: Konstruktor mit zwei Paramtern (haben wir schon) \u2192 x und y werden mit den Parameterwerten initialisiert Konstruktor mit einem Parameter \u2192 x und y bekommen den gleichen Wert, den des Parameters Konstruktor ohne Parameter \u2192 x und y bekommen jeweils den Wert 0 Point.java Ausschnitt nur Konstruktoren public class Point { // --- Objektvariablen ----------- private int x ; private int y ; // --- Konstruktoren --------------- public Point ( int x , int y ) { this . x = x ; this . y = y ; } public Point ( int value ) { this . x = value ; this . y = value ; } public Point () { this . x = 0 ; this . y = 0 ; } /* restliche Methoden bleiben gleich - hier gekuerzt */ /* siehe oben. */ Mehrere Konstruktoren in Person \u00b6 Der Konstruktor in Person sieht derzeit so aus: public Person ( String name , String vorname , Adresse adresse ) { this . name = name ; this . vorname = vorname ; this . adresse = adresse ; } Das hei\u00dft, wir erwarten ein Objekt vom Typ Adresse , um ein Objekt vom Typ Person erstellen zu k\u00f6nnen. Es k\u00f6nnte ja aber sein, dass ein solches Objekt (noch) gar nicht existiert und wir selbst ein solches Objekt innerhalb unserer Konstruktors erstellen m\u00fcssen. Wir br\u00e4uchten daf\u00fcr nur alle Informationen, um das Objekt erstellen zu k\u00f6nnen, also eine Strasse ( String ), eine Hausnummer ( int ), ein Wohnort ( String ) und eine Postleitzahl ( int ). Wir erstellen uns einen Konstruktor, der daf\u00fcr Werte \u00fcbergibt (und auch f\u00fcr name und vorname ): public Person ( String name , String vorname , String strasse , int nummer , int postleitzahl , String wohnort ) { this . name = name ; this . vorname = vorname ; this . adresse = new Adresse ( strasse , nummer , postleitzahl , wohnort ); } Es wird also kein existierendes Adresse -Objekt dem Konstruktor \u00fcbergeben, sondern erst im Konstruktor eines erstellt. Die restliche Implementierung der Klasse Person \u00e4ndert sich aber nicht, da sich ja auch f\u00fcr adresse nichts ge\u00e4ndert hat - die Variable zeigt auf ein Adresse -Objekt. Objekterzeugende Methoden \u00b6 Genau die gleiche L\u00f6sung k\u00f6nnen wir verwenden, wenn eine Person umzieht, also ihre Adresse \u00e4ndert. umzug() ist dabei auf jeden Fall eher eine Eigenschaft der Klasse Person , als der Klasse Adresse ! Wir erweitern die Klasse Person um zwei umzug() -Methoden. Die eine erwartet ein (neues) Adresse -Objekt und die andere bekommt Werte f\u00fcr die Erstellung eines neuen Adresse -Objektes \u00fcbergeben: Person.java - Auszug: umzug()-Methoden 1 2 3 4 5 6 7 8 9 public void umzug ( Adresse neueAdresse ) { this . adresse = neueAdresse ; } public void umzug ( String neueStrasse , int neueNummer , int neuePostleitzahl , String neuerWohnort ) { this . adresse = new Adresse ( neueStrasse , neueNummer , neuePostleitzahl , neuerWohnort ); } Der Aufruf in der main() -Methode k\u00f6nnte dann so aussehen: public void main () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , adresse1 ); System . out . println ( maria . getAdresseString ()); maria . umzug ( adresse2 ); System . out . println ( maria . getAdresseString ()); maria . umzug ( \"Rudower Chaussee\" , 25 , 12489 , \"Berlin\" ); System . out . println ( maria . getAdresseString ()); } mit folgender Ausgabe: Wilhelminenhofstr. 75 in 12459 Berlin Treskowallee 8 in 10318 Berlin Rudower Chaussee 25 in 12489 Berlin Objekterzeugende Methoden mit Objekt als R\u00fcckgabe \u00b6 Wir betrachten zur Wiederholung erneut die Klasse Point . Wir erinnern uns: ein Point bestand aus einer x - und einer y -Koordinate. Wir hatten verschiedene Objektmethoden f\u00fcr Point erstellt - siehe hier . Angenommen, wir wollen zwei Punkte addieren - z.B. ein Point p1 und ein Point p2 . Die Idee dabei ist, dass die Summe der beiden x -Werte ( p1.x + p2.x ) einen neuen x -Wert und die Summe der beiden y -Werte ( p1.y + p2.y ) einen neuen y -Wert ergibt. Wir starten einen ersten Versuch und implementieren eine add() -Methode wie folgt: public void add ( Point p ) { this . x = this . x + p . x ; this . y = this . y + p . y ; } Der Aufruf in einer Testklasse mit: Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); p1 . print (); p1 . add ( p2 ); p1 . print (); f\u00fchrt zu folgender Ausgabe: [ x = 1 , y = 2 ] [ x = 3 , y = 6 ] Das hei\u00dft, durch die Addition mit p2 hat sich das p1 -Objekt ge\u00e4ndert. Die Frage ist, ob das beabsichtigt ist und eine eindeutige Antwort ja oder nein kann hier nicht gegeben werden. Es ist nicht ganz klar, ob sich das aufrufende Objekt selbst ver\u00e4ndern sollte, wenn es mit einem anderen Point addiert wird. Insbesondere macht es einen Unterschied, ob wir p1.add(p2) aufrufen oder p2.add(p1) . Im ersten Fall ist nach der Addition p1 -> [ x=3, y=6 ] und p2 -> [ x=2, y=4 ] . Im zweiten Fall ist nach der Addition p1 -> [ x=1, y=2 ] und p2 -> [ x=3, y=6 ] . Wir erreichen also einen anderen Gesamtzustand des Systems. Es spricht Vieles daf\u00fcr, die Implementierung zu \u00e4ndern und die beiden sich addierenden Punkte unver\u00e4ndert zu lassen und stattdessen einen neuen Point zu erzeugen: public Point add ( Point p ) { int newX = this . x + p . x ; int newY = this . y + p . y ; return new Point ( newX , newY ); } Das hei\u00dft, wir ermitteln erneut die Summen this.x + p.x bzw. this.y + p.y , doch anstelle mit diesen Summen das aufrufende Objekt zu \u00e4ndern, wird ein neues Point -Objekt erstellt. Wenn man sich nun den Gesamtzustand des gesamten Systems nach der Addition von p1 und p2 anschaut, dann ist es egal, ob wir p1.add(p2) oder ob wir p2.add(p1) aufgerufen haben. Wir haben nach der Addition drei Point-Objekte mit den Werten p1 -> [ x=1, y=2 ] , p2 -> [ x=2, y=4 ] und ein neues Point -Objekt mit [ x=3, y=6 ] . Obiges Beispiel aus der Testklasse w\u00fcrde dann so aussehen: Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); p1 . print (); Point p3 = p1 . add ( p2 ); // kann auch p2.add(p1), ist egal p3 . print (); mit der Ausgabe [ x = 1 , y = 2 ] [ x = 3 , y = 6 ] Wesentlichster Unterschied zur ersten Variante ist, dass sich weder p1 noch p2 durch die Addition ge\u00e4ndert haben. Wenn wir das Ziel verfolgen, m\u00f6glichst unver\u00e4nderliche Objekte zu erzeugen, dann ist die zweite L\u00f6sung auf jeden Fall die bessere. So oder so haben wir eine Methode kennengelernt, in der ein Objekt der Klasse erzeugt und dieses Objekt zur\u00fcckgegeben wird. Solche Objekte kommen nicht selten vor - und nun kennen wir ein Beispiel. Weitere Beispiele werden wir in der Aufgabe Bruch erzeugen. Success Wir haben eigene Datentypen in der Definition eigener Datentypen verwendet. Wir haben das Schl\u00fcsselwort this kennengerlernt, mit dem wir innerhalb der Klasse das aufrufende Objekt referenzieren k\u00f6nnen. Wir haben das \u00dcberladen von Methoden betrachtet und Konstruktoren in Klassen mehrfach \u00fcberladen. Das \u00dcberladen von Methoden l\u00e4sst sich auf alle Methoden anwenden. Dar\u00fcber hinaus haben wir Methoden erstellt, in denen Objekte erzeugt werden. Zuletzt gibt eine solche Methode das von ihr erzeugte Objekt auch zur\u00fcck.","title":"Klassen und Objekte"},{"location":"objekte/#klassen-und-objekte","text":"Wir haben bereits grob die Begriffe Klassen und Objekte kennengelernt. Nun wollen wir das Verst\u00e4ndnis daf\u00fcr vertiefen. Dazu erstellen wir uns unsere erste \"richtige\" eigene Klasse.","title":"Klassen und Objekte"},{"location":"objekte/#ein-erster-eigener-datentyp-adresse","text":"Wir erstellen uns ein neues BlueJ-Projekt und nennen es adresse . Darin erstellen wir eine neue Klasse Adresse . Wir l\u00f6schen alles aus dieser Klasse, so dass nur Adresse.java 1 2 3 4 public class Adresse { } \u00fcbrig bleibt. Von dieser Klasse erzeugen wir uns eine Testklasse - BlueJ nennt sie AdresseTest . Ein Doppelklick auf das gr\u00fcne Rechteck der Testklasse \u00f6ffnet den Editor und zeigt AdresseTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class Adresse { import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; /** * The test class AdresseTest. * * @author (your name) * @version (a version number or a date) */ public class AdresseTest { /** * Default constructor for test class AdresseTest */ public AdresseTest () { } /** * Sets up the test fixture. * * Called before every test case method. */ @BeforeEach public void setUp () { } /** * Tears down the test fixture. * * Called after every test case method. */ @AfterEach public void tearDown () { } } } In diese Testklasse f\u00fcgen wir eine Methode testAdresse() wie folgt hinzu: AdresseTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; /** * The test class AdresseTest. * * @author (your name) * @version (a version number or a date) */ public class AdresseTest { /** * Default constructor for test class AdresseTest */ public AdresseTest () { } @Test public void testAdresse () { Adresse adresse1 ; } /** * Sets up the test fixture. * * Called before every test case method. */ @BeforeEach public void setUp () { } /** * Tears down the test fixture. * * Called after every test case method. */ @AfterEach public void tearDown () { } } Wir wollen uns zun\u00e4chst um diese Testklasse nicht weiter k\u00fcmmern und ignorieren auch zun\u00e4chst den gesamten Rest. Um Platz zu sparen, zeigen wir von nun an immer nur noch die testAdresse() -Methode. In dieser Methode sehen wir aber bereits die Deklaration einer Variablen adresse1 vom Typ Adresse . Das bedeutet, dass unser neuer Datentyp Adresse bereits zur Verf\u00fcgung steht und wir ihn verwenden k\u00f6nnen. Wir haben unseren ersten eigenen Datentyp erstellt!","title":"Ein erster eigener Datentyp Adresse"},{"location":"objekte/#eigenschaften-definieren","text":"Unser Datentyp Adresse hat noch keine Eigenschaften. Als erstes definieren wir uns Objektvariablen f\u00fcr unsere Klasse: Adresse.java 1 2 3 4 5 6 7 8 9 public class Adresse { // --- Objektvariablen ----- public String strasse ; public int nummer ; public int postleitzahl ; public String wohnort ; } Die Struktur aller Objekte unserer Klasse sieht also wie folgt aus. Jedes Objekt vom Typ Adresse hat eine eigene Variable strasse (vom Typ String ), eine eigene Variable nummer (vom Typ int ), eine eigene Variable postleitzahl (vom Typ int ), eine eigene Variable wohnort (vom Typ String ).","title":"Eigenschaften definieren"},{"location":"objekte/#objektvariablen-sind-global","text":"Bis jetzt hatten wir unsere Variablen immer lokal in einer Methode deklariert. Diese Variablen waren nur in der Methode sichtbar und existierten auch nur in der Methode, in der sie deklariert wurden. Siehe dazu Sichtbarkeit und Lebensdauer von lokalen Variablen . Objektvariablen sind in der Klasse deklariert, nicht in einer Methode - sie sind global . Objektvariablen sind deshalb in der gesamten Klasse sichtbar, d.h. es kann in der gesamten Klasse daruf zugegriffen werden (in jeder Methode der Klasse). Objektvariablen existieren f\u00fcr ein konkretes Objekt. Jedes Objekt hat seine eigenen Objektvariablen. Diese existieren f\u00fcr das Objekt also so lange, solange das Objekt existiert. Objektvariablen sind global und sind in allen Methoden der Klasse sichtbar, d.h. es kann in allen Methoden der Klasse auf die Objektvariablen zugegriffen werden.","title":"Objektvariablen sind global!"},{"location":"objekte/#objektmethode-hinzufugen","text":"Jetzt wollen wir auch noch ein Verhalten implementieren und definieren uns dazu eine Objektmethode : Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Adresse { // --- Objektvariablen ----- public String strasse ; public int nummer ; public int postleitzahl ; public String wohnort ; // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } }","title":"Objektmethode hinzuf\u00fcgen"},{"location":"objekte/#objekte-erzeugen-der-konstruktor","text":"Wir haben jetzt einen \"Bauplan\" f\u00fcr alle Objekte vom Datentyp Adresse erzeugt. Nun wollen wir nach diesem Bauplan Objekte von der Klasse (vom Datentyp) Adresse erzeugen. Das geschieht mithilfe des Konstruktors . der Konstruktor einer Klasse hei\u00dft genau wie die Klasse selbst, ist aber eine Methode (z.B. Adresse() ) Um ein Objekt der Klasse zu erzeugen, verwenden wir das Schl\u00fcsselwort new und rufen dann den Konstruktor der Klasse auf: new Klassenname(); Wir erzeugen in der testAdresse() -Methode der Testklasse zwei Objekte der Klasse Adresse : AdresseTest.java 21 22 23 24 25 26 @Test public void testAdresse () { Adresse adresse1 = new Adresse (); Adresse adresse2 = new Adresse (); } Das generelle Vorgehen bei der Erzeugung eines Objektes zeigt die folgende Abbildung: Wir haben nun zwei Objekte vom Typ Adresse erstellt. Die Referenzvariable adresse1 zeigt auf das erste Objekt (Sie k\u00f6nnen auch sagen, dass adresse1 der Name des ersten Objektes ist) und die Referenzvariable adresse2 zeigt auf das zweite Objekt. Jedes dieser beiden Objekte hat seine eigenen Objektvariablen strasse , nummer , postleitzahl und wohnort und seine eigene Objektmethode getAdresse() . Wir werden jetzt auf diese Eigenschaften zugreifen.","title":"Objekte erzeugen - der Konstruktor"},{"location":"objekte/#zugriff-auf-objekteigenschaften-punktnotation","text":"Auf die Eigenschaften eines Objektes k\u00f6nnen wir \u00fcber die Referenzvariable mittels Punktnotation zugreifen. Die Syntax ist also wie folgt: referenzVariable.eigenschaft Wir verwenden die Punktnotation f\u00fcr unsere Objekte vom Typ Adresse , um ihnen Werte f\u00fcr die Objektvariablen zuzuweisen und jeweils auf die Objektmethode zuzugreifen: AdresseTest.java 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Test public void testAdresse () { Adresse adresse1 = new Adresse (); Adresse adresse2 = new Adresse (); adresse1 . strasse = \"Wilhelminenhofstr.\" ; adresse1 . nummer = 75 ; adresse1 . postleitzahl = 12459 ; adresse1 . wohnort = \"Berlin\" ; adresse2 . strasse = \"Treskowallee\" ; adresse2 . nummer = 8 ; adresse2 . postleitzahl = 10318 ; adresse2 . wohnort = \"Berlin\" ; System . out . println ( adresse1 . getAdresse ()); System . out . println ( adresse2 . getAdresse ()); } Wir weisen also den jeweiligen Objektvariablen der beiden Objekte Werte zu und geben diese jeweils mithilfe der getAdresse() -Methode aus. Es ist ganz wichtig, zu verstehen, dass jedes Objekt seine eigenen Objektvariablen und seine eigenen Objektmethoden hat. Zugriff auf diese Variablen und Methoden gibt es stets nur \u00fcber ein Objekt! Die Ausgabe f\u00fcr obiges Beispiel sieht so aus: Wilhelminenhofstr. 75 in 12459 Berlin Treskowallee 8 in 10318 Berlin Alle Objekte werden also nach dem gleichen \"Bauplan\" erstellt. Alle Objekte vom Typ Adresse haben die Eigenschaften: strasse , nummer , postleitzahl , wohnort und getAdresse() Wenn wir die Klasse Adresse \u00e4ndern, dann \u00e4ndern sich auch die Eigenschaften entsprechend f\u00fcr alle Objekte dieser Klasse.","title":"Zugriff auf Objekteigenschaften - Punktnotation"},{"location":"objekte/#datenkapselung-information-hiding-das-schlusselwort-private","text":"Ein wesentlicher Grundsatz der objektorientierten Programmierung ist das Prinzip der Datenkapselung (auch data hiding oder information hiding genannt). Dieses Prinzip dient dem Datenschutz. Wir wollen vermeiden, dass Unbefugte die Struktur (die Daten) unserer Objekte kennen und Unbefugte die Daten \u00e4ndern k\u00f6nnen, ohne dass wir es erlauben. Angenommen, Sie haben eine Klasse Konto und es w\u00e4re m\u00f6glich, ganz einfach auf ihre pin zuzugreifen. Das w\u00e4re fatal. Bereits der lesende Zugriff darauf k\u00f6nnte sch\u00e4dlich sein, aber genau so \u00e4rgerlich w\u00e4re es, wenn die pin einfach durch Fremde ge\u00e4ndert werden k\u00f6nnte. Wir wollen deshalb sowohl den lesenden als auch den schreibenden Zugriff auf unsere Daten (auf unsere Objektvariablen) verbieten. Dazu deklarieren wir unsere Objektvariablen als private : Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Adresse { // --- Objektvariablen ----- private String strasse ; // Zugriff nur innerhalb der Klasse private int nummer ; // Zugriff nur innerhalb der Klasse private int postleitzahl ; // Zugriff nur innerhalb der Klasse private String wohnort ; // Zugriff nur innerhalb der Klasse // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } } Wir haben die Sichtbarkeit der Objektvariablen in unserer Klasse ge\u00e4ndert. Vorher waren die Objektvariablen als public deklariert. Das f\u00fchrte dazu, dass sie von allen anderen Klassen gelesen und geschrieben werden konnten (z.B. von unserer Testklasse AdresseTest ). Indem wir die Variablen als private deklarieren, ist der Zugriff darauf au\u00dferhalb unserer Klasse nicht mehr m\u00f6glich. Wenn wir uns jetzt unsere Testklasse AdresseTest anschauen, dann sehen wir Fehler: Die Testklasse l\u00e4sst sich nun nicht mehr compilieren und ausf\u00fchren. Auch lesende Zugriffe, z.B. System.out.println(adresse1.wohnort); sind nicht mehr m\u00f6glich. Beachten Sie aber, dass wir weiterhin die Methode getAdresse() aufrufen k\u00f6nnen. Sie ist als public deklariert und deshalb in anderen Klassen durch Adresse -Objekte ausf\u00fchrbar. Wir k\u00f6nnten auch die Methode als private deklarieren, dann w\u00fcrde auch sie nicht mehr ausf\u00fchrbar in anderen Klassen sein. Auf eine als private deklarierte Variable kann au\u00dferhalb der Klasse, in der sie deklariert ist, nicht zugegriffen werden. Eine als private deklarierte Methode kann au\u00dferhalb der Klasse, in der sie definiert ist, nicht ausgef\u00fchrt (aufgerufen) werden. Wie k\u00f6nnen wir unseren Objektvariablen aber nun Werte zuweisen? Daf\u00fcr gibt es zwei Antworten durch einen parametrisierten Konstruktor und durch sogenannte Getter Wir betrachten zun\u00e4chst den parametrisierten Konstruktor.","title":"Datenkapselung (Information Hiding) - das Schl\u00fcsselwort private"},{"location":"objekte/#ein-eigener-konstruktor","text":"Wir haben einen Konstruktor bereits kennengelernt. Ein Konstruktor ist eine Methode, die genau wie die Klasse hei\u00dft (also auch gro\u00dfgeschrieben) und mit runden Klammern. Wir haben den Konstruktor auch bereits verwendet, n\u00e4mlich zur Erzeugung von Objekten (genau daf\u00fcr ist er auch da). Betrachten wir nochmal die beiden Aufrufe: Adresse adresse1 = new Adresse (); // Aufruf des Standardkonstruktors Adresse adresse2 = new Adresse (); // Aufruf des Standardkonstruktors Wir konnten die Objekte vom Typ Adresse mithilfe des Konstrutors Adresse() erzeugen. Dies ist ein sogenannter Standardkonstruktor , denn er existiert automatisch f\u00fcr jede neue Klasse (f\u00fcr jeden Datentyp), die wir erstellen. Jetzt wollen wir aber einen eigenen Konstruktor definieren, den wir in Zukunft zur Erzeugung unserer Adresse -Objekte verwenden wollen. In unserem neuen Konstruktor wollen wir n\u00e4mlich bereits Werte als Parameter \u00fcbergeben, die f\u00fcr die Initialisierung der Objektvariablen verwendet werden sollen. Wir erweitern unsere Klasse Adresse um einen solchen Konstruktor: Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Adresse { // --- Objektvariablen ----- private String strasse ; // Zugriff nur innerhalb der Klasse private int nummer ; // Zugriff nur innerhalb der Klasse private int postleitzahl ; // Zugriff nur innerhalb der Klasse private String wohnort ; // Zugriff nur innerhalb der Klasse // --- Konstruktor --------- public Adresse ( String str , int nr , int plz , String ort ) { strasse = str ; nummer = nr ; postleitzahl = plz ; wohnort = ort ; } // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } } In den Zeilen 10-16 haben wir einen solchen Konstruktor hinzugef\u00fcgt. Wir \u00fcbergeben dem Konstruktor vier Parameterwerte. Diese Werte werden verwendet, um unsere Objektvariablen zu initialisieren. Der Konstruktor wird aufgerufen, um ein neues Objekt zu erzeugen. Wir verwenden ihn hinter dem Schl\u00fcsselwort new . Bei der Definition eines solchen Konstruktors sind zwei Dinge zu beachten: Der Konstruktor hei\u00dft exakt wie die Klasse (also auch Gro\u00dfschreibung beachten). Der Konstruktor hat keinen R\u00fcckgabetyp (auch nicht void ). Die Aufgabe eines Konstruktors ist einzig und allein Objekte der Klasse zu erzeugen. Die \"R\u00fcckgabe\" eines solchen Konstruktors ist also ein Objekt der Klasse. Theoretisch w\u00e4re der R\u00fcckhgabetyp hier also Adresse . Aber wie gesagt, bei der Definition eines Konstruktors gibt man keinen R\u00fcckgabetyp an! Wenn wir uns nun erneut die Testklasse AdresseTest anschauen, dann sind durch die Definition eines eigenen Konstruktors weitere Fehler hinzugekommen: Dadurch, dass wir einen eigenen Konstruktor geschrieben haben, existiert der Standardkonstruktor Adresse() nicht mehr. Wir m\u00fcssen (und wollen ja auch) nun unseren eigenen Konstruktor verwenden, um Objekte zu erzeugen. Wir passen die Testklasse AdresseTest entsprechend an: AdresseTest.java 1 2 3 4 5 6 7 8 9 @Test public void testAdresse () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); System . out . println ( adresse1 . getAdresse ()); System . out . println ( adresse2 . getAdresse ()); } In den Zeilen 4 und 5 verwenden wir nun den eigenen Konstruktor und \u00fcbergeben die Werte f\u00fcr die Objektvariablen als Parameter. Bei der Erzeugung der Objekte werden die Objektvariablen nun gleich initialisiert. Der direkte Zugriff auf die Objektvariablen wurde entfernt, da dieser aufgrund der private -Deklaration nicht mehr m\u00f6glich ist. Die Ausgaben in Zeilen 7 und 8 zeigen aber, dass die Objekte die entsprechenden Werte enthalten: Wilhelminenhofstr. 75 in 12459 Berlin Treskowallee 8 in 10318 Berlin Die Objekte erhalten somit gleich bei der Erzeugung alle Werte f\u00fcr die Objektvariablen und es ist nun auch nicht mehr m\u00f6glich, diese Werte zu \u00e4ndern. Ein direkter Zugriff auf die Objektvariablen ist nicht m\u00f6glich. Die einzigen Wertzuweisungen finden im Konstruktor statt. Objekte, deren Werte nicht mehr ge\u00e4ndert werden k\u00f6nnen, hei\u00dfen immutable objects ( unver\u00e4nderliche Objekte ). Sehr h\u00e4ufig ist es w\u00fcnschenswert, dass Objekte immutable sind - das vermeidet Fehler. Wir kommen (sehr viel sp\u00e4ter) nochmal darauf zu sprechen. Die einzige Schnittstelle (also die M\u00f6glichkeiten anderer Klassen unseren neuen Datentyp Adresse zu nutzen) unserer Klasse besteht nun aus zwei Methoden: dem Konstruktor zum Erzeugen eines Objektes und der Methode getAdresse() . Wenn wir aber z.B. nur den wohnort wissen wollen, dann ist es derzeit noch nicht m\u00f6glich. Wir wollen deshalb den lesenden Zugriff auf unsere Objektvariablen erlauben und definieren uns daf\u00fcr sogenannte Getter .","title":"Ein eigener Konstruktor"},{"location":"objekte/#getxxx-methoden-getter","text":"Da die Objektvariablen alle als private deklariert sind, ist au\u00dferhalb der Klasse Adresse kein Zugriff auf diese Variablen m\u00f6glich. Wir k\u00f6nnen ihnen weder Werte zuweisen, noch deren Werte auslesen. Wir haben bereits gesagt, dass dies ein Feature der objektorientierten Programmierung ist, ein solches information hiding einfach durchf\u00fchren zu k\u00f6nnen. Wir k\u00f6nnen jetzt steuern, ob und wie der Zugriff doch m\u00f6glich sein soll. Wenn man bspw. den lesenden Zugriff erlauben m\u00f6chte, dann definiert man sich innerhalb der Klasse sogenannte get -Methoden ( Getter ). Eine solche get -methode gibt den Wert einer Objektvariablen zur\u00fcck. Es wird somit ein lesender Zugriff auf den Wert der Variablen erm\u00f6glicht. F\u00fcr unsere Klasse schreiben wir uns nun f\u00fcr jede Objektvariable einen eigenen Getter: getWohnort() gibt den Wert von wohnort zur\u00fcck, ist also vom R\u00fcckgabetyp String getPostleitzahl() gibt den Wert von postleitzahl zur\u00fcck, ist also vom R\u00fcckgabetyp int getStrasse() gibt den Wert von strasse zur\u00fcck, ist also vom R\u00fcckgabetyp String getNummer() gibt den Wert von nummer zur\u00fcck, ist also vom R\u00fcckgabetyp int Unsere Klasse Adresse sieht nun wie folgt aus: Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class Adresse { // --- Objektvariablen ----- private String strasse ; private int nummer ; private int postleitzahl ; private String wohnort ; // --- Konstruktor --------- public Adresse ( String str , int nr , int plz , String ort ) { strasse = str ; nummer = nr ; postleitzahl = plz ; wohnort = ort ; } // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } public String getStrasse () { return strasse ; } public int getNummer () { return nummer ; } public int getPostleitzahl () { return postleitzahl ; } public String getWohnort () { return wohnort ; } } Unsere Schnittstelle hat sich also erweitert. Es sind jetzt auch mehr Methoden unserer Klasse Adresse nutzbar. Wir probieren die Methoden in unserer Testklasse AdresseTest aus: AdresseTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testAdresse () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); System . out . println ( adresse1 . getAdresse ()); System . out . println ( adresse2 . getAdresse ()); System . out . println ( \"Strasse Nr : \" + adresse1 . getStrasse () + \" \" + adresse1 . getNummer ()); System . out . println ( \"PLZ Wohnort : \" + adresse1 . getPostleitzahl () + \" \" + adresse1 . getWohnort ()); System . out . println ( \"Strasse Nr : \" + adresse2 . getStrasse () + \" \" + adresse1 . getNummer ()); System . out . println ( \"PLZ Wohnort : \" + adresse2 . getPostleitzahl () + \" \" + adresse1 . getWohnort ()); } Beachten Sie, dass der Aufruf unserer get -Methoden auch wieder nur f\u00fcr konkrete Objekte erfolgen kann, hier also f\u00fcr adresse1 und adresse2 . Wir greifen also wieder mittels Punktnotation auf diese Methoden zu. Wir sehen, dass wir nun mithilfe der Getter lesenden Zugriff auf die Objektvariablen haben - in der Testklasse AdresseTest k\u00f6nnen also die einzelnen Werte der Objektvariablen der jeweiligen Adresse -Objekte ausgelesen werden. Success Wir haben unseren ersten eigenen Datentyp erstellt! Wir haben dazu eine Klasse geschrieben. Die Klasse enth\u00e4lt Objektvariablen und Objektmethoden. Wir haben mithilfe des Schl\u00fcsselwortes new und dem Aufruf eines Konstruktors Objekte dieser Klasse erzeugt. \u00dcber die Punktnotation k\u00f6nnen wir auf die Objektmethoden zugreifen und diese ausf\u00fchren. Wir haben au\u00dferdem das Schl\u00fcsselwort private kennengelernt. Auf Objektvariablen und Objektmethoden, die als private deklariert sind, kann au\u00dferhalb der Klasse nicht zugegriffen werden. Um doch einen lesenden Zugriff auf die Werte der Objektvariablen zu erm\u00f6glichen, haben wir Getter definiert. Wir wollen jetzt das Neuerlernte an weiteren Beispielen festigen.","title":"getXXX()-Methoden - Getter"},{"location":"objekte/#eine-weiterer-datentyp-point","text":"Angenommen, wir wollen in einem kartesischen Koordinatensystem einen Punkt beschreiben, also soetwas wie in der folgenden Abbildung: Um uns eine eigene Klasse f\u00fcr Point zu schreiben, \u00fcberlegen wir uns zun\u00e4chst, was die allgemeine Struktur eines solchen Punktes ist. Das ist recht leicht aus der oberen Abbildung zu erkennen: ein Punkt wird durch zwei int -Werte x und y beschrieben. Dieses werden also unsere Objektvariablen: Point.java 1 2 3 4 5 6 public class Point { // --- Objektvariablen ----- private int x ; private int y ; } Wir setzen die Objektvariablen nun gleich auf private . Wenn keine zwingenden Gr\u00fcnde dagegen sprechen (und das ist fast nie der Fall), deklarieren wir unsere Objektvariablen stets als private , um dem Prinzip des information hiding zu entsprechen. Hier nochmal eine \u00dcbersicht der bisherigen Begriffe und Bedeutungen: Wir erstellen uns auch gleich einen parametrisierten Konstruktor, um den Objektvariablen bereits beim Erzeugen der Objekte ihre Werte zuzuweisen: Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Point { // --- Objektvariablen ----- private int x ; private int y ; // --- Konstruktor --------- public Point ( int px , int py ) { x = px ; y = py ; } } Wie wir bereits wissen, hei\u00dft der Konstruktor exakt wie die Klasse und hat keinen R\u00fcckgabetyp (auch nicht void ). Achten Sie darauf, dass die Parameter (derzeit noch) anders hei\u00dfen, als die Objektvariablen. Wir haben ansonsten innerhalb des Konstruktors einen Namenskonflikt. Diesen werden wir aufl\u00f6sen, wenn wir das Schl\u00fcsselwort this kennenlernen. In unserer Testklasse (Testklasse PointTest erzeugen und Testmethode testPoint() anlegen) k\u00f6nnen wir uns nun einige Point -Objekte erzeugen: PointTest.java 1 2 3 4 5 6 7 8 @Test public void testPoint () { Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); Point p3 = new Point ( 4 , 6 ); Point p4 = new Point ( 5 , 3 ); } Wir erstellen uns also vier Point -Objekte. Die Variablen p1 , p2 , p3 und p4 referenzieren jeweils ein Point -Objekt und sind vom Typ Point . Wir k\u00f6nnen uns die vier Objekte wie folgt veranschaulichen: Jedes Point -Objekt hat also seine eigenen Objektvariablen mit den dazugeh\u00f6rigen Werten.","title":"Eine weiterer Datentyp Point"},{"location":"objekte/#getter-und-eine-print-methode-fur-point","text":"Wir wollen jetzt, dass au\u00dferhalb der Klasse die Werte von x und y ausgelesen werden k\u00f6nnen. Dazu definieren wir uns Getter, also eine getX() - und eine getY() -Methode. Au\u00dferdem wollen wir eine print() -Methode zur Klasse Point hinzuf\u00fcgen, um die Werte von x und y auf die Konsole auszugeben. Die Klasse Point sieht nun so aus: Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Point { // --- Objektvariablen ----------- private int x ; private int y ; // --- Konstruktor --------------- public Point ( int px , int py ) { x = px ; y = py ; } // --- Getter -------------------- public int getX () { return x ; } public int getY () { return y ; } // --- weitere Objektmethoden ---- public void print () { System . out . println ( \"[ x=\" + x + \", y=\" + y + \" ]\" ); } } Wir testen die neuerstellten Objektmethoden in unserer Testklasse PointTest : PointTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Test public void testPoint () { Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); Point p3 = new Point ( 4 , 6 ); Point p4 = new Point ( 5 , 3 ); System . out . println ( \" p1 : ( \" + p1 . getX () + \", \" + p1 . getY () + \" )\" ); System . out . println ( \" p2 : ( \" + p2 . getX () + \", \" + p2 . getY () + \" )\" ); System . out . println ( \" p3 : ( \" + p3 . getX () + \", \" + p3 . getY () + \" )\" ); System . out . println ( \" p4 : ( \" + p4 . getX () + \", \" + p4 . getY () + \" )\" ); p1 . print (); p2 . print (); p3 . print (); p4 . print (); } Wir greifen also wieder \u00fcber die jeweilige Referenzvariable p1 , p2 , p3 bzw. p4 \u00fcber Punktnotation auf die Objektmethoden zu. Beachten Sie, dass - genau wie f\u00fcr die Objektvariablen - auch bei den Objektmethoden jedes Objekt \"seine eigene\" Objektmethode hat. p1.getX() gibt also genau den x -Wert des Objektes aus, auf das p1 zeigt ( 1 ) und p2.getX() gibt also genau den x -Wert des Objektes aus, auf das p2 zeigt ( 2 ). Die print() -Methode gibt genau die x - und y -Werte des Objektes aus, das die print() -Methode aufgerufen hat. Unsere vier Objekte k\u00f6nnen wir uns nun also so veranschaulichen: Die Ausgabe sieht so aus: p1 : ( 1 , 2 ) p2 : ( 2 , 4 ) p3 : ( 4 , 6 ) p4 : ( 5 , 3 ) [ x = 1 , y = 2 ] [ x = 2 , y = 4 ] [ x = 4 , y = 6 ] [ x = 5 , y = 3 ] Wir erstellen eine weitere Objektmethode f\u00fcr die Klasse Point , um einen Punkt zu verschieben.","title":"Getter und eine print()-Methode f\u00fcr Point"},{"location":"objekte/#objektmethode-translate-fur-point","text":"Wir wollen einen Punkt um ein deltaX nach links oder rechts und um ein deltaY nach oben oder unten verschieben: Angenommen, unser Punkt ist, wie in der obigen Abbildung gezeigt, bei x=1 und y=2 und er soll um deltaX=4 nach rechts und um deltaY=3 nach oben verschoben werden, dann ist er nach translate(4,3) bei x=5 und y=5 . Wir implementieren die Objektmethode in der Klasse Point wie folgt: public void translate ( int deltaX , int deltaY ) { x = x + deltaX ; y = y + deltaY ; } Beachten Sie, dass der R\u00fcckgabetyp void ist. Das hatten wir bisher immer nur bei Methoden, in denen eine Ausgabe auf die Konsole erfolgte. Bei Objektmethoden wird dies nun h\u00e4ufig vorkommen. In der Methode translate() werden die Werte von den Objektvariablen x und y neu gesetzt. Sie ergeben sich hier aus den alten Werten von x und y und der Addition mit deltaX bzw. deltaY . Beachten Sie auch, dass die Werte von deltaX und deltaY negativ sein k\u00f6nnen. Dann wird der Punkt nach links bzw. nach unten verschoben. Im Ergebnis der Ausf\u00fchrung der Methode translate() haben die Objektvariablen des Objektes, das diese Methode aufgerufen hat, neue Werte. Wir testen das in unserer Testklasse PointTest : PointTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testPoint () { /* hier gekuerzt - siehe oben */ /* die Erzeugung der Objekte muss bleiben */ /* Testen der Getter und print() kann auch bleiben */ p1 . print (); // [ x=1, y=2 ] p1 . translate ( 4 , 3 ); p1 . print (); // [ x=5, y=5 ] p4 . print (); // [ x=5, y=3 ] p4 . translate ( - 3 , - 1 ); p4 . print (); // [ x=2, y=2 ] }","title":"Objektmethode translate() f\u00fcr Point"},{"location":"objekte/#vergleiche-mit-anderen-objekten-gleichen-typs","text":"Angenommen, ein Punkt m\u00f6chte \"wissen\", ob er selbst weiter links positioniert ist, als ein anderer Punkt. Dann muss er seinen eigenen x -Wert mit dem x -Wert des anderen Punktes vergleichen. Wenn wir daf\u00fcr eine Objektmethode schreiben wollen, dann m\u00fcssen wir den anderen Punkt als Parameter \u00fcbergeben. Das ist kein Problem: public boolean isLeft ( Point otherPoint ) { return ( x < otherPoint . x ); } Wir \u00fcbergeben der Objektmethode ein Objekt vom Typ Point . Wir wissen, dass jedes Point -Objekt folgende Eigenschaften hat: x , y , getX() , getY() , print() und translate() Auf diese Eigenschaften k\u00f6nnen wir nat\u00fcrlich auch innerhalb der Klasse \u00fcber die Punktnotation zugreifen. Hierbei ist anzumerken, dass wir innerhalb der Klasse auch direkt auf die x - und y -variablen zugreifen k\u00f6nnen. Der Sichtbarkeitsmodifizierer private besagt nur, dass wir nicht au\u00dferhalb der Klasse auf die Objektvariablen zugreifen k\u00f6nnen. Innerhalb der Klasse ist der direkte Zugriff erlaubt! Wir h\u00e4tten aber auch \u00fcber die getX() -Methode den Wert von x von otherPoint auslesen k\u00f6nnen. Wir erweitern um die Methoden isRight() , isAbove() , isBelow() . Die gesamte Klasse Point sieht dann so aus: Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class Point { // --- Objektvariablen ----------- private int x ; private int y ; // --- Konstruktor --------------- public Point ( int px , int py ) { x = px ; y = py ; } // --- Getter -------------------- public int getX () { return x ; } public int getY () { return y ; } // --- weitere Objektmethoden ---- public void print () { System . out . println ( \"[ x=\" + x + \", y=\" + y + \" ]\" ); } public void translate ( int deltaX , int deltaY ) { x = x + deltaX ; y = y + deltaY ; } public boolean isLeft ( Point otherPoint ) { return ( x < otherPoint . x ); } public boolean isRight ( Point otherPoint ) { return ( x > otherPoint . x ); } public boolean isAbove ( Point otherPoint ) { return ( y > otherPoint . y ); } public boolean isBelow ( Point otherPoint ) { return ( y < otherPoint . y ); } } Wir testen die Methoden in unserer Testklasse: PointTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Test public void testPoint () { Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); Point p3 = new Point ( 4 , 6 ); Point p4 = new Point ( 5 , 3 ); System . out . println ( \" p1 : ( \" + p1 . getX () + \", \" + p1 . getY () + \" )\" ); System . out . println ( \" p2 : ( \" + p2 . getX () + \", \" + p2 . getY () + \" )\" ); System . out . println ( \" p3 : ( \" + p3 . getX () + \", \" + p3 . getY () + \" )\" ); System . out . println ( \" p4 : ( \" + p4 . getX () + \", \" + p4 . getY () + \" )\" ); p1 . print (); p2 . print (); p3 . print (); p4 . print (); p1 . print (); // [ x=1, y=2 ] p1 . translate ( 4 , 3 ); p1 . print (); // [ x=5, y=5 ] p4 . print (); // [ x=5, y=3 ] p4 . translate ( - 3 , - 1 ); p4 . print (); // [ x=2, y=2 ] System . out . println ( \"p1 links von p2 ? \" + p1 . isLeft ( p2 )); // p1.x=5 > p2.x=2 System . out . println ( \"p1 rechts von p2 ? \" + p1 . isRight ( p2 )); System . out . println ( \"p3 ueber p4 ? \" + p3 . isAbove ( p4 )); // p3.y=6 > p4.y=2 System . out . println ( \"p3 unter p4 ? \" + p3 . isBelow ( p4 )); } Beachten Sie, dass es immer ein Objekt gibt, das die Methode aufruft und ein Objekt, das der Methode als Parameter \u00fcbergeben wird. Beispielsweise ist bei p1.isLeft(p2) das Point -Objekt p1 das aufrufende Objekt und das Point -Objekt p2 das Objekt, das der Methode als Parameter\"wert\" \u00fcbergeben wird. p1 vergleicht sich also selbst mit p2 . Da der x -Wert von p1 5 ist und der x -Wert von p2 ist 2 ergibt p1.isLeft(p2) false . Der Aufruf p2.isLeft(p1) w\u00fcrde dann true ergeben. Success Wir haben einen weiteren Datentyp erstellt, n\u00e4mlich Point . In diesem beispiel gibt es eine Methode translate() , in der die Werte der Objektvariablen x und y ge\u00e4ndert werden. Objekte vom Typ Point sind somit nicht immutable (unver\u00e4nderlich). Der R\u00fcckgabetyp solcher Objektmethoden, die die Werte von Objektvariablen \u00e4ndern, ist typischerweise void . Wir haben au\u00dferdem Objektmethoden definiert, in denen sich das aufrufende Objekt mit einem anderen Objekt gleichen Typs vergleicht. Der Vergleich erfolgt \u00fcber die Werte der Objektvariablen sowohl des aufrufenden Objektes, als auch der Werte der Objektvariablen des Objektes, mit dem verglichen wird (das als Parameter \u00fcbergeben wird). Wir festigen unserer neuen Erkenntnisse an noch einem weiteren Beispiel:","title":"Vergleiche mit anderen Objekten gleichen Typs"},{"location":"objekte/#ein-weiterer-datentyp-circle","text":"Wir erstellen uns einen Datentyp, der einen Kreis repr\u00e4sentiert. Wir nennen den Datentyp Circle . Ein Kreis ist durch seinen radius eindeutig beschrieben. Wir k\u00f6nnten als Objektvariable auch den Durchmesser diameter w\u00e4hlen, das bleibt sich gleich und ist eine eigene Programmierentscheidung. Wir sollten aber keinesfalls radius und diameter als Objekteigenschaften w\u00e4hlen, da es ansonsten zu Inkonsistenten kommen k\u00f6nnte - angenommen, radius h\u00e4tte den Wert 5 und diameter den Wert 11 , das w\u00e4re inkonsistent und w\u00fcrde nicht passen. Vielmehr kann der Durchmesser aus dem Radius berechnet werden. Wir implementieren also: Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double pRadius ) { radius = pRadius ; } // ----- Getter der Objektvariablen ----- public double getRadius () { return radius ; } // ----- weitere Objektmethoden --------- public double getDiameter () { return 2.0 * radius ; } public void print () { System . out . println ( \"Radius : \" + radius ); System . out . println ( \"Durchmesser : \" + getDiameter ()); // Aufruf Objektmethode } } Die Objektvariable radius ist wieder als private deklariert - es gibt keinen Grund, dies nicht zu tun. Wir erlauben aber den lesenden Zugriff darauf durch die Erstellung der getRadius() -Methode, die public ist. Au\u00dferdem berechnen wir auch noch den Durchmesser und geben ihn mit der getDiameter() -Methode zur\u00fcck. Beachten Sie, dass sowohl radius als auch getDiameter() vom Typ double sind. Damit wir die Werte auch ausgeben, haben wir eine print() -Methode erstellt. Beachten Sie, dass wir in der print() -Methode die Objektmethode getDiameter() aufrufen. Wir testen den Datentyp Circle in einer Testklasse CircleTest : CircleTest.java 1 2 3 4 5 6 7 8 9 10 @Test public void testCircle () { Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 3.5 ); c1 . print (); System . out . println (); c2 . print (); } Es werden folgende Ausgaben erzeugt: Radius : 5 .0 Durchmesser : 10 .0 Radius : 3 .5 Durchmesser : 7 .0 F\u00fcr einen Kreis k\u00f6nnen wir auch noch den Umfang circumference() und den Fl\u00e4cheninhalt area() berechnen und verwenden dazu die Konstante PI aus der Math -Klasse (siehe Die Klasse Math ). Mit den Ergebnissen der circumference() - und der area() -Methode erweitern wir auch die Ausgabe in print() : Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double pRadius ) { radius = pRadius ; } // ----- Getter der Objektvariablen ----- public double getRadius () { return radius ; } // ----- weitere Objektmethoden --------- public double getDiameter () { return 2.0 * radius ; } public void print () { System . out . println ( \"Radius : \" + radius ); System . out . println ( \"Durchmesser : \" + getDiameter ()); // Aufruf Objektmethode System . out . println ( \"Umfang : \" + circumference ()); // Aufruf Objektmethode System . out . println ( \"Flaecheninhalt : \" + area ()); // Aufruf Objektmethode } public double circumference () { return Math . PI * getDiameter (); } public double area () { return Math . PI * radius * radius ; } } Das erneute Ausf\u00fchren der Testklasse (in der Testklasse nichts ge\u00e4ndert, aber die print() -Methode wurde ge\u00e4ndert) ergibt: Radius : 5 .0 Durchmesser : 10 .0 Umfang : 31 .41592653589793 Flaecheninhalt : 78 .53981633974483 Radius : 3 .5 Durchmesser : 7 .0 Umfang : 21 .991148575128552 Flaecheninhalt : 38 .48451000647496 Zur Wiederholung und Festigung wollen wir auch hier zwei Circle -Objekte miteinander vergleichen. Auch hier gibt es immer ein aufrufendes Circle -Objekt und ein Circle -Objekt, das als Parameter \u00fcbergeben wird. Wir schreiben drei Methoden, die jeweils ein boolean zur\u00fcckgeben: isSmaller() , isBigger() , isEqual() : Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double pRadius ) { radius = pRadius ; } // ----- Getter der Objektvariablen ----- public double getRadius () { return radius ; } // ----- weitere Objektmethoden --------- public double getDiameter () { return 2.0 * radius ; } public void print () { System . out . println ( \"Radius : \" + radius ); System . out . println ( \"Durchmesser : \" + getDiameter ()); // Aufruf Objektmethode System . out . println ( \"Umfang : \" + circumference ()); // Aufruf Objektmethode System . out . println ( \"Flaecheninhalt : \" + area ()); // Aufruf Objektmethode } public double circumference () { return Math . PI * getDiameter (); } public double area () { return Math . PI * radius * radius ; } public boolean isSmaller ( Circle c ) { return ( radius < c . radius ); } public boolean isBigger ( Circle c ) { return ( radius > c . radius ); } public boolean isEqual ( Circle c ) { return ! isSmaller ( c ) && ! isBigger ( c ); } } In der isEqual() -Methode h\u00e4tten wir nat\u00fcrlich auch return radius==c.radius; schreiben k\u00f6nnen. Aber wir wollten hier nochmal die Verwendung von Objektmethoden innerhalb der Klasse zeigen. Die Testklasse CircleTest CircleTest.java 1 2 3 4 5 6 7 8 9 10 @Test public void testCircle () { Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 3.5 ); c1 . print (); System . out . println (); c2 . print (); } erzeugt folgende Ausgaben (nur die Vergleiche): bash c1 groesser als c2 ? true c1 kleiner als c2 ? false c1 gleich c2 ? false c2 groesser als c1 ? false c2 kleiner als c1 ? true c2 gleich c1 ? false c1 groesser als c1 ? false c1 kleiner als c1 ? false c1 gleich c1 ? true Beachten Sie, dass im dritten Vergleichsblock das c1 -Objekt mit sich selbst verglichen wird. Auch das ist ohne Probleme m\u00f6glich (aber normalerweise sinnlos). Success Wir haben in diesem dritten Beispiel die ersten Erkenntnisse \u00fcber das objektorientierte Programmieren wiederholt und gefestigt. In der Klasse Circle haben wir insbesondere h\u00e4ufiger die Objektmethoden innerhalb der Klasse aufgerufen. Die Einf\u00fchrung in die objektorientierte Programmierung ist hiermit zun\u00e4chst beendet. Beim n\u00e4chsten Mal werden wir mehrere Konstruktoren in der Klasse definieren, wir werden eigene Datentypen in neuen Datentypen verwenden und das Schl\u00fcsselwort this kennenlernen. Viel Spa\u00df beim \u00dcben ! Die Klassen Adresse , Point , Circle und Testklasse` Adresse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class Adresse { // --- Objektvariablen ----- private String strasse ; private int nummer ; private int postleitzahl ; private String wohnort ; // --- Konstruktor --------- public Adresse ( String str , int nr , int plz , String ort ) { strasse = str ; nummer = nr ; postleitzahl = plz ; wohnort = ort ; } // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } public String getStrasse () { return strasse ; } public int getNummer () { return nummer ; } public int getPostleitzahl () { return postleitzahl ; } public String getWohnort () { return wohnort ; } } Point.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 public class Point { // --- Objektvariablen ----------- private int x ; private int y ; // --- Konstruktor --------------- public Point ( int px , int py ) { x = px ; y = py ; } // --- Getter -------------------- public int getX () { return x ; } public int getY () { return y ; } // --- weitere Objektmethoden ---- public void print () { System . out . println ( \"[ x=\" + x + \", y=\" + y + \" ]\" ); } public void translate ( int deltaX , int deltaY ) { x = x + deltaX ; y = y + deltaY ; } public boolean isLeft ( Point otherPoint ) { return ( x < otherPoint . x ); } public boolean isRight ( Point otherPoint ) { return ( x > otherPoint . x ); } public boolean isAbove ( Point otherPoint ) { return ( y > otherPoint . y ); } public boolean isBelow ( Point otherPoint ) { return ( y < otherPoint . y ); } } Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double pRadius ) { radius = pRadius ; } // ----- Getter der Objektvariablen ----- public double getRadius () { return radius ; } // ----- weitere Objektmethoden --------- public double getDiameter () { return 2.0 * radius ; } public void print () { System . out . println ( \"Radius : \" + radius ); System . out . println ( \"Durchmesser : \" + getDiameter ()); // Aufruf Objektmethode System . out . println ( \"Umfang : \" + circumference ()); // Aufruf Objektmethode System . out . println ( \"Flaecheninhalt : \" + area ()); // Aufruf Objektmethode System . out . println (); } public double circumference () { return Math . PI * getDiameter (); } public double area () { return Math . PI * radius * radius ; } public boolean isSmaller ( Circle c ) { return ( radius < c . radius ); } public boolean isBigger ( Circle c ) { return ( radius > c . radius ); } public boolean isEqual ( Circle c ) { return ! isSmaller ( c ) && ! isBigger ( c ); } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; public class Testklasse { @Test public void testAll () { // Tests fuer Adresse System . out . printf ( \"%n%n ---------------- Testen des Datentyps Adresse ------------------ %n%n\" ); Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); System . out . println ( adresse1 . getAdresse ()); System . out . println ( adresse2 . getAdresse ()); System . out . println ( \"Strasse Nr : \" + adresse1 . getStrasse () + \" \" + adresse1 . getNummer ()); System . out . println ( \"PLZ Wohnort : \" + adresse1 . getPostleitzahl () + \" \" + adresse1 . getWohnort ()); System . out . println ( \"Strasse Nr : \" + adresse2 . getStrasse () + \" \" + adresse1 . getNummer ()); System . out . println ( \"PLZ Wohnort : \" + adresse2 . getPostleitzahl () + \" \" + adresse1 . getWohnort ()); // Tests fuer Point System . out . printf ( \"%n%n ---------------- Testen des Datentyps Point ------------------ %n%n\" ); Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); Point p3 = new Point ( 4 , 6 ); Point p4 = new Point ( 5 , 3 ); System . out . println ( \" p1 : ( \" + p1 . getX () + \", \" + p1 . getY () + \" )\" ); System . out . println ( \" p2 : ( \" + p2 . getX () + \", \" + p2 . getY () + \" )\" ); System . out . println ( \" p3 : ( \" + p3 . getX () + \", \" + p3 . getY () + \" )\" ); System . out . println ( \" p4 : ( \" + p4 . getX () + \", \" + p4 . getY () + \" )\" ); p1 . print (); p2 . print (); p3 . print (); p4 . print (); p1 . print (); // [ x=1, y=2 ] p1 . translate ( 4 , 3 ); p1 . print (); // [ x=5, y=5 ] p4 . print (); // [ x=5, y=3 ] p4 . translate ( - 3 , - 1 ); p4 . print (); // [ x=2, y=2 ] System . out . println ( \"p1 links von p2 ? \" + p1 . isLeft ( p2 )); // p1.x=5 > p2.x=2 System . out . println ( \"p1 rechts von p2 ? \" + p1 . isRight ( p2 )); System . out . println ( \"p3 ueber p4 ? \" + p3 . isAbove ( p4 )); // p3.y=6 > p4.y=2 System . out . println ( \"p3 unter p4 ? \" + p3 . isBelow ( p4 )); // Tests fuer Circle System . out . printf ( \"%n%n ---------------- Testen des Datentyps Circle ------------------ %n%n\" ); Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 3.5 ); c1 . print (); System . out . println (); c2 . print (); System . out . println ( \"c1 groesser als c2 ? \" + c1 . isBigger ( c2 )); System . out . println ( \"c1 kleiner als c2 ? \" + c1 . isSmaller ( c2 )); System . out . println ( \"c1 gleich c2 ? \" + c1 . isEqual ( c2 )); System . out . println (); System . out . println ( \"c2 groesser als c1 ? \" + c2 . isBigger ( c1 )); System . out . println ( \"c2 kleiner als c1 ? \" + c2 . isSmaller ( c1 )); System . out . println ( \"c2 gleich c1 ? \" + c2 . isEqual ( c1 )); System . out . println (); System . out . println ( \"c1 groesser als c1 ? \" + c1 . isBigger ( c1 )); System . out . println ( \"c1 kleiner als c1 ? \" + c1 . isSmaller ( c1 )); System . out . println ( \"c1 gleich c1 ? \" + c1 . isEqual ( c1 )); System . out . println (); } }","title":"Ein weiterer Datentyp Circle"},{"location":"objekte/#klassen-und-objekte-ii","text":"Wir machen weiter mit eigenen Datentypen und erstellen uns Objekte, die von diesen Typen sind. Wir werden im Folgenden eigene Datentypen in neuen Datentypen verwenden, mehrere Konstruktoren in der Klasse definieren, in Methoden Objekte erzeugen und diese auch zur\u00fcckgeben und das Schl\u00fcsselwort this kennenlernen.","title":"Klassen und Objekte II"},{"location":"objekte/#eigene-datentypen-in-eigenen-datentypen-verwenden","text":"Wir beginnen damit, eigene Datentypen in neuen Datentypen zu verwenden, da dies eine gute Wiederholung ist. Angenommen, wir haben unsere Klasse Adresse in einem BlueJ-Projekt erstellt. In diesem Projekt erstellen wir uns eine neue Klasse Person mit folgenden Objektvariablen: name vom Typ String , vorname vom Typ String und adresse vom Typ Adresse . Wir f\u00fcgen auch gleich noch den Konstruktor hinzu und bereiten die print() -Methode vor: Person.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Person { // ------- Objektvariablen ----------- private String name ; private String vorname ; private Adresse adresse ; // ------- Konstruktor ----------- public Person ( String pName , String pVorname , Adresse pAdresse ) { name = pName ; vorname = pVorname ; adresse = pAdresse ; } // ------- Objektmethoden ----------- public void print () { // wie sieht die Ausgabe aus? // wie kann ich die Adresse ausgeben? } } In Zeile 6 verwenden wir die von uns geschriebene Klasse Adresse . der Konstruktor (Zeilen 9-14 ) sieht aus, wie erwartet. Wir initialisieren alle Objektvariablen mit den als Parameter \u00fcbergebenen Werten. in den Zeilen 17-21 haben wir auch schon die print() -Methode vorbereitet. Darin wollen wir alle Informationen \u00fcber das jeweilige Person -Objekt ausgeben. F\u00fcr name und vorname ist das sicherlich einfach. Aber wie kommen wir an die Informationen von adresse ? Wir erstellen uns in einer Testklasse zun\u00e4chst Objekte der Klasse Person .","title":"Eigene Datentypen in eigenen Datentypen verwenden"},{"location":"objekte/#person-objekte-erzeugen","text":"Um Objekte von Person erstellen zu k\u00f6nnen, ben\u00f6tigen wir Objekte des Typs Adresse , da diese dem Konstruktor als Parameter \u00fcbergeben werden m\u00fcssen. Beachten Sie auch hier, dass wir die Klasse Adresse dazu aus dem package themen.objekte importieren. Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Testklasse { public void main () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , adresse1 ); Person max = new Person ( \"Mustermann\" , \"Max\" , adresse2 ); } }","title":"Person-Objekte erzeugen"},{"location":"objekte/#objektmethoden-aufrufen","text":"Zun\u00e4chst erweitern wir unsere print() -Methode in Person : print() in Person.java erweitern 20 21 22 23 24 25 // ------- Objektmethoden ----------- public void print () { System . out . println ( vorname + \" \" + name ); // wie kann ich die Adresse ausgeben? } In der Testklasse rufen wir die print() -Methode f\u00fcr die beiden Person -Objekte auf: main() in Testklasse.java erweitern 8 9 10 11 12 13 14 15 16 17 18 public void main () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , adresse1 ); Person max = new Person ( \"Mustermann\" , \"Max\" , adresse2 ); maria . print (); max . print (); } Die Ausgabe erfolgt wie gew\u00fcnscht: Maria Musterfrau Max Mustermann Wie k\u00f6nnen wir nun auch die Adressen von maria und max ausgeben? Die Antwort ist: mithilfe der Objektmethoden von Adresse . Schauen wir uns die Objektmethoden von Adresse nochmal an (siehe auch hier ): Objektmethoden von Adresse.java 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // --- Objektmethoden ------ public String getAdresse () { return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort ; } public String getStrasse () { return strasse ; } public int getNummer () { return nummer ; } public int getPostleitzahl () { return postleitzahl ; } public String getWohnort () { return wohnort ; } Alle diese Methoden sind public und k\u00f6nnen von allen Klassen aufgerufen werden. Wir nutzen in der print() -Methode von Person die Objektmethode getAdresse() von Adresse , k\u00f6nnten aber auch alle anderen Objektmethoden verwenden. print() in Person.java erweitern 20 21 22 23 24 25 // ------- Objektmethoden ----------- public void print () { // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse() System . out . println ( vorname + \" \" + name + \" wohnt in \" + adresse . getAdresse ()); } Erneutes Ausf\u00fchren der Testklasse erzeugt nun folgende Ausgabe: Maria Musterfrau wohnt in Wilhelminenhofstr. 75 in 12459 Berlin Max Mustermann wohnt in Treskowallee 8 in 10318 Berlin Die Objekteigenschaft adresse der Klasse Person ist vom Typ Adresse. Um ein Objekt der Klasse Person zu erzeugen, muss dem Konstruktor der Klasse Person ein Objekt der Klasse Adresse \u00fcbergeben werden - das erwartet der Konstruktor als Parameter. Jedes Objekt vom Typ Person \"besitzt\" somit ein eigenes Objekt von Typ Adresse , welches in adresse gespeichert ist. F\u00fcr dieses Objekt k\u00f6nnen alle Objekteigenschaften aus Adresse aufgerufen werden (z.B. auch getStrasse() , getNummer() , getPostleitzahl() und getWohnort() ).","title":"Objektmethoden aufrufen"},{"location":"objekte/#getter-fur-person-erzeugen","text":"Wir erstellen uns f\u00fcr die Klasse Person getter (also getXXX() -Methoden) f\u00fcr die Objektvariablen: Person.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Person { // ------- Objektvariablen ----------- private String name ; private String vorname ; private Adresse adresse ; // ------- Konstruktor ----------- public Person ( String pName , String pVorname , Adresse pAdresse ) { name = pName ; vorname = pVorname ; adresse = pAdresse ; } // ------- Objektmethoden ----------- public void print () { // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse() System . out . println ( vorname + \" \" + name + \" wohnt in \" + adresse . getAdresse ()); } public String getName () { return name ; } public String getVorname () { return vorname ; } public Adresse getAdresse () { return adresse ; } } Die Implementierungen der Getter sind so, wie wir sie bereits kennen. Wir nennen die Methoden get und h\u00e4ngen jeweils in camel-case -Schreibweise den Namen der Objektvariablen an, also getName() , getVorname() und getAdrese() . Der R\u00fcckgabetyp der Methode entspricht stets dem Typ der Variablen, also f\u00fcr name und vorname ist der R\u00fcckgabetyp der Methoden getName() und getVorname() jeweils String und der R\u00fcckgabetyp von getAdresse() ist wie der Typ von adresse , n\u00e4mlich Adresse . Wir betrachten nun besonders die Methode getAdresse() der Klasse Person und rufen diese in der Testklasse auf. main() in Testklasse.java erweitern 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void main () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , adresse1 ); Person max = new Person ( \"Mustermann\" , \"Max\" , adresse2 ); maria . print (); max . print (); Adresse mariasAdresse = maria . getAdresse (); // getAdresse() von Person Adresse maxAdresse = max . getAdresse (); // getAdresse() von Person System . out . println ( mariasAdresse . getAdresse ()); // getAdresse() von Adresse System . out . println ( maxAdresse . getAdresse ()); // getAdresse() von Adresse } In Zeile 12 rufen wir die soeben erstelle Methode getAdresse() f\u00fcr das Person -Objekt maria auf. Die R\u00fcckgabe dieser Objektmethode ist die adresse von maria , also ein Objekt vom Typ Adresse , welches wir in der Referenzvariablen mariasAdresse vom Typ Adresse speichern. In Zeile 13 passiert das gleiche mit dem Person -Obejkt max . In der Variablen maxAdresse vom Typ Adresse ist nun das Adresse -Objekt von max gespeichert. f\u00fcr diese beiden Adresse -Objekte k\u00f6nnen wir nun alle Objektmethoden aus Adresse aufrufen. In Zeile 15 wird z.B. die getAdresse() -Methode des Objektes mariasAdresse aufgerufen und in Zeile 16 die getAdresse() -Methode des Adresse -Objektes maxAdresse . Beachten Sie, dass es zwei Methoden mit dem gleichen Namen gibt! Es existiert eine getAdresse() -Methode f\u00fcr den Datentyp Adresse . Diese Methode kann von Objekten des Typs Adresse aufegrufen werden und gibt einen String zur\u00fcck. Au\u00dferdem gibt es eine getAdresse() -Methode f\u00fcr den Datentyp Person . Diese kann von Objekten des Datentyps Person aufgerufen werden und gibt eine Adresse zur\u00fcck.","title":"Getter f\u00fcr Person erzeugen"},{"location":"objekte/#aneinanderreihung-von-aufrufen-von-objektmethoden","text":"Wir h\u00e4tten in der main() -Methode der Testklasse auch folgende Anweisungen ausf\u00fchren k\u00f6nnen: main() in Testklasse.java erweitern 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public void main () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , adresse1 ); Person max = new Person ( \"Mustermann\" , \"Max\" , adresse2 ); maria . print (); max . print (); Adresse mariasAdresse = maria . getAdresse (); // getAdresse() von Person Adresse maxAdresse = max . getAdresse (); // getAdresse() von Person System . out . println ( mariasAdresse . getAdresse ()); // getAdresse() von Adresse System . out . println ( maxAdresse . getAdresse ()); // getAdresse() von Adresse // ginge auch System . out . println ( maria . getAdresse (). getAdresse ()); // getAdresse() von Person und von Adresse System . out . println ( max . getAdresse (). getAdresse ()); // getAdresse() von Person und von Adresse } Die Anweisung maria.getAdresse() gibt, wie gesagt, ein Adresse -Objekt zur\u00fcck. Wir m\u00fcssen dieses Objekt nicht zwingend zwischenspeichern (so, wie in Zeile 12 ), sondern k\u00f6nnen auch gleich f\u00fcr dieses Objekt eine Objektmethode aufrufen, n\u00e4mlich z.B. die Methode getAdresse() des Typs Adresse , welche einen String zur\u00fcckgibt, der durch println() ausgegeben wird. Das gleiche passiert in Zeile 20 mit dem Person -Objekt max , f\u00fcr das zun\u00e4chst die getAdresse() -Methode aus Person aufgerufen wird, welche ein Adresse -Objekt zur\u00fcckgibt und f\u00fcr diese Adresse -Objekt wird die Objektmethode getAdresse() des Typs Adresse aufgerufen. Wir sehen bereits an diesem einfachen Beispiel, dass eine solche Hintereinanderreihung von Aufrufen von Objektmethoden leicht f\u00fcr Verwirrung Sorgen kann und schwer zu verstehen ist. Hier kommt noch gesondert hinzu, dass verschiedene Methoden gleich hei\u00dfen. Eine solche Hintereinanderreihung von Objektmethoden sollten wir m\u00f6glichst vermeiden. Wir k\u00f6nnten unserer Person -Klasse z.B. eine Methode getAdresseString() hinzuf\u00fcgen, die uns die Adresse als String zur\u00fcckgibt: Person.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class Person { // ------- Objektvariablen ----------- private String name ; private String vorname ; private Adresse adresse ; // ------- Konstruktor ----------- public Person ( String pName , String pVorname , Adresse pAdresse ) { name = pName ; vorname = pVorname ; adresse = pAdresse ; } // ------- Objektmethoden ----------- public void print () { // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse() System . out . println ( vorname + \" \" + name + \" wohnt in \" + adresse . getAdresse ()); } public String getName () { return name ; } public String getVorname () { return vorname ; } public Adresse getAdresse () { return adresse ; } public String getAdresseString () { return adresse . getAdresse (); } } Dann k\u00f6nnten wir in der main() -Methode der Testklasse main() in Testklasse.java erweitern 21 22 23 24 25 26 27 public void main () { /* gekuerzt - siehe oben */ System . out . println ( maria . getAdresseString ()); System . out . println ( max . getAdresseString ()); } die neue Objektmethode aus Person aufrufen und bek\u00e4men die Adresse als String zur\u00fcck.","title":"Aneinanderreihung von Aufrufen von Objektmethoden"},{"location":"objekte/#das-schlusselwort-this","text":"Wir wissen jetzt schon, dass Objektmethoden immer nur von Objekten aufgerufen werden k\u00f6nnen. Wir k\u00f6nnen z.B. nicht einfach nur getAdresseString() aus der Klasse Person aufrufen, sondern ben\u00f6tigen ein Objekt der Klasse Person , welches die Objektmethode aufruft. Objektmethoden k\u00f6nnen nur von einem Objekt aufgerufen werden! In dem obigen Beispiel hatten wir z.B. die Objekte maria und max vom Typ Person , die beide jeweils (f\u00fcr sich) die Objektmethode getAdresseString() aufgerufen haben. Wenn wir uns also den Aufruf einer Objektmethode anschauen, dann wissen wir auch immer: Wenn eine Objektmethode aufgerufen wird, dann immer durch genau ein konkretes Objekt. Innerhalb der Klasse Person wissen wir nicht, von welchem konkreten Objekt eine Objektmethode aufgerufen wird. Die Referenzvariablen max und maria sind z.B. innerhalb der Klasse Person nicht sichtbar (es sind lokale Variablen der main() -Methode von Testklasse ). Wir wissen aber, dass es ein aufrufendes Objekt gibt (denn nur f\u00fcr ein konkretes Objekt kann eine Objektmethode aufgerufen werden). Dieses konkrete Objekt k\u00f6nnen wir innerhalb der Klasse referenzieren - das machen wir mit dem Schl\u00fcsselwort this . this steht also f\u00fcr das konkrete Objekt, das die Methode (gerade) aufruft. this ist das aufrufende Objekt. Schauen wir uns zur Wiederholung nochmal die Klasse Circle an. In der dazugeh\u00f6rigen Testklasse hatten wir zwei Objekte der Klasse Circle erstellt und diese Objekte haben Objektmethoden aufgerufen: Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Testklasse { public void main () { Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 3.5 ); c1 . print (); System . out . println (); c2 . print (); System . out . println ( \"c1 groesser als c2 ? \" + c1 . isBigger ( c2 )); System . out . println ( \"c1 kleiner als c2 ? \" + c1 . isSmaller ( c2 )); System . out . println ( \"c1 gleich c2 ? \" + c1 . isEqual ( c2 )); System . out . println (); } } In den Zeilen 6 und 7 werden die beiden Circle -Objekte erzeugt. In Zeile 9 ruft das c1 -Objekt die print() -Methode auf und in Zeile 11 ruft das c2 -Objekt die print() -Methode auf. Innerhalb der Klasse w\u00e4re dann this einmal das c1 -Objekt (n\u00e4mlich bei c1.print() ) und ein anderes Mal ist this das c2 -Objekt, n\u00e4mlich bei c2.print() . Bei den Aufrufen c1.isBigger(c2) , c1.isSmaller(c2) und c1.isEqual(c2) ist das aufrufende Objekt immer c1 . Wozu ben\u00f6tigen wir this \u00fcberhaupt? Bis jetzt kamen wir ohne this aus. Aber schauen wir uns nur einmal den Konstruktor von Circle an: Circle.java 1 2 3 4 5 6 7 8 9 10 11 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double pRadius ) { radius = pRadius ; } } Im Konstruktor wird die Objektvariable radius mit dem Wert des Parameters pRadius initialisiert. Die Objektvariable radius ist global , d.h. wir haben in jeder Methode der Klasse Zugriff auf diese Variable. Objektvariablen werden innerhalb der Klasse (nicht innerhalb einer Methode) deklariert und sind deshalb in dem gesamten Anweisungsblock der Klasse, also in der gesamten Klasse sichtbar. Wir k\u00f6nnen in allen Methoden der Klasse auf die Objektvariablen zugreifen. Der Parameter pRadius ist eine lokale Variable. Diese Variable wird in der Methode deklariert und ist auch nur dort sichtbar. Sie existiert auch nur, solange die Methode ausgef\u00fchrt wird. Was passiert aber, wenn wir den Parameter genau wir die Objektvariable nennen? Circle.java 1 2 3 4 5 6 7 8 9 10 11 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double radius ) // Parameter heisst wie die Objektvariable { radius = radius ; // Achtung!!! nur Parameter sichtbar - sogenanntes shadowing!!! } } Wenn der Parameter genau so hei\u00dft, wie die Objektvariable, gibt es einen Namenskonflikt. Wir k\u00f6nnen in der Methode auf die Objektvariable zugreifen (sie ist ja global), es gibt aber auch eine lokale Variable mit dem gleichen Namen radius . Woher soll der Compiler (oder die Laufzeitumgebung) nun wissen, ob wir die Objektvariable radius meinen oder die lokale Variable radius ? Tats\u00e4chlich, stehen in der Anweisung radius = radius; in Zeile 9 beide radius f\u00fcr den Parameter, d.h. wir weisen dem Parameter radius dort den Wert des Parameters radius zu. Das ist erstens nicht gewollte und zweitens unsinnig. Die Objektvariable radius wird durch den Parameter radius \u00fcberschattet - sogenanntes shadowing . Wenn wir in diesem Falle die Objektvariable radius meinen, dann m\u00fcssen wir this.radius schreiben. Mit this. k\u00f6nnen wir innerhalb der Klasse auf alle Objekteigenschaften (Objektvariablen und Objektmethoden) zugreifen. Die korrekte Implementierung des Konstruktors lautet also: Circle.java 1 2 3 4 5 6 7 8 9 10 11 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double radius ) // Parameter heisst wie die Objektvariable { this . radius = radius ; // Objektvariable = Parameterwert; } } Jetzt wird der Objektvariablen this.radius der Wert des Parameters radius zugewiesen. Ab jetzt referenzieren wir alle Objekteigenschaften innerhalb der Klasse mit this ! Wir passen zun\u00e4chst die Implementierung von Circle an: Circle.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktor ---------------- public Circle ( double radius ) // Parameter heisst wie die Objektvariable { this . radius = radius ; // hier muss this } // ----- Getter der Objektvariablen ----- public double getRadius () { return this . radius ; // hier kann this - sollte ab jetzt aber immer } // ----- weitere Objektmethoden --------- public double getDiameter () { return 2.0 * this . radius ; } public void print () { System . out . println ( \"Radius : \" + this . radius ); System . out . println ( \"Durchmesser : \" + this . getDiameter ()); // Aufruf Objektmethode System . out . println ( \"Umfang : \" + this . circumference ()); // Aufruf Objektmethode System . out . println ( \"Flaecheninhalt : \" + this . area ()); // Aufruf Objektmethode System . out . println (); } public double circumference () { return Math . PI * this . getDiameter (); } public double area () { return Math . PI * this . radius * this . radius ; } public boolean isSmaller ( Circle c ) { return ( this . radius < c . radius ); } public boolean isBigger ( Circle c ) { return ( this . radius > c . radius ); } public boolean isEqual ( Circle c ) { return ! this . isSmaller ( c ) && ! this . isBigger ( c ); } } Wir sehen, dass wir \u00fcberall dort, wo wir auf Objekteigenschaften zugreifen, die Referenz this. davor gesetzt haben. das sollten wir von un ab in Zukunft auch immer so handhaben, da der Code dann leichter erweiterbar ist (wir m\u00fcssen uns nicht darum k\u00fcmmern, ob eine neue lokale Variable eventuell genau so hei\u00dft, wie eine Objektvariable) und er ist auch besser lesbar, denn wir k\u00f6nnen leichter zwischen Methoden anderer Klassen und eigenen unterscheiden. Betrachten wir die Implementierung der Methode isSmaller() nochmal genauer: public boolean isSmaller ( Circle c ) { return ( this . radius < c . radius ); } Angenommen, wir haben, wie oben in dem Beispiel, in der main() -Methode den Aufruf c1.isSmaller(c2) . Dann ist c1 das aufrufende Objekt dieser Objektmethode und steht innerhalb der Klasse f\u00fcr das this . Das Objekt c2 wird als Parameter \u00fcbergeben und steht in der Implementierung f\u00fcr das Objekt c der Klasse Circle . Innerhalb der Methode werden die Werte von radius vom aufrufenden Objekt this und vom Parameter c miteinander verglichen. Wir passen auch unsere Klasse Person entsprechend an: Person.java mit this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class Person { // ------- Objektvariablen ----------- private String name ; private String vorname ; private Adresse adresse ; // ------- Konstruktor ----------- public Person ( String name , String vorname , Adresse adresse ) { this . name = name ; this . vorname = vorname ; this . adresse = adresse ; } // ------- Objektmethoden ----------- public void print () { // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse() System . out . println ( this . vorname + \" \" + this . name + \" wohnt in \" + this . adresse . getAdresse ()); } public String getName () { return this . name ; } public String getVorname () { return this . vorname ; } public Adresse getAdresse () { return this . adresse ; } public String getAdresseString () { return this . adresse . getAdresse (); } } Insbesondere innerhalb der Methode getAdresseString() erkennen wir gut, dass wir darin nicht auf die getAdresse() -Methode von Person zugreifen, sondern auf die getAdresse() -Methode von Adresse . Wir haben auch die Parameter des Konstruktors anegpasst, denn es ist v\u00f6llig \u00fcblich, die Parameter so zu nennen, wie die Objektvariablen, die damit initialisiert werden sollen. Aber dann muss vor den Objektvariablen auch jeweils this. stehen! Integrieren Sie auch in den Klassen Adresse und Point die this. -Referenz!","title":"Das Schl\u00fcsselwort this"},{"location":"objekte/#mehrere-konstruktoren","text":"Es kann vorkommen, dass wir gar nicht allen Objektvariablen einen Wert im Konstruktor \u00fcbergeben wollen. Wenn wir f\u00fcr eine Objektvariable keinen Wert im Konstruktor \u00fcbergeben, dann soll dieser Objektvariablen ein Standardwert zugewiesen werden. Ein einfaches Beispiel w\u00e4re, dass wir f\u00fcr unsere Klasse Circle einen Konstruktor haben, dem ein Wert f\u00fcr radius \u00fcbergeben wird und einen Konstruktor, der parameterlos ist, dem also kein Wert f\u00fcr radius \u00fcbergeben wird. In diesem Fall soll radius den Wert 1.0 annhmen, also der Einheitskreis sein. Diese Anforderung erf\u00fcllen wir, indem wir zwei Konstruktoren definieren: Circle.java mit zwei Konstruktoren 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Circle { // ------- Objektvariable --------------- private double radius ; // --------- Konstruktoren ---------------- public Circle ( double radius ) // Parameter heisst wie die Objektvariable { this . radius = radius ; // hier muss this } public Circle () // parameterlos { this . radius = 1.0 ; // Standardwert - Einheitskreis } /* alle anderen Methoden bleiben, wie sie sind - siehe oben */ } Jetzt k\u00f6nnen Objekte von Circle sowohl unter Verwendung des parametrisierten Konstruktors, als auch unter Verwendung des parameterlosen Konstruktors erzeugt werden: Testklasse.java - Auszug main()-Methode Circle c1 = new Circle ( 5.0 ); Circle c2 = new Circle ( 3.5 ); Circle c3 = new Circle (); // parameterloser Konstruktor - Einheitskreis c1 . print (); c2 . print (); c3 . print (); ergibt folgende Ausgabe: Radius : 5 .0 Durchmesser : 10 .0 Umfang : 31 .41592653589793 Flaecheninhalt : 78 .53981633974483 Radius : 3 .5 Durchmesser : 7 .0 Umfang : 21 .991148575128552 Flaecheninhalt : 38 .48451000647496 Radius : 1 .0 Durchmesser : 2 .0 Umfang : 6 .283185307179586 Flaecheninhalt : 3 .141592653589793 Das Prinzip, das hierbei angewendet wird, nennt sich \u00dcberladen von Methoden .","title":"Mehrere Konstruktoren"},{"location":"objekte/#uberladen-von-methoden","text":"Wir hatten dieses Prinzip auch bereits in \u00dcbung 4 angewendet, wo wir zwei print() -Methoden erstellt hatten. Die eine print() -Methode hat ein char[] als Parameter erwartet und die andere ein int[] . Das \u00dcberladen von Methoden erfolgt immer dann, wenn Methoden gleichen Namens existieren. Wichtig ist, dass sich diese Methoden in ihrer Parameterliste unterscheiden. Was bedeutet, dass sich Parameterlisten von Methoden unterscheiden? Methoden haben eine unterschiedliche Parameterliste , wenn sich die Anzahl der Parameter unterscheidet oder wenn sich die Typen bzw. die Typreihenfolge der Parameter unterscheiden. Angenommen, unsere Methode hei\u00dft method , dann haben folgende Methoden eine unterschiedliche Parmaterliste: method(int number) // nur ein Parameter method(int nr1, int nr2) // zwei Parameter int, int method(double nr1, double nr2) // zwei Parameter double, double method(int nr1, double nr2) // zwei Parameter int, double method(double nr1, int nr2) // zwei parameter double, int Die Methode method w\u00e4re also in diesem Fall (wenn es jeweils noch passende Implementierungen dazu gibt), f\u00fcnf Mal \u00fcberladen . Dem Compiler muss beim Aufruf klar sein, welche der jeweiligen Methoden er aufrufen muss. Das ist durch unterschiedliche Parameterlisten gegeben. Folgende Beispiele zeigen dies: method(3.0, 3); // ruft Methode 5. auf method(3, 3); // ruft Methode 2. auf method(3.0, 3.0); // ruft Methode 3. auf method(3); // ruft Methode 1. auf method(3, 3.0); // ruft Methode 4. auf Die Namen der Parameter spielen keine Rolle. Beispielsweise w\u00e4re method(int number1, int number2) ein Dopplung zu Methode 2. Das programm lie\u00dfe sich gar nicht \u00fcbersetzen. Auch der R\u00fcckgabetyp wird nicht zur Unterscheidung der Methodensignatur hinzugezogen. Die beiden Methoden int method(int nr1, int nr2) und double method(int nr1, int nr2) w\u00e4ren ebenfalls eine Dopplung. Woher soll der Compiler beim Aufruf von z.B. method(3, 3); wissen, welche der beiden Methoden ausgef\u00fchrt werden soll, die die ein int zur\u00fcckgibt oder die, die ein double zur\u00fcckgibt. Zur Methodensignatur geh\u00f6ren der Name der Methode und die Parameterliste. F\u00fcr alle Methoden einer Klasse m\u00fcssen sich deren Methodensignaturen unterscheiden, also entweder deren Namen oder deren Parameterlisten.","title":"\u00dcberladen von Methoden"},{"location":"objekte/#mehrere-konstruktoren-in-point","text":"F\u00fcr unsere Klasse Point wollen wir ebenfalls mehrere Konstruktoren definieren: Konstruktor mit zwei Paramtern (haben wir schon) \u2192 x und y werden mit den Parameterwerten initialisiert Konstruktor mit einem Parameter \u2192 x und y bekommen den gleichen Wert, den des Parameters Konstruktor ohne Parameter \u2192 x und y bekommen jeweils den Wert 0 Point.java Ausschnitt nur Konstruktoren public class Point { // --- Objektvariablen ----------- private int x ; private int y ; // --- Konstruktoren --------------- public Point ( int x , int y ) { this . x = x ; this . y = y ; } public Point ( int value ) { this . x = value ; this . y = value ; } public Point () { this . x = 0 ; this . y = 0 ; } /* restliche Methoden bleiben gleich - hier gekuerzt */ /* siehe oben. */","title":"Mehrere Konstruktoren in Point"},{"location":"objekte/#mehrere-konstruktoren-in-person","text":"Der Konstruktor in Person sieht derzeit so aus: public Person ( String name , String vorname , Adresse adresse ) { this . name = name ; this . vorname = vorname ; this . adresse = adresse ; } Das hei\u00dft, wir erwarten ein Objekt vom Typ Adresse , um ein Objekt vom Typ Person erstellen zu k\u00f6nnen. Es k\u00f6nnte ja aber sein, dass ein solches Objekt (noch) gar nicht existiert und wir selbst ein solches Objekt innerhalb unserer Konstruktors erstellen m\u00fcssen. Wir br\u00e4uchten daf\u00fcr nur alle Informationen, um das Objekt erstellen zu k\u00f6nnen, also eine Strasse ( String ), eine Hausnummer ( int ), ein Wohnort ( String ) und eine Postleitzahl ( int ). Wir erstellen uns einen Konstruktor, der daf\u00fcr Werte \u00fcbergibt (und auch f\u00fcr name und vorname ): public Person ( String name , String vorname , String strasse , int nummer , int postleitzahl , String wohnort ) { this . name = name ; this . vorname = vorname ; this . adresse = new Adresse ( strasse , nummer , postleitzahl , wohnort ); } Es wird also kein existierendes Adresse -Objekt dem Konstruktor \u00fcbergeben, sondern erst im Konstruktor eines erstellt. Die restliche Implementierung der Klasse Person \u00e4ndert sich aber nicht, da sich ja auch f\u00fcr adresse nichts ge\u00e4ndert hat - die Variable zeigt auf ein Adresse -Objekt.","title":"Mehrere Konstruktoren in Person"},{"location":"objekte/#objekterzeugende-methoden","text":"Genau die gleiche L\u00f6sung k\u00f6nnen wir verwenden, wenn eine Person umzieht, also ihre Adresse \u00e4ndert. umzug() ist dabei auf jeden Fall eher eine Eigenschaft der Klasse Person , als der Klasse Adresse ! Wir erweitern die Klasse Person um zwei umzug() -Methoden. Die eine erwartet ein (neues) Adresse -Objekt und die andere bekommt Werte f\u00fcr die Erstellung eines neuen Adresse -Objektes \u00fcbergeben: Person.java - Auszug: umzug()-Methoden 1 2 3 4 5 6 7 8 9 public void umzug ( Adresse neueAdresse ) { this . adresse = neueAdresse ; } public void umzug ( String neueStrasse , int neueNummer , int neuePostleitzahl , String neuerWohnort ) { this . adresse = new Adresse ( neueStrasse , neueNummer , neuePostleitzahl , neuerWohnort ); } Der Aufruf in der main() -Methode k\u00f6nnte dann so aussehen: public void main () { Adresse adresse1 = new Adresse ( \"Wilhelminenhofstr.\" , 75 , 12459 , \"Berlin\" ); Adresse adresse2 = new Adresse ( \"Treskowallee\" , 8 , 10318 , \"Berlin\" ); Person maria = new Person ( \"Musterfrau\" , \"Maria\" , adresse1 ); System . out . println ( maria . getAdresseString ()); maria . umzug ( adresse2 ); System . out . println ( maria . getAdresseString ()); maria . umzug ( \"Rudower Chaussee\" , 25 , 12489 , \"Berlin\" ); System . out . println ( maria . getAdresseString ()); } mit folgender Ausgabe: Wilhelminenhofstr. 75 in 12459 Berlin Treskowallee 8 in 10318 Berlin Rudower Chaussee 25 in 12489 Berlin","title":"Objekterzeugende Methoden"},{"location":"objekte/#objekterzeugende-methoden-mit-objekt-als-ruckgabe","text":"Wir betrachten zur Wiederholung erneut die Klasse Point . Wir erinnern uns: ein Point bestand aus einer x - und einer y -Koordinate. Wir hatten verschiedene Objektmethoden f\u00fcr Point erstellt - siehe hier . Angenommen, wir wollen zwei Punkte addieren - z.B. ein Point p1 und ein Point p2 . Die Idee dabei ist, dass die Summe der beiden x -Werte ( p1.x + p2.x ) einen neuen x -Wert und die Summe der beiden y -Werte ( p1.y + p2.y ) einen neuen y -Wert ergibt. Wir starten einen ersten Versuch und implementieren eine add() -Methode wie folgt: public void add ( Point p ) { this . x = this . x + p . x ; this . y = this . y + p . y ; } Der Aufruf in einer Testklasse mit: Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); p1 . print (); p1 . add ( p2 ); p1 . print (); f\u00fchrt zu folgender Ausgabe: [ x = 1 , y = 2 ] [ x = 3 , y = 6 ] Das hei\u00dft, durch die Addition mit p2 hat sich das p1 -Objekt ge\u00e4ndert. Die Frage ist, ob das beabsichtigt ist und eine eindeutige Antwort ja oder nein kann hier nicht gegeben werden. Es ist nicht ganz klar, ob sich das aufrufende Objekt selbst ver\u00e4ndern sollte, wenn es mit einem anderen Point addiert wird. Insbesondere macht es einen Unterschied, ob wir p1.add(p2) aufrufen oder p2.add(p1) . Im ersten Fall ist nach der Addition p1 -> [ x=3, y=6 ] und p2 -> [ x=2, y=4 ] . Im zweiten Fall ist nach der Addition p1 -> [ x=1, y=2 ] und p2 -> [ x=3, y=6 ] . Wir erreichen also einen anderen Gesamtzustand des Systems. Es spricht Vieles daf\u00fcr, die Implementierung zu \u00e4ndern und die beiden sich addierenden Punkte unver\u00e4ndert zu lassen und stattdessen einen neuen Point zu erzeugen: public Point add ( Point p ) { int newX = this . x + p . x ; int newY = this . y + p . y ; return new Point ( newX , newY ); } Das hei\u00dft, wir ermitteln erneut die Summen this.x + p.x bzw. this.y + p.y , doch anstelle mit diesen Summen das aufrufende Objekt zu \u00e4ndern, wird ein neues Point -Objekt erstellt. Wenn man sich nun den Gesamtzustand des gesamten Systems nach der Addition von p1 und p2 anschaut, dann ist es egal, ob wir p1.add(p2) oder ob wir p2.add(p1) aufgerufen haben. Wir haben nach der Addition drei Point-Objekte mit den Werten p1 -> [ x=1, y=2 ] , p2 -> [ x=2, y=4 ] und ein neues Point -Objekt mit [ x=3, y=6 ] . Obiges Beispiel aus der Testklasse w\u00fcrde dann so aussehen: Point p1 = new Point ( 1 , 2 ); Point p2 = new Point ( 2 , 4 ); p1 . print (); Point p3 = p1 . add ( p2 ); // kann auch p2.add(p1), ist egal p3 . print (); mit der Ausgabe [ x = 1 , y = 2 ] [ x = 3 , y = 6 ] Wesentlichster Unterschied zur ersten Variante ist, dass sich weder p1 noch p2 durch die Addition ge\u00e4ndert haben. Wenn wir das Ziel verfolgen, m\u00f6glichst unver\u00e4nderliche Objekte zu erzeugen, dann ist die zweite L\u00f6sung auf jeden Fall die bessere. So oder so haben wir eine Methode kennengelernt, in der ein Objekt der Klasse erzeugt und dieses Objekt zur\u00fcckgegeben wird. Solche Objekte kommen nicht selten vor - und nun kennen wir ein Beispiel. Weitere Beispiele werden wir in der Aufgabe Bruch erzeugen. Success Wir haben eigene Datentypen in der Definition eigener Datentypen verwendet. Wir haben das Schl\u00fcsselwort this kennengerlernt, mit dem wir innerhalb der Klasse das aufrufende Objekt referenzieren k\u00f6nnen. Wir haben das \u00dcberladen von Methoden betrachtet und Konstruktoren in Klassen mehrfach \u00fcberladen. Das \u00dcberladen von Methoden l\u00e4sst sich auf alle Methoden anwenden. Dar\u00fcber hinaus haben wir Methoden erstellt, in denen Objekte erzeugt werden. Zuletzt gibt eine solche Methode das von ihr erzeugte Objekt auch zur\u00fcck.","title":"Objekterzeugende Methoden mit Objekt als R\u00fcckgabe"},{"location":"selektion/","text":"Selektion \u00b6 In Programmablaufstrukturen haben wir uns die drei Kontrollstrukturen angeschaut, die in Programmen vorkommen k\u00f6nnen: die Sequenz , die Iteration und die Selektion . Wir betrachten nun die Selektion genauer und schauen uns an, wie wir sie in Java umsetzen. if...else \u00b6 Bei der Selektion ist die Ausf\u00fchrung von Anweisungen von einer Bedingung abh\u00e4ngig. Angenommen, wir wollen erreichen, dass eine Zahl number halbiert wird, wenn sie gerade ist oder sie wird mit 3 multipliziert und 1 addiert, wenn sie ungerade ist. Es findet also eine Selektion der Anweisungen statt, je nachdem ob number gerade ist oder nicht. Als \"Pseudocode\" sieht das so aus: wenn ( number ist gerade ) dann teile number durch 2 sonst multipliziere number mit 3 und addiere 1 In Java gibt es daf\u00fcr die if ... else -Anweisung: if ( number % 2 == 0 ) { number = number / 2 ; } else { number = 3 * number + 1 ; } Das hei\u00dft, es wird zun\u00e4chst eine Bedingung (ein Ausdruck vom Typ boolean ) gepr\u00fcft. Ist der Wert dieser Bedingung true , dann wird der erste Anweisungsblock ausgef\u00fchrt. Ist der Wert der Bedingung jedoch false , dann wird der zweite Anweisungsblock (der nach dem else ) ausgef\u00fchrt. Es wird also genau einer der beiden Anweisungsbl\u00f6cke ausgef\u00fchrt - entweder der eine oder der andere (je nach Wert der Bedingung). Noch ein Beispiel aus dem euklidischen Algorithmus : if ( a > b ) { a = a - b ; } else { b = b - a ; } Innerhalb der Anweisungsbl\u00f6cke k\u00f6nnen nat\u00fcrlich jeweils mehrere Anweisungen stehen. Als Information sei hier gesagt, dass es theoretisch m\u00f6glich ist, bei nur einer Anweisung die Klammern wegzulassen, also z.B. if ( a > b ) a = a - b ; else b = b - a ; Aber wir machen das nicht, da solche Programme nicht gut erweiterbar sind! Es gibt gen\u00fcgend Beispiele, in denen so etwas schief lief (z.B. bei Apple ). Die allgemeine Syntax einer solchen Selektion sieht also wie folgt aus: if ( bedingung ) { /* * Anweisungsblock, der ausgef\u00fchrt wird, * wenn die bedingung true ist. * das k\u00f6nnen beliebig viele Anweisungen sein: * Sequenzen, Iterationen und/oder Selektionen */ } else { /* * Anweisungsblock, der ausgef\u00fchrt wird, * wenn die bedingung false ist. * das k\u00f6nnen beliebig viele Anweisungen sein: * Sequenzen, Iterationen und/oder Selektionen * dieser else -Block kann aber auch ganz weg- * gelassen werden - sehen wir gleich */ } Bedingungen \u00b6 Bevor wir uns noch weitere Varianten der if...else -Anweisung anschauen, gehen wir nochmal darauf ein, was eine Bedingung ist. Eine Bedingung ist ein logischer Ausdruck, - d.h. der Datentyp des Wertes einer Bedingung ist `boolean`, - d.h. der Wert einer Bedingung ist entweder `true` oder `false` Wir betrachten einige Beispiele von Bedingungen (wir nehmen an, dass die Methoden isOdd(int) und notZero(int) existieren und ein boolean zur\u00fcckgeben): boolean cond1 = true ; // kann genutzt werden als if(cond1) oder if(true) boolean cond2 = cond1 ; // kann genutzt werden als if(cond2) oder if(cond1) boolean cond3 = cond1 && true ; // kann genutzt werden als if(cond3) oder if(cond1 && true) boolean cond4 = ( 7 >= 4 ); // kann genutzt werden als if(cond4) oder if(7 >= 4) boolean cond5 = ( 7 >= 4 ) && ( 3 < 5 ); // kann genutzt werden als if(cond5) oder if((7 >= 4) && (3 < 5)) boolean cond6 = cond5 || cond3 ; // kann genutzt werden als if(cond6) oder if(cond5 || cond3) boolean cond7 = isOdd ( 3 ) && notZero ( 3 ); // kann genutzt werden als if(cond7) oder if(isOdd(3) && notZero(3)) Wichtig ist also, dass alle Werte, die vom Typ boolean sind, als Bedingungen verwendet werden k\u00f6nnen. Achten Sie auch darauf, dass die Ausdr\u00fccke selbst (also die Bedingungen) kein Semikolon am Ende haben - Ausdr\u00fccke sind keine Anweisungen. Beachte Vergleichen Sie logische Ausdr\u00fccke nicht mit true ! Man sieht h\u00e4ufig so etwas wie isOdd(3) == true . Das ist unn\u00f6tig! Angenommen, der Wert von isOdd(3) ist true , dann ist auch der Vergleich isOdd(3) == true true . Angenommen, der Wert von isOdd(3) ist false , dann ist auch der Vergleich isOdd(3) == true false . Das bedeutet, der Wert des Vergleiches entspricht exakt dem Wert von isOdd(3) , also benutzen wir nur isOdd(3) . if...else ohne else -Block \u00b6 Der else -Block ist nicht zwingend n\u00f6tig. Es gibt Beispiele, in denen etwas getan werden soll, wenn eine bestimmte Bedingung gilt, aber wenn sie nicht gilt, dann muss auch nichts getan werden, z.B. (Methoden ausgedacht): if ( fileOpen ( file )) { closeFile ( file ); } if ( connectionEstablished ( database )) { disconnect ( database ); } if ( divisor == 0 ) { System . out . println ( \"Divsion durch 0 nicht m\u00f6glich!\" ); } Verschachtelte Selektionen \u00b6 Die Anweisungsbl\u00f6cke sowohl im true -Zweig als auch im else -Zweig k\u00f6nnen beliebige Kontrollstrukturen enthalten: nur eine Anweisung oder Sequenzen von Anweisungen und/oder Iterationen und/oder Selektionen. Ist eine Selektion innerhalb einer Selektion, spricht man auch von verschachtelten Selektionen. Angenommen, wir haben drei int -Variablen a , b , c und wollen diese der Gr\u00f6\u00dfe nach sortieren (und wollen auch noch pr\u00fcfen, ob die Werte evenzuell gleich sind): // a, b, c vom Typ `int` if ( a > b ) { if ( b > c ) { System . out . println ( \"a > b > c\" ); } else // c >= b { if ( c > b ) { if ( a > c ) { System . out . println ( \"a > c > b\" ); } else // c >= a { if ( c > a ) { System . out . println ( \"c > a > b\" ); } else // c == a { System . out . println ( \"c = a > b\" ); } } } else // c == b { System . out . println ( \"a > b = c\" ); } } } else // b >= a { if ( b > a ) { if ( b > c ) { if ( a > c ) { System . out . println ( \"b > a > c\" ); } else // c >= a { if ( c > a ) { System . out . println ( \"b > c > a\" ); } else // a == c { System . out . println ( \"b > a = c\" ); } } } else // c >= b { if ( c == b ) { System . out . println ( \"b = c > a\" ); } else // c > b { System . out . println ( \"c > b > a\" ); } } } else // b == a { if ( b > c ) { System . out . println ( \"a = b > c\" ); } else // c >= b { if ( c == b ) { System . out . println ( \"a = b = c\" ); } else // c > b { System . out . println ( \"c > b = a\" ); } } } } Sie sehen, so etwas wird sehr schnell sehr un\u00fcbersichtlich. Wir sollten versuchen, solche Verschachtelungen nur auf sehr geringe Verschachtelungstiefen zu beschr\u00e4nken. Die beste M\u00f6glichkeit, solche Verschachtelungstiefen zu vermeiden, besteht darin, die Bedingungen komplexer zu gestalten indem wir logische Operatoren verwenden, z.B. if(a > b) && (b > c)) . Wir zeigen das mal am obigen Beispiel, in dem wir gar keine Verschachtelungstiefe haben: // a, b, c vom Typ `int` if ( a > b && b > c ) { System . out . println ( \"a > b > c\" ); } if ( a > b && c > b && a > c ) { System . out . println ( \"a > c > b\" ); } if ( a > b && c > b && c > a ) { System . out . println ( \"c > a > b\" ); } if ( a > b && c > b && c == a ) { System . out . println ( \"a = c > b\" ); } if ( a > b && b == c ) { System . out . println ( \"a > b = c\" ); } if ( a == b && b == c ) { System . out . println ( \"a = b = c\" ); } if ( a == b && b > c ) { System . out . println ( \"a = b > c\" ); } if ( a == b && c > b ) { System . out . println ( \"c > a = b\" ); } if ( b > a && a > c ) { System . out . println ( \"b > a > c\" ); } if ( b > a && c > a && b > c ) { System . out . println ( \"b > c > a\" ); } if ( b > a && c > a && b == c ) { System . out . println ( \"b = c > a\" ); } if ( b > a && c == a ) { System . out . println ( \"b > c = a\" ); } if ( b > a && c > b ) { System . out . println ( \"c > b > a\" ); } \u00dcbung Bei welchem der beiden oberen Programme werden (im Durchschnitt) mehr Vergleiche durchgef\u00fchrt und warum? Das Problem mit komplexen Bedingungen besteht darin, dass diese recht schwer zu verstehen sind. F\u00fcr komplexe Bedingungen sollten wir stets eigene Methoden definieren (die ein boolean zur\u00fcckgeben) und die mit ihrem Namen verraten, was die Bedingung pr\u00fcft. Darauf kommen wir sp\u00e4ter nochmal zur\u00fcck. switch -Anweisung \u00b6 Die switch -Anweisung war in Java lange ungl\u00fccklich gel\u00f6st. Die switch -Anweisung kann verwendet werden, wenn Sie viele Fallunterscheidungen haben. Wir geben zun\u00e4chst ein Beispiel in der alten Form der switch -Anweisung, die immer noch funktioniert und die Sie so wahrscheinlich auch noch sehr h\u00e4ufig antreffen werden: // monat vom Typ `int` switch ( monat ) { case 1 : System . out . println ( \"Januar\" ); break ; case 2 : System . out . println ( \"Februar\" ); break ; case 3 : System . out . println ( \"M\u00e4rz\" ); break ; case 4 : System . out . println ( \"April\" ); break ; case 5 : System . out . println ( \"Mai\" ); break ; case 6 : System . out . println ( \"Juni\" ); break ; case 7 : System . out . println ( \"Juli\" ); break ; case 8 : System . out . println ( \"August\" ); break ; case 9 : System . out . println ( \"September\" ); break ; case 10 : System . out . println ( \"Oktober\" ); break ; case 11 : System . out . println ( \"November\" ); break ; case 12 : System . out . println ( \"Dezember\" ); break ; default : System . out . println ( \"kein Monat\" ); } Betrachten wir die Anweisung zun\u00e4chst etwas genauer. Die Fallunterscheidungen betreffen den Wert der int -Variablen monat . Das bedeutet schonmal, dass in den runden Klammern der switch() -Anweisung keine Bedingung steht, sondern ein Ausdruck, der von verschiedenen Datentypen sein kann, z.B. byte , short , int und String . Der Ablauf einer switch() -Anweisung ist nun so, dass f\u00fcr den entsprechenden Wert der case gesucht wird, also z.B. wenn month den Wert 6 hat, dann ist case 6: der \"Einsprungspunkt\". Dort werden nun alle Anweisungen abgearbeitet, bis entweder ein break; kommt oder die switch() -Anweisung beendet ist. break; stoppt also die Abarbeitung. W\u00fcrde in unserem Beispiel kein break enthalten sein und w\u00e4re month z.B. 6 , dann w\u00fcrden alle Monate ab und inkl. Juni ausgegeben werden. Der default: -Fall ist daf\u00fcr, falls keine der case passt. Der default: -Fall ist optional. Dass die Anweisungen nach case x: nicht in Anweisungsbl\u00f6cken stehen und dass die Verwendung von break; erforderlich ist, um die Ausf\u00fchrung von Anweisungen zu stoppen, macht diese alte Syntax der switch() -Anweisung unsch\u00f6n. Wir betrachten noch ein Beispiel in der alten Syntax, um den Unterschied zur neuen noch besser zu erl\u00e4utern: // monat vom Typ `int` int anzahlTageImMonat = 0 ; switch ( monat ) { case 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 : anzahlTageImMonat = 31 ; break ; case 4 : case 6 : case 9 : case 11 : anzahlTageImMonat = 30 ; break ; case 2 : anzahlTageImMonat = 28 ; } Ab Java 12 wurde die switch() -Anweisung gr\u00fcndlich \u00fcberarbeitet. Wir betrachten das so eben gezeigte Beispiel nun in der neuen Schreibweise: int anzahlTageImMonat = switch ( monat ) { case 1 , 3 , 5 , 7 , 8 , 10 , 12 -> 31 ; case 4 , 6 , 9 , 11 -> 30 ; case 2 -> 28 ; default -> 0 ; }; Mehrere Dinge fallen auf: kann eine switch() -Anweisung nun auch als Ausdruck verwendet werden und somit z.B. einer Variablen einen Wert zu weisen (das machen wir hier) hat sich die Schreibweise beim case ge\u00e4ndert. Aus dem Doppelpunkt wurde ein Pfeil und es k\u00f6nnen mit einem case auch mehrere durch Komma getrennte Werte aufgef\u00fchrt werden und - besonders gut - wir ben\u00f6tigen kein break mehr. Es wird immer nur der case ausgef\u00fchrt. Die Abarbeitung der dort beschriebenen Anweisungen stoppt beim n\u00e4chsten case bzw. bei default oder am Ende der switch() -Anweisung Success Wir haben 2 M\u00f6glichkeiten kennengelernt, die Selektion in Java zu implementieren. Die eine (und bedeutendste) M\u00f6glichkeit ist die if...else -Anweisung. Dort wird in Abh\u00e4ngigkeit vom Wahreheitswert einer Bedingung entweder der eine oder der andere Anweisungsblock ausgef\u00fchrt. Der else -Block kann auch weggelassen werden. Innerhalb eines Anweisungsblockes k\u00f6nnen beliebige Kontrollstrukturen stehen: Sequenzen, Iterationen und Selektionen. Die zweite M\u00f6glichkeit ist die switch() -Anweisung, die seit Java 12 auch selbst ein Ausdruck sein kann. Wir haben die alte Syntax der switch() -Anweisung kritisch betrachtet und die neue Syntax kennengelernt.","title":"Selektion"},{"location":"selektion/#selektion","text":"In Programmablaufstrukturen haben wir uns die drei Kontrollstrukturen angeschaut, die in Programmen vorkommen k\u00f6nnen: die Sequenz , die Iteration und die Selektion . Wir betrachten nun die Selektion genauer und schauen uns an, wie wir sie in Java umsetzen.","title":"Selektion"},{"location":"selektion/#ifelse","text":"Bei der Selektion ist die Ausf\u00fchrung von Anweisungen von einer Bedingung abh\u00e4ngig. Angenommen, wir wollen erreichen, dass eine Zahl number halbiert wird, wenn sie gerade ist oder sie wird mit 3 multipliziert und 1 addiert, wenn sie ungerade ist. Es findet also eine Selektion der Anweisungen statt, je nachdem ob number gerade ist oder nicht. Als \"Pseudocode\" sieht das so aus: wenn ( number ist gerade ) dann teile number durch 2 sonst multipliziere number mit 3 und addiere 1 In Java gibt es daf\u00fcr die if ... else -Anweisung: if ( number % 2 == 0 ) { number = number / 2 ; } else { number = 3 * number + 1 ; } Das hei\u00dft, es wird zun\u00e4chst eine Bedingung (ein Ausdruck vom Typ boolean ) gepr\u00fcft. Ist der Wert dieser Bedingung true , dann wird der erste Anweisungsblock ausgef\u00fchrt. Ist der Wert der Bedingung jedoch false , dann wird der zweite Anweisungsblock (der nach dem else ) ausgef\u00fchrt. Es wird also genau einer der beiden Anweisungsbl\u00f6cke ausgef\u00fchrt - entweder der eine oder der andere (je nach Wert der Bedingung). Noch ein Beispiel aus dem euklidischen Algorithmus : if ( a > b ) { a = a - b ; } else { b = b - a ; } Innerhalb der Anweisungsbl\u00f6cke k\u00f6nnen nat\u00fcrlich jeweils mehrere Anweisungen stehen. Als Information sei hier gesagt, dass es theoretisch m\u00f6glich ist, bei nur einer Anweisung die Klammern wegzulassen, also z.B. if ( a > b ) a = a - b ; else b = b - a ; Aber wir machen das nicht, da solche Programme nicht gut erweiterbar sind! Es gibt gen\u00fcgend Beispiele, in denen so etwas schief lief (z.B. bei Apple ). Die allgemeine Syntax einer solchen Selektion sieht also wie folgt aus: if ( bedingung ) { /* * Anweisungsblock, der ausgef\u00fchrt wird, * wenn die bedingung true ist. * das k\u00f6nnen beliebig viele Anweisungen sein: * Sequenzen, Iterationen und/oder Selektionen */ } else { /* * Anweisungsblock, der ausgef\u00fchrt wird, * wenn die bedingung false ist. * das k\u00f6nnen beliebig viele Anweisungen sein: * Sequenzen, Iterationen und/oder Selektionen * dieser else -Block kann aber auch ganz weg- * gelassen werden - sehen wir gleich */ }","title":"if...else"},{"location":"selektion/#bedingungen","text":"Bevor wir uns noch weitere Varianten der if...else -Anweisung anschauen, gehen wir nochmal darauf ein, was eine Bedingung ist. Eine Bedingung ist ein logischer Ausdruck, - d.h. der Datentyp des Wertes einer Bedingung ist `boolean`, - d.h. der Wert einer Bedingung ist entweder `true` oder `false` Wir betrachten einige Beispiele von Bedingungen (wir nehmen an, dass die Methoden isOdd(int) und notZero(int) existieren und ein boolean zur\u00fcckgeben): boolean cond1 = true ; // kann genutzt werden als if(cond1) oder if(true) boolean cond2 = cond1 ; // kann genutzt werden als if(cond2) oder if(cond1) boolean cond3 = cond1 && true ; // kann genutzt werden als if(cond3) oder if(cond1 && true) boolean cond4 = ( 7 >= 4 ); // kann genutzt werden als if(cond4) oder if(7 >= 4) boolean cond5 = ( 7 >= 4 ) && ( 3 < 5 ); // kann genutzt werden als if(cond5) oder if((7 >= 4) && (3 < 5)) boolean cond6 = cond5 || cond3 ; // kann genutzt werden als if(cond6) oder if(cond5 || cond3) boolean cond7 = isOdd ( 3 ) && notZero ( 3 ); // kann genutzt werden als if(cond7) oder if(isOdd(3) && notZero(3)) Wichtig ist also, dass alle Werte, die vom Typ boolean sind, als Bedingungen verwendet werden k\u00f6nnen. Achten Sie auch darauf, dass die Ausdr\u00fccke selbst (also die Bedingungen) kein Semikolon am Ende haben - Ausdr\u00fccke sind keine Anweisungen. Beachte Vergleichen Sie logische Ausdr\u00fccke nicht mit true ! Man sieht h\u00e4ufig so etwas wie isOdd(3) == true . Das ist unn\u00f6tig! Angenommen, der Wert von isOdd(3) ist true , dann ist auch der Vergleich isOdd(3) == true true . Angenommen, der Wert von isOdd(3) ist false , dann ist auch der Vergleich isOdd(3) == true false . Das bedeutet, der Wert des Vergleiches entspricht exakt dem Wert von isOdd(3) , also benutzen wir nur isOdd(3) .","title":"Bedingungen"},{"location":"selektion/#ifelse-ohne-else-block","text":"Der else -Block ist nicht zwingend n\u00f6tig. Es gibt Beispiele, in denen etwas getan werden soll, wenn eine bestimmte Bedingung gilt, aber wenn sie nicht gilt, dann muss auch nichts getan werden, z.B. (Methoden ausgedacht): if ( fileOpen ( file )) { closeFile ( file ); } if ( connectionEstablished ( database )) { disconnect ( database ); } if ( divisor == 0 ) { System . out . println ( \"Divsion durch 0 nicht m\u00f6glich!\" ); }","title":"if...else ohne else-Block"},{"location":"selektion/#verschachtelte-selektionen","text":"Die Anweisungsbl\u00f6cke sowohl im true -Zweig als auch im else -Zweig k\u00f6nnen beliebige Kontrollstrukturen enthalten: nur eine Anweisung oder Sequenzen von Anweisungen und/oder Iterationen und/oder Selektionen. Ist eine Selektion innerhalb einer Selektion, spricht man auch von verschachtelten Selektionen. Angenommen, wir haben drei int -Variablen a , b , c und wollen diese der Gr\u00f6\u00dfe nach sortieren (und wollen auch noch pr\u00fcfen, ob die Werte evenzuell gleich sind): // a, b, c vom Typ `int` if ( a > b ) { if ( b > c ) { System . out . println ( \"a > b > c\" ); } else // c >= b { if ( c > b ) { if ( a > c ) { System . out . println ( \"a > c > b\" ); } else // c >= a { if ( c > a ) { System . out . println ( \"c > a > b\" ); } else // c == a { System . out . println ( \"c = a > b\" ); } } } else // c == b { System . out . println ( \"a > b = c\" ); } } } else // b >= a { if ( b > a ) { if ( b > c ) { if ( a > c ) { System . out . println ( \"b > a > c\" ); } else // c >= a { if ( c > a ) { System . out . println ( \"b > c > a\" ); } else // a == c { System . out . println ( \"b > a = c\" ); } } } else // c >= b { if ( c == b ) { System . out . println ( \"b = c > a\" ); } else // c > b { System . out . println ( \"c > b > a\" ); } } } else // b == a { if ( b > c ) { System . out . println ( \"a = b > c\" ); } else // c >= b { if ( c == b ) { System . out . println ( \"a = b = c\" ); } else // c > b { System . out . println ( \"c > b = a\" ); } } } } Sie sehen, so etwas wird sehr schnell sehr un\u00fcbersichtlich. Wir sollten versuchen, solche Verschachtelungen nur auf sehr geringe Verschachtelungstiefen zu beschr\u00e4nken. Die beste M\u00f6glichkeit, solche Verschachtelungstiefen zu vermeiden, besteht darin, die Bedingungen komplexer zu gestalten indem wir logische Operatoren verwenden, z.B. if(a > b) && (b > c)) . Wir zeigen das mal am obigen Beispiel, in dem wir gar keine Verschachtelungstiefe haben: // a, b, c vom Typ `int` if ( a > b && b > c ) { System . out . println ( \"a > b > c\" ); } if ( a > b && c > b && a > c ) { System . out . println ( \"a > c > b\" ); } if ( a > b && c > b && c > a ) { System . out . println ( \"c > a > b\" ); } if ( a > b && c > b && c == a ) { System . out . println ( \"a = c > b\" ); } if ( a > b && b == c ) { System . out . println ( \"a > b = c\" ); } if ( a == b && b == c ) { System . out . println ( \"a = b = c\" ); } if ( a == b && b > c ) { System . out . println ( \"a = b > c\" ); } if ( a == b && c > b ) { System . out . println ( \"c > a = b\" ); } if ( b > a && a > c ) { System . out . println ( \"b > a > c\" ); } if ( b > a && c > a && b > c ) { System . out . println ( \"b > c > a\" ); } if ( b > a && c > a && b == c ) { System . out . println ( \"b = c > a\" ); } if ( b > a && c == a ) { System . out . println ( \"b > c = a\" ); } if ( b > a && c > b ) { System . out . println ( \"c > b > a\" ); } \u00dcbung Bei welchem der beiden oberen Programme werden (im Durchschnitt) mehr Vergleiche durchgef\u00fchrt und warum? Das Problem mit komplexen Bedingungen besteht darin, dass diese recht schwer zu verstehen sind. F\u00fcr komplexe Bedingungen sollten wir stets eigene Methoden definieren (die ein boolean zur\u00fcckgeben) und die mit ihrem Namen verraten, was die Bedingung pr\u00fcft. Darauf kommen wir sp\u00e4ter nochmal zur\u00fcck.","title":"Verschachtelte Selektionen"},{"location":"selektion/#switch-anweisung","text":"Die switch -Anweisung war in Java lange ungl\u00fccklich gel\u00f6st. Die switch -Anweisung kann verwendet werden, wenn Sie viele Fallunterscheidungen haben. Wir geben zun\u00e4chst ein Beispiel in der alten Form der switch -Anweisung, die immer noch funktioniert und die Sie so wahrscheinlich auch noch sehr h\u00e4ufig antreffen werden: // monat vom Typ `int` switch ( monat ) { case 1 : System . out . println ( \"Januar\" ); break ; case 2 : System . out . println ( \"Februar\" ); break ; case 3 : System . out . println ( \"M\u00e4rz\" ); break ; case 4 : System . out . println ( \"April\" ); break ; case 5 : System . out . println ( \"Mai\" ); break ; case 6 : System . out . println ( \"Juni\" ); break ; case 7 : System . out . println ( \"Juli\" ); break ; case 8 : System . out . println ( \"August\" ); break ; case 9 : System . out . println ( \"September\" ); break ; case 10 : System . out . println ( \"Oktober\" ); break ; case 11 : System . out . println ( \"November\" ); break ; case 12 : System . out . println ( \"Dezember\" ); break ; default : System . out . println ( \"kein Monat\" ); } Betrachten wir die Anweisung zun\u00e4chst etwas genauer. Die Fallunterscheidungen betreffen den Wert der int -Variablen monat . Das bedeutet schonmal, dass in den runden Klammern der switch() -Anweisung keine Bedingung steht, sondern ein Ausdruck, der von verschiedenen Datentypen sein kann, z.B. byte , short , int und String . Der Ablauf einer switch() -Anweisung ist nun so, dass f\u00fcr den entsprechenden Wert der case gesucht wird, also z.B. wenn month den Wert 6 hat, dann ist case 6: der \"Einsprungspunkt\". Dort werden nun alle Anweisungen abgearbeitet, bis entweder ein break; kommt oder die switch() -Anweisung beendet ist. break; stoppt also die Abarbeitung. W\u00fcrde in unserem Beispiel kein break enthalten sein und w\u00e4re month z.B. 6 , dann w\u00fcrden alle Monate ab und inkl. Juni ausgegeben werden. Der default: -Fall ist daf\u00fcr, falls keine der case passt. Der default: -Fall ist optional. Dass die Anweisungen nach case x: nicht in Anweisungsbl\u00f6cken stehen und dass die Verwendung von break; erforderlich ist, um die Ausf\u00fchrung von Anweisungen zu stoppen, macht diese alte Syntax der switch() -Anweisung unsch\u00f6n. Wir betrachten noch ein Beispiel in der alten Syntax, um den Unterschied zur neuen noch besser zu erl\u00e4utern: // monat vom Typ `int` int anzahlTageImMonat = 0 ; switch ( monat ) { case 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 : anzahlTageImMonat = 31 ; break ; case 4 : case 6 : case 9 : case 11 : anzahlTageImMonat = 30 ; break ; case 2 : anzahlTageImMonat = 28 ; } Ab Java 12 wurde die switch() -Anweisung gr\u00fcndlich \u00fcberarbeitet. Wir betrachten das so eben gezeigte Beispiel nun in der neuen Schreibweise: int anzahlTageImMonat = switch ( monat ) { case 1 , 3 , 5 , 7 , 8 , 10 , 12 -> 31 ; case 4 , 6 , 9 , 11 -> 30 ; case 2 -> 28 ; default -> 0 ; }; Mehrere Dinge fallen auf: kann eine switch() -Anweisung nun auch als Ausdruck verwendet werden und somit z.B. einer Variablen einen Wert zu weisen (das machen wir hier) hat sich die Schreibweise beim case ge\u00e4ndert. Aus dem Doppelpunkt wurde ein Pfeil und es k\u00f6nnen mit einem case auch mehrere durch Komma getrennte Werte aufgef\u00fchrt werden und - besonders gut - wir ben\u00f6tigen kein break mehr. Es wird immer nur der case ausgef\u00fchrt. Die Abarbeitung der dort beschriebenen Anweisungen stoppt beim n\u00e4chsten case bzw. bei default oder am Ende der switch() -Anweisung Success Wir haben 2 M\u00f6glichkeiten kennengelernt, die Selektion in Java zu implementieren. Die eine (und bedeutendste) M\u00f6glichkeit ist die if...else -Anweisung. Dort wird in Abh\u00e4ngigkeit vom Wahreheitswert einer Bedingung entweder der eine oder der andere Anweisungsblock ausgef\u00fchrt. Der else -Block kann auch weggelassen werden. Innerhalb eines Anweisungsblockes k\u00f6nnen beliebige Kontrollstrukturen stehen: Sequenzen, Iterationen und Selektionen. Die zweite M\u00f6glichkeit ist die switch() -Anweisung, die seit Java 12 auch selbst ein Ausdruck sein kann. Wir haben die alte Syntax der switch() -Anweisung kritisch betrachtet und die neue Syntax kennengelernt.","title":"switch-Anweisung"},{"location":"sortieren/","text":"Sortieren von Arrays \u00b6 Es ist h\u00e4ufig notwendig, die Elemente von bestimmten Datenstrukturen (Arrays, Listen, B\u00e4ume, \u2026 - bis jetzt kennen wir davon nur Arrays) zu sortieren. Dazu muss es eine Ordnung \u00fcber die Elemente geben (z.B. numerische Ordnungen von Zahlen, lexikografische Ordnungen von Zeichenketten, \u2026). Man unterscheidet zwischen Sortierverfahren, die mit dem gegebenen Speicherplatz der Datenstruktur auskommen und denen, die zus\u00e4tzlichen Platz zum zwischenzeitlichen Auslagern von Elementen ben\u00f6tigen. Prinzipiell ist der paarweise Vergleich aller Elemente notwendig. Es gibt verschiedene Sortierverfahren, die unterschiedliche Aufw\u00e4nde f\u00fcr den besten Fall, den schlechtesten Fall und im Durchschnitt aufweisen. Wir werden im Folgenden verschiedene Sortierverfahren betrachten. Sie m\u00fcssen aber nur eins selbst\u00e4ndig umsetzen k\u00f6nnen! Ich nehme an, das wird f\u00fcr die allermeisten Bubble-Sort sein. Hint In diesem Abschnitt werden h\u00e4ufig Methoden gezeigt, die als static deklariert sind. Das Schl\u00fcsselwort static besagt, dass wir diese Methode verwenden (aufrufen) k\u00f6nnen, ohne eine Objekt der Klasse erzeugen zu m\u00fcssen, in der diese Methoden deklariert sind. Es handelt sich um statische Methoden oder besser um Klassenmethoden (im Gegensatz zu Objektmethoden , welche nur f\u00fcr ein Objekt aufgerufen werden k\u00f6nnen). Die bekannteste statische Methode ist die main -Methode. Aber auch aus anderen Klassen kennen wir bereits statische Methoden, z.B. Math.sqrt() . Wir k\u00f6nnen die sqrt() -Methode der Klasse Math aufrufen, ohne ein Objekt der Klasse Math zu erzeugen, einfach Klassenname.klassenMethode() . Bubble-Sort \u00b6 Bei Bubble-Sort wird das gr\u00f6\u00dfte Element immer nach rechts \"gebubbled\". Das Prinzip bei Bubble-Sort ist wie folgt: die Datenstruktur (hier: Array) wird von links nach rechts durchlaufen \u201eBubble-Phase\u201c es wird stets das aktuelle Element mit den rechten Nachbarn verglichen ist die Ordnung falsch, werden die Elemente getauscht am Ende einer Bubble-Phase befindet sich das gr\u00f6\u00dfte Element ganz rechts Wiederholung der Bubble-Phase Bubble-Phase wird wiederholt, d.h. es wird wieder vorne im Array angefangen und jedes Element mit seinem rechten Nachbarn verglichen da das ganz rechte Element bereits das gr\u00f6\u00dfte ist, muss es nicht mehr verglichen werden mit jeder Bubble-Phase muss also ein Vergleich weniger durchgef\u00fchrt werden und das jeweils gr\u00f6\u00dfte rutscht nach rechts die Bubble-Phasen werden so oft wiederholt, bis das Array komplett sortiert ist (L\u00e4nge des Arrays-1 Bubble-Phasen) Wir betrachten ein Beispiel. Folgendes Array soll sortiert werden: 55 07 78 12 42 Wir starten von links nach rechts und vergleichen die Elemente paarweise: 1 . Bubble-Phase 55 07 78 12 42 --> 55 und 07 vergleichen --> es muss getauscht werden 07 55 78 12 42 --> 55 und 78 vergleichen --> es muss nicht getauscht werden 07 55 78 12 42 --> 78 und 12 vergleichen --> es muss getauscht werden 07 55 12 78 42 --> 78 und 42 vergleichen --> es muss getauscht werden 07 55 12 42 78 --> 1 . Bubble-Phase beendet --> die gr\u00f6\u00dfte Zahl 78 steht ganz rechts Nach der ersten Bubble-Phase steht die gr\u00f6\u00dfte Zahl aus dem Array ganz rechts. Diese muss nun nicht mehr mitverglichen werden. Bei der 2. Buble-Phase haben wir also einen Vergleich weniger, als bei der ersten. 2 . Bubble-Phase 07 55 12 42 78 --> 07 und 55 vergleichen --> es muss nicht getauscht werden 07 55 12 42 78 --> 55 und 12 vergleichen --> es muss getauscht werden 07 12 55 42 78 --> 55 und 42 vergleichen --> es muss getauscht werden 07 12 42 55 78 --> 2 . Bubble-Phase beendet --> die zweitgr\u00f6\u00dfte Zahl 55 steht an zweitletzter Stelle Mit dem letzten Wert muss also in der 2. Bubble-Phase nicht mehr verglichen werden, da im Ergebnis der ersten Bubble-Phase ja der gr\u00f6\u00dfte Wert nach gaz rechts geschoben wurde. In der dritten Bubble-Phase muss dann auch nicht mehr mit dem vorletzten Wert verglichen werden usw. 3 . Bubble-Phase 07 12 42 55 78 --> 07 und 12 vergleichen --> es muss nicht getauscht werden 07 12 42 55 78 --> 12 und 42 vergleichen --> es muss nicht getauscht werden 07 12 42 55 78 --> 3 . Bubble-Phase beendet --> die drittgr\u00f6\u00dfte Zahl 42 steht an drittletzter Stelle Wie wir sehen, ist dieses Array sogar schon nach der 3. Buble-Phase sortiert. Wir werden uns sp\u00e4ter auch \u00fcberlegen, wie wir solche F\u00e4lle ausnutzen k\u00f6nnen, um nicht zwingend alle Bubble-Phasen durchlaufen zu m\u00fcssen, wenn das Array bereits vorzeitig sortiert ist. F\u00fcr ein Array der L\u00e4nge 5 , so wie hier, brauchen wir aber h\u00e4ufig noch die letzte Bubble-Phase 4 : 4 . Bubble-Phase 07 12 42 55 78 --> 07 und 12 vergleichen --> es muss nicht getauscht werden 07 12 42 55 78 --> 4 . Bubble-Phase beendet --> ein Array der L\u00e4nge 5 ist nach sp\u00e4testens 4 Bubble-Phasen sortiert F\u00fcr ein Array der L\u00e4nge n braucht es n-1 Bubble-Phasen. Die erste Bubble-Phase besteht aus n-1 Vergleichen, die 2. Bubble-Phase besteht aus n-2 Vergleichen usw. Wir wollen uns der algorithmischen Idee von Bubble-Sort ann\u00e4hern. Wir wollen eine Methode bubblesort() schreiben, f\u00fcr die folgendes gilt: Parameter : unsortiertes Array a R\u00fcckgabe : sortiertes Array b Vorgehen : zuerst a komplett nach b kopieren, um a im Original zu belassen; b ist unsortiert Array b vom ersten bis zum letzten Element durchlaufen und alle benachbarten Elemente b[index] und b[index+1] miteinander vergleichen wenn b[index] <= b[index+1] \u2794 nichts tun wenn b[index] > b[index+1] \u2794 b[index] und b[index+1] vertauschen Wenn Array b einmal durchlaufen \u2794 das gr\u00f6\u00dfte Element von b steht an der letzten Stelle (\u2248 letztes Element sortiert) Verfahren auf Array b vom ersten bis zum vorletzten Element anwenden \u2026 bis alle Elemente in b sortiert Eine m\u00f6gliche Implementierung von Bubble-Sort: 1 2 3 4 5 6 7 8 9 10 11 12 13 for ( int bubble = 1 ; bubble <= b . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; } } } return b ; Zeile 1 zeigt die \u00e4u\u00dfere for -Schleife f\u00fcr die Bubble-Phasen. Es werden length-1 viele Bubble-Phasen durchlaufen (Initialisierung von bubble mit 1 und Bedingung <= ). Zeile 3 zeigt die innere for -Schleife, die in jeder Bubble-Phase durchlaufen wird. Die Anzahl der Durchl\u00e4ufe wird immer kleiner (wegen length - bubble in der Bedingung). Die innere for -Schleife ist f\u00fcr den Vergleich aller Nachbarn. Zeile 5 zeigt die Bedingung, unter der die Nachbarn tauschen m\u00fcssen. Zeilen 7-9 zeigt den Tausch der Werte zweier Nachbarn. Wir gehen auf diesen Tausch gleich nochmal ausf\u00fchrlich ein. Wenn die \u00e4u\u00dfere for -Schleife abgearbeitet wurde, also alle Bubble-Phasen durchlaufen wurden, ist das Array b sortiert und kann zur\u00fcckgegeben werden. Sortieren.java zum Ausprobieren package themen.arrays.sortieren ; import java.util.Random ; public class Sortieren { /* * aus Skript */ public static void printArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } System . out . println ( s ); } /* * aus Skript */ public static int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } public static int [] bubblesort ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = new int [ a . length ] ; for ( int index = 0 ; index < b . length ; index ++ ) { b [ index ] = a [ index ] ; } /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ for ( int bubble = 1 ; bubble <= b . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; } } } return b ; } public static void main ( String [] args ) { int [] unsorted = createAndFillArray ( 20 , 50 ); int [] sorted = bubblesort ( unsorted ); printArray ( unsorted ); printArray ( sorted ); } } Tauschen der Werte zweier Nachbarn \u00b6 Angenommen, wir haben folgenden Fall, in dem die Werte 18 und 7 ihre Positionen tauschen sollen, also die 18 auf den Index 3 wechseln soll und die 7 auf den Index 2 . Was wir nicht machen k\u00f6nnen, ist etwas in der Art: b [ 2 ] = b [ 3 ] ; // b[2]==7 und b[3]==7 - die 18 ist \u00fcberschrieben b [ 3 ] = b [ 2 ] ; // b[2]==7 und b[3]==7 Nach der ersten Anweisung w\u00fcrde sowohl in b[2] als auch in b[3] der Wert 7 stehen und die 18 w\u00e4re \"weg\". Wir brauchen eine Variable, auf die wir einen Wert zwischenspeichern k\u00f6nnen. Wichtig ist, dass diese Variable vom selben Typ ist, wie alle Werte des Arrays (in diesem Fall int ). In dieser Variablen k\u00f6nnen wir uns den Wert aus b[2] zun\u00e4chst (zwischen-)speichern. Nun kann der Wert in b[2] problemlos \u00fcberschrieben werden, denn wir haben ihn ja noch in tmp verf\u00fcgbar. Nun m\u00fcssen wir nur noch den Wert aus tmp nach b[3] kopieren. Die Werte 7 und 18 haben im Array ihre Positionen getauscht. Im obigen Beispiel ist dieses Vertauschen in den 3 Zeilen ausgedr\u00fcckt: int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; Verbesserung von Bubble-Sort \u00b6 In dem eingangs gezeigten Beispiel haben wir gesehen, dass manchmal gar nicht alle length-1 Bubble-Phasen durchlaufen werden m\u00fcssen, da das Array manchmal schon vorher fertig sortiert ist. Wir wollen unsere Methode dahingehend verbessern, dass dies erkannt wird und dementsprechend die Sortierung gestoppt wird. Woran erkennen wir aber, dass das Array fertig sortiert ist? Die Antwort f\u00fcr den Bubble-Sort-Algorithmus: Wenn in einer Bubble-Phase gar kein Vertauschen mehr stattfindet, dann sind alle linken Nachbarn kleiner als ihre rechten und somit ist das Array fertig sortiert. Das hei\u00dft, wir pr\u00fcfen f\u00fcr eine Bubble-Phase, ob (mindestens) ein Vertauschen stattfand oder nicht. Dazu ben\u00f6tigen wir: eine Variable swapped vom Typ boolean , die false ist, wenn nicht getauscht wurde und true , wenn getauscht wurde \u2192 initial ist sie aber true (wegen 2.) eine Bedingung in der \u00e4u\u00dferen for -Schleife && swapped . Neben der Bedingung \u00fcber den bubble -Wert pr\u00fcfen wir nun auch noch, ob swapped true ist. Nur wenn das der Fall ist (wenn getauscht wurde), betreten wir das Innere der Schleife. Wenn nicht getauscht wurde, ist der Wert von swapped``false und die Sortierung wird beendet. eine Anweisung swapped=false; direkt nachdem wir die \u00e4u\u00dfere for -Schleife betreten haben, d.h. eine neue Bubble-Phase angefangen hat. Wir setzen den Wert also erstmal auf false und nur dann, wenn ein Tausch stattfindet, wird er auf true gesetzt. eine Anweisung swapped=true; f\u00fcr den Fall, dass getauscht wird. Wenn die Bedingung b[index] > b[index+1] true ist, dann tauschen die beiden Nachbarn auf den Indizes index und index+1 ihre Positionen und also wurde getauscht \u2192 es muss noch (mindestens) eine weitere Bubble-Phase stattfinden. Die optimierte Bubble-Sortierung sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; } } } return b ; Damit ist die Implementierung von Bubble-Sort vollst\u00e4ndig. So kann sie bleiben und genutzt werden. Wir wollen jetzt nur noch ein paar Ausgaben hinzuf\u00fcgen, die aber einzig und allein dem Verst\u00e4ndnis des Ablaufs der Sortierung mit Bubble-Sort dienen soll. ori---> [ 46 , 12 , 15 , 39 , 37 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 1 . Bubble-Phase : ------> [ 46 , 12 , 15 , 39 , 37 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 0 --> [ 12 , 46 , 15 , 39 , 37 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 1 --> [ 12 , 15 , 46 , 39 , 37 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 2 --> [ 12 , 15 , 39 , 46 , 37 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 3 --> [ 12 , 15 , 39 , 37 , 46 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 4 --> [ 12 , 15 , 39 , 37 , 12 , 46 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 5 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 46 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 6 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 8 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 49 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 9 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 49 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 10 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 49 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 11 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 49 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 12 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 49 , 3 , 14 , 26 , 24 , 31 ] 14 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 49 , 14 , 26 , 24 , 31 ] 15 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 49 , 26 , 24 , 31 ] 16 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 49 , 24 , 31 ] 17 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 49 , 31 ] 18 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 2 . Bubble-Phase : ------> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 2 --> [ 12 , 15 , 37 , 39 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 3 --> [ 12 , 15 , 37 , 12 , 39 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 4 --> [ 12 , 15 , 37 , 12 , 20 , 39 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 5 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 7 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 46 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 8 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 46 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 9 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 46 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 10 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 46 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 11 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 13 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 49 , 14 , 26 , 24 , 31 , 49 ] 14 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 49 , 26 , 24 , 31 , 49 ] 15 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 49 , 24 , 31 , 49 ] 16 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 49 , 31 , 49 ] 17 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 3 . Bubble-Phase : ------> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 2 --> [ 12 , 15 , 12 , 37 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 3 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 6 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 8 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 41 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 9 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 41 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 10 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 12 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 46 , 14 , 26 , 24 , 31 , 49 , 49 ] 13 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 46 , 26 , 24 , 31 , 49 , 49 ] 14 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 26 , 46 , 24 , 31 , 49 , 49 ] 15 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 26 , 24 , 46 , 31 , 49 , 49 ] 16 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 4 . Bubble-Phase : ------> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 1 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 7 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 39 , 2 , 36 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 8 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 39 , 36 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 9 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 11 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 41 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 12 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 14 , 41 , 26 , 24 , 31 , 46 , 49 , 49 ] 13 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 14 , 26 , 41 , 24 , 31 , 46 , 49 , 49 ] 14 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 14 , 26 , 24 , 41 , 31 , 46 , 49 , 49 ] 15 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 5 . Bubble-Phase : ------> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 6 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 38 , 2 , 36 , 39 , 3 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 7 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 38 , 36 , 39 , 3 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 8 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 39 , 3 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 10 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 39 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 11 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 14 , 39 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 12 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 14 , 26 , 39 , 24 , 31 , 41 , 46 , 49 , 49 ] 13 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 14 , 26 , 24 , 39 , 31 , 41 , 46 , 49 , 49 ] 14 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 6 . Bubble-Phase : ------> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 5 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 37 , 2 , 36 , 38 , 3 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 6 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 37 , 36 , 38 , 3 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 7 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 38 , 3 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 9 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 38 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 10 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 14 , 38 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 11 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 38 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 12 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 38 , 31 , 39 , 41 , 46 , 49 , 49 ] 13 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 7 . Bubble-Phase : ------> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 4 --> [ 12 , 12 , 15 , 20 , 6 , 37 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 5 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 37 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 6 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 37 , 3 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 8 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 37 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 9 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 14 , 37 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 10 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 37 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 11 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 37 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 12 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 8 . Bubble-Phase : ------> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 3 --> [ 12 , 12 , 15 , 6 , 20 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 4 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 7 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 37 , 14 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 8 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 14 , 37 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 9 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 14 , 26 , 37 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 10 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 14 , 26 , 24 , 37 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 11 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 14 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 9 . Bubble-Phase : ------> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 14 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 2 --> [ 12 , 12 , 6 , 15 , 2 , 20 , 36 , 3 , 14 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 3 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 36 , 3 , 14 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 6 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 36 , 14 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 7 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 14 , 36 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 8 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 14 , 26 , 36 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 9 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 14 , 26 , 24 , 36 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 10 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 14 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 10 . Bubble-Phase : ------> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 14 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 1 --> [ 12 , 6 , 12 , 2 , 15 , 20 , 3 , 14 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 2 --> [ 12 , 6 , 2 , 12 , 15 , 20 , 3 , 14 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 5 --> [ 12 , 6 , 2 , 12 , 15 , 3 , 20 , 14 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 6 --> [ 12 , 6 , 2 , 12 , 15 , 3 , 14 , 20 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 8 --> [ 12 , 6 , 2 , 12 , 15 , 3 , 14 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 11 . Bubble-Phase : ------> [ 12 , 6 , 2 , 12 , 15 , 3 , 14 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 0 --> [ 6 , 12 , 2 , 12 , 15 , 3 , 14 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 1 --> [ 6 , 2 , 12 , 12 , 15 , 3 , 14 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 4 --> [ 6 , 2 , 12 , 12 , 3 , 15 , 14 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 5 --> [ 6 , 2 , 12 , 12 , 3 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 12 . Bubble-Phase : ------> [ 6 , 2 , 12 , 12 , 3 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 0 --> [ 2 , 6 , 12 , 12 , 3 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 3 --> [ 2 , 6 , 12 , 3 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 13 . Bubble-Phase : ------> [ 2 , 6 , 12 , 3 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 2 --> [ 2 , 6 , 3 , 12 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 14 . Bubble-Phase : ------> [ 2 , 6 , 3 , 12 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 1 --> [ 2 , 3 , 6 , 12 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 15 . Bubble-Phase : ------> [ 2 , 3 , 6 , 12 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] Wir sehen, wie sich von oben nach unten der sortierte Bereich von rechts nach links vergr\u00f6\u00dfert. Es werden immer nur die Zeilen mit ihren jeweiligen Indizes (die ganz linke Zahl am Anfang der Zeile) ausgegeben, in denen Nachbarn getauscht werden. In diesem Beispiel wird bereits in der 15. Bubble-Phase nichts mehr getauscht. Da das Array die L\u00e4nge 20 hat, g\u00e4be es eigentlich 19 Bubble-Phasen. Der Code, der f\u00fcr die obige Ausgabe verwendet wurde package themen.arrays.sortieren ; import java.util.Random ; public class Sortieren { /* * aus Skript */ public static void printArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } System . out . println ( s ); } /* * angepasste printArray-Methode * hier wird davon ausgegangen, dass die Zahlen * in dem Array nie gr\u00f6\u00dfer als zweistellig sind * ist haupts\u00e4chlich, damit die Ausgaben der Arrays besser * miteinander verglichen werden k\u00f6nnen auf der Konsole * */ public static void print ( int [] a ) { String s = \"--> [ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + String . format ( \"%2d, \" , a [ index ] ); } if ( a . length > 0 ) { s = s + String . format ( \"%2d ]\" , a [ a . length - 1 ] ); } System . out . println ( s ); } /* * aus Skript */ public static int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } public static int [] bubblesort ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = new int [ a . length ] ; for ( int index = 0 ; index < b . length ; index ++ ) { b [ index ] = a [ index ] ; } System . out . print ( \"ori-\" ); print ( b ); // Ausgangs-Array System . out . println (); /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { System . out . printf ( \"%3d. Bubble-Phase : %n----\" , bubble ); print ( b ); swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; System . out . printf ( \"%3d \" , index ); print ( b ); } } System . out . println (); } return b ; } public static void main ( String [] args ) { int [] unsorted = createAndFillArray ( 20 , 50 ); int [] sorted = bubblesort ( unsorted ); printArray ( unsorted ); printArray ( sorted ); } } Noch kurz ein Wort zur Komplexit\u00e4t von Bubble-Sort. Wenn n die L\u00e4nge des Arrays ist, dann finden in der ersten Bubble-Phase n-1 Vergleiche statt, in der zweiten Bubble-Phase n-2 Vergleiche usw. Es gibt maximal n-1 Bubble-Phasen, also (n-1) + (n-2) + (n-3) + ... + 3 + 2 + 1 Vergleiche. Das sind n*(n-1)/2 Vergleiche und maximal ebenso viele Vertauschungen. Das ergibt Vergleiche + Vertauschungen = n*(n-1) Operationen. Das entspricht einer (Zeit-)Komplexit\u00e4t von O(n^2) . Success Wir haben einen Sortieralgorithmus kennengelernt, mit dem wir Arrays sortieren k\u00f6nnen. Beachten Sie, dass das nicht nur f\u00fcr int -Arrays m\u00f6glich ist, sondern f\u00fcr alle Datentypen, \u00fcber die sich eine Ordnung definieren l\u00e4sst. Wir werden jetzt noch weitere Sortieralgorithmen betrachten, aber nur aus Interesse. Den Bubble-Sort-Algorithmus sollten Sie aus dem Kopf beherrschen, also programmieren k\u00f6nnen. Alle weiteren Sortieralgorithmen sollten Sie \"nur\" verstehen. Selection-Sort \u00b6 Die Idee des Selection-Sort-Algorithmus ist die, dass bei jedem Durchlauf durch das Array das jeweils kleinste (oder gr\u00f6\u00dfte - je, nachdem, wie man sortieren m\u00f6chte) ausgew\u00e4hlt und an seine richtige Position im Array sortiert wird. Wir betrachten erneut unser Beispiel: 55 07 78 12 42 Erster Durchlauf: Im ersten Schritt suchen wir das kleinste Element im Array und wollen es ganz links (auf den Index 0 ) legen die 7 ist das kleinste Element, also muss es seine Poition mit der 55 tauschen Nach dem ersten Schritt: 07 55 78 12 42 Zweiter Durchlauf: Jetzt steht das kleinste Element ganz links \u2192 es muss nicht mehr betrachtet werden wir suchen jetzt das zweitkleinste Element, um es auf den Index 1 zu legen die 12 ist das zweitkleinste Element, also muss es seine Position mit der 55 tauschen Nach dem zweiten Schritt: 07 12 78 55 42 Dritter Durchlauf: Jetzt stehen die 2 kleinsten Element ganz links \u2192 sie m\u00fcssen nicht mehr betrachtet werden wir suchen jetzt das drittkleinste Element, um es auf den Index 2 zu legen die 42 ist das drittkleinste Element, also muss es seine Position mit der 78 tauschen Nach dem dritten Schritt: 07 12 42 55 78 Vierter Durchlauf: Jetzt stehen die 3 kleinsten Element ganz links \u2192 sie m\u00fcssen nicht mehr betrachtet werden wir suchen jetzt das viertkleinste Element, um es auf den Index 3 zu legen die 55 ist das viertkleinste Element, es ist bereits auf der richtigen Position \u2192 wir m\u00fcssen also nicht (mehr) tauschen Ein Array der L\u00e4nge 5 ist nach 4 Durchl\u00e4ufen sortiert. Generell gilt auch hier wieder, dass ein Array der L\u00e4nge n nach sp\u00e4testens n-1 Durchl\u00e4ufen (das waren In Bubble-Sort die Bubble-Phasen) sortiert ist. W\u00e4hrend bei Bubble-Sort der sortierte Teil des Arrays von rechts anwuchs (von gro\u00df nach klein), w\u00e4chst bei Selection-Sort der sortierte Teil des Arrays von links an (von klein nach gro\u00df). Auch hier gilt wieder, dass immer nur der unsortierte Teil erneut durchsucht werden muss. Auch hier finden wieder paarweise Vergleiche mit allen unsortierten Elementen statt. Dieses Mal sind es aber nicht die Nachbarn, die verglichen und evtl. getauscht werden m\u00fcssen, sondern es wird im unsortierten (rechten) Teil nach dem kleinsten Element gesucht. Hier noch ein Bild, das den Selection-Sort-Algorithmus an einem anderen Beispiel verdeutlicht: Wir wollen uns der algorithmischen Idee von Selection-Sort ann\u00e4hern. Wir wollen eine Methode selectionsort() schreiben, f\u00fcr die folgendes gilt: Parameter : unsortiertes Array a R\u00fcckgabe : sortiertes Array b Vorgehen : gedachte Teilung des Arrays in 2 Teile: linker Teil: sortiert rechter Teil: unsortiert \u2794 anfangs: linker Teil leer d.h. Array unsortiert rechten unsortierten Teil b[j] ,\u2026, b[n-1] betrachten ( n ist L\u00e4nge des Arrays) das kleinste Element (Minimum) im rechten Teil suchen mit dem ersten Element b[j] im rechten Teil vertauschen \u2794 rechter unsortierter Teil des Array b[j+1] ,\u2026, b[n-1] um ein Element kleiner, linker sortierter Teil w\u00e4chst um ein Element b[j] so verfahren, bis rechter Teil nur ein Element b[n-1] enth\u00e4lt Eine m\u00f6gliche Implementierung von Selection-Sort: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public static int [] selectionsort ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int durchlauf = 0 ; durchlauf < b . length ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes for ( int index = durchlauf ; index < b . length ; index ++ ) // Suche nach dem kleinsten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } } // jetzt den kleinsten Wert auf den Index durchlauf legen // der Wert, der auf durchlauf lag, kommt nach minIndex int tmp = b [ durchlauf ] ; b [ durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmp ; } return b ; } Zeile 5 zeigt die \u00e4u\u00dfere for -Schleife f\u00fcr die Durchl\u00e4ufe. Es werden length-1 viele Phasen durchlaufen. in Zeile 7 wird die Variable deklariert, in der wir uns den kleinsten Wert des rechten (unsortierten) Teils merken. Wir initialisieren die Variable mit dem ersten Wert im unsortierten Teil. Der unsortierte Teil beginnt beim Index durchlauf . in Zeile 8 wird die Variable deklariert, in der wir uns den Index des kleinsten Wertes im rechten (unsortierten) Teils merken. Wir initialisieren die Variable mit dem ersten Index im unsortierten Teil - dies ist durchlauf . in den Zeilen 19-21 tauschen wir die Werte. Der kleinste Wert kommt auf den Index durchlauf und der Wert, der auf dem Index durchlauf stand, kommt nach minIndex Wenn die \u00e4u\u00dfere for -Schleife abgearbeitet wurde, also alle length-1 Phasen durchlaufen wurden, ist das Array b sortiert und kann zur\u00fcckgegeben werden. Die copy() -Methode, die in Zeile 3 verwendet wurde, sieht so aus: public static int [] copy ( int [] a ) { int [] b = new int [ a . length ] ; for ( int index = 0 ; index < b . length ; index ++ ) { b [ index ] = a [ index ] ; } return b ; } Wir werden jetzt die Implementierung des Selection-Sort-Algorithmus um einige Ausgaben erweitern, damit das Prinzip noch deutlicher wird (wie bei Bubble-Sort). Die Ausgaben haben in der Methode nat\u00fcrlich eigentlich nichts zu suchen - es ist hier nur zur n\u00e4heren Information: original -------> [ 38 , 22 , 18 , 6 , 15 , 12 , 9 , 1 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] 1 . Durchlauf - kleinstes Element soll auf den index 0 ----> kleinster Wert ist 1 auf dem Index 7 vor Tausch : --> [ 38 , 22 , 18 , 6 , 15 , 12 , 9 , 1 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 22 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] 2 . Durchlauf - kleinstes Element soll auf den index 1 ----> kleinster Wert ist 5 auf dem Index 9 vor Tausch : --> [ 1 , 22 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] 3 . Durchlauf - kleinstes Element soll auf den index 2 ----> kleinster Wert ist 6 auf dem Index 3 vor Tausch : --> [ 1 , 5 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 18 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] 4 . Durchlauf - kleinstes Element soll auf den index 3 ----> kleinster Wert ist 9 auf dem Index 6 vor Tausch : --> [ 1 , 5 , 6 , 18 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 15 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] 5 . Durchlauf - kleinstes Element soll auf den index 4 ----> kleinster Wert ist 10 auf dem Index 17 vor Tausch : --> [ 1 , 5 , 6 , 9 , 15 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 15 , 31 , 49 ] 6 . Durchlauf - kleinstes Element soll auf den index 5 ----> kleinster Wert ist 11 auf dem Index 14 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 12 , 24 , 30 , 15 , 31 , 49 ] 7 . Durchlauf - kleinstes Element soll auf den index 6 ----> kleinster Wert ist 12 auf dem Index 14 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 12 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] 8 . Durchlauf - kleinstes Element soll auf den index 7 ----> kleinster Wert ist 14 auf dem Index 8 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 38 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] 9 . Durchlauf - kleinstes Element soll auf den index 8 ----> kleinster Wert ist 15 auf dem Index 17 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 38 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 38 , 31 , 49 ] 10 . Durchlauf - kleinstes Element soll auf den index 9 ----> kleinster Wert ist 18 auf dem Index 14 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 22 , 49 , 31 , 19 , 22 , 24 , 30 , 38 , 31 , 49 ] 11 . Durchlauf - kleinstes Element soll auf den index 10 ----> kleinster Wert ist 19 auf dem Index 13 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 22 , 49 , 31 , 19 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 49 , 31 , 22 , 22 , 24 , 30 , 38 , 31 , 49 ] 12 . Durchlauf - kleinstes Element soll auf den index 11 ----> kleinster Wert ist 22 auf dem Index 13 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 49 , 31 , 22 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 31 , 49 , 22 , 24 , 30 , 38 , 31 , 49 ] 13 . Durchlauf - kleinstes Element soll auf den index 12 ----> kleinster Wert ist 22 auf dem Index 14 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 31 , 49 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 49 , 31 , 24 , 30 , 38 , 31 , 49 ] 14 . Durchlauf - kleinstes Element soll auf den index 13 ----> kleinster Wert ist 24 auf dem Index 15 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 49 , 31 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 31 , 49 , 30 , 38 , 31 , 49 ] 15 . Durchlauf - kleinstes Element soll auf den index 14 ----> kleinster Wert ist 30 auf dem Index 16 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 31 , 49 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 49 , 31 , 38 , 31 , 49 ] 16 . Durchlauf - kleinstes Element soll auf den index 15 ----> kleinster Wert ist 31 auf dem Index 16 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 49 , 31 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 49 , 38 , 31 , 49 ] 17 . Durchlauf - kleinstes Element soll auf den index 16 ----> kleinster Wert ist 31 auf dem Index 18 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 49 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] 18 . Durchlauf - kleinstes Element soll auf den index 17 ----> kleinster Wert ist 38 auf dem Index 17 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] 19 . Durchlauf - kleinstes Element soll auf den index 18 ----> kleinster Wert ist 49 auf dem Index 18 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] 20 . Durchlauf - kleinstes Element soll auf den index 19 ----> kleinster Wert ist 49 auf dem Index 19 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] Wenn wir nur alle Zeilen nach dem Tausch betrachten, dann sehen wir die Entwicklung der Sortierung von links nach rechts: original -------> [ 38 , 22 , 18 , 6 , 15 , 12 , 9 , 1 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 22 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 18 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 15 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 12 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 38 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 22 , 49 , 31 , 19 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 49 , 31 , 22 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 31 , 49 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 49 , 31 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 31 , 49 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 49 , 31 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 49 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] Verbesserung von Selection-Sort \u00b6 In dem obigen Beispiel sehen wir, dass die letzten drei Durchl\u00e4ufe gar nicht mehr notwendig waren, da das Array dann bereits vollst\u00e4ndig sortiert war. Beim Selection-Sort-Algorithmus ist es jedoch gar nicht leicht, diesen Zustand zu erkennen. Stattdessen k\u00f6nnten wir aber folgende Optimierung vornehmen: wir suchen in einem Durchlauf nicht nur das kleinste Element und tauschen dieses nach links, sondern wir suchen gleichzeitig nach dem gr\u00f6\u00dften Element und tauschen dieses nach rechts dann entstehen drei Teile in unserem Array: ein linker, sortierter Teil, ein rechter, sortierter Teil und ein mittlerer, unsortierter Teil Die Anzahl der Durchl\u00e4ufe halbiert sich damit! Hier eine m\u00f6gliche Implementierung des optimieretn Selection-Sort-Algorithmus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 public static int [] selectionsortOptimiert ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int durchlauf = 0 ; durchlauf < b . length / 2 + 1 ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes int maxValue = b [ b . length - 1 - durchlauf ] ; // in maxValue merken wir uns den aktuell groessten Wert int maxIndex = b . length - 1 - durchlauf ; // in maxIndex merken wir uns den Index des aktuell groessten Wertes for ( int index = durchlauf ; index < b . length - durchlauf ; index ++ ) // Suche nach dem kleinsten UND groessten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } if ( maxValue < b [ index ] ) { maxValue = b [ index ] ; // aktuell groesster Wert maxIndex = index ; // aktueller Index des groessten Wertes } } /* * jetzt den kleinsten Wert auf den Index durchlauf legen * der Wert, der auf durchlauf lag, kommt nach minIndex * UND den groessten Wert auf den Index b.length-1-durchlauf legen * der Wert, der auf b.length-1-durchlauf lag, kommt nach maxIndex * wir m\u00fcssen zun\u00e4chst aber beide Werte sichern, sonst kann es zu * Konflikten beim Tauschen kommen! * */ int tmpMin = b [ durchlauf ] ; int tmpMax = b [ b . length - 1 - durchlauf ] ; b [ durchlauf ] = minValue ; b [ minIndex ] = tmpMin ; /* * hier wird es sehr kompliziert * wenn der MaximumWert dort war, wo das neue Minimum hin kommt (Index durchlauf), * dann m\u00fcssen wir aufpassen, dass wir den alten Wert tmpMax nicht verlieren * es sind jetzt nur noch 3 Werte im Spiel * der alte Wert von durchlauf - ist in tmpMin UND ist gleichzeitig maxValue! * der alte Wert von length-1-durchlauf - ist in tmpMax * der alte Wert von minIndex ist minValue und jetzt auf durchlauf * Versuchen Sie es mal ohne die Bedingung und nur * b[b.length-1-durchlauf] = maxValue; * b[maxIndex] = tmpMax; * dann sehen Sie den Fehler */ if ( maxIndex == durchlauf ) { b [ b . length - 1 - durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmpMax ; } else { b [ b . length - 1 - durchlauf ] = maxValue ; b [ maxIndex ] = tmpMax ; } } return b ; } Die Entwicklung eines Arrays mit Zufallszahlen sieht f\u00fcr den optimierten Selection-Sort-Algorithmus z.B. so aus: --> [ 8 , 6 , 7 , 49 , 3 , 7 , 17 , 40 , 48 , 37 , 37 , 49 , 30 , 34 , 15 , 34 , 9 , 38 , 7 , 32 ] // Ausgangs-Array --> [ 3 , 6 , 7 , 32 , 8 , 7 , 17 , 40 , 48 , 37 , 37 , 49 , 30 , 34 , 15 , 34 , 9 , 38 , 7 , 49 ] // Durchlauf 1 --> [ 3 , 6 , 7 , 32 , 8 , 7 , 17 , 40 , 48 , 37 , 37 , 7 , 30 , 34 , 15 , 34 , 9 , 38 , 49 , 49 ] // Durchlauf 2 --> [ 3 , 6 , 7 , 32 , 8 , 7 , 17 , 40 , 38 , 37 , 37 , 7 , 30 , 34 , 15 , 34 , 9 , 48 , 49 , 49 ] // Durchlauf 3 --> [ 3 , 6 , 7 , 7 , 8 , 32 , 17 , 9 , 38 , 37 , 37 , 7 , 30 , 34 , 15 , 34 , 40 , 48 , 49 , 49 ] // Durchlauf 4 --> [ 3 , 6 , 7 , 7 , 7 , 32 , 17 , 9 , 34 , 37 , 37 , 8 , 30 , 34 , 15 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 5 --> [ 3 , 6 , 7 , 7 , 7 , 8 , 17 , 9 , 34 , 15 , 37 , 32 , 30 , 34 , 37 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 6 --> [ 3 , 6 , 7 , 7 , 7 , 8 , 9 , 17 , 34 , 15 , 34 , 32 , 30 , 37 , 37 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 7 --> [ 3 , 6 , 7 , 7 , 7 , 8 , 9 , 15 , 30 , 17 , 34 , 32 , 34 , 37 , 37 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 8 --> [ 3 , 6 , 7 , 7 , 7 , 8 , 9 , 15 , 17 , 30 , 32 , 34 , 34 , 37 , 37 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 9 --> [ 3 , 6 , 7 , 7 , 7 , 8 , 9 , 15 , 17 , 30 , 32 , 34 , 34 , 37 , 37 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 10 Man sieht, dass sich nun die sortierten Teile sowohl von links als auch von rechts ann\u00e4hern und der mittlere, unsortierte Teil immer kleiner wird. Die Komplexit\u00e4t des Selection-Sort-Algorithmus ist die gleiche, wie bei Bubble-Sort. Wir ben\u00f6tigen im ersten Durchlauf n-1 Vergleiche, um das Minimum zu bestimmen, im zweiten Durchlauf n-2 usw. Insgesamt also wieder n*(n-1)/2 Vergleiche. Dazu kommen n-1 Vertauschungen. Das macht insgesamt n^2/2 + n/2 + n - 1 Operationen und ergibt somit eine Zeitkomplexit\u00e4t von O(n^2) . Aktueller Stand der Klasse Sortieren.java package themen.arrays.sortieren ; import java.util.Random ; public class Sortieren { /* * aus Skript */ public static void printArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } System . out . println ( s ); } /* * angepasste printArray-Methode * hier wird davon ausgegangen, dass die Zahlen * in dem Array nie gr\u00f6\u00dfer als zweistellig sind * ist haupts\u00e4chlich, damit die Ausgaben der Arrays besser * miteinander verglichen werden k\u00f6nnen auf der Konsole * */ public static void print ( int [] a ) { String s = \"--> [ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + String . format ( \"%2d, \" , a [ index ] ); } if ( a . length > 0 ) { s = s + String . format ( \"%2d ]\" , a [ a . length - 1 ] ); } System . out . println ( s ); } /* * aus Skript */ public static int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } public static int [] copy ( int [] a ) { int [] b = new int [ a . length ] ; for ( int index = 0 ; index < b . length ; index ++ ) { b [ index ] = a [ index ] ; } return b ; } public static int [] bubblesortDebug ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = copy ( a ); System . out . print ( \"ori-\" ); print ( b ); // Ausgangs-Array System . out . println (); /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { System . out . printf ( \"%3d. Bubble-Phase : %n----\" , bubble ); print ( b ); swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; System . out . printf ( \"%3d \" , index ); print ( b ); } } System . out . println (); } return b ; } public static int [] bubblesort ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = copy ( a ); /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; } } } return b ; } public static int [] selectionsortDebug ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck System . out . print ( \" original -----\" ); print ( b ); // Ausgangs-Array System . out . println (); for ( int durchlauf = 0 ; durchlauf < b . length ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { System . out . printf ( \"%3d. Durchlauf - kleinstes Element soll auf den index %2d %n----> \" , durchlauf + 1 , durchlauf ); int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes for ( int index = durchlauf ; index < b . length ; index ++ ) // Suche nach dem kleinsten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } } System . out . printf ( \"kleinster Wert ist %3d auf dem Index %3d %n\" , minValue , minIndex ); System . out . printf ( \"%13s : \" , \"vor Tausch \" ); print ( b ); // jetzt den kleinsten Wert auf den Index durchlauf legen // der Wert, der auf durchlauf lag, kommt nach minIndex int tmp = b [ durchlauf ] ; b [ durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmp ; System . out . printf ( \"%13s : \" , \"nach Tausch \" ); print ( b ); System . out . println (); } return b ; } public static int [] selectionsort ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int durchlauf = 0 ; durchlauf < b . length ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes for ( int index = durchlauf ; index < b . length ; index ++ ) // Suche nach dem kleinsten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } } // jetzt den kleinsten Wert auf den Index durchlauf legen // der Wert, der auf durchlauf lag, kommt nach minIndex int tmp = b [ durchlauf ] ; b [ durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmp ; } return b ; } public static int [] selectionsortOptimiert ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck System . out . print ( \" \" ); print ( b ); // Ausgangs-Array for ( int durchlauf = 0 ; durchlauf < b . length / 2 ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes int maxValue = b [ b . length - 1 - durchlauf ] ; // in maxValue merken wir uns den aktuell groessten Wert int maxIndex = b . length - 1 - durchlauf ; // in maxIndex merken wir uns den Index des aktuell groessten Wertes System . out . printf ( \"%3d %3d %3d %3d %3d %n\" , durchlauf , minValue , minIndex , maxValue , maxIndex ); for ( int index = durchlauf ; index < b . length - durchlauf ; index ++ ) // Suche nach dem kleinsten UND groessten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } if ( maxValue < b [ index ] ) { maxValue = b [ index ] ; // aktuell groesster Wert maxIndex = index ; // aktueller Index des groessten Wertes } } /* * jetzt den kleinsten Wert auf den Index durchlauf legen * der Wert, der auf durchlauf lag, kommt nach minIndex * UND den groessten Wert auf den Index b.length-1-durchlauf legen * der Wert, der auf b.length-1-durchlauf lag, kommt nach maxIndex * wir m\u00fcssen zun\u00e4chst aber beide Werte sichern, sonst kann es zu * Konflikten beim Tauschen kommen! * */ System . out . printf ( \"%3d %3d %3d %3d %3d \" , durchlauf , minValue , minIndex , maxValue , maxIndex ); int tmpMin = b [ durchlauf ] ; int tmpMax = b [ b . length - 1 - durchlauf ] ; b [ durchlauf ] = minValue ; b [ minIndex ] = tmpMin ; /* * hier wird es sehr kompliziert * wenn der MaximumWert dort war, wo das neue Minimum hin kommt (Index durchlauf), * dann m\u00fcssen wir aufpassen, dass wir den alten Wert tmpMax nicht verlieren * es sind jetzt nur noch 3 Werte im Spiel * der alte Wert von durchlauf - ist in tmpMin UND ist gleichzeitig maxValue! * der alte Wert von length-1-durchlauf - ist in tmpMax * der alte Wert von minIndex ist minValue und jetzt auf durchlauf * Versuchen Sie es mal ohne die Bedingung und nur * b[b.length-1-durchlauf] = maxValue; * b[maxIndex] = tmpMax; * dann sehen Sie den Fehler */ if ( maxIndex == durchlauf ) { b [ b . length - 1 - durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmpMax ; } else { b [ b . length - 1 - durchlauf ] = maxValue ; b [ maxIndex ] = tmpMax ; } print ( b ); } return b ; } public static void main ( String [] args ) { int [] unsorted = createAndFillArray ( 21 , 50 ); System . out . printf ( \"%n%n--------------- bubblesort ----------------------%n%n\" ); int [] sorted = bubblesort ( unsorted ); printArray ( unsorted ); printArray ( sorted ); System . out . printf ( \"%n%n--------------- selection ----------------------%n%n\" ); int [] us = { 1 , 12 , 41 , 35 , 49 , 2 , 28 , 38 , 21 , 35 , 41 , 12 , 21 , 29 , 27 , 17 , 5 , 6 , 18 , 3 }; sorted = selectionsortOptimiert ( unsorted ); printArray ( unsorted ); printArray ( sorted ); } } Success Wir haben einen zweiten Sortieralgorithmus kennengelernt, mit dem wir Arrays sortieren k\u00f6nnen. Das Grundprinzip hier ist, in jedem Durchgang das Minimum des unsortierten Teils des Arrays zu suchen und dieses an den Anfang des unsortierten Teils zu bewegen. Der Grundalgorithmus des Selection-Sort ist dadurch nicht sehr kompliziert. Die Optimierung von Selection-Sort, n\u00e4mlich nicht nur das Minimum, sondern auch das Maximum in einem Durchlauf zu bestimmen, ist jedoch aufgrund des recht komplizierten \"Vertauschens\" der Werte bereits sehr schwer zu verstehen. Aber, wie gesagt, es gen\u00fcgt ja auch, wenn Sie Bubble-Sort vollst\u00e4ndig verstanden haben. Insertion-Sort \u00b6 Dieser Sortier-Algorithmus (auch h\u00e4ufig Insert-Sort genannt) basiert auf einer Idee, die immer mit der Aufnahme eines Kartenspiels verglichen wird. Man nimmt eine Karte auf, steckt sie an die richtige Position, nimmt die n\u00e4chste Karte auf, steckt sie wieder an die richtige Position usw. Wir betrachten zun\u00e4chst erneut unser Beispiel: 55 07 78 12 42 wir beginnen mit dem Index 1 (nicht mit 0 - die erste \"Karte\", die 55 haben wir bereits \"auf der Hand\") die 7 ist kleiner als die 55 , deshalb \"stecken\" wir die 7 vor die 55 : 07 55 78 12 42 jetzt sind die ersten beiden Elemente sortiert wir setzen mit dem Index 2 fort die 78 ist gr\u00f6\u00dfer als die 7 und gr\u00f6\u00dfer als die 55 , deshalb lassen wir die 78 dort, wo sie ist 07 55 78 12 42 jetzt sind die ersten drei Elemente sortiert wir setzen mit dem Index 3 fort die 12 ist gr\u00f6\u00dfer als die 7 , aber kleiner als die 55 , deshalb \"stecken\" wir die 12 zwischen die 7 und die 55 die bereits sortierten Werte 55 und 78 \"rutschen\" um eins nach rechts 07 12 55 78 42 jetzt sind die ersten vier Elemente sortiert wir setzen mit dem Index 4 fort die 42 ist gr\u00f6\u00dfer als die 7 und gr\u00f6\u00dfer als die 12 , aber kleiner als die 55 , deshalb \"stecken\" wir die 42 zwischen die 12 und die 55 die bereits sortierten Werte 55 und 78 \"rutschen\" um eins nach rechts die bereits sortierten Werte 55 und 78 \"rutschen\" um eins nach rechts 07 12 42 55 78 Index 5 gibt es nicht, wir sind am Ende des Arrays angelangt das Array ist sortiert Hier noch ein Bild, das den Insertion-Sort-Algorithmus an einem anderen Beispiel verdeutlicht: Wir n\u00e4hern uns wieder der algorithmischen Idee von Insertion-Sort an. Wir wollen eine Methode insertionsort() schreiben, f\u00fcr die folgendes gilt: Parameter : unsortiertes Array a R\u00fcckgabe : sortiertes Array b Vorgehen : gedachte Teilung des Arrays in 2 Teile: linker Teil: sortiert rechter Teil: unsortiert \u2794 anfangs: linker Teil = b[0] - d.h. nur erstes Element sortiert erstes unsortiertes Element b[i] f\u00fcr i > 0 , betrachten durch Vergleichen und Verschieben an der richtigen Stelle in das sortierte Array b[0] ,\u2026, b[i-1] einf\u00fcgen \u2794 rechter unsortierter Teil des Arrays b[i+1] ,\u2026, b[n-1] wird um ein Element kleiner ( n ist L\u00e4nge des Arrays), \u2794 linker sortierter Teil w\u00e4chst um ein Element b[j] so verfahren, bis linker Teil das gesamte Array ist und der \"rechte\" Teil leer Eine m\u00f6gliche Implementierung von Insertion-Sort: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public static int [] insertionsort ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int index = 1 ; index < b . length ; index ++ ) // das Element von index soll an die richtige { // Position <= index eingefuegt werden int indexLinks = 0 ; while ( indexLinks < index && b [ indexLinks ] < b [ index ] ) { indexLinks ++ ; } /* * jetzt muss der Wert von b[index] an die Stelle von indexLinks eingefuegt werden * dazu muessen alle Elemente von indexLinks bis index-1 um eins nach rechts geschoben * werden * wir merken uns dazu b[index] und schieben dann alle Elemente: * b[index-1] nach b[index] * b[index-2] nach b[index-1] * ... * b[indexLinks] nach b[indexLinks+1] */ int tmp = b [ index ] ; for ( int indexInsert = index ; indexInsert > indexLinks ; indexInsert -- ) { b [ indexInsert ] = b [ indexInsert - 1 ] ; } b [ indexLinks ] = tmp ; } return b ; } die \u00e4u\u00dfere for -Schleife (Zeile 5 ) legt den aktuellen index f\u00fcr das Element fest, das wir betrachten und korrekt links daneben einf\u00fcgen wollen die while -Schleife (Zeilen 8-11 ) sucht im linken Teil (links von index ) nach dem ersten Element, das einen gr\u00f6\u00dferen Wert hat, als der aktuell einzuf\u00fcgende Wert b[index] . ist die while -Schleife verlassen (nach Zeile 11 ), gibt der Wert in indexLinks die Position an, an die der einzuf\u00fcgende Wert eingef\u00fcgt werden soll \u2794 dann m\u00fcssen wir alle Elemente von indexLinks , indexLinks+1 , indexLinks+2 , ... , index-2 , index-1 um eins nach rechts verschieben. Dazu schauen wir uns zun\u00e4chst die folgenden Abbildungen an: Angenommen, wir haben das Array aus der Abbildung. Die Elemente 3 , 6 , 7 , 8 sind bereits sortiert. Der aktuelle index ist 4 und wir haben ermittelt, dass indexLinks==1 ist, dass wir also die 4 an die zweite Poition im Array einf\u00fcgen wollen. Dazu muss die 9 auf den index==4 geschoben werden, die 7 auf den Index 3 und die 6 auf den Index 2 . Damit wir den Wert 4 nicht \u00fcberschreiben, m\u00fcssen wir ihn in einer Variablen zwischenspeichern. Jetzt k\u00f6nnen wir die Werte nach rechts verschieben. Angenommen, wir erstellen uns einen indexInsert (siehe Zeile 23 oben), der initial den Wert index (also 4 ) hat. Dann schieben wir den Wert 9 mithilfe von b[indexInsert] = b[indexInsert-1]; vom Index 3 nach Index 4 . Wenn wir dann indexInsert um 1 reduzieren (Zeile 23 oben), dann wird durch das n\u00e4chste b[indexInsert] = b[indexInsert-1]; der Wert 7 vom Index 2 nach Index 3 geschoben. Zuletzt noch die 6 von Index 2 nach Index 3 . Dann haben wir indexLinks erreicht. Jetzt muss nur noch der zwischengespeicherte Wert aus tmp nach b[indexLinks] geschrieben werden (Zeile 27 oben) und der Wert 4 wurde korrekt eingef\u00fcgt und es kann mit dem Index 5 weitergehen. Wir f\u00fcgen zum besseren Verst\u00e4ndnis des Algorithmus wieder Ausgaben in unsere Methode ein. Die erste Zeile enth\u00e4lt das Ausgangsarray: --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 1 , aktueller Wert = 45 , wird eingef\u00fcgt an Index = 1 --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 2 , aktueller Wert = 31 , wird eingef\u00fcgt an Index = 1 --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 3 , aktueller Wert = 40 , wird eingef\u00fcgt an Index = 2 --> [ 30 , 31 , 45 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 4 , aktueller Wert = 35 , wird eingef\u00fcgt an Index = 2 --> [ 30 , 31 , 40 , 45 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 5 , aktueller Wert = 33 , wird eingef\u00fcgt an Index = 2 --> [ 30 , 31 , 35 , 40 , 45 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 6 , aktueller Wert = 0 , wird eingef\u00fcgt an Index = 0 --> [ 30 , 31 , 33 , 35 , 40 , 45 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 7 , aktueller Wert = 25 , wird eingef\u00fcgt an Index = 1 --> [ 0 , 30 , 31 , 33 , 35 , 40 , 45 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 8 , aktueller Wert = 25 , wird eingef\u00fcgt an Index = 1 --> [ 0 , 25 , 30 , 31 , 33 , 35 , 40 , 45 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 9 , aktueller Wert = 30 , wird eingef\u00fcgt an Index = 3 --> [ 0 , 25 , 25 , 30 , 31 , 33 , 35 , 40 , 45 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 10 , aktueller Wert = 39 , wird eingef\u00fcgt an Index = 8 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 40 , 45 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 11 , aktueller Wert = 41 , wird eingef\u00fcgt an Index = 10 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 45 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 12 , aktueller Wert = 1 , wird eingef\u00fcgt an Index = 1 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 13 , aktueller Wert = 18 , wird eingef\u00fcgt an Index = 2 --> [ 0 , 1 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 14 , aktueller Wert = 6 , wird eingef\u00fcgt an Index = 2 --> [ 0 , 1 , 18 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 15 , aktueller Wert = 24 , wird eingef\u00fcgt an Index = 4 --> [ 0 , 1 , 6 , 18 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 16 , aktueller Wert = 33 , wird eingef\u00fcgt an Index = 10 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 17 , aktueller Wert = 30 , wird eingef\u00fcgt an Index = 7 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 30 , 27 , 36 , 30 ] Aktueller Index = 18 , aktueller Wert = 27 , wird eingef\u00fcgt an Index = 7 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 27 , 36 , 30 ] Aktueller Index = 19 , aktueller Wert = 36 , wird eingef\u00fcgt an Index = 15 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 27 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 36 , 30 ] Aktueller Index = 20 , aktueller Wert = 30 , wird eingef\u00fcgt an Index = 8 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 27 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 36 , 39 , 40 , 41 , 45 , 30 ] Hier noch einmal nur das Array. Man sieht, dass sich, im Gegensatz zu den vorherigen Algorithmen, kein fertig sortierter Teil ausbreitet, da die Elemente auch am Ende noch ganz nach vorne eingef\u00fcgt werden k\u00f6nnen. --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 1 --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 2 --> [ 30 , 31 , 45 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 3 --> [ 30 , 31 , 40 , 45 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 4 --> [ 30 , 31 , 35 , 40 , 45 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 5 --> [ 30 , 31 , 33 , 35 , 40 , 45 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 6 --> [ 0 , 30 , 31 , 33 , 35 , 40 , 45 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 7 --> [ 0 , 25 , 30 , 31 , 33 , 35 , 40 , 45 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 8 --> [ 0 , 25 , 25 , 30 , 31 , 33 , 35 , 40 , 45 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 9 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 40 , 45 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 10 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 45 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 11 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 12 --> [ 0 , 1 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 13 --> [ 0 , 1 , 18 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 14 --> [ 0 , 1 , 6 , 18 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 15 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 33 , 30 , 27 , 36 , 30 ] // Index 16 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 30 , 27 , 36 , 30 ] // Index 17 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 27 , 36 , 30 ] // Index 18 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 27 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 36 , 30 ] // Index 19 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 27 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 36 , 39 , 40 , 41 , 45 , 30 ] // Index 20 Auch f\u00fcr den Insertion-Sort-Algorithmus gibt es Optimierungsvorschl\u00e4ge, von denen wir hier aber keine betrachten wollen. Wir werden uns noch einen letzten Sortier-Algorithmus anschauen, der allerdings ein wenig komplizierter auf den ersten Blick aussieht, der Merge-Sort-Algorithmus. Merge-Sort \u00b6 In Merge-Sort kommt ein v\u00f6llig neues Konzept hinzu, das wir noch gar nicht kennen. Es handelt sich um Rekursion . In der Programmierung spricht man von Rekursion , wenn sich eine Methode selbst wieder aufruft. Rekursion \u00b6 Ruft sich eine Methode selbst wieder auf, sprechen wir von Rekursion (latein recurrere \u201ezur\u00fccklaufen\u201c). Das Prinzip kennen wir schon aus der Mathematik - das klassische Beispiel ist die Definition der Fakult\u00e4t: Diese Funktion ist rekursiv definiert, d.h. in der Definition f\u00fcr Fakult\u00e4t wird selbst wieder die Fakult\u00e4t verwendet ( n! = n * (n-1)! ). Beachten Sie, dass es eine Abbruchbedingung f\u00fcr die Rekursion gibt, n\u00e4mlich hier 1! = 1 , d.h. es gibt einen (oder mehrere) Wert(e) ( n <= 1 ), f\u00fcr den kein rekursicher Aufruf (keine rekursive Defintion) verwendet wird. Als Implementierung sieht diese Funktion so aus: 1 2 3 4 5 6 7 8 9 public static int fakultaet ( int n ) { int fak = 1 ; if ( n > 1 ) { fak = n * fakultaet ( n - 1 ); } return fak ; } F\u00fcr n>1 wird also erneut die Methode aufgerufen, wobei der Parameterwert um 1 rediziert wird und sich somit der Abbruchbedingung (dem Rekursionsende) ann\u00e4hert. Wir betrachten einmal den Methodenstack bei der Ausf\u00fchrung der Methode f\u00fcr den Aufruf von fakultaet(5) : Beginnend, mit fakultatet(5) (links oben) wird im Ausdruck 5 * fakulatet(4) die Methode fakultatet(4) aufgerufen. Darin gibt es den Ausdruck 4 * fakulatet(3) , so dass dort fakultaet(3) aufgerufen wird usw. bis zum Aufruf von fakulaet(1) . Dieser Aufruf gibt 1 zur\u00fcck. Damit wird die Ausf\u00fchrung der Methode fakultaet(1) beendet und wir landen im Stack zur\u00fcck beim Aufruf von fakultaet(2) . Darin wird nun 2 * 1 zur\u00fcckgegeben, also 2 und wir landen im Stack zur\u00fcck beim Aufruf von fakultaet(3) . Darin wird nun 3 * 2 zur\u00fcckgegeben, also 6 usw. bis der Aufruf von fakultaet(5) die 5 * 24 , also 120 zur\u00fcckgibt. Das ist der Wert, dem der Aufruf von fakultaet(5) entspricht. Mit Rekursion kann nicht mehr berechnet werden als mit Iteration, d.h. die Rekursion ist kein m\u00e4chtigeres Konzept als die Iteration. Alles, was mit Iteration geht, geht auch mit Rekursion und umgedreht. Manchmal sind die Algorithmen aber als Rekursion leichter zu implementieren als ohne. Beispiele daf\u00fcr sind gebeOrdnerstrukturAus(ordnerOderDatei) wenn Datei , dann Ende wenn Ordner , dann alle Unterordner ermitteln und f\u00fcr alle Unterordner: gebeOrdnerstrukturAus(unterOrdner) gebeBaumAus(knoten) wenn Blatt , dann Ende sonst: ermittle linkes und rechtes Kind des Knotens und rufe auf: gebeBaumAus(linkesKind) gebeBaumAus(rechtesKind) Merge-Sort rekursiv \u00b6 Der Merge-Sort-Algorithmus geh\u00f6rt zu den Algorithmen, die rekursiv besser zu implementieren sind, als iterativ. Das liegt daran, dass Merge-Sort auf dem sogenannten Divide-and-Conquer -Prinzip basiert. Dieses Prinzip ist eine rekursive Programmiertechnik, in dem ein gro\u00dfes Problem in gleichartige, aber einfachere Teilprobleme zerlegt wird. Das Grundprinzip bei Divide-and-Conquer ist wie folgt: Bestimme ein Ma\u00df f\u00fcr die Gr\u00f6\u00dfe des Problems (z.B. Gr\u00f6\u00dfe des Arrays) Finde eine kleinere Gr\u00f6\u00dfe, f\u00fcr das Problem einfach zu l\u00f6sen ist (z.B. kleinere Arrays) L\u00f6se die kleineren Probleme und f\u00fcge die L\u00f6sungen so zusammen, dass sich die L\u00f6sung des gro\u00dfen Problems ergibt Bei Merge-Sort sieht das so aus: teile den Datensatz (meistens einfach halbieren) sortiere beide Datens\u00e4tze f\u00fcge sie zusammen (einsortieren der Gr\u00f6\u00dfe nach) das Teilen erfolgt dabei so lange, bis der kleine Datensatz meistens nur noch aus einem einzigen Datum besteht Wir betrachten ein konkretes Beispiel. Angenommen, wir wollen das Array { 2, 4, 1, 6, 8, 5, 3, 7 } mithilfe von Merge-Sort sortieren: Dann zerlegen wir das Ausgangsarray zun\u00e4chst so lange, bis die einzelnen Arrays nur noch jeweils ein Element enthalten: Das Teilen ist also einfach, wir ermitteln einfach immer die Mitte ( mid ) des Ausgangsarrays ( a ) und zwerlegen das Ausgangsarray dann in einen linken und in einen rechten Teil: public int [] mergesort ( int [] a ) { int [] b = copy ( a ); if ( b . length > 1 ) { int mid = b . length / 2 ; /* * linken Teil von b in neues Array left kopieren */ int [] left = new int [ mid ] ; for ( int index = 0 ; index < mid ; index ++ ) { left [ index ] = b [ index ] ; } /* * rechten Teil von b in neues Array rechts kopieren */ int [] right = new int [ b . length - mid ] ; for ( int index = mid ; index < b . length ; index ++ ) { right [ index - mid ] = b [ index ] ; } /* * jetzt haben wir zwei Arrays: left und right * diese sollen jetzt mithilfe von mergesort() * sortiert werden * dazu rufen wir mergesort f\u00fcr Array left * und mergesort f\u00fcr Array right * auf. Wir bekommen sie sortiert zur\u00fcck. * * Die Methode ruft sich selber wieder auf --> * das nennen wir Rekursion * */ left = mergesort ( left ); // hier der rekursive Aufruf fuer left right = mergesort ( right ); // hier der rekursive Aufruf fuer right /* * jetzt sind left und right jeweils sortiert * jetzt \"mergen\" wir sie so, dass insgesamt * ein sortiertes Array entsteht, d.h. wir * nehmen immer ein Element aus left und right und * vergleichen sie miteinander; das kleinere kommt * nach b, das gr\u00f6\u00dfere bleibt noch und wir * nehmen aus dem Array, aus dem gerade das Element * einsortiert wurde, ein neues Element */ /* kommt gleich - siehe unten */ Das Zusammenf\u00fcgen ( merge ) ist bei Merge-Sort komplizierter - deshalb Merge-Sort . Aus dem linken und aus dem rechten Array werden jetzt jeweils die ersten Elemente betrachtet und miteinander verglichen. Das kleinere von beiden kommt in das \"zusammengesetzte\" ( merged ) Array, das so nach und nach sortiert w\u00e4chst. /* * jetzt sind left und right jeweils sortiert * jetzt \"mergen\" wir sie so, dass insgesamt * ein sortiertes Array entsteht, d.h. wir * nehmen immer ein Element aus left und right und * vergleichen sie miteinander; das kleinere kommt * nach b, das gr\u00f6\u00dfere bleibt noch und wir * nehmen aus dem Array, aus dem gerade das Element * einsortiert wurde, ein neues Element */ int indexLeft = 0 ; int indexRight = 0 ; int indexB = 0 ; /* * merge von left und right * solange noch in einem Elemente sind */ while ( indexLeft < left . length && indexRight < right . length ) { if ( left [ indexLeft ] < right [ indexRight ] ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; } else { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; } indexB ++ ; } /* * jetzt ist left oder right leer, aber in dem * jeweils anderen sind noch Elemente */ /* * falls noch in left Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexLeft < left . length ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; indexB ++ ; } /* * falls noch in right Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexRight < right . length ) { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; indexB ++ ; } } return b ; } Insgesamt sieht die Implementierung von Merge-Sort also so aus: mergesort(int[] a) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 public static int [] mergesort ( int [] a ) { int [] b = copy ( a ); if ( b . length > 1 ) { int mid = b . length / 2 ; /* * linken Teil von b in neues Array left kopieren */ int [] left = new int [ mid ] ; for ( int index = 0 ; index < mid ; index ++ ) { left [ index ] = b [ index ] ; } /* * rechten Teil von b in neues Array rechts kopieren */ int [] right = new int [ b . length - mid ] ; for ( int index = mid ; index < b . length ; index ++ ) { right [ index - mid ] = b [ index ] ; } /* * jetzt haben wir zwei Arrays: left und right * diese sollen jetzt mithilfe von mergesort() * sortiert werden * dazu rufen wir mergesort f\u00fcr Array left * und mergesort f\u00fcr Array right * auf. Wir bekommen sie sortiert zur\u00fcck. * * Die Methode ruft sich selber wieder auf --> * das nennen wir Rekursion * */ left = mergesort ( left ); right = mergesort ( right ); /* * jetzt sind left und right jeweils sortiert * jetzt \"mergen\" wir sie so, dass insgesamt * ein sortiertes Array entsteht, d.h. wir * nehmen immer ein Element aus left und right und * vergleichen sie miteinander; das kleinere kommt * nach b, das gr\u00f6\u00dfere bleibt noch und wir * nehmen aus dem Array, aus dem gerade das Element * einsortiert wurde, ein neues Element */ int indexLeft = 0 ; int indexRight = 0 ; int indexB = 0 ; /* * merge von left und right * solange noch in einem Elemente sind */ while ( indexLeft < left . length && indexRight < right . length ) { if ( left [ indexLeft ] < right [ indexRight ] ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; } else { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; } indexB ++ ; } /* * jetzt ist left oder right leer, aber in dem * jeweils anderen sind noch Elemente */ /* * falls noch in left Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexLeft < left . length ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; indexB ++ ; } /* * falls noch in right Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexRight < right . length ) { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; indexB ++ ; } } return b ; } Sortieren.java package themen.arrays.sortieren ; import java.util.Random ; public class Sortieren { /* * aus Skript */ public static void printArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } System . out . println ( s ); } /* * angepasste printArray-Methode * hier wird davon ausgegangen, dass die Zahlen * in dem Array nie gr\u00f6\u00dfer als zweistellig sind * ist haupts\u00e4chlich, damit die Ausgaben der Arrays besser * miteinander verglichen werden k\u00f6nnen auf der Konsole * */ public static void print ( int [] a ) { String s = \"--> [ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + String . format ( \"%2d, \" , a [ index ] ); } if ( a . length > 0 ) { s = s + String . format ( \"%2d ]\" , a [ a . length - 1 ] ); } System . out . println ( s ); } /* * aus Skript */ public static int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } public static int [] copy ( int [] a ) { int [] b = new int [ a . length ] ; for ( int index = 0 ; index < b . length ; index ++ ) { b [ index ] = a [ index ] ; } return b ; } public static int [] bubblesortDebug ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = copy ( a ); System . out . print ( \"ori-\" ); print ( b ); // Ausgangs-Array System . out . println (); /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { System . out . printf ( \"%3d. Bubble-Phase : %n----\" , bubble ); print ( b ); swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; System . out . printf ( \"%3d \" , index ); print ( b ); } } System . out . println (); } return b ; } public static int [] bubblesort ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = copy ( a ); /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; } } } return b ; } public static int [] selectionsortDebug ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck System . out . print ( \" original -----\" ); print ( b ); // Ausgangs-Array System . out . println (); for ( int durchlauf = 0 ; durchlauf < b . length ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { System . out . printf ( \"%3d. Durchlauf - kleinstes Element soll auf den index %2d %n----> \" , durchlauf + 1 , durchlauf ); int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes for ( int index = durchlauf ; index < b . length ; index ++ ) // Suche nach dem kleinsten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } } System . out . printf ( \"kleinster Wert ist %3d auf dem Index %3d %n\" , minValue , minIndex ); System . out . printf ( \"%13s : \" , \"vor Tausch \" ); print ( b ); // jetzt den kleinsten Wert auf den Index durchlauf legen // der Wert, der auf durchlauf lag, kommt nach minIndex int tmp = b [ durchlauf ] ; b [ durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmp ; System . out . printf ( \"%13s : \" , \"nach Tausch \" ); print ( b ); System . out . println (); } return b ; } public static int [] selectionsort ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int durchlauf = 0 ; durchlauf < b . length ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes for ( int index = durchlauf ; index < b . length ; index ++ ) // Suche nach dem kleinsten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } } // jetzt den kleinsten Wert auf den Index durchlauf legen // der Wert, der auf durchlauf lag, kommt nach minIndex int tmp = b [ durchlauf ] ; b [ durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmp ; } return b ; } public static int [] insertionsort ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int index = 1 ; index < b . length ; index ++ ) // das Element von index soll an die richtige { // Position <= index eingefuegt werden int indexLinks = 0 ; while ( indexLinks < index && b [ indexLinks ] < b [ index ] ) { indexLinks ++ ; } /* * jetzt muss der Wert von b[index] an die Stelle von indexLinks eingefuegt werden * dazu muessen alle Elemente von indexLinks bis index-1 um eins nach rechts geschoben * werden * wir merken uns dazu b[index] und schieben dann alle Elemente: * b[index-1] nach b[index] * b[index-2] nach b[index-1] * ... * b[indexLinks] nach b[indexLinks+1] */ int tmp = b [ index ] ; for ( int indexInsert = index ; indexInsert > indexLinks ; indexInsert -- ) { b [ indexInsert ] = b [ indexInsert - 1 ] ; } b [ indexLinks ] = tmp ; } return b ; } public static int [] insertionsortDebug ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck print ( b ); // Ausgangs-Array System . out . println (); for ( int index = 1 ; index < b . length ; index ++ ) // das Element von index soll an die richtige { // Position <= index eingefuegt werden int indexLinks = 0 ; while ( indexLinks < index && b [ indexLinks ] < b [ index ] ) { indexLinks ++ ; } System . out . printf ( \"Aktueller Index=%3d, aktueller Wert=%3d, wird eingef\u00fcgt an Index=%3d%n\" , index , b [ index ] , indexLinks ); print ( b ); System . out . println (); /* * jetzt muss der Wert von b[index] an die Stelle von indexLinks eingefuegt werden * dazu muessen alle Elemente von indexLinks bis index-1 um eins nach rechts geschoben * werden * wir merken uns dazu b[index] und schieben dann alle Elemente: * b[index-1] nach b[index] * b[index-2] nach b[index-1] * ... * b[indexLinks] nach b[indexLinks+1] */ int tmp = b [ index ] ; for ( int indexInsert = index ; indexInsert > indexLinks ; indexInsert -- ) { b [ indexInsert ] = b [ indexInsert - 1 ] ; } b [ indexLinks ] = tmp ; } return b ; } public static int [] selectionsortOptimiert ( int [] a ) { int [] b = new int [ 0 ] ; if ( a . length > 1 ) { b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck System . out . print ( \" \" ); print ( b ); // Ausgangs-Array for ( int durchlauf = 0 ; durchlauf < b . length / 2 ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes int maxValue = b [ b . length - 1 - durchlauf ] ; // in maxValue merken wir uns den aktuell groessten Wert int maxIndex = b . length - 1 - durchlauf ; // in maxIndex merken wir uns den Index des aktuell groessten Wertes System . out . printf ( \"%3d %3d %3d %3d %3d %n\" , durchlauf , minValue , minIndex , maxValue , maxIndex ); for ( int index = durchlauf ; index < b . length - durchlauf ; index ++ ) // Suche nach dem kleinsten UND groessten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } if ( maxValue < b [ index ] ) { maxValue = b [ index ] ; // aktuell groesster Wert maxIndex = index ; // aktueller Index des groessten Wertes } } /* * jetzt den kleinsten Wert auf den Index durchlauf legen * der Wert, der auf durchlauf lag, kommt nach minIndex * UND den groessten Wert auf den Index b.length-1-durchlauf legen * der Wert, der auf b.length-1-durchlauf lag, kommt nach maxIndex * wir m\u00fcssen zun\u00e4chst aber beide Werte sichern, sonst kann es zu * Konflikten beim Tauschen kommen! * */ System . out . printf ( \"%3d %3d %3d %3d %3d \" , durchlauf , minValue , minIndex , maxValue , maxIndex ); int tmpMin = b [ durchlauf ] ; int tmpMax = b [ b . length - 1 - durchlauf ] ; b [ durchlauf ] = minValue ; b [ minIndex ] = tmpMin ; /* * hier wird es sehr kompliziert * wenn der MaximumWert dort war, wo das neue Minimum hin kommt (Index durchlauf), * dann m\u00fcssen wir aufpassen, dass wir den alten Wert tmpMax nicht verlieren * es sind jetzt nur noch 3 Werte im Spiel * der alte Wert von durchlauf - ist in tmpMin UND ist gleichzeitig maxValue! * der alte Wert von length-1-durchlauf - ist in tmpMax * der alte Wert von minIndex ist minValue und jetzt auf durchlauf * Versuchen Sie es mal ohne die Bedingung und nur * b[b.length-1-durchlauf] = maxValue; * b[maxIndex] = tmpMax; * dann sehen Sie den Fehler */ if ( maxIndex == durchlauf ) { b [ b . length - 1 - durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmpMax ; } else { b [ b . length - 1 - durchlauf ] = maxValue ; b [ maxIndex ] = tmpMax ; } print ( b ); } } return b ; } public static int [] mergesort ( int [] a ) { int [] b = copy ( a ); if ( b . length > 1 ) { int mid = b . length / 2 ; /* * linken Teil von b in neues Array left kopieren */ int [] left = new int [ mid ] ; for ( int index = 0 ; index < mid ; index ++ ) { left [ index ] = b [ index ] ; } /* * rechten Teil von b in neues Array rechts kopieren */ int [] right = new int [ b . length - mid ] ; for ( int index = mid ; index < b . length ; index ++ ) { right [ index - mid ] = b [ index ] ; } /* * jetzt haben wir zwei Arrays: left und right * diese sollen jetzt mithilfe von mergesort() * sortiert werden * dazu rufen wir mergesort f\u00fcr Array left * und mergesort f\u00fcr Array right * auf. Wir bekommen sie sortiert zur\u00fcck. * * Die Methode ruft sich selber wieder auf --> * das nennen wir Rekursion * */ left = mergesort ( left ); right = mergesort ( right ); /* * jetzt sind left und right jeweils sortiert * jetzt \"mergen\" wir sie so, dass insgesamt * ein sortiertes Array entsteht, d.h. wir * nehmen immer ein Element aus left und right und * vergleichen sie miteinander; das kleinere kommt * nach b, das gr\u00f6\u00dfere bleibt noch und wir * nehmen aus dem Array, aus dem gerade das Element * einsortiert wurde, ein neues Element */ int indexLeft = 0 ; int indexRight = 0 ; int indexB = 0 ; /* * merge von left und right * solange noch in einem Elemente sind */ while ( indexLeft < left . length && indexRight < right . length ) { if ( left [ indexLeft ] < right [ indexRight ] ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; } else { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; } indexB ++ ; } /* * jetzt ist left oder right leer, aber in dem * jeweils anderen sind noch Elemente */ /* * falls noch in left Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexLeft < left . length ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; indexB ++ ; } /* * falls noch in right Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexRight < right . length ) { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; indexB ++ ; } } return b ; } public static int fakultaet ( int n ) { int fak = 1 ; if ( n > 1 ) { fak = n * fakultaet ( n - 1 ); } return fak ; } public static void main ( String [] args ) { int [] unsorted = createAndFillArray ( 21 , 50 ); System . out . printf ( \"%n%n--------------- bubblesort ----------------------%n%n\" ); int [] sorted = bubblesort ( unsorted ); printArray ( unsorted ); printArray ( sorted ); System . out . printf ( \"%n%n--------------- selectionsort ----------------------%n%n\" ); int [] us = { 1 , 12 , 41 , 35 , 49 , 2 , 28 , 38 , 21 , 35 , 41 , 12 , 21 , 29 , 27 , 17 , 5 , 6 , 18 , 3 }; sorted = selectionsortOptimiert ( unsorted ); printArray ( unsorted ); printArray ( sorted ); System . out . printf ( \"%n%n--------------- insertionsort ----------------------%n%n\" ); sorted = insertionsortDebug ( unsorted ); printArray ( unsorted ); printArray ( sorted ); System . out . printf ( \"%n%n--------------- mergesort ----------------------%n%n\" ); sorted = mergesort ( unsorted ); printArray ( unsorted ); printArray ( sorted ); System . out . println ( fakultaet ( 5 )); } } Quicksort \u00b6 Ein Sortier-Algorithmus, der ebenfalls auf dem Divide-and-Conquer -Prinzip berucht, ist Quicksort . Bei Quicksort ist, im Gegensatz zu Merge-Sort, das Teilen kompliziert und das Zusammenf\u00fcgen einfach. Die Methode sort() der Klasse Arrays verwendet Quicksort. Wir gehen hier aber aus Zeitgr\u00fcnden nicht weiter auf den Algroithmus ein. Sie k\u00f6nnen sich aber gerne dar\u00fcber selbst\u00e4ndig informieren. Es gibt viele Implementierungen und Erl\u00e4uterungen davon im Netz, z.B. hier , hier und hier .","title":"Sortieren"},{"location":"sortieren/#sortieren-von-arrays","text":"Es ist h\u00e4ufig notwendig, die Elemente von bestimmten Datenstrukturen (Arrays, Listen, B\u00e4ume, \u2026 - bis jetzt kennen wir davon nur Arrays) zu sortieren. Dazu muss es eine Ordnung \u00fcber die Elemente geben (z.B. numerische Ordnungen von Zahlen, lexikografische Ordnungen von Zeichenketten, \u2026). Man unterscheidet zwischen Sortierverfahren, die mit dem gegebenen Speicherplatz der Datenstruktur auskommen und denen, die zus\u00e4tzlichen Platz zum zwischenzeitlichen Auslagern von Elementen ben\u00f6tigen. Prinzipiell ist der paarweise Vergleich aller Elemente notwendig. Es gibt verschiedene Sortierverfahren, die unterschiedliche Aufw\u00e4nde f\u00fcr den besten Fall, den schlechtesten Fall und im Durchschnitt aufweisen. Wir werden im Folgenden verschiedene Sortierverfahren betrachten. Sie m\u00fcssen aber nur eins selbst\u00e4ndig umsetzen k\u00f6nnen! Ich nehme an, das wird f\u00fcr die allermeisten Bubble-Sort sein. Hint In diesem Abschnitt werden h\u00e4ufig Methoden gezeigt, die als static deklariert sind. Das Schl\u00fcsselwort static besagt, dass wir diese Methode verwenden (aufrufen) k\u00f6nnen, ohne eine Objekt der Klasse erzeugen zu m\u00fcssen, in der diese Methoden deklariert sind. Es handelt sich um statische Methoden oder besser um Klassenmethoden (im Gegensatz zu Objektmethoden , welche nur f\u00fcr ein Objekt aufgerufen werden k\u00f6nnen). Die bekannteste statische Methode ist die main -Methode. Aber auch aus anderen Klassen kennen wir bereits statische Methoden, z.B. Math.sqrt() . Wir k\u00f6nnen die sqrt() -Methode der Klasse Math aufrufen, ohne ein Objekt der Klasse Math zu erzeugen, einfach Klassenname.klassenMethode() .","title":"Sortieren von Arrays"},{"location":"sortieren/#bubble-sort","text":"Bei Bubble-Sort wird das gr\u00f6\u00dfte Element immer nach rechts \"gebubbled\". Das Prinzip bei Bubble-Sort ist wie folgt: die Datenstruktur (hier: Array) wird von links nach rechts durchlaufen \u201eBubble-Phase\u201c es wird stets das aktuelle Element mit den rechten Nachbarn verglichen ist die Ordnung falsch, werden die Elemente getauscht am Ende einer Bubble-Phase befindet sich das gr\u00f6\u00dfte Element ganz rechts Wiederholung der Bubble-Phase Bubble-Phase wird wiederholt, d.h. es wird wieder vorne im Array angefangen und jedes Element mit seinem rechten Nachbarn verglichen da das ganz rechte Element bereits das gr\u00f6\u00dfte ist, muss es nicht mehr verglichen werden mit jeder Bubble-Phase muss also ein Vergleich weniger durchgef\u00fchrt werden und das jeweils gr\u00f6\u00dfte rutscht nach rechts die Bubble-Phasen werden so oft wiederholt, bis das Array komplett sortiert ist (L\u00e4nge des Arrays-1 Bubble-Phasen) Wir betrachten ein Beispiel. Folgendes Array soll sortiert werden: 55 07 78 12 42 Wir starten von links nach rechts und vergleichen die Elemente paarweise: 1 . Bubble-Phase 55 07 78 12 42 --> 55 und 07 vergleichen --> es muss getauscht werden 07 55 78 12 42 --> 55 und 78 vergleichen --> es muss nicht getauscht werden 07 55 78 12 42 --> 78 und 12 vergleichen --> es muss getauscht werden 07 55 12 78 42 --> 78 und 42 vergleichen --> es muss getauscht werden 07 55 12 42 78 --> 1 . Bubble-Phase beendet --> die gr\u00f6\u00dfte Zahl 78 steht ganz rechts Nach der ersten Bubble-Phase steht die gr\u00f6\u00dfte Zahl aus dem Array ganz rechts. Diese muss nun nicht mehr mitverglichen werden. Bei der 2. Buble-Phase haben wir also einen Vergleich weniger, als bei der ersten. 2 . Bubble-Phase 07 55 12 42 78 --> 07 und 55 vergleichen --> es muss nicht getauscht werden 07 55 12 42 78 --> 55 und 12 vergleichen --> es muss getauscht werden 07 12 55 42 78 --> 55 und 42 vergleichen --> es muss getauscht werden 07 12 42 55 78 --> 2 . Bubble-Phase beendet --> die zweitgr\u00f6\u00dfte Zahl 55 steht an zweitletzter Stelle Mit dem letzten Wert muss also in der 2. Bubble-Phase nicht mehr verglichen werden, da im Ergebnis der ersten Bubble-Phase ja der gr\u00f6\u00dfte Wert nach gaz rechts geschoben wurde. In der dritten Bubble-Phase muss dann auch nicht mehr mit dem vorletzten Wert verglichen werden usw. 3 . Bubble-Phase 07 12 42 55 78 --> 07 und 12 vergleichen --> es muss nicht getauscht werden 07 12 42 55 78 --> 12 und 42 vergleichen --> es muss nicht getauscht werden 07 12 42 55 78 --> 3 . Bubble-Phase beendet --> die drittgr\u00f6\u00dfte Zahl 42 steht an drittletzter Stelle Wie wir sehen, ist dieses Array sogar schon nach der 3. Buble-Phase sortiert. Wir werden uns sp\u00e4ter auch \u00fcberlegen, wie wir solche F\u00e4lle ausnutzen k\u00f6nnen, um nicht zwingend alle Bubble-Phasen durchlaufen zu m\u00fcssen, wenn das Array bereits vorzeitig sortiert ist. F\u00fcr ein Array der L\u00e4nge 5 , so wie hier, brauchen wir aber h\u00e4ufig noch die letzte Bubble-Phase 4 : 4 . Bubble-Phase 07 12 42 55 78 --> 07 und 12 vergleichen --> es muss nicht getauscht werden 07 12 42 55 78 --> 4 . Bubble-Phase beendet --> ein Array der L\u00e4nge 5 ist nach sp\u00e4testens 4 Bubble-Phasen sortiert F\u00fcr ein Array der L\u00e4nge n braucht es n-1 Bubble-Phasen. Die erste Bubble-Phase besteht aus n-1 Vergleichen, die 2. Bubble-Phase besteht aus n-2 Vergleichen usw. Wir wollen uns der algorithmischen Idee von Bubble-Sort ann\u00e4hern. Wir wollen eine Methode bubblesort() schreiben, f\u00fcr die folgendes gilt: Parameter : unsortiertes Array a R\u00fcckgabe : sortiertes Array b Vorgehen : zuerst a komplett nach b kopieren, um a im Original zu belassen; b ist unsortiert Array b vom ersten bis zum letzten Element durchlaufen und alle benachbarten Elemente b[index] und b[index+1] miteinander vergleichen wenn b[index] <= b[index+1] \u2794 nichts tun wenn b[index] > b[index+1] \u2794 b[index] und b[index+1] vertauschen Wenn Array b einmal durchlaufen \u2794 das gr\u00f6\u00dfte Element von b steht an der letzten Stelle (\u2248 letztes Element sortiert) Verfahren auf Array b vom ersten bis zum vorletzten Element anwenden \u2026 bis alle Elemente in b sortiert Eine m\u00f6gliche Implementierung von Bubble-Sort: 1 2 3 4 5 6 7 8 9 10 11 12 13 for ( int bubble = 1 ; bubble <= b . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; } } } return b ; Zeile 1 zeigt die \u00e4u\u00dfere for -Schleife f\u00fcr die Bubble-Phasen. Es werden length-1 viele Bubble-Phasen durchlaufen (Initialisierung von bubble mit 1 und Bedingung <= ). Zeile 3 zeigt die innere for -Schleife, die in jeder Bubble-Phase durchlaufen wird. Die Anzahl der Durchl\u00e4ufe wird immer kleiner (wegen length - bubble in der Bedingung). Die innere for -Schleife ist f\u00fcr den Vergleich aller Nachbarn. Zeile 5 zeigt die Bedingung, unter der die Nachbarn tauschen m\u00fcssen. Zeilen 7-9 zeigt den Tausch der Werte zweier Nachbarn. Wir gehen auf diesen Tausch gleich nochmal ausf\u00fchrlich ein. Wenn die \u00e4u\u00dfere for -Schleife abgearbeitet wurde, also alle Bubble-Phasen durchlaufen wurden, ist das Array b sortiert und kann zur\u00fcckgegeben werden. Sortieren.java zum Ausprobieren package themen.arrays.sortieren ; import java.util.Random ; public class Sortieren { /* * aus Skript */ public static void printArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } System . out . println ( s ); } /* * aus Skript */ public static int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } public static int [] bubblesort ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = new int [ a . length ] ; for ( int index = 0 ; index < b . length ; index ++ ) { b [ index ] = a [ index ] ; } /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ for ( int bubble = 1 ; bubble <= b . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; } } } return b ; } public static void main ( String [] args ) { int [] unsorted = createAndFillArray ( 20 , 50 ); int [] sorted = bubblesort ( unsorted ); printArray ( unsorted ); printArray ( sorted ); } }","title":"Bubble-Sort"},{"location":"sortieren/#tauschen-der-werte-zweier-nachbarn","text":"Angenommen, wir haben folgenden Fall, in dem die Werte 18 und 7 ihre Positionen tauschen sollen, also die 18 auf den Index 3 wechseln soll und die 7 auf den Index 2 . Was wir nicht machen k\u00f6nnen, ist etwas in der Art: b [ 2 ] = b [ 3 ] ; // b[2]==7 und b[3]==7 - die 18 ist \u00fcberschrieben b [ 3 ] = b [ 2 ] ; // b[2]==7 und b[3]==7 Nach der ersten Anweisung w\u00fcrde sowohl in b[2] als auch in b[3] der Wert 7 stehen und die 18 w\u00e4re \"weg\". Wir brauchen eine Variable, auf die wir einen Wert zwischenspeichern k\u00f6nnen. Wichtig ist, dass diese Variable vom selben Typ ist, wie alle Werte des Arrays (in diesem Fall int ). In dieser Variablen k\u00f6nnen wir uns den Wert aus b[2] zun\u00e4chst (zwischen-)speichern. Nun kann der Wert in b[2] problemlos \u00fcberschrieben werden, denn wir haben ihn ja noch in tmp verf\u00fcgbar. Nun m\u00fcssen wir nur noch den Wert aus tmp nach b[3] kopieren. Die Werte 7 und 18 haben im Array ihre Positionen getauscht. Im obigen Beispiel ist dieses Vertauschen in den 3 Zeilen ausgedr\u00fcckt: int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ;","title":"Tauschen der Werte zweier Nachbarn"},{"location":"sortieren/#verbesserung-von-bubble-sort","text":"In dem eingangs gezeigten Beispiel haben wir gesehen, dass manchmal gar nicht alle length-1 Bubble-Phasen durchlaufen werden m\u00fcssen, da das Array manchmal schon vorher fertig sortiert ist. Wir wollen unsere Methode dahingehend verbessern, dass dies erkannt wird und dementsprechend die Sortierung gestoppt wird. Woran erkennen wir aber, dass das Array fertig sortiert ist? Die Antwort f\u00fcr den Bubble-Sort-Algorithmus: Wenn in einer Bubble-Phase gar kein Vertauschen mehr stattfindet, dann sind alle linken Nachbarn kleiner als ihre rechten und somit ist das Array fertig sortiert. Das hei\u00dft, wir pr\u00fcfen f\u00fcr eine Bubble-Phase, ob (mindestens) ein Vertauschen stattfand oder nicht. Dazu ben\u00f6tigen wir: eine Variable swapped vom Typ boolean , die false ist, wenn nicht getauscht wurde und true , wenn getauscht wurde \u2192 initial ist sie aber true (wegen 2.) eine Bedingung in der \u00e4u\u00dferen for -Schleife && swapped . Neben der Bedingung \u00fcber den bubble -Wert pr\u00fcfen wir nun auch noch, ob swapped true ist. Nur wenn das der Fall ist (wenn getauscht wurde), betreten wir das Innere der Schleife. Wenn nicht getauscht wurde, ist der Wert von swapped``false und die Sortierung wird beendet. eine Anweisung swapped=false; direkt nachdem wir die \u00e4u\u00dfere for -Schleife betreten haben, d.h. eine neue Bubble-Phase angefangen hat. Wir setzen den Wert also erstmal auf false und nur dann, wenn ein Tausch stattfindet, wird er auf true gesetzt. eine Anweisung swapped=true; f\u00fcr den Fall, dass getauscht wird. Wenn die Bedingung b[index] > b[index+1] true ist, dann tauschen die beiden Nachbarn auf den Indizes index und index+1 ihre Positionen und also wurde getauscht \u2192 es muss noch (mindestens) eine weitere Bubble-Phase stattfinden. Die optimierte Bubble-Sortierung sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; } } } return b ; Damit ist die Implementierung von Bubble-Sort vollst\u00e4ndig. So kann sie bleiben und genutzt werden. Wir wollen jetzt nur noch ein paar Ausgaben hinzuf\u00fcgen, die aber einzig und allein dem Verst\u00e4ndnis des Ablaufs der Sortierung mit Bubble-Sort dienen soll. ori---> [ 46 , 12 , 15 , 39 , 37 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 1 . Bubble-Phase : ------> [ 46 , 12 , 15 , 39 , 37 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 0 --> [ 12 , 46 , 15 , 39 , 37 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 1 --> [ 12 , 15 , 46 , 39 , 37 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 2 --> [ 12 , 15 , 39 , 46 , 37 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 3 --> [ 12 , 15 , 39 , 37 , 46 , 12 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 4 --> [ 12 , 15 , 39 , 37 , 12 , 46 , 20 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 5 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 46 , 37 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 6 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 49 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 8 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 49 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 9 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 49 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 10 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 49 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 11 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 49 , 36 , 49 , 3 , 14 , 26 , 24 , 31 ] 12 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 49 , 3 , 14 , 26 , 24 , 31 ] 14 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 49 , 14 , 26 , 24 , 31 ] 15 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 49 , 26 , 24 , 31 ] 16 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 49 , 24 , 31 ] 17 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 49 , 31 ] 18 --> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 2 . Bubble-Phase : ------> [ 12 , 15 , 39 , 37 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 2 --> [ 12 , 15 , 37 , 39 , 12 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 3 --> [ 12 , 15 , 37 , 12 , 39 , 20 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 4 --> [ 12 , 15 , 37 , 12 , 20 , 39 , 37 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 5 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 46 , 38 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 7 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 46 , 41 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 8 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 46 , 6 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 9 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 46 , 2 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 10 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 46 , 36 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 11 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 49 , 3 , 14 , 26 , 24 , 31 , 49 ] 13 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 49 , 14 , 26 , 24 , 31 , 49 ] 14 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 49 , 26 , 24 , 31 , 49 ] 15 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 49 , 24 , 31 , 49 ] 16 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 49 , 31 , 49 ] 17 --> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 3 . Bubble-Phase : ------> [ 12 , 15 , 37 , 12 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 2 --> [ 12 , 15 , 12 , 37 , 20 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 3 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 39 , 38 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 6 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 41 , 6 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 8 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 41 , 2 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 9 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 41 , 36 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 10 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 46 , 3 , 14 , 26 , 24 , 31 , 49 , 49 ] 12 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 46 , 14 , 26 , 24 , 31 , 49 , 49 ] 13 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 46 , 26 , 24 , 31 , 49 , 49 ] 14 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 26 , 46 , 24 , 31 , 49 , 49 ] 15 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 26 , 24 , 46 , 31 , 49 , 49 ] 16 --> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 4 . Bubble-Phase : ------> [ 12 , 15 , 12 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 1 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 39 , 6 , 2 , 36 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 7 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 39 , 2 , 36 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 8 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 39 , 36 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 9 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 41 , 3 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 11 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 41 , 14 , 26 , 24 , 31 , 46 , 49 , 49 ] 12 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 14 , 41 , 26 , 24 , 31 , 46 , 49 , 49 ] 13 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 14 , 26 , 41 , 24 , 31 , 46 , 49 , 49 ] 14 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 14 , 26 , 24 , 41 , 31 , 46 , 49 , 49 ] 15 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 5 . Bubble-Phase : ------> [ 12 , 12 , 15 , 20 , 37 , 37 , 38 , 6 , 2 , 36 , 39 , 3 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 6 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 38 , 2 , 36 , 39 , 3 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 7 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 38 , 36 , 39 , 3 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 8 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 39 , 3 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 10 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 39 , 14 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 11 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 14 , 39 , 26 , 24 , 31 , 41 , 46 , 49 , 49 ] 12 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 14 , 26 , 39 , 24 , 31 , 41 , 46 , 49 , 49 ] 13 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 14 , 26 , 24 , 39 , 31 , 41 , 46 , 49 , 49 ] 14 --> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 6 . Bubble-Phase : ------> [ 12 , 12 , 15 , 20 , 37 , 37 , 6 , 2 , 36 , 38 , 3 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 5 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 37 , 2 , 36 , 38 , 3 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 6 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 37 , 36 , 38 , 3 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 7 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 38 , 3 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 9 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 38 , 14 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 10 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 14 , 38 , 26 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 11 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 38 , 24 , 31 , 39 , 41 , 46 , 49 , 49 ] 12 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 38 , 31 , 39 , 41 , 46 , 49 , 49 ] 13 --> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 7 . Bubble-Phase : ------> [ 12 , 12 , 15 , 20 , 37 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 4 --> [ 12 , 12 , 15 , 20 , 6 , 37 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 5 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 37 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 6 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 37 , 3 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 8 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 37 , 14 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 9 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 14 , 37 , 26 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 10 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 37 , 24 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 11 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 37 , 31 , 38 , 39 , 41 , 46 , 49 , 49 ] 12 --> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 8 . Bubble-Phase : ------> [ 12 , 12 , 15 , 20 , 6 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 3 --> [ 12 , 12 , 15 , 6 , 20 , 2 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 4 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 37 , 3 , 14 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 7 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 37 , 14 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 8 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 14 , 37 , 26 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 9 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 14 , 26 , 37 , 24 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 10 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 14 , 26 , 24 , 37 , 31 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 11 --> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 14 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 9 . Bubble-Phase : ------> [ 12 , 12 , 15 , 6 , 2 , 20 , 36 , 3 , 14 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 2 --> [ 12 , 12 , 6 , 15 , 2 , 20 , 36 , 3 , 14 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 3 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 36 , 3 , 14 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 6 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 36 , 14 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 7 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 14 , 36 , 26 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 8 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 14 , 26 , 36 , 24 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 9 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 14 , 26 , 24 , 36 , 31 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 10 --> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 14 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 10 . Bubble-Phase : ------> [ 12 , 12 , 6 , 2 , 15 , 20 , 3 , 14 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 1 --> [ 12 , 6 , 12 , 2 , 15 , 20 , 3 , 14 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 2 --> [ 12 , 6 , 2 , 12 , 15 , 20 , 3 , 14 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 5 --> [ 12 , 6 , 2 , 12 , 15 , 3 , 20 , 14 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 6 --> [ 12 , 6 , 2 , 12 , 15 , 3 , 14 , 20 , 26 , 24 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 8 --> [ 12 , 6 , 2 , 12 , 15 , 3 , 14 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 11 . Bubble-Phase : ------> [ 12 , 6 , 2 , 12 , 15 , 3 , 14 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 0 --> [ 6 , 12 , 2 , 12 , 15 , 3 , 14 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 1 --> [ 6 , 2 , 12 , 12 , 15 , 3 , 14 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 4 --> [ 6 , 2 , 12 , 12 , 3 , 15 , 14 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 5 --> [ 6 , 2 , 12 , 12 , 3 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 12 . Bubble-Phase : ------> [ 6 , 2 , 12 , 12 , 3 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 0 --> [ 2 , 6 , 12 , 12 , 3 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 3 --> [ 2 , 6 , 12 , 3 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 13 . Bubble-Phase : ------> [ 2 , 6 , 12 , 3 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 2 --> [ 2 , 6 , 3 , 12 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 14 . Bubble-Phase : ------> [ 2 , 6 , 3 , 12 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 1 --> [ 2 , 3 , 6 , 12 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] 15 . Bubble-Phase : ------> [ 2 , 3 , 6 , 12 , 12 , 14 , 15 , 20 , 24 , 26 , 31 , 36 , 37 , 37 , 38 , 39 , 41 , 46 , 49 , 49 ] Wir sehen, wie sich von oben nach unten der sortierte Bereich von rechts nach links vergr\u00f6\u00dfert. Es werden immer nur die Zeilen mit ihren jeweiligen Indizes (die ganz linke Zahl am Anfang der Zeile) ausgegeben, in denen Nachbarn getauscht werden. In diesem Beispiel wird bereits in der 15. Bubble-Phase nichts mehr getauscht. Da das Array die L\u00e4nge 20 hat, g\u00e4be es eigentlich 19 Bubble-Phasen. Der Code, der f\u00fcr die obige Ausgabe verwendet wurde package themen.arrays.sortieren ; import java.util.Random ; public class Sortieren { /* * aus Skript */ public static void printArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } System . out . println ( s ); } /* * angepasste printArray-Methode * hier wird davon ausgegangen, dass die Zahlen * in dem Array nie gr\u00f6\u00dfer als zweistellig sind * ist haupts\u00e4chlich, damit die Ausgaben der Arrays besser * miteinander verglichen werden k\u00f6nnen auf der Konsole * */ public static void print ( int [] a ) { String s = \"--> [ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + String . format ( \"%2d, \" , a [ index ] ); } if ( a . length > 0 ) { s = s + String . format ( \"%2d ]\" , a [ a . length - 1 ] ); } System . out . println ( s ); } /* * aus Skript */ public static int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } public static int [] bubblesort ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = new int [ a . length ] ; for ( int index = 0 ; index < b . length ; index ++ ) { b [ index ] = a [ index ] ; } System . out . print ( \"ori-\" ); print ( b ); // Ausgangs-Array System . out . println (); /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { System . out . printf ( \"%3d. Bubble-Phase : %n----\" , bubble ); print ( b ); swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; System . out . printf ( \"%3d \" , index ); print ( b ); } } System . out . println (); } return b ; } public static void main ( String [] args ) { int [] unsorted = createAndFillArray ( 20 , 50 ); int [] sorted = bubblesort ( unsorted ); printArray ( unsorted ); printArray ( sorted ); } } Noch kurz ein Wort zur Komplexit\u00e4t von Bubble-Sort. Wenn n die L\u00e4nge des Arrays ist, dann finden in der ersten Bubble-Phase n-1 Vergleiche statt, in der zweiten Bubble-Phase n-2 Vergleiche usw. Es gibt maximal n-1 Bubble-Phasen, also (n-1) + (n-2) + (n-3) + ... + 3 + 2 + 1 Vergleiche. Das sind n*(n-1)/2 Vergleiche und maximal ebenso viele Vertauschungen. Das ergibt Vergleiche + Vertauschungen = n*(n-1) Operationen. Das entspricht einer (Zeit-)Komplexit\u00e4t von O(n^2) . Success Wir haben einen Sortieralgorithmus kennengelernt, mit dem wir Arrays sortieren k\u00f6nnen. Beachten Sie, dass das nicht nur f\u00fcr int -Arrays m\u00f6glich ist, sondern f\u00fcr alle Datentypen, \u00fcber die sich eine Ordnung definieren l\u00e4sst. Wir werden jetzt noch weitere Sortieralgorithmen betrachten, aber nur aus Interesse. Den Bubble-Sort-Algorithmus sollten Sie aus dem Kopf beherrschen, also programmieren k\u00f6nnen. Alle weiteren Sortieralgorithmen sollten Sie \"nur\" verstehen.","title":"Verbesserung von Bubble-Sort"},{"location":"sortieren/#selection-sort","text":"Die Idee des Selection-Sort-Algorithmus ist die, dass bei jedem Durchlauf durch das Array das jeweils kleinste (oder gr\u00f6\u00dfte - je, nachdem, wie man sortieren m\u00f6chte) ausgew\u00e4hlt und an seine richtige Position im Array sortiert wird. Wir betrachten erneut unser Beispiel: 55 07 78 12 42 Erster Durchlauf: Im ersten Schritt suchen wir das kleinste Element im Array und wollen es ganz links (auf den Index 0 ) legen die 7 ist das kleinste Element, also muss es seine Poition mit der 55 tauschen Nach dem ersten Schritt: 07 55 78 12 42 Zweiter Durchlauf: Jetzt steht das kleinste Element ganz links \u2192 es muss nicht mehr betrachtet werden wir suchen jetzt das zweitkleinste Element, um es auf den Index 1 zu legen die 12 ist das zweitkleinste Element, also muss es seine Position mit der 55 tauschen Nach dem zweiten Schritt: 07 12 78 55 42 Dritter Durchlauf: Jetzt stehen die 2 kleinsten Element ganz links \u2192 sie m\u00fcssen nicht mehr betrachtet werden wir suchen jetzt das drittkleinste Element, um es auf den Index 2 zu legen die 42 ist das drittkleinste Element, also muss es seine Position mit der 78 tauschen Nach dem dritten Schritt: 07 12 42 55 78 Vierter Durchlauf: Jetzt stehen die 3 kleinsten Element ganz links \u2192 sie m\u00fcssen nicht mehr betrachtet werden wir suchen jetzt das viertkleinste Element, um es auf den Index 3 zu legen die 55 ist das viertkleinste Element, es ist bereits auf der richtigen Position \u2192 wir m\u00fcssen also nicht (mehr) tauschen Ein Array der L\u00e4nge 5 ist nach 4 Durchl\u00e4ufen sortiert. Generell gilt auch hier wieder, dass ein Array der L\u00e4nge n nach sp\u00e4testens n-1 Durchl\u00e4ufen (das waren In Bubble-Sort die Bubble-Phasen) sortiert ist. W\u00e4hrend bei Bubble-Sort der sortierte Teil des Arrays von rechts anwuchs (von gro\u00df nach klein), w\u00e4chst bei Selection-Sort der sortierte Teil des Arrays von links an (von klein nach gro\u00df). Auch hier gilt wieder, dass immer nur der unsortierte Teil erneut durchsucht werden muss. Auch hier finden wieder paarweise Vergleiche mit allen unsortierten Elementen statt. Dieses Mal sind es aber nicht die Nachbarn, die verglichen und evtl. getauscht werden m\u00fcssen, sondern es wird im unsortierten (rechten) Teil nach dem kleinsten Element gesucht. Hier noch ein Bild, das den Selection-Sort-Algorithmus an einem anderen Beispiel verdeutlicht: Wir wollen uns der algorithmischen Idee von Selection-Sort ann\u00e4hern. Wir wollen eine Methode selectionsort() schreiben, f\u00fcr die folgendes gilt: Parameter : unsortiertes Array a R\u00fcckgabe : sortiertes Array b Vorgehen : gedachte Teilung des Arrays in 2 Teile: linker Teil: sortiert rechter Teil: unsortiert \u2794 anfangs: linker Teil leer d.h. Array unsortiert rechten unsortierten Teil b[j] ,\u2026, b[n-1] betrachten ( n ist L\u00e4nge des Arrays) das kleinste Element (Minimum) im rechten Teil suchen mit dem ersten Element b[j] im rechten Teil vertauschen \u2794 rechter unsortierter Teil des Array b[j+1] ,\u2026, b[n-1] um ein Element kleiner, linker sortierter Teil w\u00e4chst um ein Element b[j] so verfahren, bis rechter Teil nur ein Element b[n-1] enth\u00e4lt Eine m\u00f6gliche Implementierung von Selection-Sort: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public static int [] selectionsort ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int durchlauf = 0 ; durchlauf < b . length ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes for ( int index = durchlauf ; index < b . length ; index ++ ) // Suche nach dem kleinsten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } } // jetzt den kleinsten Wert auf den Index durchlauf legen // der Wert, der auf durchlauf lag, kommt nach minIndex int tmp = b [ durchlauf ] ; b [ durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmp ; } return b ; } Zeile 5 zeigt die \u00e4u\u00dfere for -Schleife f\u00fcr die Durchl\u00e4ufe. Es werden length-1 viele Phasen durchlaufen. in Zeile 7 wird die Variable deklariert, in der wir uns den kleinsten Wert des rechten (unsortierten) Teils merken. Wir initialisieren die Variable mit dem ersten Wert im unsortierten Teil. Der unsortierte Teil beginnt beim Index durchlauf . in Zeile 8 wird die Variable deklariert, in der wir uns den Index des kleinsten Wertes im rechten (unsortierten) Teils merken. Wir initialisieren die Variable mit dem ersten Index im unsortierten Teil - dies ist durchlauf . in den Zeilen 19-21 tauschen wir die Werte. Der kleinste Wert kommt auf den Index durchlauf und der Wert, der auf dem Index durchlauf stand, kommt nach minIndex Wenn die \u00e4u\u00dfere for -Schleife abgearbeitet wurde, also alle length-1 Phasen durchlaufen wurden, ist das Array b sortiert und kann zur\u00fcckgegeben werden. Die copy() -Methode, die in Zeile 3 verwendet wurde, sieht so aus: public static int [] copy ( int [] a ) { int [] b = new int [ a . length ] ; for ( int index = 0 ; index < b . length ; index ++ ) { b [ index ] = a [ index ] ; } return b ; } Wir werden jetzt die Implementierung des Selection-Sort-Algorithmus um einige Ausgaben erweitern, damit das Prinzip noch deutlicher wird (wie bei Bubble-Sort). Die Ausgaben haben in der Methode nat\u00fcrlich eigentlich nichts zu suchen - es ist hier nur zur n\u00e4heren Information: original -------> [ 38 , 22 , 18 , 6 , 15 , 12 , 9 , 1 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] 1 . Durchlauf - kleinstes Element soll auf den index 0 ----> kleinster Wert ist 1 auf dem Index 7 vor Tausch : --> [ 38 , 22 , 18 , 6 , 15 , 12 , 9 , 1 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 22 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] 2 . Durchlauf - kleinstes Element soll auf den index 1 ----> kleinster Wert ist 5 auf dem Index 9 vor Tausch : --> [ 1 , 22 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] 3 . Durchlauf - kleinstes Element soll auf den index 2 ----> kleinster Wert ist 6 auf dem Index 3 vor Tausch : --> [ 1 , 5 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 18 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] 4 . Durchlauf - kleinstes Element soll auf den index 3 ----> kleinster Wert ist 9 auf dem Index 6 vor Tausch : --> [ 1 , 5 , 6 , 18 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 15 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] 5 . Durchlauf - kleinstes Element soll auf den index 4 ----> kleinster Wert ist 10 auf dem Index 17 vor Tausch : --> [ 1 , 5 , 6 , 9 , 15 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 15 , 31 , 49 ] 6 . Durchlauf - kleinstes Element soll auf den index 5 ----> kleinster Wert ist 11 auf dem Index 14 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 12 , 24 , 30 , 15 , 31 , 49 ] 7 . Durchlauf - kleinstes Element soll auf den index 6 ----> kleinster Wert ist 12 auf dem Index 14 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 12 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] 8 . Durchlauf - kleinstes Element soll auf den index 7 ----> kleinster Wert ist 14 auf dem Index 8 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 38 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] 9 . Durchlauf - kleinstes Element soll auf den index 8 ----> kleinster Wert ist 15 auf dem Index 17 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 38 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 38 , 31 , 49 ] 10 . Durchlauf - kleinstes Element soll auf den index 9 ----> kleinster Wert ist 18 auf dem Index 14 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 22 , 49 , 31 , 19 , 22 , 24 , 30 , 38 , 31 , 49 ] 11 . Durchlauf - kleinstes Element soll auf den index 10 ----> kleinster Wert ist 19 auf dem Index 13 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 22 , 49 , 31 , 19 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 49 , 31 , 22 , 22 , 24 , 30 , 38 , 31 , 49 ] 12 . Durchlauf - kleinstes Element soll auf den index 11 ----> kleinster Wert ist 22 auf dem Index 13 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 49 , 31 , 22 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 31 , 49 , 22 , 24 , 30 , 38 , 31 , 49 ] 13 . Durchlauf - kleinstes Element soll auf den index 12 ----> kleinster Wert ist 22 auf dem Index 14 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 31 , 49 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 49 , 31 , 24 , 30 , 38 , 31 , 49 ] 14 . Durchlauf - kleinstes Element soll auf den index 13 ----> kleinster Wert ist 24 auf dem Index 15 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 49 , 31 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 31 , 49 , 30 , 38 , 31 , 49 ] 15 . Durchlauf - kleinstes Element soll auf den index 14 ----> kleinster Wert ist 30 auf dem Index 16 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 31 , 49 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 49 , 31 , 38 , 31 , 49 ] 16 . Durchlauf - kleinstes Element soll auf den index 15 ----> kleinster Wert ist 31 auf dem Index 16 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 49 , 31 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 49 , 38 , 31 , 49 ] 17 . Durchlauf - kleinstes Element soll auf den index 16 ----> kleinster Wert ist 31 auf dem Index 18 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 49 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] 18 . Durchlauf - kleinstes Element soll auf den index 17 ----> kleinster Wert ist 38 auf dem Index 17 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] 19 . Durchlauf - kleinstes Element soll auf den index 18 ----> kleinster Wert ist 49 auf dem Index 18 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] 20 . Durchlauf - kleinstes Element soll auf den index 19 ----> kleinster Wert ist 49 auf dem Index 19 vor Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] Wenn wir nur alle Zeilen nach dem Tausch betrachten, dann sehen wir die Entwicklung der Sortierung von links nach rechts: original -------> [ 38 , 22 , 18 , 6 , 15 , 12 , 9 , 1 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 22 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 5 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 18 , 6 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 18 , 15 , 12 , 9 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 15 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 10 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 12 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 11 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 18 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 12 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 38 , 14 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 38 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 15 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 22 , 22 , 49 , 31 , 19 , 18 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 22 , 49 , 31 , 19 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 49 , 31 , 22 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 31 , 49 , 22 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 49 , 31 , 24 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 31 , 49 , 30 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 49 , 31 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 49 , 38 , 31 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ] nach Tausch : --> [ 1 , 5 , 6 , 9 , 10 , 11 , 12 , 14 , 15 , 18 , 19 , 22 , 22 , 24 , 30 , 31 , 31 , 38 , 49 , 49 ]","title":"Selection-Sort"},{"location":"sortieren/#verbesserung-von-selection-sort","text":"In dem obigen Beispiel sehen wir, dass die letzten drei Durchl\u00e4ufe gar nicht mehr notwendig waren, da das Array dann bereits vollst\u00e4ndig sortiert war. Beim Selection-Sort-Algorithmus ist es jedoch gar nicht leicht, diesen Zustand zu erkennen. Stattdessen k\u00f6nnten wir aber folgende Optimierung vornehmen: wir suchen in einem Durchlauf nicht nur das kleinste Element und tauschen dieses nach links, sondern wir suchen gleichzeitig nach dem gr\u00f6\u00dften Element und tauschen dieses nach rechts dann entstehen drei Teile in unserem Array: ein linker, sortierter Teil, ein rechter, sortierter Teil und ein mittlerer, unsortierter Teil Die Anzahl der Durchl\u00e4ufe halbiert sich damit! Hier eine m\u00f6gliche Implementierung des optimieretn Selection-Sort-Algorithmus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 public static int [] selectionsortOptimiert ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int durchlauf = 0 ; durchlauf < b . length / 2 + 1 ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes int maxValue = b [ b . length - 1 - durchlauf ] ; // in maxValue merken wir uns den aktuell groessten Wert int maxIndex = b . length - 1 - durchlauf ; // in maxIndex merken wir uns den Index des aktuell groessten Wertes for ( int index = durchlauf ; index < b . length - durchlauf ; index ++ ) // Suche nach dem kleinsten UND groessten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } if ( maxValue < b [ index ] ) { maxValue = b [ index ] ; // aktuell groesster Wert maxIndex = index ; // aktueller Index des groessten Wertes } } /* * jetzt den kleinsten Wert auf den Index durchlauf legen * der Wert, der auf durchlauf lag, kommt nach minIndex * UND den groessten Wert auf den Index b.length-1-durchlauf legen * der Wert, der auf b.length-1-durchlauf lag, kommt nach maxIndex * wir m\u00fcssen zun\u00e4chst aber beide Werte sichern, sonst kann es zu * Konflikten beim Tauschen kommen! * */ int tmpMin = b [ durchlauf ] ; int tmpMax = b [ b . length - 1 - durchlauf ] ; b [ durchlauf ] = minValue ; b [ minIndex ] = tmpMin ; /* * hier wird es sehr kompliziert * wenn der MaximumWert dort war, wo das neue Minimum hin kommt (Index durchlauf), * dann m\u00fcssen wir aufpassen, dass wir den alten Wert tmpMax nicht verlieren * es sind jetzt nur noch 3 Werte im Spiel * der alte Wert von durchlauf - ist in tmpMin UND ist gleichzeitig maxValue! * der alte Wert von length-1-durchlauf - ist in tmpMax * der alte Wert von minIndex ist minValue und jetzt auf durchlauf * Versuchen Sie es mal ohne die Bedingung und nur * b[b.length-1-durchlauf] = maxValue; * b[maxIndex] = tmpMax; * dann sehen Sie den Fehler */ if ( maxIndex == durchlauf ) { b [ b . length - 1 - durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmpMax ; } else { b [ b . length - 1 - durchlauf ] = maxValue ; b [ maxIndex ] = tmpMax ; } } return b ; } Die Entwicklung eines Arrays mit Zufallszahlen sieht f\u00fcr den optimierten Selection-Sort-Algorithmus z.B. so aus: --> [ 8 , 6 , 7 , 49 , 3 , 7 , 17 , 40 , 48 , 37 , 37 , 49 , 30 , 34 , 15 , 34 , 9 , 38 , 7 , 32 ] // Ausgangs-Array --> [ 3 , 6 , 7 , 32 , 8 , 7 , 17 , 40 , 48 , 37 , 37 , 49 , 30 , 34 , 15 , 34 , 9 , 38 , 7 , 49 ] // Durchlauf 1 --> [ 3 , 6 , 7 , 32 , 8 , 7 , 17 , 40 , 48 , 37 , 37 , 7 , 30 , 34 , 15 , 34 , 9 , 38 , 49 , 49 ] // Durchlauf 2 --> [ 3 , 6 , 7 , 32 , 8 , 7 , 17 , 40 , 38 , 37 , 37 , 7 , 30 , 34 , 15 , 34 , 9 , 48 , 49 , 49 ] // Durchlauf 3 --> [ 3 , 6 , 7 , 7 , 8 , 32 , 17 , 9 , 38 , 37 , 37 , 7 , 30 , 34 , 15 , 34 , 40 , 48 , 49 , 49 ] // Durchlauf 4 --> [ 3 , 6 , 7 , 7 , 7 , 32 , 17 , 9 , 34 , 37 , 37 , 8 , 30 , 34 , 15 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 5 --> [ 3 , 6 , 7 , 7 , 7 , 8 , 17 , 9 , 34 , 15 , 37 , 32 , 30 , 34 , 37 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 6 --> [ 3 , 6 , 7 , 7 , 7 , 8 , 9 , 17 , 34 , 15 , 34 , 32 , 30 , 37 , 37 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 7 --> [ 3 , 6 , 7 , 7 , 7 , 8 , 9 , 15 , 30 , 17 , 34 , 32 , 34 , 37 , 37 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 8 --> [ 3 , 6 , 7 , 7 , 7 , 8 , 9 , 15 , 17 , 30 , 32 , 34 , 34 , 37 , 37 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 9 --> [ 3 , 6 , 7 , 7 , 7 , 8 , 9 , 15 , 17 , 30 , 32 , 34 , 34 , 37 , 37 , 38 , 40 , 48 , 49 , 49 ] // Durchlauf 10 Man sieht, dass sich nun die sortierten Teile sowohl von links als auch von rechts ann\u00e4hern und der mittlere, unsortierte Teil immer kleiner wird. Die Komplexit\u00e4t des Selection-Sort-Algorithmus ist die gleiche, wie bei Bubble-Sort. Wir ben\u00f6tigen im ersten Durchlauf n-1 Vergleiche, um das Minimum zu bestimmen, im zweiten Durchlauf n-2 usw. Insgesamt also wieder n*(n-1)/2 Vergleiche. Dazu kommen n-1 Vertauschungen. Das macht insgesamt n^2/2 + n/2 + n - 1 Operationen und ergibt somit eine Zeitkomplexit\u00e4t von O(n^2) . Aktueller Stand der Klasse Sortieren.java package themen.arrays.sortieren ; import java.util.Random ; public class Sortieren { /* * aus Skript */ public static void printArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } System . out . println ( s ); } /* * angepasste printArray-Methode * hier wird davon ausgegangen, dass die Zahlen * in dem Array nie gr\u00f6\u00dfer als zweistellig sind * ist haupts\u00e4chlich, damit die Ausgaben der Arrays besser * miteinander verglichen werden k\u00f6nnen auf der Konsole * */ public static void print ( int [] a ) { String s = \"--> [ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + String . format ( \"%2d, \" , a [ index ] ); } if ( a . length > 0 ) { s = s + String . format ( \"%2d ]\" , a [ a . length - 1 ] ); } System . out . println ( s ); } /* * aus Skript */ public static int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } public static int [] copy ( int [] a ) { int [] b = new int [ a . length ] ; for ( int index = 0 ; index < b . length ; index ++ ) { b [ index ] = a [ index ] ; } return b ; } public static int [] bubblesortDebug ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = copy ( a ); System . out . print ( \"ori-\" ); print ( b ); // Ausgangs-Array System . out . println (); /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { System . out . printf ( \"%3d. Bubble-Phase : %n----\" , bubble ); print ( b ); swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; System . out . printf ( \"%3d \" , index ); print ( b ); } } System . out . println (); } return b ; } public static int [] bubblesort ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = copy ( a ); /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; } } } return b ; } public static int [] selectionsortDebug ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck System . out . print ( \" original -----\" ); print ( b ); // Ausgangs-Array System . out . println (); for ( int durchlauf = 0 ; durchlauf < b . length ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { System . out . printf ( \"%3d. Durchlauf - kleinstes Element soll auf den index %2d %n----> \" , durchlauf + 1 , durchlauf ); int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes for ( int index = durchlauf ; index < b . length ; index ++ ) // Suche nach dem kleinsten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } } System . out . printf ( \"kleinster Wert ist %3d auf dem Index %3d %n\" , minValue , minIndex ); System . out . printf ( \"%13s : \" , \"vor Tausch \" ); print ( b ); // jetzt den kleinsten Wert auf den Index durchlauf legen // der Wert, der auf durchlauf lag, kommt nach minIndex int tmp = b [ durchlauf ] ; b [ durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmp ; System . out . printf ( \"%13s : \" , \"nach Tausch \" ); print ( b ); System . out . println (); } return b ; } public static int [] selectionsort ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int durchlauf = 0 ; durchlauf < b . length ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes for ( int index = durchlauf ; index < b . length ; index ++ ) // Suche nach dem kleinsten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } } // jetzt den kleinsten Wert auf den Index durchlauf legen // der Wert, der auf durchlauf lag, kommt nach minIndex int tmp = b [ durchlauf ] ; b [ durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmp ; } return b ; } public static int [] selectionsortOptimiert ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck System . out . print ( \" \" ); print ( b ); // Ausgangs-Array for ( int durchlauf = 0 ; durchlauf < b . length / 2 ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes int maxValue = b [ b . length - 1 - durchlauf ] ; // in maxValue merken wir uns den aktuell groessten Wert int maxIndex = b . length - 1 - durchlauf ; // in maxIndex merken wir uns den Index des aktuell groessten Wertes System . out . printf ( \"%3d %3d %3d %3d %3d %n\" , durchlauf , minValue , minIndex , maxValue , maxIndex ); for ( int index = durchlauf ; index < b . length - durchlauf ; index ++ ) // Suche nach dem kleinsten UND groessten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } if ( maxValue < b [ index ] ) { maxValue = b [ index ] ; // aktuell groesster Wert maxIndex = index ; // aktueller Index des groessten Wertes } } /* * jetzt den kleinsten Wert auf den Index durchlauf legen * der Wert, der auf durchlauf lag, kommt nach minIndex * UND den groessten Wert auf den Index b.length-1-durchlauf legen * der Wert, der auf b.length-1-durchlauf lag, kommt nach maxIndex * wir m\u00fcssen zun\u00e4chst aber beide Werte sichern, sonst kann es zu * Konflikten beim Tauschen kommen! * */ System . out . printf ( \"%3d %3d %3d %3d %3d \" , durchlauf , minValue , minIndex , maxValue , maxIndex ); int tmpMin = b [ durchlauf ] ; int tmpMax = b [ b . length - 1 - durchlauf ] ; b [ durchlauf ] = minValue ; b [ minIndex ] = tmpMin ; /* * hier wird es sehr kompliziert * wenn der MaximumWert dort war, wo das neue Minimum hin kommt (Index durchlauf), * dann m\u00fcssen wir aufpassen, dass wir den alten Wert tmpMax nicht verlieren * es sind jetzt nur noch 3 Werte im Spiel * der alte Wert von durchlauf - ist in tmpMin UND ist gleichzeitig maxValue! * der alte Wert von length-1-durchlauf - ist in tmpMax * der alte Wert von minIndex ist minValue und jetzt auf durchlauf * Versuchen Sie es mal ohne die Bedingung und nur * b[b.length-1-durchlauf] = maxValue; * b[maxIndex] = tmpMax; * dann sehen Sie den Fehler */ if ( maxIndex == durchlauf ) { b [ b . length - 1 - durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmpMax ; } else { b [ b . length - 1 - durchlauf ] = maxValue ; b [ maxIndex ] = tmpMax ; } print ( b ); } return b ; } public static void main ( String [] args ) { int [] unsorted = createAndFillArray ( 21 , 50 ); System . out . printf ( \"%n%n--------------- bubblesort ----------------------%n%n\" ); int [] sorted = bubblesort ( unsorted ); printArray ( unsorted ); printArray ( sorted ); System . out . printf ( \"%n%n--------------- selection ----------------------%n%n\" ); int [] us = { 1 , 12 , 41 , 35 , 49 , 2 , 28 , 38 , 21 , 35 , 41 , 12 , 21 , 29 , 27 , 17 , 5 , 6 , 18 , 3 }; sorted = selectionsortOptimiert ( unsorted ); printArray ( unsorted ); printArray ( sorted ); } } Success Wir haben einen zweiten Sortieralgorithmus kennengelernt, mit dem wir Arrays sortieren k\u00f6nnen. Das Grundprinzip hier ist, in jedem Durchgang das Minimum des unsortierten Teils des Arrays zu suchen und dieses an den Anfang des unsortierten Teils zu bewegen. Der Grundalgorithmus des Selection-Sort ist dadurch nicht sehr kompliziert. Die Optimierung von Selection-Sort, n\u00e4mlich nicht nur das Minimum, sondern auch das Maximum in einem Durchlauf zu bestimmen, ist jedoch aufgrund des recht komplizierten \"Vertauschens\" der Werte bereits sehr schwer zu verstehen. Aber, wie gesagt, es gen\u00fcgt ja auch, wenn Sie Bubble-Sort vollst\u00e4ndig verstanden haben.","title":"Verbesserung von Selection-Sort"},{"location":"sortieren/#insertion-sort","text":"Dieser Sortier-Algorithmus (auch h\u00e4ufig Insert-Sort genannt) basiert auf einer Idee, die immer mit der Aufnahme eines Kartenspiels verglichen wird. Man nimmt eine Karte auf, steckt sie an die richtige Position, nimmt die n\u00e4chste Karte auf, steckt sie wieder an die richtige Position usw. Wir betrachten zun\u00e4chst erneut unser Beispiel: 55 07 78 12 42 wir beginnen mit dem Index 1 (nicht mit 0 - die erste \"Karte\", die 55 haben wir bereits \"auf der Hand\") die 7 ist kleiner als die 55 , deshalb \"stecken\" wir die 7 vor die 55 : 07 55 78 12 42 jetzt sind die ersten beiden Elemente sortiert wir setzen mit dem Index 2 fort die 78 ist gr\u00f6\u00dfer als die 7 und gr\u00f6\u00dfer als die 55 , deshalb lassen wir die 78 dort, wo sie ist 07 55 78 12 42 jetzt sind die ersten drei Elemente sortiert wir setzen mit dem Index 3 fort die 12 ist gr\u00f6\u00dfer als die 7 , aber kleiner als die 55 , deshalb \"stecken\" wir die 12 zwischen die 7 und die 55 die bereits sortierten Werte 55 und 78 \"rutschen\" um eins nach rechts 07 12 55 78 42 jetzt sind die ersten vier Elemente sortiert wir setzen mit dem Index 4 fort die 42 ist gr\u00f6\u00dfer als die 7 und gr\u00f6\u00dfer als die 12 , aber kleiner als die 55 , deshalb \"stecken\" wir die 42 zwischen die 12 und die 55 die bereits sortierten Werte 55 und 78 \"rutschen\" um eins nach rechts die bereits sortierten Werte 55 und 78 \"rutschen\" um eins nach rechts 07 12 42 55 78 Index 5 gibt es nicht, wir sind am Ende des Arrays angelangt das Array ist sortiert Hier noch ein Bild, das den Insertion-Sort-Algorithmus an einem anderen Beispiel verdeutlicht: Wir n\u00e4hern uns wieder der algorithmischen Idee von Insertion-Sort an. Wir wollen eine Methode insertionsort() schreiben, f\u00fcr die folgendes gilt: Parameter : unsortiertes Array a R\u00fcckgabe : sortiertes Array b Vorgehen : gedachte Teilung des Arrays in 2 Teile: linker Teil: sortiert rechter Teil: unsortiert \u2794 anfangs: linker Teil = b[0] - d.h. nur erstes Element sortiert erstes unsortiertes Element b[i] f\u00fcr i > 0 , betrachten durch Vergleichen und Verschieben an der richtigen Stelle in das sortierte Array b[0] ,\u2026, b[i-1] einf\u00fcgen \u2794 rechter unsortierter Teil des Arrays b[i+1] ,\u2026, b[n-1] wird um ein Element kleiner ( n ist L\u00e4nge des Arrays), \u2794 linker sortierter Teil w\u00e4chst um ein Element b[j] so verfahren, bis linker Teil das gesamte Array ist und der \"rechte\" Teil leer Eine m\u00f6gliche Implementierung von Insertion-Sort: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public static int [] insertionsort ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int index = 1 ; index < b . length ; index ++ ) // das Element von index soll an die richtige { // Position <= index eingefuegt werden int indexLinks = 0 ; while ( indexLinks < index && b [ indexLinks ] < b [ index ] ) { indexLinks ++ ; } /* * jetzt muss der Wert von b[index] an die Stelle von indexLinks eingefuegt werden * dazu muessen alle Elemente von indexLinks bis index-1 um eins nach rechts geschoben * werden * wir merken uns dazu b[index] und schieben dann alle Elemente: * b[index-1] nach b[index] * b[index-2] nach b[index-1] * ... * b[indexLinks] nach b[indexLinks+1] */ int tmp = b [ index ] ; for ( int indexInsert = index ; indexInsert > indexLinks ; indexInsert -- ) { b [ indexInsert ] = b [ indexInsert - 1 ] ; } b [ indexLinks ] = tmp ; } return b ; } die \u00e4u\u00dfere for -Schleife (Zeile 5 ) legt den aktuellen index f\u00fcr das Element fest, das wir betrachten und korrekt links daneben einf\u00fcgen wollen die while -Schleife (Zeilen 8-11 ) sucht im linken Teil (links von index ) nach dem ersten Element, das einen gr\u00f6\u00dferen Wert hat, als der aktuell einzuf\u00fcgende Wert b[index] . ist die while -Schleife verlassen (nach Zeile 11 ), gibt der Wert in indexLinks die Position an, an die der einzuf\u00fcgende Wert eingef\u00fcgt werden soll \u2794 dann m\u00fcssen wir alle Elemente von indexLinks , indexLinks+1 , indexLinks+2 , ... , index-2 , index-1 um eins nach rechts verschieben. Dazu schauen wir uns zun\u00e4chst die folgenden Abbildungen an: Angenommen, wir haben das Array aus der Abbildung. Die Elemente 3 , 6 , 7 , 8 sind bereits sortiert. Der aktuelle index ist 4 und wir haben ermittelt, dass indexLinks==1 ist, dass wir also die 4 an die zweite Poition im Array einf\u00fcgen wollen. Dazu muss die 9 auf den index==4 geschoben werden, die 7 auf den Index 3 und die 6 auf den Index 2 . Damit wir den Wert 4 nicht \u00fcberschreiben, m\u00fcssen wir ihn in einer Variablen zwischenspeichern. Jetzt k\u00f6nnen wir die Werte nach rechts verschieben. Angenommen, wir erstellen uns einen indexInsert (siehe Zeile 23 oben), der initial den Wert index (also 4 ) hat. Dann schieben wir den Wert 9 mithilfe von b[indexInsert] = b[indexInsert-1]; vom Index 3 nach Index 4 . Wenn wir dann indexInsert um 1 reduzieren (Zeile 23 oben), dann wird durch das n\u00e4chste b[indexInsert] = b[indexInsert-1]; der Wert 7 vom Index 2 nach Index 3 geschoben. Zuletzt noch die 6 von Index 2 nach Index 3 . Dann haben wir indexLinks erreicht. Jetzt muss nur noch der zwischengespeicherte Wert aus tmp nach b[indexLinks] geschrieben werden (Zeile 27 oben) und der Wert 4 wurde korrekt eingef\u00fcgt und es kann mit dem Index 5 weitergehen. Wir f\u00fcgen zum besseren Verst\u00e4ndnis des Algorithmus wieder Ausgaben in unsere Methode ein. Die erste Zeile enth\u00e4lt das Ausgangsarray: --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 1 , aktueller Wert = 45 , wird eingef\u00fcgt an Index = 1 --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 2 , aktueller Wert = 31 , wird eingef\u00fcgt an Index = 1 --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 3 , aktueller Wert = 40 , wird eingef\u00fcgt an Index = 2 --> [ 30 , 31 , 45 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 4 , aktueller Wert = 35 , wird eingef\u00fcgt an Index = 2 --> [ 30 , 31 , 40 , 45 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 5 , aktueller Wert = 33 , wird eingef\u00fcgt an Index = 2 --> [ 30 , 31 , 35 , 40 , 45 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 6 , aktueller Wert = 0 , wird eingef\u00fcgt an Index = 0 --> [ 30 , 31 , 33 , 35 , 40 , 45 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 7 , aktueller Wert = 25 , wird eingef\u00fcgt an Index = 1 --> [ 0 , 30 , 31 , 33 , 35 , 40 , 45 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 8 , aktueller Wert = 25 , wird eingef\u00fcgt an Index = 1 --> [ 0 , 25 , 30 , 31 , 33 , 35 , 40 , 45 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 9 , aktueller Wert = 30 , wird eingef\u00fcgt an Index = 3 --> [ 0 , 25 , 25 , 30 , 31 , 33 , 35 , 40 , 45 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 10 , aktueller Wert = 39 , wird eingef\u00fcgt an Index = 8 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 40 , 45 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 11 , aktueller Wert = 41 , wird eingef\u00fcgt an Index = 10 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 45 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 12 , aktueller Wert = 1 , wird eingef\u00fcgt an Index = 1 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 13 , aktueller Wert = 18 , wird eingef\u00fcgt an Index = 2 --> [ 0 , 1 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 14 , aktueller Wert = 6 , wird eingef\u00fcgt an Index = 2 --> [ 0 , 1 , 18 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 15 , aktueller Wert = 24 , wird eingef\u00fcgt an Index = 4 --> [ 0 , 1 , 6 , 18 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 24 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 16 , aktueller Wert = 33 , wird eingef\u00fcgt an Index = 10 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 33 , 30 , 27 , 36 , 30 ] Aktueller Index = 17 , aktueller Wert = 30 , wird eingef\u00fcgt an Index = 7 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 30 , 27 , 36 , 30 ] Aktueller Index = 18 , aktueller Wert = 27 , wird eingef\u00fcgt an Index = 7 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 27 , 36 , 30 ] Aktueller Index = 19 , aktueller Wert = 36 , wird eingef\u00fcgt an Index = 15 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 27 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 36 , 30 ] Aktueller Index = 20 , aktueller Wert = 30 , wird eingef\u00fcgt an Index = 8 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 27 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 36 , 39 , 40 , 41 , 45 , 30 ] Hier noch einmal nur das Array. Man sieht, dass sich, im Gegensatz zu den vorherigen Algorithmen, kein fertig sortierter Teil ausbreitet, da die Elemente auch am Ende noch ganz nach vorne eingef\u00fcgt werden k\u00f6nnen. --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 1 --> [ 30 , 45 , 31 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 2 --> [ 30 , 31 , 45 , 40 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 3 --> [ 30 , 31 , 40 , 45 , 35 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 4 --> [ 30 , 31 , 35 , 40 , 45 , 33 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 5 --> [ 30 , 31 , 33 , 35 , 40 , 45 , 0 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 6 --> [ 0 , 30 , 31 , 33 , 35 , 40 , 45 , 25 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 7 --> [ 0 , 25 , 30 , 31 , 33 , 35 , 40 , 45 , 25 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 8 --> [ 0 , 25 , 25 , 30 , 31 , 33 , 35 , 40 , 45 , 30 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 9 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 40 , 45 , 39 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 10 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 45 , 41 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 11 --> [ 0 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 1 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 12 --> [ 0 , 1 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 18 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 13 --> [ 0 , 1 , 18 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 6 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 14 --> [ 0 , 1 , 6 , 18 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 24 , 33 , 30 , 27 , 36 , 30 ] // Index 15 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 31 , 33 , 35 , 39 , 40 , 41 , 45 , 33 , 30 , 27 , 36 , 30 ] // Index 16 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 30 , 27 , 36 , 30 ] // Index 17 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 27 , 36 , 30 ] // Index 18 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 27 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 39 , 40 , 41 , 45 , 36 , 30 ] // Index 19 --> [ 0 , 1 , 6 , 18 , 24 , 25 , 25 , 27 , 30 , 30 , 30 , 31 , 33 , 33 , 35 , 36 , 39 , 40 , 41 , 45 , 30 ] // Index 20 Auch f\u00fcr den Insertion-Sort-Algorithmus gibt es Optimierungsvorschl\u00e4ge, von denen wir hier aber keine betrachten wollen. Wir werden uns noch einen letzten Sortier-Algorithmus anschauen, der allerdings ein wenig komplizierter auf den ersten Blick aussieht, der Merge-Sort-Algorithmus.","title":"Insertion-Sort"},{"location":"sortieren/#merge-sort","text":"In Merge-Sort kommt ein v\u00f6llig neues Konzept hinzu, das wir noch gar nicht kennen. Es handelt sich um Rekursion . In der Programmierung spricht man von Rekursion , wenn sich eine Methode selbst wieder aufruft.","title":"Merge-Sort"},{"location":"sortieren/#rekursion","text":"Ruft sich eine Methode selbst wieder auf, sprechen wir von Rekursion (latein recurrere \u201ezur\u00fccklaufen\u201c). Das Prinzip kennen wir schon aus der Mathematik - das klassische Beispiel ist die Definition der Fakult\u00e4t: Diese Funktion ist rekursiv definiert, d.h. in der Definition f\u00fcr Fakult\u00e4t wird selbst wieder die Fakult\u00e4t verwendet ( n! = n * (n-1)! ). Beachten Sie, dass es eine Abbruchbedingung f\u00fcr die Rekursion gibt, n\u00e4mlich hier 1! = 1 , d.h. es gibt einen (oder mehrere) Wert(e) ( n <= 1 ), f\u00fcr den kein rekursicher Aufruf (keine rekursive Defintion) verwendet wird. Als Implementierung sieht diese Funktion so aus: 1 2 3 4 5 6 7 8 9 public static int fakultaet ( int n ) { int fak = 1 ; if ( n > 1 ) { fak = n * fakultaet ( n - 1 ); } return fak ; } F\u00fcr n>1 wird also erneut die Methode aufgerufen, wobei der Parameterwert um 1 rediziert wird und sich somit der Abbruchbedingung (dem Rekursionsende) ann\u00e4hert. Wir betrachten einmal den Methodenstack bei der Ausf\u00fchrung der Methode f\u00fcr den Aufruf von fakultaet(5) : Beginnend, mit fakultatet(5) (links oben) wird im Ausdruck 5 * fakulatet(4) die Methode fakultatet(4) aufgerufen. Darin gibt es den Ausdruck 4 * fakulatet(3) , so dass dort fakultaet(3) aufgerufen wird usw. bis zum Aufruf von fakulaet(1) . Dieser Aufruf gibt 1 zur\u00fcck. Damit wird die Ausf\u00fchrung der Methode fakultaet(1) beendet und wir landen im Stack zur\u00fcck beim Aufruf von fakultaet(2) . Darin wird nun 2 * 1 zur\u00fcckgegeben, also 2 und wir landen im Stack zur\u00fcck beim Aufruf von fakultaet(3) . Darin wird nun 3 * 2 zur\u00fcckgegeben, also 6 usw. bis der Aufruf von fakultaet(5) die 5 * 24 , also 120 zur\u00fcckgibt. Das ist der Wert, dem der Aufruf von fakultaet(5) entspricht. Mit Rekursion kann nicht mehr berechnet werden als mit Iteration, d.h. die Rekursion ist kein m\u00e4chtigeres Konzept als die Iteration. Alles, was mit Iteration geht, geht auch mit Rekursion und umgedreht. Manchmal sind die Algorithmen aber als Rekursion leichter zu implementieren als ohne. Beispiele daf\u00fcr sind gebeOrdnerstrukturAus(ordnerOderDatei) wenn Datei , dann Ende wenn Ordner , dann alle Unterordner ermitteln und f\u00fcr alle Unterordner: gebeOrdnerstrukturAus(unterOrdner) gebeBaumAus(knoten) wenn Blatt , dann Ende sonst: ermittle linkes und rechtes Kind des Knotens und rufe auf: gebeBaumAus(linkesKind) gebeBaumAus(rechtesKind)","title":"Rekursion"},{"location":"sortieren/#merge-sort-rekursiv","text":"Der Merge-Sort-Algorithmus geh\u00f6rt zu den Algorithmen, die rekursiv besser zu implementieren sind, als iterativ. Das liegt daran, dass Merge-Sort auf dem sogenannten Divide-and-Conquer -Prinzip basiert. Dieses Prinzip ist eine rekursive Programmiertechnik, in dem ein gro\u00dfes Problem in gleichartige, aber einfachere Teilprobleme zerlegt wird. Das Grundprinzip bei Divide-and-Conquer ist wie folgt: Bestimme ein Ma\u00df f\u00fcr die Gr\u00f6\u00dfe des Problems (z.B. Gr\u00f6\u00dfe des Arrays) Finde eine kleinere Gr\u00f6\u00dfe, f\u00fcr das Problem einfach zu l\u00f6sen ist (z.B. kleinere Arrays) L\u00f6se die kleineren Probleme und f\u00fcge die L\u00f6sungen so zusammen, dass sich die L\u00f6sung des gro\u00dfen Problems ergibt Bei Merge-Sort sieht das so aus: teile den Datensatz (meistens einfach halbieren) sortiere beide Datens\u00e4tze f\u00fcge sie zusammen (einsortieren der Gr\u00f6\u00dfe nach) das Teilen erfolgt dabei so lange, bis der kleine Datensatz meistens nur noch aus einem einzigen Datum besteht Wir betrachten ein konkretes Beispiel. Angenommen, wir wollen das Array { 2, 4, 1, 6, 8, 5, 3, 7 } mithilfe von Merge-Sort sortieren: Dann zerlegen wir das Ausgangsarray zun\u00e4chst so lange, bis die einzelnen Arrays nur noch jeweils ein Element enthalten: Das Teilen ist also einfach, wir ermitteln einfach immer die Mitte ( mid ) des Ausgangsarrays ( a ) und zwerlegen das Ausgangsarray dann in einen linken und in einen rechten Teil: public int [] mergesort ( int [] a ) { int [] b = copy ( a ); if ( b . length > 1 ) { int mid = b . length / 2 ; /* * linken Teil von b in neues Array left kopieren */ int [] left = new int [ mid ] ; for ( int index = 0 ; index < mid ; index ++ ) { left [ index ] = b [ index ] ; } /* * rechten Teil von b in neues Array rechts kopieren */ int [] right = new int [ b . length - mid ] ; for ( int index = mid ; index < b . length ; index ++ ) { right [ index - mid ] = b [ index ] ; } /* * jetzt haben wir zwei Arrays: left und right * diese sollen jetzt mithilfe von mergesort() * sortiert werden * dazu rufen wir mergesort f\u00fcr Array left * und mergesort f\u00fcr Array right * auf. Wir bekommen sie sortiert zur\u00fcck. * * Die Methode ruft sich selber wieder auf --> * das nennen wir Rekursion * */ left = mergesort ( left ); // hier der rekursive Aufruf fuer left right = mergesort ( right ); // hier der rekursive Aufruf fuer right /* * jetzt sind left und right jeweils sortiert * jetzt \"mergen\" wir sie so, dass insgesamt * ein sortiertes Array entsteht, d.h. wir * nehmen immer ein Element aus left und right und * vergleichen sie miteinander; das kleinere kommt * nach b, das gr\u00f6\u00dfere bleibt noch und wir * nehmen aus dem Array, aus dem gerade das Element * einsortiert wurde, ein neues Element */ /* kommt gleich - siehe unten */ Das Zusammenf\u00fcgen ( merge ) ist bei Merge-Sort komplizierter - deshalb Merge-Sort . Aus dem linken und aus dem rechten Array werden jetzt jeweils die ersten Elemente betrachtet und miteinander verglichen. Das kleinere von beiden kommt in das \"zusammengesetzte\" ( merged ) Array, das so nach und nach sortiert w\u00e4chst. /* * jetzt sind left und right jeweils sortiert * jetzt \"mergen\" wir sie so, dass insgesamt * ein sortiertes Array entsteht, d.h. wir * nehmen immer ein Element aus left und right und * vergleichen sie miteinander; das kleinere kommt * nach b, das gr\u00f6\u00dfere bleibt noch und wir * nehmen aus dem Array, aus dem gerade das Element * einsortiert wurde, ein neues Element */ int indexLeft = 0 ; int indexRight = 0 ; int indexB = 0 ; /* * merge von left und right * solange noch in einem Elemente sind */ while ( indexLeft < left . length && indexRight < right . length ) { if ( left [ indexLeft ] < right [ indexRight ] ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; } else { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; } indexB ++ ; } /* * jetzt ist left oder right leer, aber in dem * jeweils anderen sind noch Elemente */ /* * falls noch in left Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexLeft < left . length ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; indexB ++ ; } /* * falls noch in right Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexRight < right . length ) { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; indexB ++ ; } } return b ; } Insgesamt sieht die Implementierung von Merge-Sort also so aus: mergesort(int[] a) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 public static int [] mergesort ( int [] a ) { int [] b = copy ( a ); if ( b . length > 1 ) { int mid = b . length / 2 ; /* * linken Teil von b in neues Array left kopieren */ int [] left = new int [ mid ] ; for ( int index = 0 ; index < mid ; index ++ ) { left [ index ] = b [ index ] ; } /* * rechten Teil von b in neues Array rechts kopieren */ int [] right = new int [ b . length - mid ] ; for ( int index = mid ; index < b . length ; index ++ ) { right [ index - mid ] = b [ index ] ; } /* * jetzt haben wir zwei Arrays: left und right * diese sollen jetzt mithilfe von mergesort() * sortiert werden * dazu rufen wir mergesort f\u00fcr Array left * und mergesort f\u00fcr Array right * auf. Wir bekommen sie sortiert zur\u00fcck. * * Die Methode ruft sich selber wieder auf --> * das nennen wir Rekursion * */ left = mergesort ( left ); right = mergesort ( right ); /* * jetzt sind left und right jeweils sortiert * jetzt \"mergen\" wir sie so, dass insgesamt * ein sortiertes Array entsteht, d.h. wir * nehmen immer ein Element aus left und right und * vergleichen sie miteinander; das kleinere kommt * nach b, das gr\u00f6\u00dfere bleibt noch und wir * nehmen aus dem Array, aus dem gerade das Element * einsortiert wurde, ein neues Element */ int indexLeft = 0 ; int indexRight = 0 ; int indexB = 0 ; /* * merge von left und right * solange noch in einem Elemente sind */ while ( indexLeft < left . length && indexRight < right . length ) { if ( left [ indexLeft ] < right [ indexRight ] ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; } else { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; } indexB ++ ; } /* * jetzt ist left oder right leer, aber in dem * jeweils anderen sind noch Elemente */ /* * falls noch in left Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexLeft < left . length ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; indexB ++ ; } /* * falls noch in right Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexRight < right . length ) { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; indexB ++ ; } } return b ; } Sortieren.java package themen.arrays.sortieren ; import java.util.Random ; public class Sortieren { /* * aus Skript */ public static void printArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } System . out . println ( s ); } /* * angepasste printArray-Methode * hier wird davon ausgegangen, dass die Zahlen * in dem Array nie gr\u00f6\u00dfer als zweistellig sind * ist haupts\u00e4chlich, damit die Ausgaben der Arrays besser * miteinander verglichen werden k\u00f6nnen auf der Konsole * */ public static void print ( int [] a ) { String s = \"--> [ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + String . format ( \"%2d, \" , a [ index ] ); } if ( a . length > 0 ) { s = s + String . format ( \"%2d ]\" , a [ a . length - 1 ] ); } System . out . println ( s ); } /* * aus Skript */ public static int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } public static int [] copy ( int [] a ) { int [] b = new int [ a . length ] ; for ( int index = 0 ; index < b . length ; index ++ ) { b [ index ] = a [ index ] ; } return b ; } public static int [] bubblesortDebug ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = copy ( a ); System . out . print ( \"ori-\" ); print ( b ); // Ausgangs-Array System . out . println (); /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { System . out . printf ( \"%3d. Bubble-Phase : %n----\" , bubble ); print ( b ); swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; System . out . printf ( \"%3d \" , index ); print ( b ); } } System . out . println (); } return b ; } public static int [] bubblesort ( int [] a ) { /* * zuerst a nach b kopieren */ int [] b = copy ( a ); /* * jetzt b sortieren * aeussere for-Schleife: Bubble-Phasen * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen */ boolean swapped = true ; for ( int bubble = 1 ; bubble <= b . length - 1 && swapped ; bubble ++ ) { swapped = false ; for ( int index = 0 ; index < b . length - bubble ; index ++ ) { if ( b [ index ] > b [ index + 1 ] ) { int tmp = b [ index + 1 ] ; b [ index + 1 ] = b [ index ] ; b [ index ] = tmp ; swapped = true ; } } } return b ; } public static int [] selectionsortDebug ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck System . out . print ( \" original -----\" ); print ( b ); // Ausgangs-Array System . out . println (); for ( int durchlauf = 0 ; durchlauf < b . length ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { System . out . printf ( \"%3d. Durchlauf - kleinstes Element soll auf den index %2d %n----> \" , durchlauf + 1 , durchlauf ); int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes for ( int index = durchlauf ; index < b . length ; index ++ ) // Suche nach dem kleinsten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } } System . out . printf ( \"kleinster Wert ist %3d auf dem Index %3d %n\" , minValue , minIndex ); System . out . printf ( \"%13s : \" , \"vor Tausch \" ); print ( b ); // jetzt den kleinsten Wert auf den Index durchlauf legen // der Wert, der auf durchlauf lag, kommt nach minIndex int tmp = b [ durchlauf ] ; b [ durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmp ; System . out . printf ( \"%13s : \" , \"nach Tausch \" ); print ( b ); System . out . println (); } return b ; } public static int [] selectionsort ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int durchlauf = 0 ; durchlauf < b . length ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes for ( int index = durchlauf ; index < b . length ; index ++ ) // Suche nach dem kleinsten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } } // jetzt den kleinsten Wert auf den Index durchlauf legen // der Wert, der auf durchlauf lag, kommt nach minIndex int tmp = b [ durchlauf ] ; b [ durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmp ; } return b ; } public static int [] insertionsort ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck for ( int index = 1 ; index < b . length ; index ++ ) // das Element von index soll an die richtige { // Position <= index eingefuegt werden int indexLinks = 0 ; while ( indexLinks < index && b [ indexLinks ] < b [ index ] ) { indexLinks ++ ; } /* * jetzt muss der Wert von b[index] an die Stelle von indexLinks eingefuegt werden * dazu muessen alle Elemente von indexLinks bis index-1 um eins nach rechts geschoben * werden * wir merken uns dazu b[index] und schieben dann alle Elemente: * b[index-1] nach b[index] * b[index-2] nach b[index-1] * ... * b[indexLinks] nach b[indexLinks+1] */ int tmp = b [ index ] ; for ( int indexInsert = index ; indexInsert > indexLinks ; indexInsert -- ) { b [ indexInsert ] = b [ indexInsert - 1 ] ; } b [ indexLinks ] = tmp ; } return b ; } public static int [] insertionsortDebug ( int [] a ) { int [] b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck print ( b ); // Ausgangs-Array System . out . println (); for ( int index = 1 ; index < b . length ; index ++ ) // das Element von index soll an die richtige { // Position <= index eingefuegt werden int indexLinks = 0 ; while ( indexLinks < index && b [ indexLinks ] < b [ index ] ) { indexLinks ++ ; } System . out . printf ( \"Aktueller Index=%3d, aktueller Wert=%3d, wird eingef\u00fcgt an Index=%3d%n\" , index , b [ index ] , indexLinks ); print ( b ); System . out . println (); /* * jetzt muss der Wert von b[index] an die Stelle von indexLinks eingefuegt werden * dazu muessen alle Elemente von indexLinks bis index-1 um eins nach rechts geschoben * werden * wir merken uns dazu b[index] und schieben dann alle Elemente: * b[index-1] nach b[index] * b[index-2] nach b[index-1] * ... * b[indexLinks] nach b[indexLinks+1] */ int tmp = b [ index ] ; for ( int indexInsert = index ; indexInsert > indexLinks ; indexInsert -- ) { b [ indexInsert ] = b [ indexInsert - 1 ] ; } b [ indexLinks ] = tmp ; } return b ; } public static int [] selectionsortOptimiert ( int [] a ) { int [] b = new int [ 0 ] ; if ( a . length > 1 ) { b = copy ( a ); // copy erzeugt eine Kopie von a und gibt diese zurueck System . out . print ( \" \" ); print ( b ); // Ausgangs-Array for ( int durchlauf = 0 ; durchlauf < b . length / 2 ; durchlauf ++ ) // durchlauf ist in Vorgehen j (siehe oben) { int minValue = b [ durchlauf ] ; // in minValue merken wir uns den aktuell kleinsten Wert int minIndex = durchlauf ; // in minIndex merken wir uns den Index des aktuell kleinsten Wertes int maxValue = b [ b . length - 1 - durchlauf ] ; // in maxValue merken wir uns den aktuell groessten Wert int maxIndex = b . length - 1 - durchlauf ; // in maxIndex merken wir uns den Index des aktuell groessten Wertes System . out . printf ( \"%3d %3d %3d %3d %3d %n\" , durchlauf , minValue , minIndex , maxValue , maxIndex ); for ( int index = durchlauf ; index < b . length - durchlauf ; index ++ ) // Suche nach dem kleinsten UND groessten Wert { if ( minValue > b [ index ] ) { minValue = b [ index ] ; // aktuell kleinster Wert minIndex = index ; // aktueller Index des kleinsten Wertes } if ( maxValue < b [ index ] ) { maxValue = b [ index ] ; // aktuell groesster Wert maxIndex = index ; // aktueller Index des groessten Wertes } } /* * jetzt den kleinsten Wert auf den Index durchlauf legen * der Wert, der auf durchlauf lag, kommt nach minIndex * UND den groessten Wert auf den Index b.length-1-durchlauf legen * der Wert, der auf b.length-1-durchlauf lag, kommt nach maxIndex * wir m\u00fcssen zun\u00e4chst aber beide Werte sichern, sonst kann es zu * Konflikten beim Tauschen kommen! * */ System . out . printf ( \"%3d %3d %3d %3d %3d \" , durchlauf , minValue , minIndex , maxValue , maxIndex ); int tmpMin = b [ durchlauf ] ; int tmpMax = b [ b . length - 1 - durchlauf ] ; b [ durchlauf ] = minValue ; b [ minIndex ] = tmpMin ; /* * hier wird es sehr kompliziert * wenn der MaximumWert dort war, wo das neue Minimum hin kommt (Index durchlauf), * dann m\u00fcssen wir aufpassen, dass wir den alten Wert tmpMax nicht verlieren * es sind jetzt nur noch 3 Werte im Spiel * der alte Wert von durchlauf - ist in tmpMin UND ist gleichzeitig maxValue! * der alte Wert von length-1-durchlauf - ist in tmpMax * der alte Wert von minIndex ist minValue und jetzt auf durchlauf * Versuchen Sie es mal ohne die Bedingung und nur * b[b.length-1-durchlauf] = maxValue; * b[maxIndex] = tmpMax; * dann sehen Sie den Fehler */ if ( maxIndex == durchlauf ) { b [ b . length - 1 - durchlauf ] = b [ minIndex ] ; b [ minIndex ] = tmpMax ; } else { b [ b . length - 1 - durchlauf ] = maxValue ; b [ maxIndex ] = tmpMax ; } print ( b ); } } return b ; } public static int [] mergesort ( int [] a ) { int [] b = copy ( a ); if ( b . length > 1 ) { int mid = b . length / 2 ; /* * linken Teil von b in neues Array left kopieren */ int [] left = new int [ mid ] ; for ( int index = 0 ; index < mid ; index ++ ) { left [ index ] = b [ index ] ; } /* * rechten Teil von b in neues Array rechts kopieren */ int [] right = new int [ b . length - mid ] ; for ( int index = mid ; index < b . length ; index ++ ) { right [ index - mid ] = b [ index ] ; } /* * jetzt haben wir zwei Arrays: left und right * diese sollen jetzt mithilfe von mergesort() * sortiert werden * dazu rufen wir mergesort f\u00fcr Array left * und mergesort f\u00fcr Array right * auf. Wir bekommen sie sortiert zur\u00fcck. * * Die Methode ruft sich selber wieder auf --> * das nennen wir Rekursion * */ left = mergesort ( left ); right = mergesort ( right ); /* * jetzt sind left und right jeweils sortiert * jetzt \"mergen\" wir sie so, dass insgesamt * ein sortiertes Array entsteht, d.h. wir * nehmen immer ein Element aus left und right und * vergleichen sie miteinander; das kleinere kommt * nach b, das gr\u00f6\u00dfere bleibt noch und wir * nehmen aus dem Array, aus dem gerade das Element * einsortiert wurde, ein neues Element */ int indexLeft = 0 ; int indexRight = 0 ; int indexB = 0 ; /* * merge von left und right * solange noch in einem Elemente sind */ while ( indexLeft < left . length && indexRight < right . length ) { if ( left [ indexLeft ] < right [ indexRight ] ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; } else { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; } indexB ++ ; } /* * jetzt ist left oder right leer, aber in dem * jeweils anderen sind noch Elemente */ /* * falls noch in left Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexLeft < left . length ) { b [ indexB ] = left [ indexLeft ] ; indexLeft ++ ; indexB ++ ; } /* * falls noch in right Elemente sind, werden sie * jetzt nach b kopiert */ while ( indexRight < right . length ) { b [ indexB ] = right [ indexRight ] ; indexRight ++ ; indexB ++ ; } } return b ; } public static int fakultaet ( int n ) { int fak = 1 ; if ( n > 1 ) { fak = n * fakultaet ( n - 1 ); } return fak ; } public static void main ( String [] args ) { int [] unsorted = createAndFillArray ( 21 , 50 ); System . out . printf ( \"%n%n--------------- bubblesort ----------------------%n%n\" ); int [] sorted = bubblesort ( unsorted ); printArray ( unsorted ); printArray ( sorted ); System . out . printf ( \"%n%n--------------- selectionsort ----------------------%n%n\" ); int [] us = { 1 , 12 , 41 , 35 , 49 , 2 , 28 , 38 , 21 , 35 , 41 , 12 , 21 , 29 , 27 , 17 , 5 , 6 , 18 , 3 }; sorted = selectionsortOptimiert ( unsorted ); printArray ( unsorted ); printArray ( sorted ); System . out . printf ( \"%n%n--------------- insertionsort ----------------------%n%n\" ); sorted = insertionsortDebug ( unsorted ); printArray ( unsorted ); printArray ( sorted ); System . out . printf ( \"%n%n--------------- mergesort ----------------------%n%n\" ); sorted = mergesort ( unsorted ); printArray ( unsorted ); printArray ( sorted ); System . out . println ( fakultaet ( 5 )); } }","title":"Merge-Sort rekursiv"},{"location":"sortieren/#quicksort","text":"Ein Sortier-Algorithmus, der ebenfalls auf dem Divide-and-Conquer -Prinzip berucht, ist Quicksort . Bei Quicksort ist, im Gegensatz zu Merge-Sort, das Teilen kompliziert und das Zusammenf\u00fcgen einfach. Die Methode sort() der Klasse Arrays verwendet Quicksort. Wir gehen hier aber aus Zeitgr\u00fcnden nicht weiter auf den Algroithmus ein. Sie k\u00f6nnen sich aber gerne dar\u00fcber selbst\u00e4ndig informieren. Es gibt viele Implementierungen und Erl\u00e4uterungen davon im Netz, z.B. hier , hier und hier .","title":"Quicksort"},{"location":"start/","text":"Was ist Programmieren? \u00b6 Zun\u00e4chst ein bisschen Motivation: 10 Gr\u00fcnde, Programmieren zu lernen und Bericht einer ehemaligen FIW-Studentin . Ehe wir uns weiter mit Java und Programmierkonzepten besch\u00e4ftigen, wollen wir uns bewusst werden, was Programmieren \u00fcberhaupt ist. Prinzipiell l\u00f6sen wir beim Programmieren ein Problem mithilfe einer Programmiersprache. Dabei stellt sich die Frage, welche Probleme mithilfe eines Computers l\u00f6sbar sind und welche nicht. Dazu gibt es umfangreiche theoretische Untersuchungen - viele davon werden Sie in den \"Grundlegenden Konzepten der Informatik\" diskutieren. Ein wesentlicher Begriff dabei ist Algorithmus . Ein Algorithmus ist eine eindeutige Handlungsvorschrift, die aus endlich vielen einzelnen Schritten besteht und ein Problem l\u00f6st. Algorithmen sind also auch Kochrezepte oder Bauanleitungen, wenn sie denn \"eindeutig\" sind. Wir kennen alle das Problem, dass Handlungsanweisungen nicht immer eindeutig sind - man kann es manchmal so oder so machen. In der Programmierung darf eine solche Mehrdeutigkeit nat\u00fcrlich nicht vorkommen. Der Algorithmusbegriff wurde deshalb detailliert und folgende Eigenschaften m\u00fcssen f\u00fcr eine Handlungsanweisung f\u00fcr einen Computer gelten, um ein Algorithmus zu sein: Finitheit Das Verfahren muss in einem endlichen Text (Programm) eindeutig beschreibbar sein. Ausf\u00fchrbarkeit Jeder einzelne Schritt des Verfahrens muss auch tats\u00e4chlich ausf\u00fchrbar sein. Dynamische Finitheit Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz ben\u00f6tigen. Terminierung Das Verfahren muss irgendwann enden, d.h. darf nur endlich viele Ausf\u00fchrungsschritte ben\u00f6tigen. Determiniertheit Das Verfahren muss bei denselben Voraussetzungen das gleiche Ergebnis liefern. Determinismus Die n\u00e4chste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt (in jedem Zustand) eindeutig definiert. Beispiel: Euklidischer Algorithmus \u00b6 Mit dem euklidischen Algorithmus 1 kann der gr\u00f6\u00dfte gemeinsame Teiler (ggT) zweier Zahlen berechnet werden. In seinen Elementen hat Euklid diesen Algorithmus ungef\u00e4hr so formuliert: Euklidischer Algorithmus Wenn CD aber AB nicht misst, und man nimmt bei AB, CD abwechselnd immer das kleinere vom gr\u00f6\u00dferen weg, dann muss (schlie\u00dflich) eine Zahl \u00fcbrig bleiben, die die vorangehende misst. Hm, das ist recht schwierig zu verstehen. Euklid betrachtet die beiden Zahlen, von denen der gr\u00f6\u00dfte gemeinsame Teiler ermittelt werden soll, als Strecken ( AB und CD ). Er zieht wiederholt die kleinere der beiden Strecken von der gr\u00f6\u00dferen ab. Er wiederholt dies solange, bis die beiden Strecken gleich lang sind - genauer: er wiederholt dies solange, solange die beiden Strecken nicht gleich lang sind ( ... CD aber AB nicht misst... ). Beispiel: ggT von 24 und 40 AB: 40, CD: 24, AB gr\u00f6\u00dfer als CD \u2192 40 - 24 = 16 AB: 16, CD: 24, CD gr\u00f6\u00dfer als AB \u2192 24 - 16 = 8 AB: 16, CD: 8, AB gr\u00f6\u00dfer als CD \u2192 16 - 8 = 8 AB: 8, CD: 8, AB gleich CD \u2192 Ende \u2192 ggT ist 8 Wir versuchen, den Algorithmus in eine verst\u00e4ndlichere und genauere Sprache zu \u00fcberf\u00fchren, ohne bereits eine Programmiersprache zu verwenden. Wir benutzen sogenannten Pseudocode : Angenommen, die beiden Zahlen, von denen wir den ggT berechnen wollen, sind a und b : 1 2 3 4 5 6 7 solange a ungleich b ist, wiederhole wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu wenn a gleich b ist, dann: a ( oder auch b ) ist der gesuchte ggT Wichtig ist, dass das Einr\u00fccken hier eine Bedeutung hat (eine Semantik ). In Zeile 1 formulieren wir, dass sich etwas wiederholen soll, solange eine bestimmte Bedingung gilt. Das, was sich wiederholen soll, ist in den Zeilen 2 bis 5 formuliert. Zeile 1 formuliert eine Schleife und in den Zeilen 2 - 5 befindet sich der Schleifeninhalt . Die Zeilen 2 - 5 formulieren ein eigenes Konstrukt, n\u00e4mlich eine Auswahl zwischen Alternativen, abh\u00e4ngig von einer Bedingung. Die Bedingung ist, ob a gr\u00f6\u00dfer ist als b . Wenn das der Fall ist, dann wird die Alternative ziehe b von a ab und weise das Ergebnis a zu ausgef\u00fchrt (In der Programmierung werden das sp\u00e4ter als a = a - b schreiben - das sieht f\u00fcr uns jetzt noch sehr \"falsch\" aus). Ist jedoch a nicht gr\u00f6\u00dfer als b , dann wird die Alternative ziehe a von b ab und weise das Ergebnis b zu ( b = b - a ) ausgef\u00fchrt. Ein solches Konstrukt wird Selektion (oder auch bedingte Alternative ) genannt. Nachdem entweder Zeile 3 oder Zeile 5 ausgef\u00fchrt wurde (es wird genau eins von beiden ausgef\u00fchrt), wird erneut in Zeile 1 gepr\u00fcft, ob a ungleich b ist. Wenn ja, wird die Selektion wiederholt. Wenn nicht, dann ist die Schleife beendet und Zeile 6 wird ausgef\u00fchrt. Die in Zeile 6 formulierte Bedingung wenn a gleich b ist , ist eigentlich unn\u00f6tig. Frage Warum ist die Bedingung wenn a gleich b ist in Zeile 6 unn\u00f6tig? Wir betrachten nochmals die im obigen Algorithmus betrachteten Konstrukte (wir sprechen vom Kontrollfluss von Anweisungen ): Iteration : die Schleife, die in Zeile 1 formuliert wird und die als Schleifeninhalt die Zeilen 2 - 5 hat, beschreibt einen iterativen (sich wiederholenden) Kontrollfluss . Selektion : die bedingte Alternative , die eine Bedingung pr\u00fcft (Zeile 2 ) und dann, je nachdem, ob die Bedingung richtig oder falsch ist, jeweils eine alternative Anweisung ausf\u00fchrt (entweder Zeile 3 oder Zeile 4 ), wird Selektion genannt (siehe Zeilen 2 - 5 ). Sequenz : die Anweisungen werden hintereinander ausgef\u00fchrt, erst Zeile 1 , dann Zeile 2 , dann entweder Zeile 3 oder Zeile 4 usw. Das Hintereinanderausf\u00fchren von Anweisungen wird Sequenz genannt. Schauen wir uns f\u00fcr unseren Algorithmus nochmal die Eigenschaften eines Algorithmus an: Finitheit unsere Beschreibung des Algorithmus ist endlich (siehe oben). Ausf\u00fchrbarkeit jeder einzelne Schritt kann ausgef\u00fchrt werden. Dynamische Finitheit \u00fcber den Speicherplatz k\u00f6nnen wir noch nicht viel sagen, aber wir m\u00fcssen nur einige wenige Zahlen speichern. Das sollte klappen. Terminierung Wann endet unser Algorithmus? Was muss gelten? Wissen wir, ob der Algorithmus irgendwann stoppt? Determiniertheit Es ist sicherlich nicht so leicht zu sehen, ob bei gleicher Eingabe (die Zahlen a und b ) auch stets der gleiche gr\u00f6\u00dfte gemneinsame Teiler berechnet wird. Dazu m\u00fcssten wir uns erstmal \u00fcberlegen, wie wir das pr\u00fcfen k\u00f6nnen. Determinismus Wir werden unseren Algorithmus nochmal an einem Beispiel durchspielen , um ein Gef\u00fchl daf\u00fcr zu bekommen, dass wir stets wissen, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Beispielzahlen f\u00fcr den euklidischen Algorithmus \u00b6 Wir nehmen die Zahlen a=40 und b=24 und spielen damit unseren Algorithmus durch: Zeile 1 : a (40) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von a-b ist 16. Der neue Wert von a ist 16. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist nicht gr\u00f6\u00dfer als b , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von b-a ist 8. Der neue Wert von b ist 8. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (8) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeile 5 ) Zeile 3 : das Ergebnis von a-b ist 8. Der neue Wert von a ist 8. Zeile 1 : wegen wiederhole (Iteration): a (8) ist nicht ungleich b (8) , also wird der Schleifeninhalt nicht ausgef\u00fchrt Zeile 6 : a (8) ist gleich b (8) Zeile 7 : der gesuchte ggT ist 8 Ende F\u00fcr dieses Beispiel war stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe a=40 und b=24 stets 8 ist. Fragen Was \u00e4ndert sich, wenn am Anfang a=24 und b=40 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=0 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=24 und b=24 sind? Beispiel: (3n+1)-Vermutung (Collatz-Problem) \u00b6 Wir betrachten noch einen weiteren Algorithmus: Als Eingabe bekommen wir eine positive nat\u00fcrliche Zahl, z.B. 5 . Der Algorithmus berechnet eine Folge von Zahlen und zwar nach folgender Vorschrift: ist die Zahl ungerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl mit 3 multipliziert und dann 1 addiert wird. Ist die Zahl gerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl durch 2 geteilt wird. Der Algorithmus stoppt, wenn der Nachfolger 1 ist. Angenommen, die eingegebene positive nat\u00fcrliche Zahl ist n : 1 2 3 4 5 solange n ungleich 1 ist, wiederhole wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Wir begeben uns also in eine Schleife und berechnen so lange einen Nachfolger f\u00fcr die Zahl bis der NAchfolger 1 ist. Betrachten wir den Algorithmus f\u00fcr die EIngabe von n=5 : Zeile 1 : n (5) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist ungerade , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von 3*5+1 ist 16 . Der neue Wert von n ist 16. Zeile 1 : wegen wiederhole (Iteration): n (16) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 16/2 ist 8 . Der neue Wert von n ist 8. Zeile 1 : wegen wiederhole (Iteration): n (8) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 8/2 ist 4 . Der neue Wert von n ist 4. Zeile 1 : wegen wiederhole (Iteration): n (4) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 4/2 ist 2 . Der neue Wert von n ist 2. Zeile 1 : wegen wiederhole (Iteration): n (2) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 2/2 ist 1 . Der neue Wert von n ist 1. Zeile 1 : wegen wiederhole (Iteration): n (1) ist nicht ungleich 1 , also wird der Schleifeninhalt nicht ausgef\u00fchrt Ende Auch f\u00fcr dieses Beispiel war erneut stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die Eingabe n=5 stets 1 ist. Fragen Spielen Sie den Algorithmus ruhig einmal f\u00fcr n=7 durch oder auch f\u00fcr andere n Denken Sie, dass der Algorithmus f\u00fcr jede beliebige positive nat\u00fcrliche Zahl n terminiert? Wenn ein Algorithmus f\u00fcr eine konkrete Eingabe stets ein eindeutiges Ergebnis (und zwar immer das gleiche) liefert, wie k\u00f6nnen dann Zufallszahlen berechnet werden? Success Wir haben ein Verst\u00e4ndnis \u00fcber den Algorithmus -Begriff erlangt und wissen, was Finitheit , Determiniertheit , Determinismus und Terminierung bedeuten. Programmablaufstrukturen \u00b6 Interessanterweise gibt es nur drei verschiedene Ablaufstrukturen in Programmen bzw. Algorithmen. Alle drei haben wir bereits verwendet. Mit Ablaufstrukturen meinen wir die Abarbeitungsreihenfolge von Anweisungen. Man sagt auch Kontrollfluss dazu. Die drei Ablaufstrukturen, die es gibt, sind: die Sequenz : die Anweisungen werden in sequenzieller Abfolge, d.h. hintereinander ausgef\u00fchrt die Iteration : die Abl\u00e4ufe werden wiederholt ausgef\u00fchrt, also in einer Schleife die Selektion : die Abl\u00e4ufe werden selektiv , d.h. unter einer bestimmten Bedingung ausgef\u00fchrt. Man nennt diese Struktur auch Verzweigung oder bedingte Alternative Wir schauen uns alle drei Kontrollstrukturen einmal genauer an. Die Sequenz \u00b6 Bei der Sequenz handelt es sich einfach um hintereinander ausgef\u00fchrte Anweisungen. Es wird stets erst die eine Anweisung vollst\u00e4ndig abgearbeitet, ehe die andere begonnen wird. Sequenz von 3 Anweisungen Anweisung1 Anweisung2 Anweisung3 Ein Beispiel (mit 2 Anweisungen) w\u00e4re: berechne 3 *n und weise das Ergebnis n zu berechne n+1 und weise das Ergebnis n zu Zur Visualisierung von Kontrollstrukturen werden auch sogannnte Programmablaufdiagramme oder Programmablaufpl\u00e4ne verwendet. F\u00fcr eine Sequenz s\u00e4he ein solches Ablaufdiagramm so aus: So ein Diagramm wird von oben nach unten gelesen. Es wird also erst Anweisung1 ausgef\u00fchrt, dann Anweisung2 und zuletzt Anweisung3 . Innerhalb einer Sequenz gilt immer single entry / single exit , d.h. keine der Anweisungen innerhalb einer Sequenz kann mehrere Ausg\u00e4nge oder mehrere Eing\u00e4nge haben. Es w\u00e4re ansonsten nicht-deterministisch und somit ein Versto\u00df gegen unseren Algorithmusbegriff. Die Iteration \u00b6 Bei der Iteration handelt es sich um eine wiederholte Ausf\u00fchrung einer Anweisung bzw. einer Sequenz von Anweisungen. Wie oft eine Iteration ausgef\u00fchrt wird, h\u00e4ngt von einer Bedingung ab. In der Programmierung sprechen wir bei der Iteration auch von einer Schleife . Bedingungen f\u00fcr eine solche Schleife haben wir bereits kennengelernt: solange a ungleich b ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt bzw. solange n ungleich 1 ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt Wichtig ist, dass es auch hier eine strikte Reihenfolge der Abarbeitung der Anweisungen gibt: es wird zun\u00e4chst gepr\u00fcft, ob die Bedingung erf\u00fcllt (wahr) ist, also ob z.B. a ungleich b ist oder ob n ungleich 1 . Wenn diese Bedingung erf\u00fcllt (also wahr) ist, dann werden die Anweisung(en) innerhalb der Schleife nacheinander (sequenziell) abgearbeitet. Erst wenn alle Anweisungen innerhalb der Schleife abgearbeitet wurden, wird die Schleifenbedingung erneut gepr\u00fcft. Ist sie wieder wahr, werden die Anweisungen innerhalb der Schleife erneut abgearbeitet usw. Ist sie nicht wahr, also wenn z.B. a gleich b ist oder n gleich 1 ist , dann wird die Schleife beendet und die Anweisungen innerhalb der Schleife nicht (erneut) abgearbeitet. Das Ablaufdiagramm einer Schleife (Iteration) sieht so aus: Die eigentliche Iteration ist gr\u00fcn dargestellt. Wir kommen von einer anderen Anweisung und pr\u00fcfen die Bedingung. Ist sie wahr, wird Anweisung1 ausgef\u00fchrt. Beachte Anweisung1 muss nicht zwingend nur genau eine Anweisung sein. Bei Anweisung1 kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder sogar selbst um eine Iteration (Schleife in der Schleife - verschachtelte Schleife) handeln! Nach jeder Ausf\u00fchrung von Anweisung1 wird die Bedingung erneut gepr\u00fcft. Ist sie (immernoch) wahr, wird Anweisung1 erneut ausgef\u00fchrt. Ist die Bedingung jedoch falsch, dann wird Anweisung1 nicht (mehr) ausgef\u00fchrt, sondern die Schleife wird verlassen und die Anweisung, die der Schleife folgt, wird ausgef\u00fchrt ( Anweisung2 ) oder das Programm ist dann zu Ende. Beachte Es kann sein, dass Anweisung1 gar nicht ausgef\u00fchrt wird, weil die Bedingung bereits bei der ersten Pr\u00fcfung falsch ist. Es ist also nicht gesagt, dass sich eine Iteration wirklich wiederholt . Es kann sein, dass Anweisung1 gar nicht oder nur genau ein Mal ausgef\u00fchrt wird (wenn die Bedingung nach der ersten Ausf\u00fchrung falsch ist). Das ist kein Problem! Ein Problem ist es jedoch, wenn die Bedingung niemals falsch wird und die Schleife unendlich oft hintereinander ausgef\u00fchrt wird. Das ist ein Versto\u00df gegen die Terminierung eines Algorithmus. In einem solchen Fall werden wir irgendwann einen Fehler bei der Programmausf\u00fchrung erhalten (aber erst zur Ausf\u00fchrungszeit, nicht bereits beim Compilieren). Wir werden uns ausf\u00fchrlich mit Schleifen auseinandersetzen, da sie logisch recht anspruchsvoll und dadurch h\u00e4ufig fehleranf\u00e4llig sein k\u00f6nnen. Die Selektion \u00b6 Bei der Selektion handelt es sich, im Gegensatz zur Iteration, um eine einmalige Ausf\u00fchrung einer (oder mehrerer) Anweisung(en). Jedoch ist diese Ausf\u00fchrung, im Gegensatz zur Sequenz, von einer Bedingung abh\u00e4ngig. Wir hatten eine solche Selektion jeweils in obigen Beispielalgorithmen. Selektion aus dem euklidischen Algorithmus: wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu Selektion aus der (3n+1)-Vermutung (dem Collatz-Problem): wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Es gibt also immer eine Bedingung (z.B. wenn a gr\u00f6\u00dfer ist als b ) und abh\u00e4ngig vom Wert dieser Bedingung (wahr oder falsch), wird entweder die eine Anweisung (z.B. ziehe b von a ab und weise das Ergebnis a zu ) oder die andere (z.B. ziehe a von b ab und weise das Ergebnis b zu ) ausgef\u00fchrt. Das Ablaufdiagramm einer Selektion sieht so aus: Beachte Anweisung1 und auch Anweisung2 m\u00fcssen nicht zwingend jeweils nur genau eine Anweisung sein. Bei beiden kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder um eine Iteration handeln! Verschachteln von Kontrollstrukturen \u00b6 Mehr als diese drei genannten Kontrollstrukturen gibt es nicht. Aber diese Kontrollstrukturen k\u00f6nnen beliebig ineinander verschachtelt werden. \u00dcberall dort, wo eine Anweisung steht (z.B. Anweisung1 ) kann auch eine komplette Kontrollstruktur eingesetzt werden, also eine Sequenz von Anweisungen oder eine Iteration oder eine Selektion. Die kann dann beliebig fortgef\u00fchrt werden. So entstehen komplexe Strukturen - und somit komplexe Programme. Ein (immernoch recht einfaches) Beispiel f\u00fcr eine etwas komplexere Struktur: \u00dcbung Programmablaufpl\u00e4ne Erstellen Sie sowohl f\u00fcr den euklidischen Algorithmus als auch f\u00fcr die (3n+1)-Vermutung einen Programmablaufplan! \u00dcbung Algorithmus und Programmablaufplan Ein Jahr ist ein Schaltjahr, wenn es sich durch 4 teilen l\u00e4sst. Au\u00dfer, es l\u00e4sst sich durch 100 teilen. Dann ist es doch kein Schaltjahr. Au\u00dfer, es l\u00e4sst sich durch 400 teilen. Dann ist es doch ein Schaltjahr. Beschreiben Sie diese Vorschrift als einen Algorithmus in der Form, in der auch der euklidische Algorithmus und die (3n+1)-Vermutung beschrieben wurden. Erstellen Sie dann den dazugeh\u00f6rigen Programmablaufplan. Success Wir wissen nun, dass es nur drei verschiedene Programmablaufstrukturen gibt: die Sequenz, die Iteration und die Selektion. Wir haben ein Verst\u00e4ndnis davon, was die drei Programmablaufstrukturen ausmacht, welchen Zweck sie haben und was sie voneinander unterscheidet. Wir wissen, dass sich diese Strukturen beliebig ineinander verschachteln lassen. Benannt nach Euklid von Alexandria, einem Mathematiker aus dem 3. Jahrhundert, Autor der Elemente - einem Kompendium des Wissens der Mathematik seiner Zeit. \u21a9","title":"Start"},{"location":"start/#was-ist-programmieren","text":"Zun\u00e4chst ein bisschen Motivation: 10 Gr\u00fcnde, Programmieren zu lernen und Bericht einer ehemaligen FIW-Studentin . Ehe wir uns weiter mit Java und Programmierkonzepten besch\u00e4ftigen, wollen wir uns bewusst werden, was Programmieren \u00fcberhaupt ist. Prinzipiell l\u00f6sen wir beim Programmieren ein Problem mithilfe einer Programmiersprache. Dabei stellt sich die Frage, welche Probleme mithilfe eines Computers l\u00f6sbar sind und welche nicht. Dazu gibt es umfangreiche theoretische Untersuchungen - viele davon werden Sie in den \"Grundlegenden Konzepten der Informatik\" diskutieren. Ein wesentlicher Begriff dabei ist Algorithmus . Ein Algorithmus ist eine eindeutige Handlungsvorschrift, die aus endlich vielen einzelnen Schritten besteht und ein Problem l\u00f6st. Algorithmen sind also auch Kochrezepte oder Bauanleitungen, wenn sie denn \"eindeutig\" sind. Wir kennen alle das Problem, dass Handlungsanweisungen nicht immer eindeutig sind - man kann es manchmal so oder so machen. In der Programmierung darf eine solche Mehrdeutigkeit nat\u00fcrlich nicht vorkommen. Der Algorithmusbegriff wurde deshalb detailliert und folgende Eigenschaften m\u00fcssen f\u00fcr eine Handlungsanweisung f\u00fcr einen Computer gelten, um ein Algorithmus zu sein: Finitheit Das Verfahren muss in einem endlichen Text (Programm) eindeutig beschreibbar sein. Ausf\u00fchrbarkeit Jeder einzelne Schritt des Verfahrens muss auch tats\u00e4chlich ausf\u00fchrbar sein. Dynamische Finitheit Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz ben\u00f6tigen. Terminierung Das Verfahren muss irgendwann enden, d.h. darf nur endlich viele Ausf\u00fchrungsschritte ben\u00f6tigen. Determiniertheit Das Verfahren muss bei denselben Voraussetzungen das gleiche Ergebnis liefern. Determinismus Die n\u00e4chste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt (in jedem Zustand) eindeutig definiert.","title":"Was ist Programmieren?"},{"location":"start/#beispiel-euklidischer-algorithmus","text":"Mit dem euklidischen Algorithmus 1 kann der gr\u00f6\u00dfte gemeinsame Teiler (ggT) zweier Zahlen berechnet werden. In seinen Elementen hat Euklid diesen Algorithmus ungef\u00e4hr so formuliert: Euklidischer Algorithmus Wenn CD aber AB nicht misst, und man nimmt bei AB, CD abwechselnd immer das kleinere vom gr\u00f6\u00dferen weg, dann muss (schlie\u00dflich) eine Zahl \u00fcbrig bleiben, die die vorangehende misst. Hm, das ist recht schwierig zu verstehen. Euklid betrachtet die beiden Zahlen, von denen der gr\u00f6\u00dfte gemeinsame Teiler ermittelt werden soll, als Strecken ( AB und CD ). Er zieht wiederholt die kleinere der beiden Strecken von der gr\u00f6\u00dferen ab. Er wiederholt dies solange, bis die beiden Strecken gleich lang sind - genauer: er wiederholt dies solange, solange die beiden Strecken nicht gleich lang sind ( ... CD aber AB nicht misst... ). Beispiel: ggT von 24 und 40 AB: 40, CD: 24, AB gr\u00f6\u00dfer als CD \u2192 40 - 24 = 16 AB: 16, CD: 24, CD gr\u00f6\u00dfer als AB \u2192 24 - 16 = 8 AB: 16, CD: 8, AB gr\u00f6\u00dfer als CD \u2192 16 - 8 = 8 AB: 8, CD: 8, AB gleich CD \u2192 Ende \u2192 ggT ist 8 Wir versuchen, den Algorithmus in eine verst\u00e4ndlichere und genauere Sprache zu \u00fcberf\u00fchren, ohne bereits eine Programmiersprache zu verwenden. Wir benutzen sogenannten Pseudocode : Angenommen, die beiden Zahlen, von denen wir den ggT berechnen wollen, sind a und b : 1 2 3 4 5 6 7 solange a ungleich b ist, wiederhole wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu wenn a gleich b ist, dann: a ( oder auch b ) ist der gesuchte ggT Wichtig ist, dass das Einr\u00fccken hier eine Bedeutung hat (eine Semantik ). In Zeile 1 formulieren wir, dass sich etwas wiederholen soll, solange eine bestimmte Bedingung gilt. Das, was sich wiederholen soll, ist in den Zeilen 2 bis 5 formuliert. Zeile 1 formuliert eine Schleife und in den Zeilen 2 - 5 befindet sich der Schleifeninhalt . Die Zeilen 2 - 5 formulieren ein eigenes Konstrukt, n\u00e4mlich eine Auswahl zwischen Alternativen, abh\u00e4ngig von einer Bedingung. Die Bedingung ist, ob a gr\u00f6\u00dfer ist als b . Wenn das der Fall ist, dann wird die Alternative ziehe b von a ab und weise das Ergebnis a zu ausgef\u00fchrt (In der Programmierung werden das sp\u00e4ter als a = a - b schreiben - das sieht f\u00fcr uns jetzt noch sehr \"falsch\" aus). Ist jedoch a nicht gr\u00f6\u00dfer als b , dann wird die Alternative ziehe a von b ab und weise das Ergebnis b zu ( b = b - a ) ausgef\u00fchrt. Ein solches Konstrukt wird Selektion (oder auch bedingte Alternative ) genannt. Nachdem entweder Zeile 3 oder Zeile 5 ausgef\u00fchrt wurde (es wird genau eins von beiden ausgef\u00fchrt), wird erneut in Zeile 1 gepr\u00fcft, ob a ungleich b ist. Wenn ja, wird die Selektion wiederholt. Wenn nicht, dann ist die Schleife beendet und Zeile 6 wird ausgef\u00fchrt. Die in Zeile 6 formulierte Bedingung wenn a gleich b ist , ist eigentlich unn\u00f6tig. Frage Warum ist die Bedingung wenn a gleich b ist in Zeile 6 unn\u00f6tig? Wir betrachten nochmals die im obigen Algorithmus betrachteten Konstrukte (wir sprechen vom Kontrollfluss von Anweisungen ): Iteration : die Schleife, die in Zeile 1 formuliert wird und die als Schleifeninhalt die Zeilen 2 - 5 hat, beschreibt einen iterativen (sich wiederholenden) Kontrollfluss . Selektion : die bedingte Alternative , die eine Bedingung pr\u00fcft (Zeile 2 ) und dann, je nachdem, ob die Bedingung richtig oder falsch ist, jeweils eine alternative Anweisung ausf\u00fchrt (entweder Zeile 3 oder Zeile 4 ), wird Selektion genannt (siehe Zeilen 2 - 5 ). Sequenz : die Anweisungen werden hintereinander ausgef\u00fchrt, erst Zeile 1 , dann Zeile 2 , dann entweder Zeile 3 oder Zeile 4 usw. Das Hintereinanderausf\u00fchren von Anweisungen wird Sequenz genannt. Schauen wir uns f\u00fcr unseren Algorithmus nochmal die Eigenschaften eines Algorithmus an: Finitheit unsere Beschreibung des Algorithmus ist endlich (siehe oben). Ausf\u00fchrbarkeit jeder einzelne Schritt kann ausgef\u00fchrt werden. Dynamische Finitheit \u00fcber den Speicherplatz k\u00f6nnen wir noch nicht viel sagen, aber wir m\u00fcssen nur einige wenige Zahlen speichern. Das sollte klappen. Terminierung Wann endet unser Algorithmus? Was muss gelten? Wissen wir, ob der Algorithmus irgendwann stoppt? Determiniertheit Es ist sicherlich nicht so leicht zu sehen, ob bei gleicher Eingabe (die Zahlen a und b ) auch stets der gleiche gr\u00f6\u00dfte gemneinsame Teiler berechnet wird. Dazu m\u00fcssten wir uns erstmal \u00fcberlegen, wie wir das pr\u00fcfen k\u00f6nnen. Determinismus Wir werden unseren Algorithmus nochmal an einem Beispiel durchspielen , um ein Gef\u00fchl daf\u00fcr zu bekommen, dass wir stets wissen, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird.","title":"Beispiel: Euklidischer Algorithmus"},{"location":"start/#beispielzahlen-fur-den-euklidischen-algorithmus","text":"Wir nehmen die Zahlen a=40 und b=24 und spielen damit unseren Algorithmus durch: Zeile 1 : a (40) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von a-b ist 16. Der neue Wert von a ist 16. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist nicht gr\u00f6\u00dfer als b , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von b-a ist 8. Der neue Wert von b ist 8. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (8) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeile 5 ) Zeile 3 : das Ergebnis von a-b ist 8. Der neue Wert von a ist 8. Zeile 1 : wegen wiederhole (Iteration): a (8) ist nicht ungleich b (8) , also wird der Schleifeninhalt nicht ausgef\u00fchrt Zeile 6 : a (8) ist gleich b (8) Zeile 7 : der gesuchte ggT ist 8 Ende F\u00fcr dieses Beispiel war stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe a=40 und b=24 stets 8 ist. Fragen Was \u00e4ndert sich, wenn am Anfang a=24 und b=40 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=0 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=24 und b=24 sind?","title":"Beispielzahlen f\u00fcr den euklidischen Algorithmus"},{"location":"start/#beispiel-3n1-vermutung-collatz-problem","text":"Wir betrachten noch einen weiteren Algorithmus: Als Eingabe bekommen wir eine positive nat\u00fcrliche Zahl, z.B. 5 . Der Algorithmus berechnet eine Folge von Zahlen und zwar nach folgender Vorschrift: ist die Zahl ungerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl mit 3 multipliziert und dann 1 addiert wird. Ist die Zahl gerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl durch 2 geteilt wird. Der Algorithmus stoppt, wenn der Nachfolger 1 ist. Angenommen, die eingegebene positive nat\u00fcrliche Zahl ist n : 1 2 3 4 5 solange n ungleich 1 ist, wiederhole wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Wir begeben uns also in eine Schleife und berechnen so lange einen Nachfolger f\u00fcr die Zahl bis der NAchfolger 1 ist. Betrachten wir den Algorithmus f\u00fcr die EIngabe von n=5 : Zeile 1 : n (5) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist ungerade , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von 3*5+1 ist 16 . Der neue Wert von n ist 16. Zeile 1 : wegen wiederhole (Iteration): n (16) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 16/2 ist 8 . Der neue Wert von n ist 8. Zeile 1 : wegen wiederhole (Iteration): n (8) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 8/2 ist 4 . Der neue Wert von n ist 4. Zeile 1 : wegen wiederhole (Iteration): n (4) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 4/2 ist 2 . Der neue Wert von n ist 2. Zeile 1 : wegen wiederhole (Iteration): n (2) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von 2/2 ist 1 . Der neue Wert von n ist 1. Zeile 1 : wegen wiederhole (Iteration): n (1) ist nicht ungleich 1 , also wird der Schleifeninhalt nicht ausgef\u00fchrt Ende Auch f\u00fcr dieses Beispiel war erneut stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die Eingabe n=5 stets 1 ist. Fragen Spielen Sie den Algorithmus ruhig einmal f\u00fcr n=7 durch oder auch f\u00fcr andere n Denken Sie, dass der Algorithmus f\u00fcr jede beliebige positive nat\u00fcrliche Zahl n terminiert? Wenn ein Algorithmus f\u00fcr eine konkrete Eingabe stets ein eindeutiges Ergebnis (und zwar immer das gleiche) liefert, wie k\u00f6nnen dann Zufallszahlen berechnet werden? Success Wir haben ein Verst\u00e4ndnis \u00fcber den Algorithmus -Begriff erlangt und wissen, was Finitheit , Determiniertheit , Determinismus und Terminierung bedeuten.","title":"Beispiel: (3n+1)-Vermutung (Collatz-Problem)"},{"location":"start/#programmablaufstrukturen","text":"Interessanterweise gibt es nur drei verschiedene Ablaufstrukturen in Programmen bzw. Algorithmen. Alle drei haben wir bereits verwendet. Mit Ablaufstrukturen meinen wir die Abarbeitungsreihenfolge von Anweisungen. Man sagt auch Kontrollfluss dazu. Die drei Ablaufstrukturen, die es gibt, sind: die Sequenz : die Anweisungen werden in sequenzieller Abfolge, d.h. hintereinander ausgef\u00fchrt die Iteration : die Abl\u00e4ufe werden wiederholt ausgef\u00fchrt, also in einer Schleife die Selektion : die Abl\u00e4ufe werden selektiv , d.h. unter einer bestimmten Bedingung ausgef\u00fchrt. Man nennt diese Struktur auch Verzweigung oder bedingte Alternative Wir schauen uns alle drei Kontrollstrukturen einmal genauer an.","title":"Programmablaufstrukturen"},{"location":"start/#die-sequenz","text":"Bei der Sequenz handelt es sich einfach um hintereinander ausgef\u00fchrte Anweisungen. Es wird stets erst die eine Anweisung vollst\u00e4ndig abgearbeitet, ehe die andere begonnen wird. Sequenz von 3 Anweisungen Anweisung1 Anweisung2 Anweisung3 Ein Beispiel (mit 2 Anweisungen) w\u00e4re: berechne 3 *n und weise das Ergebnis n zu berechne n+1 und weise das Ergebnis n zu Zur Visualisierung von Kontrollstrukturen werden auch sogannnte Programmablaufdiagramme oder Programmablaufpl\u00e4ne verwendet. F\u00fcr eine Sequenz s\u00e4he ein solches Ablaufdiagramm so aus: So ein Diagramm wird von oben nach unten gelesen. Es wird also erst Anweisung1 ausgef\u00fchrt, dann Anweisung2 und zuletzt Anweisung3 . Innerhalb einer Sequenz gilt immer single entry / single exit , d.h. keine der Anweisungen innerhalb einer Sequenz kann mehrere Ausg\u00e4nge oder mehrere Eing\u00e4nge haben. Es w\u00e4re ansonsten nicht-deterministisch und somit ein Versto\u00df gegen unseren Algorithmusbegriff.","title":"Die Sequenz"},{"location":"start/#die-iteration","text":"Bei der Iteration handelt es sich um eine wiederholte Ausf\u00fchrung einer Anweisung bzw. einer Sequenz von Anweisungen. Wie oft eine Iteration ausgef\u00fchrt wird, h\u00e4ngt von einer Bedingung ab. In der Programmierung sprechen wir bei der Iteration auch von einer Schleife . Bedingungen f\u00fcr eine solche Schleife haben wir bereits kennengelernt: solange a ungleich b ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt bzw. solange n ungleich 1 ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt Wichtig ist, dass es auch hier eine strikte Reihenfolge der Abarbeitung der Anweisungen gibt: es wird zun\u00e4chst gepr\u00fcft, ob die Bedingung erf\u00fcllt (wahr) ist, also ob z.B. a ungleich b ist oder ob n ungleich 1 . Wenn diese Bedingung erf\u00fcllt (also wahr) ist, dann werden die Anweisung(en) innerhalb der Schleife nacheinander (sequenziell) abgearbeitet. Erst wenn alle Anweisungen innerhalb der Schleife abgearbeitet wurden, wird die Schleifenbedingung erneut gepr\u00fcft. Ist sie wieder wahr, werden die Anweisungen innerhalb der Schleife erneut abgearbeitet usw. Ist sie nicht wahr, also wenn z.B. a gleich b ist oder n gleich 1 ist , dann wird die Schleife beendet und die Anweisungen innerhalb der Schleife nicht (erneut) abgearbeitet. Das Ablaufdiagramm einer Schleife (Iteration) sieht so aus: Die eigentliche Iteration ist gr\u00fcn dargestellt. Wir kommen von einer anderen Anweisung und pr\u00fcfen die Bedingung. Ist sie wahr, wird Anweisung1 ausgef\u00fchrt. Beachte Anweisung1 muss nicht zwingend nur genau eine Anweisung sein. Bei Anweisung1 kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder sogar selbst um eine Iteration (Schleife in der Schleife - verschachtelte Schleife) handeln! Nach jeder Ausf\u00fchrung von Anweisung1 wird die Bedingung erneut gepr\u00fcft. Ist sie (immernoch) wahr, wird Anweisung1 erneut ausgef\u00fchrt. Ist die Bedingung jedoch falsch, dann wird Anweisung1 nicht (mehr) ausgef\u00fchrt, sondern die Schleife wird verlassen und die Anweisung, die der Schleife folgt, wird ausgef\u00fchrt ( Anweisung2 ) oder das Programm ist dann zu Ende. Beachte Es kann sein, dass Anweisung1 gar nicht ausgef\u00fchrt wird, weil die Bedingung bereits bei der ersten Pr\u00fcfung falsch ist. Es ist also nicht gesagt, dass sich eine Iteration wirklich wiederholt . Es kann sein, dass Anweisung1 gar nicht oder nur genau ein Mal ausgef\u00fchrt wird (wenn die Bedingung nach der ersten Ausf\u00fchrung falsch ist). Das ist kein Problem! Ein Problem ist es jedoch, wenn die Bedingung niemals falsch wird und die Schleife unendlich oft hintereinander ausgef\u00fchrt wird. Das ist ein Versto\u00df gegen die Terminierung eines Algorithmus. In einem solchen Fall werden wir irgendwann einen Fehler bei der Programmausf\u00fchrung erhalten (aber erst zur Ausf\u00fchrungszeit, nicht bereits beim Compilieren). Wir werden uns ausf\u00fchrlich mit Schleifen auseinandersetzen, da sie logisch recht anspruchsvoll und dadurch h\u00e4ufig fehleranf\u00e4llig sein k\u00f6nnen.","title":"Die Iteration"},{"location":"start/#die-selektion","text":"Bei der Selektion handelt es sich, im Gegensatz zur Iteration, um eine einmalige Ausf\u00fchrung einer (oder mehrerer) Anweisung(en). Jedoch ist diese Ausf\u00fchrung, im Gegensatz zur Sequenz, von einer Bedingung abh\u00e4ngig. Wir hatten eine solche Selektion jeweils in obigen Beispielalgorithmen. Selektion aus dem euklidischen Algorithmus: wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu Selektion aus der (3n+1)-Vermutung (dem Collatz-Problem): wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Es gibt also immer eine Bedingung (z.B. wenn a gr\u00f6\u00dfer ist als b ) und abh\u00e4ngig vom Wert dieser Bedingung (wahr oder falsch), wird entweder die eine Anweisung (z.B. ziehe b von a ab und weise das Ergebnis a zu ) oder die andere (z.B. ziehe a von b ab und weise das Ergebnis b zu ) ausgef\u00fchrt. Das Ablaufdiagramm einer Selektion sieht so aus: Beachte Anweisung1 und auch Anweisung2 m\u00fcssen nicht zwingend jeweils nur genau eine Anweisung sein. Bei beiden kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder um eine Iteration handeln!","title":"Die Selektion"},{"location":"start/#verschachteln-von-kontrollstrukturen","text":"Mehr als diese drei genannten Kontrollstrukturen gibt es nicht. Aber diese Kontrollstrukturen k\u00f6nnen beliebig ineinander verschachtelt werden. \u00dcberall dort, wo eine Anweisung steht (z.B. Anweisung1 ) kann auch eine komplette Kontrollstruktur eingesetzt werden, also eine Sequenz von Anweisungen oder eine Iteration oder eine Selektion. Die kann dann beliebig fortgef\u00fchrt werden. So entstehen komplexe Strukturen - und somit komplexe Programme. Ein (immernoch recht einfaches) Beispiel f\u00fcr eine etwas komplexere Struktur: \u00dcbung Programmablaufpl\u00e4ne Erstellen Sie sowohl f\u00fcr den euklidischen Algorithmus als auch f\u00fcr die (3n+1)-Vermutung einen Programmablaufplan! \u00dcbung Algorithmus und Programmablaufplan Ein Jahr ist ein Schaltjahr, wenn es sich durch 4 teilen l\u00e4sst. Au\u00dfer, es l\u00e4sst sich durch 100 teilen. Dann ist es doch kein Schaltjahr. Au\u00dfer, es l\u00e4sst sich durch 400 teilen. Dann ist es doch ein Schaltjahr. Beschreiben Sie diese Vorschrift als einen Algorithmus in der Form, in der auch der euklidische Algorithmus und die (3n+1)-Vermutung beschrieben wurden. Erstellen Sie dann den dazugeh\u00f6rigen Programmablaufplan. Success Wir wissen nun, dass es nur drei verschiedene Programmablaufstrukturen gibt: die Sequenz, die Iteration und die Selektion. Wir haben ein Verst\u00e4ndnis davon, was die drei Programmablaufstrukturen ausmacht, welchen Zweck sie haben und was sie voneinander unterscheidet. Wir wissen, dass sich diese Strukturen beliebig ineinander verschachteln lassen. Benannt nach Euklid von Alexandria, einem Mathematiker aus dem 3. Jahrhundert, Autor der Elemente - einem Kompendium des Wissens der Mathematik seiner Zeit. \u21a9","title":"Verschachteln von Kontrollstrukturen"},{"location":"tools/","text":"Werkzeuge \u00b6 Literaturempfehlungen \u00b6 Joachim Goll, Cornelia Heinisch: \"Java als erste Programmiersprache. Ein professioneller Einstieg in die Objektorientierung mit Java\" , Springer Vieweg Sebastian D\u00f6rn: \"Java lernen in abgeschlossenen Lerneinheiten\" , Springer Vieweg Dietmar Ratz, Jens Scheffler, Detlef Seese, Jan Wiesenberger: \"Grundkurs Programmieren in Java x\" , Hanser Verlag Kathy Sierra, Bert Bates: \"Java von Kopf bis Fu\u00df\" , O'Reilly Verlag Joshua Bloch: \"Effective Java. Best practices for the Java platform\" , Pearson Education Inc. Robin C. Martin: \"Clean Code: A Handbook of Agile Software Craftmanship\" , Prentice Hall und alle B\u00fccher f\u00fcr Einsteigerinnen, die Sie ansprechen... Java \u00b6 Wir verwenden die Programmiersprache Java , um die Programmierkonzepte, die wir lernen und anwenden wollen, zu implementieren. Java besteht aus 2 Teilen: der Java Run Time Environment (Java RTE) (Java-Laufzeitumgebung) dem Java Development Kit (JDK) (die Java-Entwicklungsumgebung) Die Java-Laufzeitumgebung ist \u00fcblicherweise bereits auf allen Rechnern installiert. Sie ist selbst ein Programm. Innerhalb dieses Programms werden Java-Programme ausgef\u00fchrt. Das JDK m\u00fcssen Sie installieren. Verwenden Sie dazu diesen Link und gehen wie f\u00fcr Ihr Betriebssystem angegeben vor (pr\u00fcfen Sie aber zun\u00e4chst, ob Sie nicht eventuell bereits Beides haben - java -version und javac -version - siehe folgend). Testen Sie am besten auf Ihrer Konsole (Terminal), ob Ihr Java korrekt funktioniert. Zum Testen Ihrer Laufzeitumgebung geben Sie dazu java -version ein. Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): java version \"15.0.1\" 2020 -10-20 Java ( TM ) SE Runtime Environment ( build 15 .0.1+9-18 ) Java HotSpot ( TM ) 64 -Bit Server VM ( build 15 .0.1+9-18, mixed mode, sharing ) Somit wissen Sie, dass die Laufzeitumgebung funktioniert. Zum Testen des JDK rufen wir am besten den Compiler ( javac ) auf: javac -version Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): javac 15 .0.1 Success Sie haben nun die Java-Laufzeitumgebung installiert, in der unsere Java-Programme ausgef\u00fchrt werden und Sie haben das Java Development Kit installiert. Teil des JDK ist z.B. der Compiler , der unsere Java-Programme in Byte-Code \u00fcbersetzt. Dieser Bytecode wird in unserer Java-Laufzeitumgebung ausgef\u00fchrt. IDE \u00b6 Um unsere Programme \"zu schreiben\", verwenden wir eine sogenannte Integrated Development Environment (IDE) , eine integrierte Entwicklungsumgebung, die uns beim Programmieren unterst\u00fctzt. Wir k\u00f6nnten unsere Programme auch mit einfachen Texteditoren schreiben, aber eine IDE unterst\u00fctzt uns, indem der Programmcode geeignet hervorgehoben wird ( Syntx-Highlighting ) und uns Vorschl\u00e4ge f\u00fcr die Verwendung von Methoden und Variablen gemacht werden ( Intelligent Code Completion ). BlueJ \u00b6 Am Anfang verwenden wir BlueJ . BlueJ wird an der University of Kent (UK) entwickelt und richtet sich speziell an Programmieranf\u00e4ngerinnen. Das Tolle an BlueJ ist, dass die Funktionsbl\u00f6cke , die zusammengeh\u00f6ren, farbig hervorgehoben werden. Die Download-Seite von BlueJ befindet sich hier . Laden Sie BlueJ herunter, entpacken Sie das zip-File und bewegen Sie den Ordner BlueJ in Ihren Programme-Ordner. Derzeit hei\u00dft der Ordner BlueJ 5 .0.2 In dem Ordner befindet sich die ausf\u00fchrbare BlueJ -Datei ( BlueJ.app oder BlueJ.exe ) und ein examples -Ordner. \u00d6ffnen Sie BlueJ durch Doppelklick auf die ausf\u00fchrbare BlueJ -Datei. W\u00e4hlen Sie im Men\u00fc Project --> Open Project... . Klicken Sie zum examples -Ordner und w\u00e4hlen Sie das Projekt hello und \u00f6ffnen Sie es. BlueJ sieht dann so aus: Klicken Sie mit der rechten Maustaste auf das gelbe Rechteck Hello und w\u00e4hlen Sie im Men\u00fc Open editor aus. Es erscheint folgendes Fenster: Klicken Sie in diesem Fenster auf den Button Compile . Es sollte folgendes Fenster erscheinen: Success Sie haben BlueJ erfolgreich installiert und die Java-Programme werden \u00fcbersetzt (compiliert). Eclipse \u00b6 Nachdem wir anfangs alle BlueJ verwenden, sind Sie danach in der Wahl Ihrer IDE frei. Wir verwenden Eclipse . Eclipse ist in Java geschrieben und Open-Source. Den Download-Link f\u00fcr Eclipse finden Sie hier . Es gibt verschiedene Versionen von Eclipse, wir verwenden die Eclipse IDE for Java Developers . Installieren Sie Eclipse am besten in ihren Applications oder Programme Ordner. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 oder Uebung1 oder Aufgabe2 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie einen Paketnamen ein (Paketnamen werden kleingeschrieben), z.B. themen.start . Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes (z.B. themen.start ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe eines beliebigen Namens, der gleichzeitig der Klassen- und Dateiname ist (z.B. HelloFIW ). Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . Klicken auf den Button Finish . Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die Bedeutung der einzelnen Fenster in Eclipse: IntelliJ \u00b6 Diejenigen von Ihnen, die nicht Eclipse verwenden, werden sich stattdessen wahrscheinlich f\u00fcr IntelliJ entscheiden. Das ist v\u00f6llig in Ordnung. IntelliJ ist von JetBrains, einem tschechischen Unternehmen, und derzeit die wohl modernste IDE auf dem Markt, nicht nur f\u00fcr Java- sondern auch f\u00fcr Web-Entwicklungen. IntelliJ ist nicht Open-Source und ist kostenpflichtig. Mit einer Hochschullizenz erhalten Sie jedoch kostenlosen Zugriff auf alle Enterprise-Versionen. Sie m\u00fcssen sich dazu bei JetBrains mit Ihrer HTW-Adresse registrieren. Visual Studio Code \u00b6 Wer gerne mit Microsoft-Produkten arbeitet, kann auch gerne Visual Studio Code ( VS Code ) arbeiten. Das ist auch eine sehr gute IDE und ebenfalls nicht nur zur Nutzung f\u00fcr die Java-Entwicklung, sondern auch f\u00fcr Web- und App-Entwicklungen geeignet. Sp\u00e4testens im dritten Semster in WebTech werden die meisten von Ihnen entweder auf IntelliJ oder VS Code wechseln. Weitere n\u00fctzliche Werkzeuge \u00b6 Windows: gitBash \u00b6 Das Terminal ( cmd ) in Windows ist nicht so gut. Installieren Sie sich lieber die GitBash f\u00fcr Windows . Unter Downloads \u00f6ffnet sich das GitHub-Repository f\u00fcr Git. Aktuell w\u00e4hlen Sie dort Git-2.29.2-64-bit.exe und folgen dann den Installationsanweisungen. Online-Kurse \u00b6 SoloLearn https://www.sololearn.com/Course/Java/ JetBrains Academy https://hyperskill.org/tracks/1","title":"Werkzeuge"},{"location":"tools/#werkzeuge","text":"","title":"Werkzeuge"},{"location":"tools/#literaturempfehlungen","text":"Joachim Goll, Cornelia Heinisch: \"Java als erste Programmiersprache. Ein professioneller Einstieg in die Objektorientierung mit Java\" , Springer Vieweg Sebastian D\u00f6rn: \"Java lernen in abgeschlossenen Lerneinheiten\" , Springer Vieweg Dietmar Ratz, Jens Scheffler, Detlef Seese, Jan Wiesenberger: \"Grundkurs Programmieren in Java x\" , Hanser Verlag Kathy Sierra, Bert Bates: \"Java von Kopf bis Fu\u00df\" , O'Reilly Verlag Joshua Bloch: \"Effective Java. Best practices for the Java platform\" , Pearson Education Inc. Robin C. Martin: \"Clean Code: A Handbook of Agile Software Craftmanship\" , Prentice Hall und alle B\u00fccher f\u00fcr Einsteigerinnen, die Sie ansprechen...","title":"Literaturempfehlungen"},{"location":"tools/#java","text":"Wir verwenden die Programmiersprache Java , um die Programmierkonzepte, die wir lernen und anwenden wollen, zu implementieren. Java besteht aus 2 Teilen: der Java Run Time Environment (Java RTE) (Java-Laufzeitumgebung) dem Java Development Kit (JDK) (die Java-Entwicklungsumgebung) Die Java-Laufzeitumgebung ist \u00fcblicherweise bereits auf allen Rechnern installiert. Sie ist selbst ein Programm. Innerhalb dieses Programms werden Java-Programme ausgef\u00fchrt. Das JDK m\u00fcssen Sie installieren. Verwenden Sie dazu diesen Link und gehen wie f\u00fcr Ihr Betriebssystem angegeben vor (pr\u00fcfen Sie aber zun\u00e4chst, ob Sie nicht eventuell bereits Beides haben - java -version und javac -version - siehe folgend). Testen Sie am besten auf Ihrer Konsole (Terminal), ob Ihr Java korrekt funktioniert. Zum Testen Ihrer Laufzeitumgebung geben Sie dazu java -version ein. Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): java version \"15.0.1\" 2020 -10-20 Java ( TM ) SE Runtime Environment ( build 15 .0.1+9-18 ) Java HotSpot ( TM ) 64 -Bit Server VM ( build 15 .0.1+9-18, mixed mode, sharing ) Somit wissen Sie, dass die Laufzeitumgebung funktioniert. Zum Testen des JDK rufen wir am besten den Compiler ( javac ) auf: javac -version Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): javac 15 .0.1 Success Sie haben nun die Java-Laufzeitumgebung installiert, in der unsere Java-Programme ausgef\u00fchrt werden und Sie haben das Java Development Kit installiert. Teil des JDK ist z.B. der Compiler , der unsere Java-Programme in Byte-Code \u00fcbersetzt. Dieser Bytecode wird in unserer Java-Laufzeitumgebung ausgef\u00fchrt.","title":"Java"},{"location":"tools/#ide","text":"Um unsere Programme \"zu schreiben\", verwenden wir eine sogenannte Integrated Development Environment (IDE) , eine integrierte Entwicklungsumgebung, die uns beim Programmieren unterst\u00fctzt. Wir k\u00f6nnten unsere Programme auch mit einfachen Texteditoren schreiben, aber eine IDE unterst\u00fctzt uns, indem der Programmcode geeignet hervorgehoben wird ( Syntx-Highlighting ) und uns Vorschl\u00e4ge f\u00fcr die Verwendung von Methoden und Variablen gemacht werden ( Intelligent Code Completion ).","title":"IDE"},{"location":"tools/#bluej","text":"Am Anfang verwenden wir BlueJ . BlueJ wird an der University of Kent (UK) entwickelt und richtet sich speziell an Programmieranf\u00e4ngerinnen. Das Tolle an BlueJ ist, dass die Funktionsbl\u00f6cke , die zusammengeh\u00f6ren, farbig hervorgehoben werden. Die Download-Seite von BlueJ befindet sich hier . Laden Sie BlueJ herunter, entpacken Sie das zip-File und bewegen Sie den Ordner BlueJ in Ihren Programme-Ordner. Derzeit hei\u00dft der Ordner BlueJ 5 .0.2 In dem Ordner befindet sich die ausf\u00fchrbare BlueJ -Datei ( BlueJ.app oder BlueJ.exe ) und ein examples -Ordner. \u00d6ffnen Sie BlueJ durch Doppelklick auf die ausf\u00fchrbare BlueJ -Datei. W\u00e4hlen Sie im Men\u00fc Project --> Open Project... . Klicken Sie zum examples -Ordner und w\u00e4hlen Sie das Projekt hello und \u00f6ffnen Sie es. BlueJ sieht dann so aus: Klicken Sie mit der rechten Maustaste auf das gelbe Rechteck Hello und w\u00e4hlen Sie im Men\u00fc Open editor aus. Es erscheint folgendes Fenster: Klicken Sie in diesem Fenster auf den Button Compile . Es sollte folgendes Fenster erscheinen: Success Sie haben BlueJ erfolgreich installiert und die Java-Programme werden \u00fcbersetzt (compiliert).","title":"BlueJ"},{"location":"tools/#eclipse","text":"Nachdem wir anfangs alle BlueJ verwenden, sind Sie danach in der Wahl Ihrer IDE frei. Wir verwenden Eclipse . Eclipse ist in Java geschrieben und Open-Source. Den Download-Link f\u00fcr Eclipse finden Sie hier . Es gibt verschiedene Versionen von Eclipse, wir verwenden die Eclipse IDE for Java Developers . Installieren Sie Eclipse am besten in ihren Applications oder Programme Ordner. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 oder Uebung1 oder Aufgabe2 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie einen Paketnamen ein (Paketnamen werden kleingeschrieben), z.B. themen.start . Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes (z.B. themen.start ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe eines beliebigen Namens, der gleichzeitig der Klassen- und Dateiname ist (z.B. HelloFIW ). Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . Klicken auf den Button Finish . Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die Bedeutung der einzelnen Fenster in Eclipse:","title":"Eclipse"},{"location":"tools/#intellij","text":"Diejenigen von Ihnen, die nicht Eclipse verwenden, werden sich stattdessen wahrscheinlich f\u00fcr IntelliJ entscheiden. Das ist v\u00f6llig in Ordnung. IntelliJ ist von JetBrains, einem tschechischen Unternehmen, und derzeit die wohl modernste IDE auf dem Markt, nicht nur f\u00fcr Java- sondern auch f\u00fcr Web-Entwicklungen. IntelliJ ist nicht Open-Source und ist kostenpflichtig. Mit einer Hochschullizenz erhalten Sie jedoch kostenlosen Zugriff auf alle Enterprise-Versionen. Sie m\u00fcssen sich dazu bei JetBrains mit Ihrer HTW-Adresse registrieren.","title":"IntelliJ"},{"location":"tools/#visual-studio-code","text":"Wer gerne mit Microsoft-Produkten arbeitet, kann auch gerne Visual Studio Code ( VS Code ) arbeiten. Das ist auch eine sehr gute IDE und ebenfalls nicht nur zur Nutzung f\u00fcr die Java-Entwicklung, sondern auch f\u00fcr Web- und App-Entwicklungen geeignet. Sp\u00e4testens im dritten Semster in WebTech werden die meisten von Ihnen entweder auf IntelliJ oder VS Code wechseln.","title":"Visual Studio Code"},{"location":"tools/#weitere-nutzliche-werkzeuge","text":"","title":"Weitere n\u00fctzliche Werkzeuge"},{"location":"tools/#windows-gitbash","text":"Das Terminal ( cmd ) in Windows ist nicht so gut. Installieren Sie sich lieber die GitBash f\u00fcr Windows . Unter Downloads \u00f6ffnet sich das GitHub-Repository f\u00fcr Git. Aktuell w\u00e4hlen Sie dort Git-2.29.2-64-bit.exe und folgen dann den Installationsanweisungen.","title":"Windows: gitBash"},{"location":"tools/#online-kurse","text":"SoloLearn https://www.sololearn.com/Course/Java/ JetBrains Academy https://hyperskill.org/tracks/1","title":"Online-Kurse"},{"location":"uebungen/","text":"\u00dcbungen \u00b6 \u00dcbungsbl\u00e4tter (wochenweise) \u00b6 \u00dcbung 1 (20.10.2021) Vorbereitung Installieren Sie - falls noch nicht geschehen - das Java Davelopment Kit (JDK) (siehe Java ). Installieren Sie BlueJ (siehe IDE ). Starten Sie BlueJ und \u00f6ffnen Sie ( Project --> Open Project... ) das Projekt picture (im BlueJ-Ordner unter examples ). Klicken Sie dann den Compile -Button. Klicken Sie mit der rechten Maustaste auf die Klasse Picture (das orangene K\u00e4stchen mit der Beschriftung Picture ) und erzeugen Sie davon ein Objekt picture1 . Klicken Sie mit der rechten Maustaste auf das Objekt picture1 und rufen Sie die Methode draw() auf. Klicken Sie erneut mit der rechten Maustaste auf die Klasse Picture und \u00f6ffnen Sie den Editor mit Open Editor . Es erscheint das Java-Programm (der Quellcode ) der Klasse Picture : Picture.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /** * This class represents a simple picture. You can draw the picture using * the draw method. But wait, there's more: being an electronic picture, it * can be changed. You can set it to black-and-white display and back to * colors (only after it's been drawn, of course). * * This class was written as an early example for teaching Java with BlueJ. * * @author Michael K\u00f6lling and David J. Barnes * @version 1.1 (24 May 2001) */ public class Picture { private Square wall ; private Square window ; private Triangle roof ; private Circle sun ; /** * Constructor for objects of class Picture */ public Picture () { // nothing to do... instance variables are automatically set to null } /** * Draw this picture. */ public void draw () { wall = new Square (); wall . moveVertical ( 80 ); wall . changeSize ( 100 ); wall . makeVisible (); window = new Square (); window . changeColor ( \"black\" ); window . moveHorizontal ( 20 ); window . moveVertical ( 100 ); window . makeVisible (); roof = new Triangle (); roof . changeSize ( 50 , 140 ); roof . moveHorizontal ( 60 ); roof . moveVertical ( 70 ); roof . makeVisible (); sun = new Circle (); sun . changeColor ( \"yellow\" ); sun . moveHorizontal ( 180 ); sun . moveVertical ( - 10 ); sun . changeSize ( 60 ); sun . makeVisible (); } /** * Change this picture to black/white display */ public void setBlackAndWhite () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"black\" ); window . changeColor ( \"white\" ); roof . changeColor ( \"black\" ); sun . changeColor ( \"black\" ); } } /** * Change this picture to use color display */ public void setColor () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"red\" ); window . changeColor ( \"black\" ); roof . changeColor ( \"green\" ); sun . changeColor ( \"yellow\" ); } } } Wir schauen uns diese Klasse ein wenig genauer an und diskutieren einige Details (Objektvariablen, Objektmethoden, Kommentare, ...). Durchf\u00fchrung F\u00fcr diese \u00dcbung interessiert uns nur die Methode draw() . Die Methodenaufrufe, die wir bis jetzt immer einzeln vorgenommen haben, werden nun \"aufgeschrieben\" - wir programmieren ! \u00c4ndern Sie Farben und Positionen der einzelnen Objekte! Wenn Sie Ihre \u00c4nderungen ausprobieren wollen, m\u00fcssen Sie die Klasse neu compilieren . Durch das Compilieren gehen die erzeugten Objekte verloren. Warum ist das wohl so? Lassen Sie die Sonne langsam untergehen. Welche Objektmethode kommt daf\u00fcr infrage? F\u00fcr welches Objekt muss diese Objektmethode aufgerufen werden? Tipp: Derzeit ist es recht m\u00fchsam, die \u00c4nderungen zu testen. Wir m\u00fcssen die Klasse Picture compilieren, dann ein Objekt dieser Klasse erzeugen und dann f\u00fcr dieses Objekt die Methode draw() aufrufen. Wir wollen diesen Vorgang etwas vereinfachen und erstellen uns dazu eine Testklasse . Klicken Sie mit der rechten Maustaste auf die Klasse Picture und w\u00e4hlen Sie Create Test Class aus. Klicken Sie mit der rechten Maustaste auf diese neue Testklasse PictureTest und w\u00e4hlen Sie Create Test Method ... aus. Geben Sie als Namen f\u00fcr diese Testmethode drawTest an und best\u00e4tigen Sie die Eingabe mit OK . Nun wird ein Test \"aufgenommen\". Klicken Sie mit der rechten Maustaste auf die Klasse Picture und erzeugen Sie von dieser Klasse eine Objekt picture1 . F\u00fcr dieses Objekt rufen Sie die draw() -Methode auf. Klicken Sie dann im Hauptfenster auf der linken Seite unter recording den Button End . Sie haben nun einen Test erzeugt, den Sie leicht aufrufen k\u00f6nnen. \u00c4ndern Sie Ihre draw() -Methode, compilieren Sie die Klasse Picture und w\u00e4hlen Sie nun mit der rechten Maustaste f\u00fcr die Klasse PictureTest die Methode drawTest() aus und rufen diese auf. \u00dcbung 2 (27.10.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung2 . Erstellen Sie darin eine Klasse Uebung2 . Ersetzen Sie den gesamten Code der Klasse Uebung2 durch folgenden Code: public class Uebung2 { public Uebung2 () { } public void printLesson2 () { // Schreiben Sie Ihren gesamten Code in diese Methode // und fuehren Sie diese Methode aus } } Deklarieren und initialisieren Sie in der printLesson2() -Methode jeweils eine Variable mit dem Datentyp int , long , char , byte , short , float , double , boolean und String . Geben Sie alle Werte einzeln durch Aufruf der println() -Methode aus. Erzeugen Sie dabei folgende Ausgabe (Werte nur Beispiele): Wert vom Typ int : 123 Wert vom Typ long : 456789 Wert vom Typ char : a Wert vom Typ byte : 127 Wert vom Typ short : 32767 Wert vom Typ float : 4 .23 Wert vom Typ double : 6 .98 Wert vom Typ boolean : true Wert vom Typ String : Hallo! Setzen Sie den Wert Ihrer int -Variablen auf 2147483647 . Geben Sie den Wert auf der Konsole aus, z.B.: Wert von i : 2147483647 Erh\u00f6hen Sie nun den Wert der Variablen um 1 und geben Sie den Wert erneut aus. Was passiert? Warum? Wiederholen Sie das gleiche mit einer `long-Variablen. Weisen Sie Ihrer char -Variablen den Wert 65 zu. Geben Sie den Wert Ihrer char -Variablen aus. Was passiert? Warum? Deklarieren Sie zwei weitere int -Variablen und weisen Sie diesen Variablen Werte zu. Erzeugen Sie unter Verwendung der Werte dieser beiden Variablen folgende Ausgabe (wir nehmen an, die beiden Werte sind 17 und 4 ): 17 geteilt durch 4 ergibt 4 . Es bleibt ein Rest von 1 \u00c4ndern Sie das Programm so, dass bei einer ganzzahligen Division ohne Rest die Ausgabe in der Form ist (z.B. f\u00fcr die Werte 16 und 4 ): 16 geteilt durch 4 ergibt 4 ohne Rest. F\u00fcgen Sie (mindestens) zwei weitere Anweisungen hinzu, sodass mit Hilfe der println() -Methode folgende Ausgaben (f\u00fcr die Beispielwerte 17 und 4 ) erscheinen: 17 /4 = 4 17 mod 4 = 1 Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2 public class Uebung2 { public Uebung2 () { } public void printLesson2 () { // Schreiben Sie Ihren gesamten Code in diese Methode // und fuehren Sie diese Methode aus int in = 123 ; long lo = 456789 ; char ch = 'a' ; byte by = 127 ; short sh = 32767 ; float fl = 4.23f ; double d1 = 6.98 ; boolean b1 = true ; String s1 = \"Hallo!\" ; System . out . println ( \" --- Aufgabe 3 -------\" ); System . out . println (); System . out . println ( \"Wert vom Typ int : \" + in ); System . out . println ( \"Wert vom Typ long : \" + lo ); System . out . println ( \"Wert vom Typ char : \" + ch ); System . out . println ( \"Wert vom Typ byte : \" + by ); System . out . println ( \"Wert vom Typ short : \" + sh ); System . out . println ( \"Wert vom Typ float : \" + fl ); System . out . println ( \"Wert vom Typ double : \" + d1 ); System . out . println ( \"Wert vom Typ boolean : \" + b1 ); System . out . println ( \"Wert vom Typ String : \" + s1 ); System . out . println (); System . out . println ( \" --- Aufgabe 4 -------\" ); System . out . println (); in = 2147483647 ; System . out . println ( \"Wert vom Typ int : \" + in ); in = in + 1 ; // in++; System . out . println ( \"Wert vom Typ int : \" + in ); System . out . println (); System . out . println ( \" --- Aufgabe 5 -------\" ); System . out . println (); lo = 2147483647L ; System . out . println ( \"Wert vom Typ long : \" + lo ); lo = lo + 1 ; System . out . println ( \"Wert vom Typ long : \" + lo ); System . out . println (); System . out . println ( \" --- Aufgabe 6 -------\" ); System . out . println (); ch = 65 ; System . out . println ( \"Wert vom Typ char : \" + ch ); System . out . println (); System . out . println ( \" --- Aufgabe 7 -------\" ); System . out . println (); int nr1 = 17 ; int nr2 = 4 ; int quotient = nr1 / nr2 ; int rest = nr1 % nr2 ; if ( rest == 0 ) { System . out . println ( nr1 + \" geteilt durch \" + nr2 + \" ergibt \" + quotient + \" ohne Rest.\" ); } else { System . out . println ( nr1 + \" geteilt durch \" + nr2 + \" ergibt \" + quotient + \". Es bleibt ein Rest von \" + rest ); } System . out . println (); System . out . println ( \" --- Aufgabe 8 -------\" ); System . out . println (); int number1 = 17 ; int number2 = 4 ; int result = number1 / number2 ; System . out . println ( number1 + \"/\" + number2 + \" = \" + result ); int rest = number1 % number2 ; System . out . println ( number1 + \" mod \" + number2 + \" = \" + rest ); } } \u00dcbung 3 (3.11.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung3 . Erstellen Sie darin eine Klasse Uebung3 . Ersetzen Sie den gesamten Code der Klasse Uebung3 durch folgenden Code: public class Uebung3 { public Uebung3 () { } public void myLesson3Method () { // Definieren Sie alle Ihre Methoden au\u00dferhalb dieser Methode // Rufen Sie alle Ihre Methoden hier auf } } Schreiben Sie eine Umrechnung f\u00fcr eine gegebene Anzahl von Sekunden ( printSeconds(int seconds) ), z.B. printSeconds(3456789) : 3456789 Sekunden sind 40 Tage, 13 Minuten, 9 Sekunden. Aber z.B. printSeconds(2345678) : 2345678 Sekunden sind 27 Tage, 3 Stunden, 34 Minuten, 38 Sekunden. Aber z.B. printSeconds(123456) : 123456 Sekunden sind 1 Tag, 10 Stunden, 17 Minuten, 36 Sekunden. Aber z.B. printSeconds(12345) : 12345 Sekunden sind 3 Stunden, 25 Minuten, 45 Sekunden. Die printSeconds() -Methode gibt selbst etwas aus. Welchen R\u00fcckgabetyp hat sie? Schreiben Sie eine weitere Methode computeSeconds(int seconds) , die genau die gleiche Funktionalit\u00e4t hat, aber den Ausgabestring nicht auf die Konsole ausgibt, sondern zur\u00fcck. Wie k\u00f6nnten (und sollten!) Sie die computeSeconds() -Methode in der printSeconds() -Methode verwenden? Warum? Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 3 public class Uebung3 { public Uebung3 () { } public void printSeconds ( int seconds ) { int minute = 60 ; int hour = 60 * minute ; // 3600 int day = 24 * hour ; // 86400 int days = seconds / day ; int remainingSeconds = seconds - ( days * day ); int hours = remainingSeconds / hour ; remainingSeconds = remainingSeconds - ( hours * hour ); int minutes = remainingSeconds / minute ; remainingSeconds = remainingSeconds - ( minutes * minute ); /* System.out.println(seconds + \" Sekunden sind \" + days + \" Tage, \" + hours + \" Stunden, \" + minutes + \" Minuten, \" + remainingSeconds + \" Sekunden.\"); */ String output = seconds + \" Sekunden sind \" ; if ( days == 1 ) { output = output + \" 1 Tag, \" ; } else { if ( days > 1 ) { output = output + days + \" Tage, \" ; } } if ( hours == 1 ) { output = output + \" 1 Stunde, \" ; } else { if ( hours > 1 ) { output = output + hours + \" Stunden, \" ; } } if ( minutes == 1 ) { output = output + \" 1 Minute, \" ; } else { if ( minutes > 1 ) { output = output + minutes + \" Minuten, \" ; } } if ( remainingSeconds == 1 ) { output = output + \" 1 Sekunde.\" ; } else { if ( remainingSeconds > 1 ) { output = output + remainingSeconds + \" Sekunden.\" ; } } System . out . println ( output ); } public void myLesson3Method () { printSeconds ( 3456789 ); printSeconds ( 2345678 ); printSeconds ( 123456 ); printSeconds ( 12345 ); } } \u00dcbung 4 (10.11.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung4 . Erstellen Sie darin eine Klasse Uebung4 . Ersetzen Sie den gesamten Code der Klasse Uebung4 durch folgenden Code: public class Uebung4 { public Uebung4 () { } public void myLesson4Method () { // Definieren Sie alle Ihre Methoden au\u00dferhalb dieser Methode // Rufen Sie alle Ihre Methoden hier auf } } Schreiben Sie eine Methode isPrime(int number) , die ein true zur\u00fcckgibt, wenn number eine Primzahl ist und ein false , wenn nicht. Eine Primzahl ist eine nat\u00fcrliche Zahl gr\u00f6\u00dfer als 1 , die nur durch 1 und sich selbst teilbar ist. Schreiben Sie eine Methode printprimeNumbers(int maximum) , die alle Primzahlen von 1 bis einschlie\u00dflich maximum wie folgt auf der Konsole ausgibt (Bsp. f\u00fcr maximum=61 ): Zahl : 61 .2 3 .5 .7 ...11 .13 ...17 .19 ...23 .....29 .31 .....37 ...41 .43 ...47 .....53 .....59 .61 d.h. es werden die Zahlen, die Primzahlen sind, ausgegeben und f\u00fcr die anderen Zahlen erscheint nur ein Punkt. Verwenden Sie in der Methode printPrimenumbers(int) die Methode isPrime(int) . Zusatzaufgabe (gute Wiederholung/Vertiefung von \u00dcbung 3) Schreiben Sie eine Methode isLeapYear(int year) , die ein true zur\u00fcckgibt, wenn year ein Schaltjahr ist und ein false , wenn nicht. Ein Jahr ist ein Schaltjahr, wenn die Jahreszahl durch 4 teilbar ist, aber nicht durch 100 , au\u00dfer sie ist durch 400 teilbar. Schreiben Sie eine Methode printleapYear(int year) , die f\u00fcr year auf die Konsole ausgibt (Beispielwerte): 2021 ist kein Schaltjahr. 2020 war ein Schaltjahr. 2000 war ein Schaltjahr. 2024 wird ein Schaltjahr. 2025 wird kein Schaltjahr. Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 4 public class Uebung4 { public Uebung4 () { } public boolean isPrime ( int number ) { if ( number > 1 ) { for ( int i = 2 ; i < number ; i ++ ) { if ( number % i == 0 ) //ob i number ganzzahlig teilt (Division ohne Rest) { return false ; } } return true ; } else { return false ; } } public void myLesson4Method () { //System.out.println(isPrime(1)); printPrimeNumbers ( 61 ); } public void printPrimeNumbers ( int maximum ) { for ( int i = 2 ; i <= maximum ; i ++ ) { if ( isPrime ( i )) { System . out . print ( i + \" \" ); } else { System . out . print ( \". \" ); } } } } \u00dcbung 5 (17.11.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung5 . Erstellen Sie darin eine Klasse Uebung5 . Ersetzen Sie den gesamten Code der Klasse Uebung5 durch folgenden Code: public class Uebung5 { public Uebung5 () { } public void start () { // Definieren Sie alle Ihre Methoden au\u00dferhalb dieser Methode // Rufen Sie alle Ihre Methoden hier auf } } Wir schreiben uns zwei Methoden, die mathematische Funktionen umsetzen. Die eine Funktion berechnet die Potenz base^exp und die andere Funktion bereechnet die Quadratwurzel einer Zahl. Ziel der \u00dcbung ist es insbesondere, uns vorab die algorithmische Idee zu \u00fcberlegen. Programmieren Sie also nicht gleich los, sondern \u00fcberlegen Sie gemeinsam, wie Sie die beiden Funktionen umsetzen wollen! Schreiben Sie eine Methode public double pow(int base, int exp) . Dabei steht pow f\u00fcr power . Es soll base^exp berechnet werden. \u00dcberlegen Sie sich zun\u00e4chst z.B.: Wenn exp positiv ist, dann wollen wir base * base * ... * base berechnen, wobei base exp oft miteinander multipliziert wird. Welche Kontrollstruktur verwenden wir? Was sind die einzelnen \"Teile\" dieser Kontrollstruktur? Wir m\u00fcssen uns irgendwie das product dieser Multiplikationen merken. Wie ist der initiale Wert von product und warum? Funktioniert Ihre Idee auch, wenn exp den Wert 0 hat? Warum bzw. warum nicht? Wenn exp negativ ist, dann ist base^-exp = 1/(base^exp) . Was m\u00fcssen wir \u00e4ndern? Warum ist der R\u00fcckgabetyp double ? Warum nicht int ? Implementieren Sie eine Methode public void printPow(int base, int exp) , um Werte der Methodenaufrufe von pow() auf die Konsole auszugeben! Rufen Sie printPow(int base, int exp) in start() auf! Zusatzaufgabe (falls noch Zeit ist) Schreiben Sie eine Methode public double sqrt(int number) , die die Quadratwurzel der Zahl number berechnet. Wir verfolgen dabei folgende Idee ( Heron-Verfahren ): Wir stellen uns ein Rechteck vor, dessen Seitenl\u00e4ngen number und 1 sind. Die Fl\u00e4che dieses Rechtecks ist also number . Nun versuchen wir, aus diesem Rechteck ein Quadrat zu machen (rein virtuell nat\u00fcrlich). Der Fl\u00e4cheninhalt von diesem Quadrat soll number sein/bleiben. Ein Quadrat mit dem Fl\u00e4cheninhalt numbeer hat die Seitenl\u00e4ngen sqrt(number) , also das, was wir wollen. Um aus dem Rechteck ein Quadrat zu machen, gehen wir schrittweise vor: die eine Seite des Rechteckes/Quadrates wird der Mittelwert aus den Seiten des Rechtecks. Nun berechnen wir die andere Seite indem wir den Fl\u00e4cheninhalt des Rechtecks ( number ) durch die neue Seitenl\u00e4nge teilen. Somit haben wir 2 neue Seitenl\u00e4ngen, das Rechteck beh\u00e4lt aber den Fl\u00e4cheninhalt number . Wir berechnen erneut die neue Seitenl\u00e4nge des Rechtecks, indem wir den Mittelwert der beiden Seitenl\u00e4ngen berechnen und ermitteln dann wieder die andere Seitenl\u00e4nge, indem wir den Fl\u00e4cheninhalt durch die Seitenl\u00e4nge teilen. Die beiden Seitenl\u00e4ngen n\u00e4hern sich dann zunehmend an und sind irgendwann fast identisch, also ein Quadrat. Wie lange m\u00fcssen wir das wiederholen? Was ist am Ende unser Ergebnis? Von welchem Datentyp sollten die Seitenl\u00e4ngen sein? \u00dcberlegen Sie sich das Vorgehen genau, ehe Sie programmieren! Beispiel zur Berechnung der Wurzel aus 8: Implementieren Sie eine Methode public void printSqrt(int number) , um Werte der Methodenaufrufe von sqrt() auf die Konsole auszugeben! Rufen Sie printSqrt(int number) in start() auf! Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 5 public class Uebung5 { public double pow ( int base , int exp ) { double product = 1.0 ; if ( exp < 0 ) { for ( int nr = 1 ; nr <= - exp ; nr ++ ) // -exp ! { product = product * base ; } product = 1.0 / product ; } else { for ( int nr = 1 ; nr <= exp ; nr ++ ) { product = product * base ; } } return product ; } public double powDifferentSolution ( int base , int exp ) { double product = 1.0 ; int copyExp = exp ; if ( exp < 0 ) { copyExp = - exp ; } for ( int nr = 1 ; nr <= copyExp ; nr ++ ) { product = product * base ; } if ( exp < 0 ) { product = 1.0 / product ; } return product ; } public double sqrt ( int number ) { double area = number ; double a = number ; double b = 1.0 ; double epsilon = 0.00000001 ; while ( ( a - b ) * ( a - b ) > epsilon ) { a = ( a + b ) / 2.0 ; b = area / a ; } return a ; } public void start () { int base = 2 ; int exp = 4 ; double result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = 2 ; exp = 0 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = 2 ; exp = - 4 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = - 2 ; exp = 4 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = - 2 ; exp = - 4 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = - 2 ; exp = 3 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = - 2 ; exp = - 3 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); System . out . println ( sqrt ( 4 )); System . out . println ( sqrt ( 8 )); System . out . println ( sqrt ( 2 )); } } \u00dcbung 6 (24.11.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung6 . Erstellen Sie darin eine Klasse Konto . Erstellen Sie eine Testklasse KontoTest und f\u00fcgen Sie darin folgende Methode ein: @Test public void testKonto () { // hier die Kontoobjekte erzeugen // und die Objektmethoden anwenden } Erstellen Sie in der Klasse Konto zwei Objektvariablen guthaben vom Typ double \u2192 nur in der Klasse sichtbar! pin vom Typ int \u2192 ebenfalls nur in der Klasse sichtbar! Erstellen Sie in der Klasse Konto einen Konstruktor f\u00fcr Konto diesem Konstruktor wird als Parameter int pPin \u00fcbergeben mit dem Wert des Parameters wird innerhalb des Konstruktors der Wert von pin initialisiert Initialisieren Sie im Konstruktor auch die Objektvariable guthaben . Sie bekommt den Wert 0.0 (hierf\u00fcr haben wir also keinen Parameter, wir setzen den initialen Wert einfach generell auf 0.0 ) Erstellen Sie in der Klasse Konto eine Objektmethode einzahlen(double betrag) diese Objektmethode ist public und gibt nichts zur\u00fcck in dieser Methode wird der Wert der Objektvariablen guthaben um den Wert von betrag erh\u00f6ht erzeugen Sie in dieser Methode au\u00dferdem eine Ausgabe in der Form: Es wurden 100 ,00 Euro eingezahlt. falls der betrag den Wert 100.0 hatte. Die Formatierung des Betrages wird bei Ihnen anders aussehen - siehe dazu auch Zusatzaufgabe . Geben Sie in der testKonto() -Methode der Testklasse KontoTest ein: Konto k1 = new Konto ( 1234 ); k1 . einzahlen ( 100.0 ); k1 . einzahlen ( 50.0 ); k1 . einzahlen ( 150.0 ); und f\u00fchren Sie die testKonto() -Methode aus. Es sollten folgende Ausgaben erzeugt werden: Es wurden 100 ,00 Euro eingezahlt. Es wurden 50 ,00 Euro eingezahlt. Es wurden 150 ,00 Euro eingezahlt. Erstellen Sie in der Klasse Konto eine Objektmethode kontoauszug(int pPin) diese Objektmethode ist public und gibt nichts zur\u00fcck einen kontoauszug(int pPin) k\u00f6nnen Sie nur \"ziehen\", wenn der Parameterwert von pPin mit dem Wert der Objektvariablen pin \u00fcbereinstimmt wird der richtige Wert f\u00fcr die pin \u00fcbergeben, geben Sie das guthaben in der folgenden Form aus: Ihr aktuelles Guthaben betraegt 300 ,00 Euro. falls guthaben den Wert von 300.0 hat. wird ein falscher Wert f\u00fcr die pin \u00fcbergeben, geben Sie folgende Ausgabe aus: Falsche PIN! Erweitern Sie die testKonto() -Methode der Testklasse um folgende Anweisungen: k1 . kontoauszug ( 1235 ); // Falsche PIN! k1 . kontoauszug ( 1234 ); und f\u00fchren Sie die testKonto() -Methode aus. Es sollten folgende (weitere) Ausgaben erzeugt werden: Falsche PIN! Ihr aktuelles Guthaben betraegt 300 ,00 Euro. Erstellen Sie in der Klasse Konto eine Objektmethode auszahlen(int pPin, double betrag) diese Objektmethode ist public und gibt nichts zur\u00fcck es kann nur etwas ausgezahlt werden, wenn der Parameterwert von pPin mit dem Wert der Objektvariablen pin \u00fcbereinstimmt stimmen die Werte nicht \u00fcberein, geben Sie erneut Falsche PIN! aus. stimmt der pin -Wert, dann m\u00fcssen Sie pr\u00fcfen, ob das guthaben reicht, um betrag auszuzahlen. Ist nicht genug guthaben vorhanden, dann geben Sie aus Ihr Guthaben reicht nicht, um 400 ,00 Euro auszuzahlen. falls betrag den Wert 400.0 hatte. wenn der pin -Wert stimmt und genug guthaben vorhanden ist, um den betrag auszuzahlen, dann reduzieren Sie guthaben um den entsprechenden betrag und geben aus Es wurden 100 ,00 Euro ausgezahlt. falls der betrag den Wert 100.0 hatte. Erweitern Sie die testKonto() -Methode der Testklasse um folgende Anweisungen: k1 . auszahlen ( 1235 , 100.0 ); // Falsche PIN! k1 . auszahlen ( 1234 , 100.0 ); k1 . kontoauszug ( 1234 ); k1 . auszahlen ( 1234 , 300.0 ); // Guthaben reicht nicht k1 . auszahlen ( 1234 , 200.0 ); k1 . kontoauszug ( 1234 ); und f\u00fchren Sie die testKonto() -Methode aus. Es sollten folgende (weitere) Ausgaben erzeugt werden: Falsche PIN! Es wurden 100 ,00 Euro ausgezahlt. Ihr aktuelles Guthaben betraegt 200 ,00 Euro. Ihr Guthaben reicht nicht, um 300 ,00 Euro auszuzahlen. Es wurden 200 ,00 Euro ausgezahlt. Ihr aktuelles Guthaben betraegt 0 ,00 Euro. Angenommen, die gesamte Testmethode sieht jetzt so aus: @Test public void testKonto () { Konto k1 = new Konto ( 1234 ); k1 . einzahlen ( 100.0 ); k1 . einzahlen ( 50.0 ); k1 . einzahlen ( 150.0 ); k1 . kontoauszug ( 1235 ); // Falsche PIN! k1 . kontoauszug ( 1234 ); k1 . auszahlen ( 1235 , 100.0 ); // Falsche PIN! k1 . auszahlen ( 1234 , 100.0 ); k1 . kontoauszug ( 1234 ); k1 . auszahlen ( 1234 , 300.0 ); k1 . auszahlen ( 1234 , 200.0 ); k1 . kontoauszug ( 1234 ); k1 . einzahlen ( 150.0 ); k1 . kontoauszug ( 1234 ); } dann sollte die Ausgabe ungef\u00e4hr so aussehen (wahrscheinlich nur eine Stelle nach dem Komma/Punkt): Es wurden 100 ,00 Euro eingezahlt. Es wurden 50 ,00 Euro eingezahlt. Es wurden 150 ,00 Euro eingezahlt. Falsche PIN! Ihr aktuelles Guthaben betraegt 300 ,00 Euro. Falsche PIN! Es wurden 100 ,00 Euro ausgezahlt. Ihr aktuelles Guthaben betraegt 200 ,00 Euro. Ihr Guthaben reicht nicht, um 300 ,00 Euro auszuzahlen. Es wurden 200 ,00 Euro ausgezahlt. Ihr aktuelles Guthaben betraegt 0 ,00 Euro. Zusatzaufgabe (falls noch Zeit ist): Informieren Sie sich \u00fcber die System.out.printf() -Methode, um stets genau 2 Stellen nach dem Komma des Betrages auszugeben (siehe hier ). Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 6 Konto.java public class Konto { private double guthaben ; private int pin ; public Konto ( int pin ) { this . pin = pin ; this . guthaben = 0.0 ; System . out . println ( \"Neues Konto eroeffnet\" ); // Ausnahme, dass hier Ausgabe!! // \"Das ist des Teufels\" } public void einzahlen ( double betrag ) { this . guthaben = betrag + this . guthaben ; System . out . println ( \"Es wurden \" + betrag + \"0 Euro eingezahlt.\" ); } public void auszahlen ( int pin , double betrag ) { if ( pin == this . pin ) // if(pin == this.pin && this.guthaben <= betrag) dann w\u00e4re es k\u00fcrzer, //aber wir k\u00f6nnen nicht sehen, wo der fehler liegt, deswegen besser einzeln...) { if ( betrag > this . guthaben ) { System . out . println ( \"Ihr Guthaben reicht nicht, um \" + betrag + \"0 Euro auszuzahlen.\" ); } else { this . guthaben = this . guthaben - betrag ; System . out . println ( \"Es wurden \" + betrag + \"0 Euro ausgezahlt.\" ); } } else { System . out . println ( \"Falsche PIN!\" ); } } public void kontoauszug ( int pin ) { if ( pin == this . pin ) { System . out . println ( \"Ihr aktuelles Guthaben betr\u00e4gt \" + this . guthaben + \"0 Euro.\" ); } else { System . out . println ( \"Falsche PIN!\" ); } } } KontoTest.java import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; public class KontoTest { @Test public void testKonto () { Konto k1 = new Konto ( 1234 ); k1 . einzahlen ( 100.0 ); k1 . einzahlen ( 50.0 ); k1 . einzahlen ( 150.0 ); k1 . kontoauszug ( 1235 ); // Falsche PIN! k1 . kontoauszug ( 1234 ); k1 . auszahlen ( 1235 , 100.0 ); // Falsche PIN! k1 . auszahlen ( 1234 , 100.0 ); k1 . kontoauszug ( 1234 ); k1 . auszahlen ( 1234 , 300.0 ); // Guthaben reicht nicht k1 . auszahlen ( 1234 , 200.0 ); k1 . kontoauszug ( 1234 ); k1 . einzahlen ( 150.0 ); k1 . kontoauszug ( 1234 ); // hier die Kontoobjekte erzeugen // und die Objektmethoden anwenden } @Test public void teststart () { } } \u00dcbung 7 (1.12.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung7 . Erstellen Sie darin eine Klasse Rectangle . Erstellen Sie eine Testklasse RectangleTest und f\u00fcgen Sie darin folgende Methode ein: @Test public void testRectangle () { // hier die Rectangleobjekte erzeugen // und die Objektmethoden anwenden } Erstellen Sie in der Klasse Rectangle zwei Objektvariablen a vom Typ int \u2192 nur in der Klasse sichtbar! b vom Typ int \u2192 ebenfalls nur in der Klasse sichtbar! a und b repr\u00e4sentieren die Seiten des Rechtecks. Erstellen Sie f\u00fcr die Klasse Rectangle einen parameterlosen Konstruktor Rectangle() . Dieser setzt f\u00fcr die Seite a den Wert 10 und f\u00fcr die Seite b den Wert 20 . Erstellen Sie au\u00dferdem einen parametrisierten Konstruktor Rectangle(int a, int b) . Dieser verwendet die Werte der Parameter, um den Objektvariablen Werte zuzuweisen. Erstellen Sie eine Objektmethode area() , die den Fl\u00e4cheninhalt des Rechtecks als int zur\u00fcckgibt. Erstellen Sie eine Objektmethode perimeter() , die den Umfang des Rechtecks als int zur\u00fcckgibt. Erstellen Sie eine Objektmethode toString() , die Informationen \u00fcber das Rechtecks als String in z.B. der folgenden Form (Beispielwerte): Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) zur\u00fcckgibt. Implementieren Sie eine Objektmethode public void print() , die den durch toString() erzeugten String auf die Konsole ausgibt. Geben Sie in der testRectangle() -Methode der RectangleTest -Klasse ein: // Objekte erzeugen Rectangle r1 = new Rectangle (); Rectangle r2 = new Rectangle ( 12 , 18 ); Rectangle r3 = new Rectangle ( 40 , 5 ); Rectangle r4 = new Rectangle ( 20 , 10 ); Rectangle r5 = new Rectangle ( 11 , 21 ); System . out . printf ( \"%n%n--------------- print()-Methode -----------------%n%n\" ); r1 . print (); r2 . print (); r3 . print (); r4 . print (); r5 . print (); und rufen Sie die testRectangle() auf. Es sollten folgende Ausgaben erzeugt werden: --------------- print () -Methode ----------------- Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) Rectangle : ( a = 12 , b = 18 , area = 216 , perimeter = 60 ) Rectangle : ( a = 40 , b = 5 , area = 200 , perimeter = 90 ) Rectangle : ( a = 20 , b = 10 , area = 200 , perimeter = 60 ) Rectangle : ( a = 11 , b = 21 , area = 231 , perimeter = 64 ) Erstellen Sie eine Methode sidesAreEqual(Rectangle r) , die ein true zur\u00fcckgibt, wenn die Seiten des aufrufenden Objektes gleich der Seiten des Rechtecks r sind; false sonst. Sie k\u00f6nnen entscheiden, dass das Rechteck auch gedreht noch gleiche Seiten haben soll, also a=10, b=20 ist nicht nur mit a=10, b=20 gleich, sondern auch mit a=20, b=10 . Wenn die Seiten ungleich sind, gibt die Methode ein false zur\u00fcck. Erstellen Sie eine Methode areasAreEqual(Rectangle r) , die ein true zur\u00fcckgibt, wenn der Fl\u00e4cheninhalt des aufrufenden Objektes gleich dem Fl\u00e4cheninhalt des Rechtecks r ist; false sonst. Erstellen Sie eine Methode perimetersAreEqual(Rectangle r) , die ein true zur\u00fcckgibt, wenn der Umfang des aufrufenden Objektes gleich dem Umfang des Rechtecks r ist; false sonst. Erstellen Sie eine Methode printComparison(Rectangle r) , die die Vergleiche mit r auf die Konsole ausgibt, z.B.: this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 12 , b = 18 , area = 216 , perimeter = 60 ) sides are not equal areas are not equal perimeters are equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 40 , b = 5 , area = 200 , perimeter = 90 ) sides are not equal areas are equal perimeters are not equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 20 , b = 10 , area = 200 , perimeter = 60 ) sides are equal areas are equal perimeters are equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 11 , b = 21 , area = 231 , perimeter = 64 ) sides are not equal areas are not equal perimeters are not equal F\u00fcgen Sie in der testRectangle() -Methode der RectangleTest -Klasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n---------- printComparison()-Methode ------------%n%n\" ); r1 . printComparison ( r2 ); r1 . printComparison ( r3 ); r1 . printComparison ( r4 ); r1 . printComparison ( r5 ); und rufen Sie die testRectangle() -Methode auf. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: ---------- printComparison () -Methode ------------ this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 12 , b = 18 , area = 216 , perimeter = 60 ) sides are not equal areas are not equal perimeters are equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 40 , b = 5 , area = 200 , perimeter = 90 ) sides are not equal areas are equal perimeters are not equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 20 , b = 10 , area = 200 , perimeter = 60 ) sides are equal areas are equal perimeters are equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 11 , b = 21 , area = 231 , perimeter = 64 ) sides are not equal areas are not equal perimeters are not equal Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 7 Rectangle.java public class Rectangle { private int a ; private int b ; // a,b repr\u00e4sentieren Seiten des Rechtecks public Rectangle () { this . a = 10 ; this . b = 20 ; } public Rectangle ( int a , int b ) { this . a = a ; this . b = b ; } public int area () { return this . a * this . b ; } public int perimeter () { return 2 * this . a + 2 * this . b ; } public String toString () { /*String output = \"Rectangle : ( a=\" + this.a + \", b=\" + this.b + \", area=\"; output = output + \" this.area() + \", perimeter=\" + this.perimeter() + \" )\" */ String output = String . format ( \"Rectangle : ( a=%2d, b=%2d, area=%3d, perimeter=%2d )\" , this . a , this . b , this . area (), this . perimeter () ); return output ; } public void print () { System . out . println ( this . toString ()); } public boolean sidesAreEqual ( Rectangle r ) { boolean equals = false ; if (( this . a == r . a && this . b == r . b ) || ( this . a == r . b && this . b == r . a )) { equals = true ; } return equals ; } public boolean areasAreEqual ( Rectangle r ) { return ( this . area () == r . area ()); } public boolean perimetersAreEqual ( Rectangle r ) { return ( this . perimeter () == r . perimeter ()); } public void printComparison ( Rectangle r ) { System . out . printf ( \"%-9s %s %n\" , \"this\" , this . toString ()); System . out . printf ( \"%-9s %s %n\" , \"the other\" , r . toString ()); if ( this . sidesAreEqual ( r )) { System . out . println ( \"sides are equal\" ); } else { System . out . println ( \"sides are not equal\" ); } if ( this . areasAreEqual ( r )) { System . out . println ( \"areas are equal\" ); } else { System . out . println ( \"areas are not equal\" ); } if ( this . perimetersAreEqual ( r )) { System . out . println ( \"perimeters are equal\" ); } else { System . out . println ( \"perimeters are not equal\" ); } System . out . println (); } } RectangleTest.java import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; public class RectangleTest { @Test public void testRectangle () { // Objekte erzeugen Rectangle r1 = new Rectangle (); Rectangle r2 = new Rectangle ( 12 , 18 ); Rectangle r3 = new Rectangle ( 40 , 5 ); Rectangle r4 = new Rectangle ( 20 , 10 ); Rectangle r5 = new Rectangle ( 11 , 21 ); System . out . printf ( \"%n%n--------------- print()-Methode -----------------%n%n\" ); r1 . print (); r2 . print (); r3 . print (); r4 . print (); r5 . print (); System . out . printf ( \"%n%n---------- printComparison()-Methode ------------%n%n\" ); r1 . printComparison ( r2 ); r1 . printComparison ( r3 ); r1 . printComparison ( r4 ); r1 . printComparison ( r5 ); } } \u00dcbung 8 (8.12.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung8 . Erstellen Sie darin eine Klasse Date . Erstellen Sie eine Programmklasse Programclass und f\u00fcgen Sie darin folgende Methode ein: public void start () { // hier die Rectangleobjekte erzeugen // und die Objektmethoden anwenden } Erstellen Sie in der Klasse Date drei Objektvariablen day vom Typ int \u2192 nur in der Klasse sichtbar! month vom Typ int \u2192 ebenfalls nur in der Klasse sichtbar! year vom Typ int \u2192 ebenfalls nur in der Klasse sichtbar! Erstellen Sie f\u00fcr die Klasse Date einen parameterlosen Konstruktor public Date() . Dieser setzt das \"Datum\" auf den 1.1.1900 . Erstellen Sie au\u00dferdem einen parametrisierten Konstruktor public Date(int day, int month, int year) . Dieser verwendet die Werte der Parameter, um den Objektvariablen Werte zuzuweisen. Erstellen Sie eine Objektmethode public String toString() , die das Datum in der Form (Beispielwerte) \"1.1.1900\" als String zur\u00fcckgibt. Implementieren Sie eine Objektmethode public void print() , die den durch toString() erzeugten String auf die Konsole ausgibt. Geben Sie in der start() -Methode der Programclass -Klasse ein: // Date-Objekte erzeugen Date d1 = new Date ( 11 , 11 , 2000 ); Date d2 = new Date ( 20 , 10 , 2020 ); Date d3 = new Date (); System . out . printf ( \"%n%n--------------- print()-Methode Date -----------------%n%n\" ); d1 . print (); d2 . print (); d3 . print (); und rufen Sie die start() -Methode auf. Es sollten folgende Ausgaben erzeugt werden: --------------- print () -Methode Date ----------------- 11 .11.2000 20 .10.2020 1 .1.1900 Erstellen Sie im Projekt eine weitere Klasse Fruit . Erstellen Sie in der Klasse Fruit zwei Objektvariablen name vom Typ String \u2192 nur in der Klasse sichtbar! expiry vom Typ Date \u2192 ebenfalls nur in der Klasse sichtbar! Erstellen Sie f\u00fcr die Klasse Fruit einen prametrisierten Konstruktor public Fruit(String name, Date expiry) . Dieser verwendet die Werte der Parameter, um den Objektvariablen Werte zuzuweisen. Erstellen Sie eine Objektmethode public String toString() , die die Frucht in der Form (Beispielwerte) \"Banana expires on 11.11.2000\" als String zur\u00fcckgibt. Implementieren Sie eine Objektmethode public void print() , die den durch toString() erzeugten String auf die Konsole ausgibt. Geben Sie in der start() -Methode der Programclass -Klasse ein: // Fruit-Objekte erzeugen Fruit banana = new Fruit ( \"Banana\" , d1 ); Fruit apple = new Fruit ( \"Apple\" , d2 ); Fruit pear = new Fruit ( \"Pear\" , d3 ); System . out . printf ( \"%n%n--------------- print()-Methode Fruit -----------------%n%n\" ); banana . print (); apple . print (); pear . print (); und rufen Sie die start() -Methode auf. Es sollten folgende Ausgaben erzeugt werden: --------------- print () -Methode Fruit ----------------- Banana expires on 11 .11.2000 Apple expires on 20 .10.2020 Pear expires on 1 .1.1900 Erweiteren Sie die Klasse Date um folgende Methode public void later(int days) . Bei Anwendung dieser Methode soll zum aktuellen Datum die als Parameter \u00fcbergebenen days hinzugef\u00fcgt werden. Dabei ist Folgendes zu beachten: Die Anzahl von days kann auch mehrere Jahre und mehrere Monate umfassen. Das soll eine Wiederholung von \u00dcbung 3 sein - aber nicht gleich dort nachgucken, sondern nochmal \u00fcberlegen! Wir nehmen an, dass jeder Monat nur 30 Tage hat und ein Jahr immer nur 365 . Erweiteren Sie die Klasse Fruit um die Methode public Date getExpiryDate() . Geben Sie in der start() -Methode der Programclass -Klasse ein: System . out . printf ( \"%n%n------------ later() und getExpiryDate ----------------%n%n\" ); d1 . later ( 12 ); d2 . later ( 123 ); d3 . later ( 1234 ); d1 . print (); d2 . print (); d3 . print (); banana . print (); apple . print (); pear . print (); banana . getExpiryDate (). later ( 12 ); apple . getExpiryDate (). later ( 123 ); pear . getExpiryDate (). later ( 1234 ); d1 . print (); d2 . print (); d3 . print (); Was stellen Sie fest? L\u00e4uft etwas schief? Was sind die Probleme? Worin liegen sie begr\u00fcndet? Haben Sie Ideen, wie Sie diese Probleme vermeiden k\u00f6nnten? ( \u00dcbrings: das Thema, das wir hier ein wenig n\u00e4her beleuchten, nennt sich immutable objects ) Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 8 Date.java public class Date { private int day ; private int month ; private int year ; public Date ( int day , int month , int year ) { this . day = day ; this . month = month ; this . year = year ; } public Date () { this . day = 1 ; this . month = 1 ; this . year = 1900 ; } /* * Die folgende Implementierung stellt eine M\u00f6glichkeit dar, * ein sp\u00e4teres Datum zu bestimmen. Diese Methode \u00e4ndert aber * das Objekt selbst, d.h. die Werte der Objektvariablen * werden neu gesetzt. Dadurch wird das Objekt ver\u00e4nderlich. */ public void later ( int days ) { int years = days / 365 ; int remainder = days % 365 ; int months = remainder / 30 ; remainder = remainder % 30 ; this . year += years ; this . day += remainder ; this . month += months ; if ( this . day > 30 ) { this . month ++ ; this . day %= 30 ; } if ( this . month > 12 ) { this . year ++ ; this . month %= 12 ; } } /* * Die folgende Implementierung stellt eine M\u00f6glichkeit dar, * ein sp\u00e4teres Datum zu bestimmen. Diese Methode \u00e4ndert aber * das Objekt selbst, d.h. die Werte der Objektvariablen * werden neu gesetzt. Dadurch wird das Objekt ver\u00e4nderlich. */ public Date laterImmutable ( int days ) { int years = days / 365 ; int remainder = days % 365 ; int months = remainder / 30 ; remainder = remainder % 30 ; // nur noch lesenden Zugriff auf die // Werte der Objektvariablen --> // Werte bleiben unver\u00e4ndert int newYears = this . year + years ; int newDays = this . day + remainder ; int newMonths = this . month + months ; if ( newDays > 30 ) { newMonths ++ ; newDays %= 30 ; } if ( newMonths > 12 ) { newYears ++ ; newMonths %= 12 ; } return new Date ( newDays , newMonths , newYears ); } public String toString () { return this . day + \".\" + this . month + \".\" + this . year ; } public void print () { System . out . println ( this . toString ()); } } Fruit.java public class Fruit { private String name ; private Date expiry ; public Fruit ( String name , Date expiry ) { this . name = name ; this . expiry = expiry ; // man k\u00f6nnte hier \u00fcberlegen, ob man wirklich die Referenz auf // das \u00fcbergebene Date-Objekt speichern m\u00f6chte oder lieber // eine eigene Kopie des Objektes erzeugen und diese speichern // dazu fehlen allerdings die Getter der Date-Objektvariablen :-( } public String toString () { return this . name + \" expires on \" + this . expiry . toString (); } public void print () { System . out . println ( this . toString () ); } public Date getExpiryDate () { return this . expiry ; // hier w\u00e4re es auch besser, nicht die Referenz, sondern // ein neues Date-Objekt zur\u00fcckzugeben // dazu fehlen allerdings die Getter der Date-Objektvariablen :-( } } Programclass.java public class Programclass { public void start () { Date d1 = new Date ( 11 , 11 , 2000 ); Date d2 = new Date ( 20 , 10 , 2020 ); Date d3 = new Date (); System . out . printf ( \"%n%n--------------- print()-Methode Date -----------------%n%n\" ); d1 . print (); d2 . print (); d3 . print (); Fruit banana = new Fruit ( \"Banana\" , d1 ); Fruit apple = new Fruit ( \"Apple\" , d2 ); Fruit pear = new Fruit ( \"Pear\" , d3 ); System . out . printf ( \"%n%n--------------- print()-Methode Fruit -----------------%n%n\" ); banana . print (); apple . print (); pear . print (); System . out . printf ( \"%n%n------------ later() und getExpiryDate ----------------%n%n\" ); d1 . later ( 12 ); d2 . later ( 123 ); d3 . later ( 1234 ); d1 . print (); d2 . print (); d3 . print (); banana . print (); apple . print (); pear . print (); banana . getExpiryDate (). later ( 12 ); apple . getExpiryDate (). later ( 123 ); pear . getExpiryDate (). later ( 1234 ); d1 . print (); d2 . print (); d3 . print (); } } \u00dcbung 9 (15.12.2021) Diese \u00dcbung wird nicht am Rechner durchgef\u00fchrt, sondern es geht um Programmverst\u00e4ndinis und algorithmische Ideen! Zun\u00e4chst ein Beispiel f\u00fcr eine \u201cErkl\u00e4ren Sie den folgenden Code in einem Satz\u201d -Aufgabe: if ( a < b ) { System . out . print ( a ); } else { System . out . print ( b ); } Antwort: Der kleinere Wert der Variablen a und b wird ausgegeben. Was wird durch folgenden Code auf der Konsole ausgegeben?: public class PrinterClass { public static void main ( String [] args ) { System . out . print ( \"answer=\" ); System . out . println ( 40 + 2 ); } } Was wird durch folgenden Code auf der Konsole ausgegeben?: int number = 3 ; while ( number == 3 ) { System . out . print ( number + \" + \" ); number ++ ; } Was wird durch folgenden Code auf der Konsole ausgegeben?: for ( int count = 0 ; count < 4 ; count -- ) { System . out . print ( count ); } Erkl\u00e4ren Sie den folgenden Code in einem Satz. int sum = 0 ; for ( int n = 1 ; n <= 20 ; n ++ ) { sum = sum + n ; } System . out . println ( sum ); Erkl\u00e4ren Sie den folgenden Code in einem Satz. if ( a < b ) { if ( b < c ) { System . out . println ( c ); } else { System . out . println ( b ); } } else if ( a < c ) { System . out . println ( c ); } else { System . out . println ( a ); } Welche Kombination von Werten sorgt daf\u00fcr, dass b ausgegeben wird? Was macht der folgende Code? public class Student { private String name ; private int age ; public Student ( String name , int age ) { this . name = name ; this . age = age ; } public int getAge ( ) { return age ; } public int hadBirthday ( ) { return age = age + 1 ; } public void main ( ) { Student willi = new Student ( \"Willi\" , 25 ) ; willi . hadBirthday ( ) ; System . out . print ( willi . getAge ( ) ) ; } } Welchen Wert liefert rect2.area( ) ? public class Rectangle { private int x1 , y1 , x2 , y2 ; public Rectangle ( int x1 , int y1 , int x2 , int y2 ) { this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; } public int width () { return this . x2 - this . x1 ; } public int height () { return this . y2 - this . y1 ; } public double area () { return this . width () * this . height (); } public void main () { Rectangle rect1 = new Rectangle ( 0 , 0 , 10 , 10 ); System . out . println ( rect1 . area ()); Rectangle rect2 = new Rectangle ( 5 , 5 , 10 , 10 ); System . out . println ( rect2 . area ()); } } Was macht der folgende Code? public class Vehicle { String producer , type ; int topSpeed , currentSpeed ; public Vehicle ( String p , String t , int tp ) { this . producer = p ; this . type = t ; this . topSpeed = tp ; this . currentSpeed = 0 ; } public int accelerate ( int kmh ) { if ( ( this . currentSpeed + kmh ) > this . topSpeed ) { this . currentSpeed = this . topSpeed ; } else { this . currentSpeed = this . currentSpeed + kmh ; } return this . currentSpeed ; } public static void main ( String args [ ] ) { Vehicle v = new Vehicle ( \"Audi\" , \"A6\" , 200 ) ; v . accelerate ( 10 ) ; } } Was wird durch folgenden Code auf der Konsole ausgegeben? int iNum = 3 ; for ( int iX = 0 ; iX < iNum ; iX ++ ) { for ( int iY = 0 ; iY < iNum ; iY ++ ) { System . out . print ( \"*\" ); } System . out . println (); } Was wird durch folgenden Code auf der Konsole ausgegeben? public class PrintPattern { public void printMethod ( int numberOfRows ) { for ( int row = 1 ; row <= numberOfRows ; row ++ ) { for ( int col = 1 ; col <= row ; col ++ ) { System . out . print ( '*' ) ; } System . out . println ( ) ; } } public void main ( ) { PrintPattern p = new PrintPattern (); p . printMethod ( 3 ) ; } } Was berechnet der folgende Code? public int calculate ( int number1 , int number2 ) { int result = number1 ; for ( int i = 2 ; i <= number2 ; i += 1 ) { result = result * number1 ; } return result ; } Was wird durch folgenden Code auf der Konsole ausgegeben? int n = 4 ; for ( int row = 1 ; row <= n ; row ++ ) { for ( int column = 1 ; column <= n ; column ++ ) { if ( row == 1 || row == n || column == 1 || column == n ) System . out . print ( \"* \" ); else System . out . print ( \" \" ); } System . out . println ( ); } } \u00dcbung 10 (22.12.2021) Wir nutzen von nun an Eclipse in den \u00dcbungen und in den Vorlesungen. Bitte installieren! Erstellen Sie ein package uebungen.uebung10 . Erstellen Sie in diesem package eine Klasse Programmklasse mit main() -Methode und eine Klasse Uebung10 . Implementieren Sie in der Klasse Uebung10 folgende Methoden: Implementieren Sie eine public void print(char[] ca) -Methode, so dass das char[] ca auf die Konsole ausgegeben wird. Achten Sie darauf, dass hinter dem letzten Element kein Komma steht. Testen Sie Ihre Methode auch f\u00fcr ein leeres Array. Bsp: print(['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c']) Ausgabe auf Konsole: [a, b, c, a, c, a, b, c] Kopieren Sie die print -Methode vollst\u00e4ndig und \u00e4ndern Sie den Typ des Parameters von char[] in int[] . (Die Methode ist jetzt \u00fcberladen und print() kann jetzt entweder ein char[] oder ein int[] \u00fcbergeben werden, welches auf die Konsole ausgegeben wird.) Implementieren Sie eine Methode public char[] stringToCharArray(String s) . Diese Methode wandelt einen String in ein char[] um, so dass jedes Zeichen des Strings im char[] enthalten ist. Das char[] wird zur\u00fcckgegeben. Tipps: die L\u00e4nge eines Strings wird mit der Objektmethode length() ermittelt. Die einzelnen Zeichen eines Strings k\u00f6nnen mithilfe der charAt(index) -Objektmethode von Strings ermittelt werden. Siehe String Bsp.: stringToCharArray(\"hallo!\") \u2192 ['h','a','l','l','o','!'] Implementieren Sie eine Methode public int[] reverse(int[] iarr) , der ein int -Array \u00fcbergeben wird und die die Reihenfolge der Elemente des Arrays umdreht (das letzte zuerst usw.) Das neuerstellte Array wird zur\u00fcckgegeben. Bsp.: reverse([4,2,8,1,6,2,4,1,8]) \u2192 [8,1,4,2,6,1,8,2,4] reverse([4]) \u2192 [4] Erzeugen Sie in der main() -Methode der Programmklasse ein char -Array mit den Werten ['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c'] , ein int -Array mit den Werten [4,2,8,1,6,2,4,1,8] und ein Objekt der Klasse Uebung10 und testen Sie alle Methoden der Klasse Uebung10 . Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 10 Programclass.java package uebungen.uebung10 ; public class Programclass { public static void main ( String [] args ) { char [] ca1 = { 'a' , 'b' , 'c' , 'a' , 'c' , 'a' , 'b' , 'c' }; char [] ca2 = new char [ 0 ] ; int [] ia1 = { 4 , 2 , 8 , 1 , 6 , 2 , 4 , 1 , 8 }; int [] ia2 = { 4 }; Uebung10 u1 = new Uebung10 (); u1 . print ( ca1 ); u1 . print ( ca2 ); u1 . print ( ia1 ); u1 . print ( ia2 ); char [] ca3 = u1 . stringToCharArray ( \"Hallo FIW!\" ); u1 . print ( ca3 ); int [] ia3 = u1 . reverse ( ia1 ); u1 . print ( ia1 ); u1 . print ( ia3 ); } } Uebung10.java package uebungen.uebung10 ; public class Uebung10 { public void print ( char [] ca ) { String s = \"[ \" ; if ( ca . length == 0 ) { s = s + \"]\" ; } else { for ( int index = 0 ; index < ca . length - 1 ; index ++ ) { s = s + ca [ index ] + \", \" ; } s = s + ca [ ca . length - 1 ] + \" ]\" ; } System . out . println ( s ); } public void print ( int [] ia ) { String s = \"[ \" ; if ( ia . length == 0 ) { s = s + \"]\" ; } else { for ( int index = 0 ; index < ia . length - 1 ; index ++ ) { s = s + ia [ index ] + \", \" ; } s = s + ia [ ia . length - 1 ] + \" ]\" ; } System . out . println ( s ); } public char [] stringToCharArray ( String s ) { char [] ca = new char [ s . length () ] ; for ( int index = 0 ; index < ca . length ; index ++ ) { ca [ index ] = s . charAt ( index ); } return ca ; } public int [] reverse ( int [] iarr ) { int [] ia = new int [ iarr . length ] ; for ( int index = 0 ; index < ia . length ; index ++ ) { ia [ index ] = iarr [ iarr . length - 1 - index ] ; } return ia ; } } \u00dcbung 11 (05.01.2022) Sie k\u00f6nnen einfach Ihre L\u00f6sung (die Klassen) aus \u00dcbung 10 weiterverwenden. Implementieren Sie in der Klasse Uebung10 (oder wenn Sie doch eine neue Klasse Uebung11 haben, dann darein) folgende Methoden: Implementieren Sie eine Methode public char[] filter(char[] carr, char filter) , der als Parameter ein char -Array und ein char \u00fcbergeben wird. Die Methode soll ein char -Array zur\u00fcckgeben, das dem als Parameter \u00fcbergeben Array entspricht, au\u00dfer dass jedes Vorkommen des als Parameter \u00fcbergeben carr entfernt wurde Bsp: filter(['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c'], 'c') \u2192 ['a', 'b', 'a', 'a', 'b'] Implementieren Sie eine Methode public int[] minAndMax(int[] iarr) , der ein int -Array als Parameter \u00fcbergeben wird und die ein zweielementiges Array zur\u00fcckgibt. Das erste Element des zur\u00fcckgegeben Arrays ist das Minimum des als Parameter \u00fcbergebenen Arrays und das zweite Element ist das Maximum. Bsp.: minAndMax([4,2,8,1,6,2,4,1,8]) \u2192 [1,8] minAndMax([4]) \u2192 [4,4] Zusatz: Implementieren Sie eine Methode public boolean containsDoublets(char[] ca) die ein true zur\u00fcckgibt, wenn mindestens ein Wert in ca mindestens zwei Mal vorkommt (wenn Sie schon dabei sind, k\u00f6nnen Sie sich auch \u00fcberlegen, wenn genau ein Wert genau zwei Mal vorkommt - oder mindestens ein Wert genau zwei Mal - oder genau ein Wert mindestens zwei Mal) und false sonst. Erzeugen Sie in der main() -Methode der Programmklasse ein char -Array mit den Werten ['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c'] , ein int -Array mit den Werten [4,2,8,1,6,2,4,1,8] und ein Objekt der Klasse Uebung10 (oder Uebung11 - siehe oben) und testen Sie alle Methoden der Klasse Uebung10 (oder Uebung11 - siehe oben). Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 11 (weiter Klasse Uebung10.java verwendet) Programclass.java package uebungen.uebung10 ; public class Programclass { public static void main ( String [] args ) { char [] ca1 = { 'a' , 'b' , 'c' , 'a' , 'c' , 'a' , 'b' , 'c' }; char [] ca2 = new char [ 0 ] ; int [] ia1 = { 4 , 2 , 8 , 1 , 6 , 2 , 4 , 1 , 8 }; int [] ia2 = { 4 }; Uebung10 u1 = new Uebung10 (); u1 . print ( ca1 ); u1 . print ( ca2 ); u1 . print ( ia1 ); u1 . print ( ia2 ); char [] ca3 = u1 . stringToCharArray ( \"Hallo FIW!\" ); u1 . print ( ca3 ); int [] ia3 = u1 . reverse ( ia1 ); u1 . print ( ia1 ); u1 . print ( ia3 ); System . out . printf ( \"%n%n------------ Uebung 11 filter()---------------%n%n\" ); u1 . print ( ca1 ); char [] ca4 = u1 . filter ( ca1 , 'c' ); u1 . print ( ca4 ); char [] ca5 = u1 . filter ( ca1 , 'a' ); u1 . print ( ca5 ); char [] ca6 = u1 . filter ( ca1 , 'b' ); u1 . print ( ca6 ); char [] ca7 = u1 . filter ( ca1 , 'd' ); u1 . print ( ca7 ); System . out . println (); u1 . print ( ca3 ); char [] ca8 = u1 . filter ( ca3 , 'l' ); u1 . print ( ca8 ); char [] ca9 = u1 . stringToCharArray ( \"superlangerTeststringzumFiltern kann auch Leerzeichen enthalten oder alle m\u00f6glichen Zeichen ?%$\u00a7!*\" ); u1 . print ( ca9 ); u1 . print ( u1 . filter ( ca9 , 'e' )); System . out . printf ( \"%n%n------------ Uebung 11 minAndMax()---------------%n%n\" ); u1 . print ( ia1 ); int [] mm1 = u1 . minAndMax ( ia1 ); u1 . print ( mm1 ); System . out . println (); u1 . print ( ia2 ); int [] mm2 = u1 . minAndMax ( ia2 ); u1 . print ( mm2 ); } } Uebung10.java package uebungen.uebung10 ; public class Uebung10 { public void print ( char [] ca ) { String s = \"[ \" ; if ( ca . length == 0 ) { s = s + \"]\" ; } else { for ( int index = 0 ; index < ca . length - 1 ; index ++ ) { s = s + ca [ index ] + \", \" ; } s = s + ca [ ca . length - 1 ] + \" ]\" ; } System . out . println ( s ); } public void print ( int [] ia ) { String s = \"[ \" ; if ( ia . length == 0 ) { s = s + \"]\" ; } else { for ( int index = 0 ; index < ia . length - 1 ; index ++ ) { s = s + ia [ index ] + \", \" ; } s = s + ia [ ia . length - 1 ] + \" ]\" ; } System . out . println ( s ); } public char [] stringToCharArray ( String s ) { char [] ca = new char [ s . length () ] ; for ( int index = 0 ; index < ca . length ; index ++ ) { ca [ index ] = s . charAt ( index ); } return ca ; } public int [] reverse ( int [] iarr ) { int [] ia = new int [ iarr . length ] ; for ( int index = 0 ; index < ia . length ; index ++ ) { ia [ index ] = iarr [ iarr . length - 1 - index ] ; } return ia ; } public char [] filter ( char [] carr , char filter ) { /* * neues Array erzeugen -- Idee: * 1. neues Array erzeugen (char[]) * 2. aber wie lang ist das neue Array? * 3. Laenge von neuen Array ist (Laenge von carr - Anzahl des Vorkommens von filter in carr) */ // wie oft kommt filter in carr vor? int counter = 0 ; for ( int index = 0 ; index < carr . length ; index ++ ) { if ( carr [ index ] == filter ) { counter ++ ; } } // jetzt wissen wir, wie oft filter in carr vorkommt: counter int laengeVomNeuenArray = carr . length - counter ; // jetzt kann das neue Array erzeugt werden (jetzt kennen wir die Laenge) char [] filterArray = new char [ laengeVomNeuenArray ] ; /* * neues Array befuellen -- Idee: * 1. wir laufen durch das komplette carr (for-Schleife) * 2. fuer jedes Element aus carr pruefen, ob es dem filter entspricht * 2a. wenn es nicht filter entspricht, dann kopieren * 2b. wenn es filter entspricht, dann wird es nicht kopiert * 3. wichtig: unterschiedlich indexCarr und indexNeuesArray (haben ja auch unter- * schiedliche Laengen) */ // jetzt befuellen - zunaechst for-Schleife fuer carr int indexFilterArray = 0 ; for ( int indexCarr = 0 ; indexCarr < carr . length ; indexCarr ++ ) { if ( carr [ indexCarr ] != filter ) { // dann kopieren (sonst nicht) // das geht nicht: --> filterArray[indexCarr] = carr[indexCarr]; filterArray [ indexFilterArray ] = carr [ indexCarr ] ; indexFilterArray ++ ; } } return filterArray ; } public int [] minAndMax ( int [] iarr ) { // wir koennen davon ausgehen, dass iarr.length mind. 1 ist int curMin = iarr [ 0 ] ; int curMax = iarr [ 0 ] ; for ( int index = 0 ; index < iarr . length ; index ++ ) { if ( iarr [ index ] < curMin ) { curMin = iarr [ index ] ; // iarr[index] ist nun mein neues aktuelles Minimum } if ( iarr [ index ] > curMax ) { curMax = iarr [ index ] ; // iarr[index] ist nun mein neues aktuelles Maximum } } // entweder so: /* * int[] minAndMax = new int[2]; * minAndMax[0] = curMin; * minAndMax[1] = curMax; * return minAndMax; */ // oder so: /* * int[] minAndMax = { curMin, curMax }; * return minAndMax; */ // oder so: return new int [] { curMin , curMax }; } } \u00dcbung 12 (12.01.2022) siehe Moodle \u00dcbung 13 (19.01.2022) Erstellen Sie ein package uebungen.uebung13 . Erstellen Sie in diesem package eine Klasse Lottery mit der privaten Objektvariablen drawingResults vom Typ int[] . Information : Lottery steht f\u00fcr eine Lotterie, bei der aus 9 Zahlen (1..9) 5 Zahlen zuf\u00e4llig gelost werden (5 aus 9). Das Array drawingResults dient zum Speichern der gezogenen 5 Zahlen. Schreiben Sie f\u00fcr die Klasse Lottery einen parameterlosen Konstruktor. In diesem Konstruktor wird das Array drawingResults mit der L\u00e4nge 5 erzeugt. Schreiben Sie eine Objektmethode contains(int number) . Diese Methode gibt ein true zur\u00fcck, wenn number in drawingResults enthalten ist und false sonst. Schreiben Sie eine Objektmethode drawing() . In dieser Methode werden die 5 Zufallszahlen gezogen (5 aus 9). Sie ben\u00f6tigen daf\u00fcr ein Objekt der Klasse Random ( Random muss aus java.util importiert werden). \u201eZiehen\u201c Sie nun zuf\u00e4llig 5 Zufallszahlen aus dem Bereich 1..9 (1 und 9 inklusive) und speichern Sie diese im Array drawingResults . Achtung : Die gleiche Zahl darf nicht doppelt gezogen (gespeichert) werden! D.h. die 5 im Array gespeicherten Zufallszahlen m\u00fcssen sich voneinander unterscheiden! Schreiben Sie eine Objektmethode sort() . Diese Methode sortiert das Array drawingResults aufsteigend (von klein nach gro\u00df). \u00dcberschreiben Sie die Objektmethode toString() , die das drawingResult -Array als String in folgender Form zur\u00fcckgibt (Beispielwerte f\u00fcr den Fall, dass 1, 3, 5, 6, 7 gezogen wurden): ( 1 - 3 - 5 6 7 - - ) das dawingResult -Array wird zun\u00e4chst sortiert 2. ist die Zahl im Array enthalten, wird sie als Wert angezeigt 3. ist die Zahl nicht enthalten, wird ein - angezeigt 4. d.h. es werden immer die 5 gezogenen Zahlen ausgegeben und 4 Striche. Schreiben Sie eine Objektmethode print() , die den von toString() zur\u00fcckgegebenen String auf der Konsole ausgibt. \u00dcberschreiben Sie die Objektmethode equals(Object o) . Diese Methode gibt true zur\u00fcck, wenn wenn bei dem aufrufenden Objekt die gleichen Zahlen gezogen wurden, wie bei o . Sonst false ( hashCode() muss nicht \u00fcberschrieben werden). Tipp : Implementieren Sie die Methode am einfachsten so, dass Sie die beiden drawingResult -Arrays erst sortieren und dann die sortierten Arrays elementweise miteinander vergleichen. Erstellen Sie im gleichen package eine Klasse Programmklasse mit main() -Methode. Erzeugen Sie in der main() -Methode in einer Schleife 10 Objekte der Klasse Lottery und rufen (auch in der Schleife) jeweils die drawing() und die print() -Methode auf. Es entsteht folgende Ausgabe (Beispielwerte sind zuf\u00e4llig und unterscheiden sich!): ( 1 - 3 - 5 6 7 - - ) ( 1 2 3 - 5 - 7 - - ) ( 1 - 3 - - 6 7 8 - ) ( - - 3 4 5 6 - - 9 ) ( 1 2 3 4 - - - - 9 ) ( 1 2 - 4 - 6 - 8 - ) ( - 2 3 - - - 7 8 9 ) ( 1 2 3 - - 6 - - 9 ) ( 1 - - 4 5 - 7 8 - ) ( - 2 3 - 5 - - 8 9 ) Erzeugen Sie ein Objekt von Lottery und rufen f\u00fcr dieses Objekt die drawing() -Methode auf. Erzeugen Sie in einer Schleife so lange ein weiteres Objekt von Lottery und rufen daf\u00fcr die drawing() -Methode auf, bis die beiden Objekte die gleichen gezogenen Zahlen enthalten, d.h. laut equals() -Methode gleich sind. Geben Sie dann beide Objekte mithilfe der print() -Methode aus. Es entsteht folgende Ausgabe (zuf\u00e4llige Beispielwerte): ( 1 - 3 - - 6 - 8 9 ) ( 1 - 3 - - 6 - 8 9 ) Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 13 Programmklasse.java package uebungen.uebung13 ; public class Programmklasse { public static void main ( String [] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { Lottery lo1 = new Lottery (); lo1 . drawing (); lo1 . print (); } System . out . println (); Lottery lo2 = new Lottery (); lo2 . drawing (); lo2 . print (); Lottery lo3 = new Lottery (); lo3 . drawing (); while ( ! lo2 . equals ( lo3 )) { lo3 . drawing (); } lo3 . print (); } } Lottery.java package uebungen.uebung13 ; import java.util.Random ; public class Lottery { private int [] drawingResults ; public Lottery () { this . drawingResults = new int [ 5 ] ; } public boolean contains ( int number ) { boolean contains = false ; for ( int index = 0 ; index < this . drawingResults . length && ! contains ; index ++ ) { if ( this . drawingResults [ index ] == number ) { contains = true ; } } return contains ; } public void drawing () { Random r = new Random (); for ( int index = 0 ; index < this . drawingResults . length ; index ++ ) { int zufZahl = r . nextInt ( 9 ) + 1 ; while ( this . contains ( zufZahl )) { zufZahl = r . nextInt ( 9 ) + 1 ; } this . drawingResults [ index ] = zufZahl ; } } public void sort () { for ( int bubble = 1 ; bubble <= drawingResults . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < drawingResults . length - bubble ; index ++ ) { if ( this . drawingResults [ index ] > this . drawingResults [ index + 1 ] ) { int tmp = this . drawingResults [ index ] ; this . drawingResults [ index ] = this . drawingResults [ index + 1 ] ; this . drawingResults [ index + 1 ] = tmp ; } } } } @Override public String toString () { this . sort (); String s = \"( \" ; /* for (int index = 0; index < drawingResults.length; index++) { s = s + this.drawingResults[index] + \" \"; } */ for ( int number = 1 ; number < 10 ; number ++ ) { if ( this . contains ( number )) { s = s + number + \" \" ; } else { s = s + \"- \" ; } } s = s + \")\" ; return s ; } public void print () { System . out . println ( this . toString ()); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( this . getClass () != o . getClass ()) return false ; Lottery lo = ( Lottery ) o ; this . sort (); lo . sort (); for ( int index = 0 ; index < drawingResults . length ; index ++ ) { if ( this . drawingResults [ index ] != lo . drawingResults [ index ] ) { return false ; } } return true ; } } Selbst\u00e4ndiges \u00dcben \u00b6 Falls Sie noch Lust und Zeit haben, ein wenig selbst\u00e4ndig zu \u00fcben, hier einige Aufgaben: Probeklausuren \u00b6 Punkt2D und Punkt3D Erstellen Sie ein package klausurvorbereitung1 . Erstellen Sie in diesem package eine Klasse Punkt3D mit drei privaten Objektvariablen x , y und z , jeweils vom Typ int , einem parametrisierten Konstruktor Punkt3D(int x, int y, int z) . Mit den Parameterwerten werden die Objektvariablen initialisiert. Getter f\u00fcr die drei Objektvariablen ( getX() , getY() und getZ() ). \u00dcberschreiben Sie die Methode toString() , so dass folgende textuelle Rer\u00e4sentation als String erzeugt wird (Beispielwerte): ( 5 ,2,3 ) also in runden Klammern die Werte von x , y und z durch Komma getrennt. Schreiben Sie eine Objektmethode print() , die den durch toString() erzeugten String auf die Konsole ausgibt. \u00dcberschreiben Sie die Methode equals(Object o) so, dass zwei Punkt3D -Objekte gleich sind, wenn ihre Objektvariablen x , y und z jeweils paarweise den gleichen Wert besitzen. Schreiben Sie eine Objektmethode xIsSmaller(Punkt3D p) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren x -Wert hat als p ; false sonst. Schreiben Sie eine Objektmethode yIsSmaller(Punkt3D p) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren y -Wert hat als p ; false sonst. Schreiben Sie eine Objektmethode zIsSmaller(Punkt3D p) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren z -Wert hat als p ; false sonst. Erstellen Sie im gleichen package eine Klasse Punkt2D . Diese Klasse erbt von Punkt3D . Bei einem Objekt vom Typ Punkt2D ist der Wert von z stets 0 ! Schreiben Sie einen parametrisierten Konstruktor Punkt2D(int x, int y) . Verwenden Sie die Parameterwerte, um den entsprechenden Objektvariablen Werte zuzuweisen und setzen Sie den Wert von z auf 0 . \u00dcberschreiben Sie die Methode toString() , so dass folgende textuelle Rer\u00e4sentation als String erzeugt wird (Beispielwerte): ( 5 ,2 ) also in runden Klammern die Werte von x und y durch Komma getrennt. ( der Wert von z wird nicht mehr ausgewertet, er ist ja immer 0 ). Testen Sie die Klassen Punkt3D und Punkt2D in einer Testklasse mit main() -Methode wie folgt: Erzeugen Sie ein Random -Objekt. Sie m\u00fcssen dazu die Klasse Random aus dem java.util -Paket importieren. innerhalb einer Schleife soll nun Folgendes passieren: Erstellen Sie ein Array vom Typ Punkt2D . Es hat die L\u00e4nge 3 . Sie erzeugen sich f\u00fcr x , y und z jeweils Zufallszahlen aus dem Bereich [0, ... ,9] ( 0 und 9 inklusive, also 10 m\u00f6gliche Zufallszahlen). - wenn z den Wert 0 hat, dann erzeugen Sie mit den zuf\u00e4llig erzeugten Werten von x und y ein Objekt vom Typ Punkt2D und speichern dieses im Array. Rufen Sie daf\u00fcr die print() -Methode auf. - wenn z einen Wert ungleich 0 hat, dann erzeugen Sie mit den zuf\u00e4llig erzeugten Werten von x , y und z ein Objekt vom Typ Punkt3D und rufen daf\u00fcr die print() -Methode auf. Ein solches Objekt wird nicht weiter gespeichert. - diesen Prozess wiederholen Sie so lange, bis das Punkt2D[] -Array bef\u00fcllt ist, bis Sie also drei Punkt2D -Objekte erzeugt und im Array gespeichert haben. Eine m\u00f6gliche Ausgabe k\u00f6nnte so sein (Zufallswerte): ---------------- Punkt2D und Punkt3D --------------- ( 3 ,8,9 ) ( 3 ,3,4 ) ( 1 ,2,3 ) ( 7 ,6,7 ) ( 0 ,4,7 ) ( 9 ,0,8 ) ( 0 ,3,8 ) ( 3 ,3,9 ) ( 7 ,2,1 ) ( 2 ,4 ) ( 1 ,8 ) ( 6 ,4,7 ) ( 2 ,1,2 ) ( 7 ,4,1 ) ( 7 ,1,1 ) ( 0 ,2,2 ) ( 6 ,4,9 ) ( 1 ,2,7 ) ( 3 ,9,8 ) ( 2 ,3 ) das letzte Objekt ist immer ein Punkt2D -Objekt, denn nach dem dritten Punkt2D -Objekt h\u00f6ren Sie ja auf, Objekte zu erzeugen (Schleifenende). Erstellen Sie im gleichen package eine Klasse Strecke mit den privaten Objektvariablen start und ende , jeweils vom Typ Punkt2D , einem parametrisierten Konstruktor Strecke(Punkt2D start, Punkt2D ende) . Mit den Parameterwerten werden die Objektvariablen initialisiert. einem weiteren parametrisierten Konstruktor Strecke(int x1, int y1, int x2, int y2) . Mit den Parameterwerten x1 und y1 erzeugen Sie sich ein Punkt2D -Objekt, das den start -Punkt bildet und mit den Parameterwerten x2 und y2 erzeugen Sie sich ein Punkt2D -Objekt, das den ende -Punkt bildet. Schreiben Sie eine Objektmethode laenge() , die die L\u00e4nge der Strecke als double zur\u00fcckgibt. Sie k\u00f6nnen dazu die Methoden Math.abs(number) f\u00fcr den absoluten Betrag von number und Math.sqrt(number) f\u00fcr die Quadratwurzel von number (als double ) verwenden. Tipp: \u00dcberschreiben Sie die Methode toString() , so dass folgende textuelle Rer\u00e4sentation der Strecke als String erzeugt wird (Beispielwerte): Strecke [ start =( 2 ,4 ) , ende =( 1 ,8 ) , Laenge = 4 ,1231cm ] also die Start- und Endpunkte ausgegeben werden und die L\u00e4nge der Strecke in eckigen Klammern nach dem Wort Strecke . Schreiben Sie eine Objektmethode print() , die den durch toString() erzeugten String auf die Konsole ausgibt. Testen Sie die Klasse Strecke in der Testklasse mit main() -Methode wie folgt: Erzeugen Sie 3 Objekte der Klasse Strecke . W\u00e4hlen Sie als start -Punkt der ersten Strecke, den ersten Punkt aus dem Punkt2D -Array aus dem ersten Teil der Aufgabe, als ende -Punkt den zweiten Punkt aus dem Punkt2D -Array aus dem ersten Teil, - als start -Punkt der zweiten Strecke, den zweiten Punkt aus dem Punkt2D -Array aus dem ersten Teil der Aufgabe, als ende -Punkt den dritten Punkt aus dem Punkt2D -Array aus dem ersten Teil, - als start -Punkt der dritten Strecke, den dritten Punkt aus dem Punkt2D -Array aus dem ersten Teil der Aufgabe, als ende -Punkt den ersten Punkt aus dem Punkt2D -Array aus dem ersten Teil. Wenden Sie f\u00fcr alle drei Strecke -Objekte die print() -Methode an. Es sollte folgende Ausgabe erzeugt werden (Beispielwerte): -------------------- Strecke ----------------------- Strecke [ start =( 7 ,1 ) , ende =( 6 ,4 ) , Laenge = 3 ,1623cm ] Strecke [ start =( 6 ,4 ) , ende =( 4 ,6 ) , Laenge = 2 ,8284cm ] Strecke [ start =( 4 ,6 ) , ende =( 7 ,1 ) , Laenge = 5 ,8310cm ] Erstellen Sie im gleichen package eine Klasse PunkteArray mit dem parametrisierten Konstruktor PunkteArray(int anzahl) , dem die Anzahl der Punkte, also die L\u00e4nge des punkte -Arrays \u00fcbergeben wird. Erzeugen Sie unter Verwendung dieser anzahl das punkte -Array. Schreiben Sie eine Objektmethode contains(Punkt2D p) . Diese Methode gibt ein true zur\u00fcck, wenn p im punkte -Array enthalten ist und false sonst. Tipp: Beachten Sie, dass es sein kann, dass nicht alle Elemente im punkte -Array tats\u00e4chlich ein Objekt enthalten. Es kann also sein, dass manche Referenzvariablen this.punkte[index] den Wert null haben. Mithilfe von this.punkte[index] != null k\u00f6nnen Sie pr\u00fcfen, ob this.punkte[index] nicht auf null zeigt. Schreiben Sie eine Objektmethode fillArray() . Diese Methode bef\u00fcllt das punkte -Array vollst\u00e4ndig mit Punkte2D -Objekten. Beachten Sie: der privaten Objektvariablen punkte vom Typ Punkt2D[] , die Werte f\u00fcr x und y aller Objekte sollen jeweils zuf\u00e4llig mithilfe von Random erzeugt werden. Der Wertebereich ist dabei jeweils [0, ... ,9] (also 0 und 9 inklusive, insgesamt 10 verschiedene Zufallszahlen), - Punkt2D -Objekte d\u00fcrfen nicht doppelt im punkte -Array vorkommen, d.h. es gibt keine zwei Punkte p1 und p2 im punkte -Array f\u00fcr die p1.equals(p2) den Wert true hat. \u00dcberschreiben Sie die Methode toString() , so dass folgende textuelle Rer\u00e4sentation des PunkteArray als String erzeugt wird (Beispielwerte): [ ( 6 ,7 ) , ( 3 ,2 ) , ( 1 ,4 ) , ( 5 ,0 ) , ( 4 ,6 ) , ( 9 ,5 ) , ( 1 ,5 ) , ( 0 ,3 ) , ( 4 ,9 ) , ( 6 ,9 ) , ( 5 ,2 ) , ( 1 ,9 ) , ( 7 ,6 ) , ( 2 ,3 ) , ( 4 ,4 ) ] also alle Punkte in eckigen Klammern durch Komma getrennt. Schreiben Sie eine Objektmethode print() , die den durch toString() erzeugten String auf die Konsole ausgibt. Hinweis: (f\u00fcr die folgenden Methoden) Ein Polygon ist ein geschlossener Linienezug aus Strecken. Die folgende Abbildung zeigt ein Polygon, das aus den Strecken (p1, p2) , (p2, p3) , (p3, p4) , (p4, p5) und (p5, p1) besteht. Es gibt darin also 5 Punkte und 5 Strecken: Schreiben Sie eine Objektmethode createPolygon() , die ein Strecke[] zur\u00fcckgibt. Das Strecke[] ist genau so lang wie das punkte -Array. Das Strecke[] wird mit Objekten vom Typ Strecke vollst\u00e4ndig bef\u00fcllt. Dabei sind die start - und ende -Punkte immer die Nachbarpunkte aus dem punkte -Array. Jeder Punkt aus dem punkte -Array wird also zwei Mal verwendet, einmal als ende -Punkt einer Strecke und einmal als start -Punkt der n\u00e4chsten Strecke im Strecke[] . Beachten Sie, dass der start -Punkt der letzten Strecke im Strecke[] der letzte Punkte im punkte -Array und der ende -Punkt dieser Strecke der erste Punkt im punkte -Array ist - siehe Skizze: Schreiben Sie eine Objektmethode gesamtLaenge() , die die Gesamtl\u00e4nge aller Strecken im Polygon ermittelt und diese als double zur\u00fcckgibt. Tipp: Sie m\u00fcssen sich in der Methode erst mithilfe der createPolygon() -Methode das Polygon erzeugen. Schreiben Sie eine Objektmethode amWeitestenLinks() , die den Punkt2D aus dem punkte -Array zur\u00fcckgibt, der am weitesten links von allen ist (den kleinsten x -Wert von allen hat). Geben Sie diesen Punkt zur\u00fcck. Schreiben Sie eine Objektmethode amWeitestenOben() , die den Punkt2D aus dem punkte -Array zur\u00fcckgibt, der am weitesten oben von allen ist (den kleinsten y -Wert von allen hat). Geben Sie diesen Punkt zur\u00fcck. Schreiben Sie eine Objektmethode laengsteStrecke() , die die l\u00e4ngste Strecke aller Strecken im Polygon ermittelt und diese zur\u00fcckgibt. Tipp: Sie m\u00fcssen sich in der Methode erst mithilfe der createPolygon() -Methode das Polygon erzeugen. Schreiben Sie eine Objektmethode printStrecken() . Diese Methode gibt alle Strecken aus dem Polygon auf die Konsole aus. Au\u00dferdem wird die Gesamtl\u00e4nge aller Strecken aus dem Polygon, der am weitesten links stehende Punkt aus dem punkte -Array und der am weitesten oben stehende Punkt aus dem punkte -Array ausgegeben. Tipp: Sie m\u00fcssen sich in der Methode erst mithilfe der createPolygon() -Methode das Polygon erzeugen. Es sollte folgende Ausgabe erfolgen (Beispielwerte): Strecke [ start =( 0 ,1 ) , ende =( 2 ,1 ) , Laenge = 2 ,0000cm ] Strecke [ start =( 2 ,1 ) , ende =( 5 ,7 ) , Laenge = 6 ,7082cm ] Strecke [ start =( 5 ,7 ) , ende =( 8 ,7 ) , Laenge = 3 ,0000cm ] Strecke [ start =( 8 ,7 ) , ende =( 7 ,4 ) , Laenge = 3 ,1623cm ] Strecke [ start =( 7 ,4 ) , ende =( 8 ,1 ) , Laenge = 3 ,1623cm ] Strecke [ start =( 8 ,1 ) , ende =( 1 ,1 ) , Laenge = 7 ,0000cm ] Strecke [ start =( 1 ,1 ) , ende =( 4 ,6 ) , Laenge = 5 ,8310cm ] Strecke [ start =( 4 ,6 ) , ende =( 2 ,9 ) , Laenge = 3 ,6056cm ] Strecke [ start =( 2 ,9 ) , ende =( 9 ,4 ) , Laenge = 8 ,6023cm ] Strecke [ start =( 9 ,4 ) , ende =( 6 ,8 ) , Laenge = 5 ,0000cm ] Strecke [ start =( 6 ,8 ) , ende =( 9 ,8 ) , Laenge = 3 ,0000cm ] Strecke [ start =( 9 ,8 ) , ende =( 5 ,6 ) , Laenge = 4 ,4721cm ] Strecke [ start =( 5 ,6 ) , ende =( 8 ,4 ) , Laenge = 3 ,6056cm ] Strecke [ start =( 8 ,4 ) , ende =( 6 ,5 ) , Laenge = 2 ,2361cm ] Strecke [ start =( 6 ,5 ) , ende =( 0 ,1 ) , Laenge = 7 ,2111cm ] Gesamtlaenge der Strecken : 68 ,5964cm am weitesten links : ( 0 ,1 ) am weitesten oben : ( 0 ,1 ) laengste : Strecke [ start =( 2 ,9 ) , ende =( 9 ,4 ) , Laenge = 8 ,6023cm ] Testen Sie die Klasse PunkteArray in der Testklasse mit main() -Methode wie folgt: Erzeugen Sie ein Objekt der Klasse PunkteArray und \u00fcbergeben Sie als Anzahl der punkte den Wert 15 . Rufen Sie f\u00fcr diese Objekt die Methoden fillArray() , print() und printStrecken() auf. Es sollten folgende Ausgaben erzeugt werden (Beispielwerte): ------------------ PunkteArray --------------------- [ ( 0 ,1 ) , ( 2 ,1 ) , ( 5 ,7 ) , ( 8 ,7 ) , ( 7 ,4 ) , ( 8 ,1 ) , ( 1 ,1 ) , ( 4 ,6 ) , ( 2 ,9 ) , ( 9 ,4 ) , ( 6 ,8 ) , ( 9 ,8 ) , ( 5 ,6 ) , ( 8 ,4 ) , ( 6 ,5 ) ] Strecke [ start =( 0 ,1 ) , ende =( 2 ,1 ) , Laenge = 2 ,0000cm ] Strecke [ start =( 2 ,1 ) , ende =( 5 ,7 ) , Laenge = 6 ,7082cm ] Strecke [ start =( 5 ,7 ) , ende =( 8 ,7 ) , Laenge = 3 ,0000cm ] Strecke [ start =( 8 ,7 ) , ende =( 7 ,4 ) , Laenge = 3 ,1623cm ] Strecke [ start =( 7 ,4 ) , ende =( 8 ,1 ) , Laenge = 3 ,1623cm ] Strecke [ start =( 8 ,1 ) , ende =( 1 ,1 ) , Laenge = 7 ,0000cm ] Strecke [ start =( 1 ,1 ) , ende =( 4 ,6 ) , Laenge = 5 ,8310cm ] Strecke [ start =( 4 ,6 ) , ende =( 2 ,9 ) , Laenge = 3 ,6056cm ] Strecke [ start =( 2 ,9 ) , ende =( 9 ,4 ) , Laenge = 8 ,6023cm ] Strecke [ start =( 9 ,4 ) , ende =( 6 ,8 ) , Laenge = 5 ,0000cm ] Strecke [ start =( 6 ,8 ) , ende =( 9 ,8 ) , Laenge = 3 ,0000cm ] Strecke [ start =( 9 ,8 ) , ende =( 5 ,6 ) , Laenge = 4 ,4721cm ] Strecke [ start =( 5 ,6 ) , ende =( 8 ,4 ) , Laenge = 3 ,6056cm ] Strecke [ start =( 8 ,4 ) , ende =( 6 ,5 ) , Laenge = 2 ,2361cm ] Strecke [ start =( 6 ,5 ) , ende =( 0 ,1 ) , Laenge = 7 ,2111cm ] Gesamtlaenge der Strecken : 68 ,5964cm am weitesten links : ( 0 ,1 ) am weitesten oben : ( 0 ,1 ) laengste : Strecke [ start =( 2 ,9 ) , ende =( 9 ,4 ) , Laenge = 8 ,6023cm ] Eine m\u00f6gliche L\u00f6sung f\u00fcr Punkt2D, Punkt3D Punkt3D.java package klausurvorbereitung.punkte ; public class Punkt3D { private int x ; private int y ; private int z ; public Punkt3D ( int x , int y , int z ) { this . x = x ; this . y = y ; this . z = z ; } public int getX () { return this . x ; } public int getY () { return this . y ; } public int getZ () { return this . z ; } @Override public String toString () { return String . format ( \"(%d,%d,%d)\" , this . x , this . y , this . z ); } public void print () { System . out . println ( this . toString ()); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Punkt3D p = ( Punkt3D ) o ; return this . x == p . x && this . y == p . y && this . z == p . z ; } public boolean xIsSmaller ( Punkt3D p ) { return this . x < p . x ; } public boolean yIsSmaller ( Punkt3D p ) { return this . y < p . y ; } public boolean zIsSmaller ( Punkt3D p ) { return this . z < p . z ; } } Punkt2D.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package klausurvorbereitung.punkte ; public class Punkt2D extends Punkt3D { public Punkt2D ( int x , int y ) { super ( x , y , 0 ); } @Override public String toString () { return String . format ( \"(%d,%d)\" , this . getX (), this . getY ()); } } Strecke.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package klausurvorbereitung.punkte ; public class Strecke { private Punkt2D start ; private Punkt2D ende ; public Strecke ( Punkt2D start , Punkt2D ende ) { this . start = start ; this . ende = ende ; } public Strecke ( int x1 , int y1 , int x2 , int y2 ) { this . start = new Punkt2D ( x1 , y1 ); this . ende = new Punkt2D ( x2 , y2 ); } public double laenge () { int diffX = Math . abs ( start . getX () - ende . getX ()); int diffY = Math . abs ( start . getY () - ende . getY ()); int diffX2 = diffX * diffX ; int diffY2 = diffY * diffY ; double laenge = Math . sqrt ( diffX2 + diffY2 ); return laenge ; } @Override public String toString () { String s = String . format ( \"Strecke [start=%s, ende=%s, Laenge=%7.4fcm]\" , start . toString (), ende . toString (), this . laenge ()); return s ; } public void print () { System . out . println ( this . toString ()); } } PunkteArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 package klausurvorbereitung.punkte ; import java.util.Random ; public class PunkteArray { private Punkt2D [] punkte ; public PunkteArray ( int anzahl ) { this . punkte = new Punkt2D [ anzahl ] ; } public boolean contains ( Punkt2D p ) { for ( int index = 0 ; index < this . punkte . length ; index ++ ) { if ( this . punkte [ index ] != null && this . punkte [ index ] . equals ( p )) { return true ; } } return false ; } public void fillArray () { Random r = new Random (); for ( int index = 0 ; index < this . punkte . length ; index ++ ) { int x = r . nextInt ( 10 ); int y = r . nextInt ( 10 ); Punkt2D p = new Punkt2D ( x , y ); while ( this . contains ( p )) { x = r . nextInt ( 10 ); y = r . nextInt ( 10 ); p = new Punkt2D ( x , y ); } this . punkte [ index ] = p ; } } @Override public String toString () { String s = \"[ \" ; for ( int index = 0 ; index < this . punkte . length ; index ++ ) { if ( index < this . punkte . length - 1 ) { s += this . punkte [ index ] . toString () + \", \" ; } else { s += this . punkte [ index ] . toString (); } } s += \" ]\" ; return s ; } public void print () { System . out . println ( this . toString ()); } public Strecke [] createPolygon () { Strecke [] polygon = new Strecke [ this . punkte . length ] ; for ( int index = 0 ; index < this . punkte . length - 1 ; index ++ ) { polygon [ index ] = new Strecke ( this . punkte [ index ] , this . punkte [ index + 1 ] ); } int index = this . punkte . length - 1 ; polygon [ index ] = new Strecke ( this . punkte [ index ] , this . punkte [ 0 ] ); return polygon ; } public void printStrecken () { Strecke [] polygon = this . createPolygon (); for ( int index = 0 ; index < polygon . length ; index ++ ) { polygon [ index ] . print (); } System . out . printf ( \"Gesamtlaenge der Strecken : %7.4fcm %n\" , this . gesamtLaenge ()); System . out . printf ( \"am weitesten links : %s %n\" , this . amWeitestenLinks (). toString ()); System . out . printf ( \"am weitesten oben : %s %n\" , this . amWeitestenOben (). toString ()); System . out . printf ( \"laengste : %s %n\" , this . laengsteStrecke (). toString ()); } public double gesamtLaenge () { Strecke [] polygon = this . createPolygon (); double gesamtLaenge = 0.0 ; for ( int index = 0 ; index < polygon . length ; index ++ ) { gesamtLaenge += polygon [ index ] . laenge (); } return gesamtLaenge ; } public Punkt2D amWeitestenLinks () { int indexLinks = 0 ; for ( int index = 0 ; index < this . punkte . length - 1 ; index ++ ) { if ( this . punkte [ index ] . xIsSmaller ( this . punkte [ indexLinks ] )) { indexLinks = index ; } } return this . punkte [ indexLinks ] ; } public Punkt2D amWeitestenOben () { int indexOben = 0 ; for ( int index = 0 ; index < this . punkte . length - 1 ; index ++ ) { if ( this . punkte [ index ] . yIsSmaller ( this . punkte [ indexOben ] )) { indexOben = index ; } } return this . punkte [ indexOben ] ; } public Strecke laengsteStrecke () { Strecke [] polygon = this . createPolygon (); int indexLaengste = 0 ; for ( int index = 0 ; index < polygon . length ; index ++ ) { if ( polygon [ index ] . laenge () > polygon [ indexLaengste ] . laenge ()) { indexLaengste = index ; } } return polygon [ indexLaengste ] ; } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package klausurvorbereitung.punkte ; import java.util.Random ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n---------------- Punkt2D und Punkt3D ---------------%n%n\" ); Random r = new Random (); Punkt2D [] pa = new Punkt2D [ 3 ] ; int anz2D = 0 ; while ( anz2D < 3 ) { int x = r . nextInt ( 10 ); int y = r . nextInt ( 10 ); int z = r . nextInt ( 10 ); Punkt3D p ; if ( z == 0 ) { pa [ anz2D ] = new Punkt2D ( x , y ); pa [ anz2D ] . print (); anz2D ++ ; } else { p = new Punkt3D ( x , y , z ); p . print (); } } System . out . printf ( \"%n%n-------------------- Strecke -----------------------%n%n\" ); Strecke s1 = new Strecke ( pa [ 0 ] , pa [ 1 ] ); Strecke s2 = new Strecke ( pa [ 1 ] , pa [ 2 ] ); Strecke s3 = new Strecke ( pa [ 2 ] , pa [ 0 ] ); s1 . print (); s2 . print (); s3 . print (); System . out . printf ( \"%n%n------------------ PunkteArray ---------------------%n%n\" ); PunkteArray parr = new PunkteArray ( 15 ); parr . fillArray (); parr . print (); parr . printStrecken (); } } Wohnung Erstellen Sie ein package klausurvorbereitung.wohnung . Erstellen Sie in diesem package eine Klasse Wohnung mit den privaten Objektvariablen - qm vom Typ int , (entspricht der Gr\u00f6\u00dfe der Wohnung in m^2) - anzZimmer vom Typ int , - etage vom Typ int und - qmMiete vom Typ double (entspricht dem Mietpreis pro m^2). einem parametrisierten Konstruktor Wohnung(int qm, int anzZimmer, int etage, double qmMiete). Die Werte der Parameter werden verwendet, um den Objektvariablen Werte zuzuweisen. Gettern f\u00fcr alle Objektvariablen ( getQm() , getAnzZimmer() , getEtage() , getQmMiete() ) einer Objektmethode gesamtMiete() , die die Gesamtmiete der Wohnung berechnet ( qm * qmMiete ) und diesen double -Wert zur\u00fcckgibt. einer Objektmethode billiger(Wohnung w) , die ein true zur\u00fcckgibt, wenn die Gesamtmiete des aufrufenden Objektes kleiner ist als die Gesamtmiete von w ; false sonst. einer Objektmethode teurer(Wohnung w) , die ein true zur\u00fcckgibt, wenn die Gesamtmiete des aufrufenden Objektes gr\u00f6\u00dfer ist als die Gesamtmiete von w ; false sonst. einer Objektmethode toString() die Details der Wohnung in folgender Form (ab inkl. 1. Etage aufw\u00e4rts) als String zur\u00fcckgibt (Beispielwerte): 2 -Zimmer Wohnung mit 40 qm in der 4 . Etage. Monatliche Miete: 360 .00 Euro Achtung! Sollte sich die Wohnung in der 0.Etage befinden, geben Sie die Details bitte wie folgt zur\u00fcck (Beispielwerte): 1 -Zimmer Wohnung mit 60 qm im Erdgeschoss. Monatliche Miete: 750 .00 Euro ` und einer Objektmethode print() , die den von toString() zur\u00fcckgegebenen String auf der Konsole ausgibt Erstellen Sie im gleichen package eine Klasse Testklasse mit main() -Methode. Geben Sie in der main() -Methode Folgendes ein: System . out . printf ( \"%n%n--------------------- Test Wohnung -------------------------%n%n\" ); Wohnung w1 = new Wohnung ( 70 , 3 , 4 , 12.50 ); Wohnung w2 = new Wohnung ( 40 , 1 , 0 , 9.50 ); Wohnung w3 = new Wohnung ( 90 , 4 , 2 , 11.10 ); Wohnung w4 = new Wohnung ( 60 , 2 , 0 , 9.00 ); w1 . print (); w2 . print (); w3 . print (); w4 . print (); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: --------------------- Test Wohnung ------------------------- 3 -Zimmer Wohnung mit 70qm in der 4 . Etage. Monatliche Miete: 875 ,00 Euro 1 -Zimmer Wohnung mit 40qm im Erdgeschoss. Monatliche Miete: 380 ,00 Euro 4 -Zimmer Wohnung mit 90qm in der 2 . Etage. Monatliche Miete: 999 ,00 Euro 2 -Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 540 ,00 Euro Erstellen Sie im gleichen package eine Klasse Dachgeschosswohnung . Diese erbt von Wohnung . Implementieren Sie einen parametrisierten Konstruktor Dachgeschosswohnung(int qm, int anzZimmer, double qmMiete) . Bei Aufruf des Konstruktors werden die entsprechenden Objektvariablen mit den Parameterwerten initialisiert. Die Objektvariable etage bekommt stets den Wert 5 . \u00dcberschreiben Sie die Methode toString() , so dass eine Zeichenkette der Form (Beispielwerte) 4 -Zimmer DG-Wohnung mit 100 qm in der 5 . Etage. Monatliche Miete: 1250 .00 Euro zur\u00fcckgegeben wird. F\u00fcgen Sie in der main() -Methode der Testklasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n--------------- Test Dachgeschosswohnung -------------------%n%n\" ); Dachgeschosswohnung dg1 = new Dachgeschosswohnung ( 70 , 3 , 15.50 ); Dachgeschosswohnung dg2 = new Dachgeschosswohnung ( 100 , 4 , 17.25 ); dg1 . print (); dg2 . print (); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: --------------- Test Dachgeschosswohnung ------------------- 3 -Zimmer DG-Wohnung mit 70qm in der 5 . Etage. Monatliche Miete: 1085 ,00 Euro 4 -Zimmer DG-Wohnung mit 100qm in der 5 . Etage. Monatliche Miete: 1725 ,00 Euro Erstellen Sie im gleichen package eine Klasse Haus . Objektvariable ist wohnungen vom Typ Wohnung[] und nur in der Klasse sichtbar. Implementieren Sie eine Objektmethode neueWohnung() . Diese Methode gibt ein Objekt vom Typ Wohnung zur\u00fcck. In dieser Methode wird zun\u00e4chst ein Random -Objekt erzeugt. Mithilfe dieses Random -Objektes und der Objektmethode nextInt(int bound) der Klasse Random sollen zun\u00e4chst nacheinander folgende Werte zuf\u00e4llig erzeugt werden: Ein Wert f\u00fcr eine Quadratmeteranzahl qm aus dem Wertebereich [20, 40, 60, 80, 100] ( \u2192 also zuf\u00e4llig eine dieser 5 Zahlen), Ein Wert f\u00fcr die Anzahl der Zimmer anzZimmer aus dem Wertebereich [1, 2, 3, 4, 5] ( \u2192 also zuf\u00e4llig eine dieser 5 Zahlen), Ein Wert f\u00fcr die Etage etage aus dem Wertebereich [0, 1, 2, 3, 4, 5] ( \u2192 also zuf\u00e4llig eine dieser 6 Zahlen), Ein Wert f\u00fcr den Mietpreis pro Quadratmeter qmMiete aus dem Wertebereich [8.0, 8.5, 9.0, 9.5, 10.0, 10.5, 11.0, 11.5, 12.0, 12.5] ( \u2192 also zuf\u00e4llig eine dieser 10 Zahlen \u2013 Achtung hier double , Sie k\u00f6nnen aber trotzdem nextInt(int bound) verwenden, m\u00fcssen dann aber geeignet multiplizieren und addieren). Erzeugen Sie mit diesen Werten ein neues Wohnung -Objekt und geben Sie dieses Objekt zur\u00fcck. Implementieren Sie einen parametrisierten Konstruktor Haus(int anzWohnungen) . Darin wird das wohnungen -Array erzeugt. Die L\u00e4nge von wohnungen entspricht dem Wert von anzWohnungen . Bef\u00fcllen Sie das wohnungen -Array vollst\u00e4ndig mit Objekten vom Typ Wohnungen . Rufen Sie dazu f\u00fcr jedes Element des wohnungen -Arrays die Objektmethode neueWohnung() auf. Tipp : Jedes Element des wohnungen -Arrays ist nach dem Bef\u00fcllen mit Objekten vom Typ Wohnung eine Referenzvariable auf ein Wohnung -Objekt, d.h. z.B. ist this.wohnungen[0] vom Typ Wohnung und zeigt auf ein Wohnung -Objekt. Die folgende Abbildung verdeutlicht das f\u00fcr den Fall, dass das wohnungen -Array die L\u00e4nge 10 hat: Implementieren Sie eine Objektmethode print() . Bei Aufruf der Methode soll das wohnungen -Array wie folgt ausgegeben werden (Beispielwerte f\u00fcr Array-L\u00e4nge 5 :) Das Haus besteht aus : 5 -Zimmer Wohnung mit 80qm im Erdgeschoss. Monatliche Miete: 1000 ,00 Euro 4 -Zimmer Wohnung mit 60qm in der 5 . Etage. Monatliche Miete: 480 ,00 Euro 2 -Zimmer Wohnung mit 80qm in der 5 . Etage. Monatliche Miete: 880 ,00 Euro 5 -Zimmer Wohnung mit 100qm in der 2 . Etage. Monatliche Miete: 1100 ,00 Euro 3 -Zimmer Wohnung mit 80qm im Erdgeschoss. Monatliche Miete: 920 ,00 Euro F\u00fcgen Sie in der main() -Methode der Testklasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n---------------------- Test Haus ---------------------------%n%n\" ); Haus h1 = new Haus ( 10 ); h1 . print (); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden (Zufallswerte!): ---------------------- Test Haus --------------------------- Das Haus besteht aus : 1 -Zimmer Wohnung mit 80qm in der 4 . Etage. Monatliche Miete: 840 ,00 Euro 3 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 4 -Zimmer Wohnung mit 80qm in der 3 . Etage. Monatliche Miete: 1000 ,00 Euro 5 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 2 -Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 510 ,00 Euro 3 -Zimmer Wohnung mit 60qm in der 4 . Etage. Monatliche Miete: 600 ,00 Euro 4 -Zimmer Wohnung mit 20qm in der 3 . Etage. Monatliche Miete: 250 ,00 Euro 4 -Zimmer Wohnung mit 100qm in der 5 . Etage. Monatliche Miete: 850 ,00 Euro 5 -Zimmer Wohnung mit 20qm in der 2 . Etage. Monatliche Miete: 160 ,00 Euro 2 -Zimmer Wohnung mit 40qm in der 2 . Etage. Monatliche Miete: 400 ,00 Euro Zusatz: Erweitern Sie die Klasse Haus um folgende Objektmethoden: eine Objektmethode wohnungenInEtage(int etage) . Diese Methode gibt ein Wohnung[] -Array zur\u00fcck. Das zur\u00fcckgegebene Wohnung[] -Array soll alle Wohnungen aus dem wohnungen -Array enthalten, die in der Etage liegen, die der Methode als Parameter \u00fcbergeben wird ( etage ). Befindet sich keine Wohnung in der als Parameter \u00fcbergeben Etage, so wird ein Wohnung[] -Array der L\u00e4nge 0 zur\u00fcckgegeben. eine Objektmethode print(Wohnung[] warr) . Diese Methode gibt das als Parameter \u00fcbergebene warr -Array auf der Konsole aus, in der Form (Bsp.:): 2 -Zimmer Wohnung mit 100 qm in der 2 . Etage. Monatliche Miete: 1250 .00 Euro 5 -Zimmer Wohnung mit 100 qm in der 2 . Etage. Monatliche Miete: 1000 .00 Euro Testen der beiden Methoden in main() : System . out . printf ( \"%n%n----- Test wohnungenInEtage() und print(Wohnung[]) ---------%n%n\" ); for ( int etage = 0 ; etage < 6 ; etage ++ ) { System . out . println ( \"Etage \" + etage + \" ---------------------------------------\" ); h1 . print ( h1 . wohnungenInEtage ( etage )); System . out . println (); } sollte folgende Ausgbabe erzeugen (Zufallswerte): ----- Test wohnungenInEtage () und print ( Wohnung []) --------- Etage 0 --------------------------------------- 2 -Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 510 ,00 Euro Etage 1 --------------------------------------- Etage 2 --------------------------------------- 5 -Zimmer Wohnung mit 20qm in der 2 . Etage. Monatliche Miete: 160 ,00 Euro 2 -Zimmer Wohnung mit 40qm in der 2 . Etage. Monatliche Miete: 400 ,00 Euro Etage 3 --------------------------------------- 3 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 4 -Zimmer Wohnung mit 80qm in der 3 . Etage. Monatliche Miete: 1000 ,00 Euro 5 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 4 -Zimmer Wohnung mit 20qm in der 3 . Etage. Monatliche Miete: 250 ,00 Euro Etage 4 --------------------------------------- 1 -Zimmer Wohnung mit 80qm in der 4 . Etage. Monatliche Miete: 840 ,00 Euro 3 -Zimmer Wohnung mit 60qm in der 4 . Etage. Monatliche Miete: 600 ,00 Euro Etage 5 --------------------------------------- 4 -Zimmer Wohnung mit 100qm in der 5 . Etage. Monatliche Miete: 850 ,00 Euro eine Objektmethode teuersteWohnung() . Diese Methode gibt die Wohnung aus dem wohnungen -Array zur\u00fcck, die die h\u00f6chste Gesamtmiete von allen Wohnungen aus dem wohnungen -Array hat. Testen der Methode in main() : System . out . printf ( \"%n%n--------------- Test teuersteWohnung() ---------------------%n%n\" ); Wohnung teuerste = h1 . teuersteWohnung (); teuerste . print (); sollte folgende Ausgbabe erzeugen (Zufallswerte): --------------- Test teuersteWohnung () --------------------- 4 -Zimmer Wohnung mit 80qm in der 3 . Etage. Monatliche Miete: 1000 ,00 Euro eine Objektmethode gesamtMieteHaus() . Diese Methode gibt die Summe der Mieten aller Wohnungen im wohnungen -Array als double zur\u00fcck. Testen der Methode in main() : System . out . printf ( \"%n%n---------------- Test gesamtMieteHaus() --------------------%n%n\" ); System . out . printf ( \"Die Gesamtmiete fuer das Haus betraegt %.2f Euro.%n\" , h1 . gesamtMieteHaus ()); sollte folgende Ausgbabe erzeugen (Zufallswerte): ---------------- Test gesamtMieteHaus () -------------------- Die Gesamtmiete fuer das Haus betraegt 5690 ,00 Euro. eine Objektmethode sortieren() . Diese Methode sortiert das wohnungen -Array nach Gesamtmieten aufsteigend (beginnend mit der billigsten Wohnung und endend mit der teuersten). Testen der Methode in main() : System . out . printf ( \"%n%n------------------- Test sortieren() -----------------------%n%n\" ); h1 . sortieren (); h1 . print (); sollte folgende Ausgbabe erzeugen (Zufallswerte): ------------------- Test sortieren () ----------------------- Das Haus besteht aus : 5 -Zimmer Wohnung mit 20qm in der 2 . Etage. Monatliche Miete: 160 ,00 Euro 4 -Zimmer Wohnung mit 20qm in der 3 . Etage. Monatliche Miete: 250 ,00 Euro 2 -Zimmer Wohnung mit 40qm in der 2 . Etage. Monatliche Miete: 400 ,00 Euro 2 -Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 510 ,00 Euro 3 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 5 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 3 -Zimmer Wohnung mit 60qm in der 4 . Etage. Monatliche Miete: 600 ,00 Euro 1 -Zimmer Wohnung mit 80qm in der 4 . Etage. Monatliche Miete: 840 ,00 Euro 4 -Zimmer Wohnung mit 100qm in der 5 . Etage. Monatliche Miete: 850 ,00 Euro 4 -Zimmer Wohnung mit 80qm in der 3 . Etage. Monatliche Miete: 1000 ,00 Euro Eine m\u00f6gliche L\u00f6sung f\u00fcr Wohnung Wohnung.java package klausurvorbereitung.wohnung ; public class Wohnung { private int qm ; private int anzZimmer ; private int etage ; private double qmMiete ; public Wohnung ( int qm , int anzZimmer , int etage , double qmMiete ) { this . qm = qm ; this . anzZimmer = anzZimmer ; this . etage = etage ; this . qmMiete = qmMiete ; } public int getQm () { return this . qm ; } public int getAnzZimmer () { return this . anzZimmer ; } public int getEtage () { return this . etage ; } public double getQmMiete () { return this . qmMiete ; } public double gesamtMiete () { return this . qm * this . qmMiete ; } public boolean billiger ( Wohnung w ) { return this . gesamtMiete () < w . gesamtMiete (); } public boolean teurer ( Wohnung w ) { return this . gesamtMiete () > w . gesamtMiete (); } public String toString () { String s = \"\" ; if ( this . etage == 0 ) { s = String . format ( \"%d-Zimmer Wohnung mit %d qm im Erdgeschoss. Monatliche Miete: %.2f Euro\" , this . anzZimmer , this . qm , this . gesamtMiete () ); } else { s = String . format ( \"%d-Zimmer Wohnung mit %d qm in der %d. Etage. Monatliche Miete: %.2f Euro\" , this . anzZimmer , this . qm , this . etage , this . gesamtMiete () ); } return s ; } public void print () { System . out . println ( this . toString ()); } } Dachgeschoss.java package klausurvorbereitung.wohnung ; public class Dachgeschosswohnung extends Wohnung { // alle Objektvariablen von Wohnung geerbt // qm, anzZimmer, etage, qmMiete // alle Objektmethoden von Wohnung geerbt public Dachgeschosswohnung ( int qm , int anzZimmer , double qmMiete ) { super ( qm , anzZimmer , 5 , qmMiete ); // Konstruktor Wohnung } @Override public String toString () { String s = \"\" ; s = String . format ( \"%d-Zimmer Wohnung mit %d qm in der %d. Etage. Monatliche Miete: %.2f Euro\" , this . getAnzZimmer (), this . getQm (), this . getEtage (), this . gesamtMiete () ); return s ; } } Haus.java package klausurvorbereitung.wohnung ; import java.util.Random ; public class Haus { private Wohnung [] wohnungen ; public Wohnung neueWohnung () { Random r = new Random (); int qm = r . nextInt ( 5 ) * 20 + 20 ; int anzZimmer = r . nextInt ( 5 ) + 1 ; int etage = r . nextInt ( 6 ); double qmMiete = r . nextInt ( 10 ) * 0.5 + 8.0 ; return new Wohnung ( qm , anzZimmer , etage , qmMiete ); } public Haus ( int anzWohnungen ) { this . wohnungen = new Wohnung [ anzWohnungen ] ; for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { this . wohnungen [ index ] = this . neueWohnung (); } } public void print () { System . out . println ( \"Das Haus besteht aus :\" ); for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { this . wohnungen [ index ] . print (); // print()-Methode von Wohnung } } public Wohnung [] wohnungenInEtage ( int etage ) { int anzWohnungenInEtage = 0 ; for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { if ( this . wohnungen [ index ] . getEtage () == etage ) { anzWohnungenInEtage ++ ; } } Wohnung [] wohnungenInEtage = new Wohnung [ anzWohnungenInEtage ] ; int indexWIE = 0 ; for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { if ( this . wohnungen [ index ] . getEtage () == etage ) { wohnungenInEtage [ indexWIE ] = this . wohnungen [ index ] ; indexWIE ++ ; } } return wohnungenInEtage ; } public void print ( Wohnung [] warr ) { for ( int index = 0 ; index < warr . length ; index ++ ) { warr [ index ] . print (); // print()-Methode von Wohnung } } public Wohnung teuersteWohnung () { int indexMax = 0 ; for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { if ( this . wohnungen [ index ] . teurer ( this . wohnungen [ indexMax ] )) { indexMax = index ; } } return this . wohnungen [ indexMax ] ; } public double gesamtMieteHaus () { double gesamtMieteHaus = 0.0 ; for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { gesamtMieteHaus = gesamtMieteHaus + this . wohnungen [ index ] . gesamtMiete (); } return gesamtMieteHaus ; } public void sortieren () { for ( int bubble = 1 ; bubble < this . wohnungen . length ; bubble ++ ) { for ( int index = 0 ; index < this . wohnungen . length - bubble ; index ++ ) { if ( this . wohnungen [ index ] . teurer ( this . wohnungen [ index + 1 ] )) { Wohnung tmp = this . wohnungen [ index ] ; this . wohnungen [ index ] = this . wohnungen [ index + 1 ] ; this . wohnungen [ index + 1 ] = tmp ; } } } } } Testklasse.java package klausurvorbereitung.wohnung ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n--------------------- Test Wohnung -------------------------%n%n\" ); Wohnung w1 = new Wohnung ( 70 , 3 , 4 , 12.50 ); Wohnung w2 = new Wohnung ( 40 , 1 , 0 , 9.50 ); Wohnung w3 = new Wohnung ( 90 , 4 , 2 , 11.10 ); Wohnung w4 = new Wohnung ( 60 , 2 , 0 , 9.00 ); w1 . print (); w2 . print (); w3 . print (); w4 . print (); System . out . printf ( \"%n%n--------------- Test Dachgeschosswohnung -------------------%n%n\" ); Dachgeschosswohnung dg1 = new Dachgeschosswohnung ( 70 , 3 , 15.50 ); Dachgeschosswohnung dg2 = new Dachgeschosswohnung ( 100 , 4 , 17.25 ); dg1 . print (); dg2 . print (); System . out . printf ( \"%n%n---------------------- Test Haus ---------------------------%n%n\" ); Haus h1 = new Haus ( 10 ); h1 . print (); System . out . printf ( \"%n%n----- Test wohnungenInEtage() und print(Wohnung[]) ---------%n%n\" ); for ( int etage = 0 ; etage < 6 ; etage ++ ) { System . out . println ( \"Etage \" + etage + \" ---------------------------------------\" ); h1 . print ( h1 . wohnungenInEtage ( etage )); System . out . println (); } System . out . printf ( \"%n%n--------------- Test teuersteWohnung() ---------------------%n%n\" ); Wohnung teuerste = h1 . teuersteWohnung (); teuerste . print (); System . out . printf ( \"%n%n---------------- Test gesamtMieteHaus() --------------------%n%n\" ); System . out . printf ( \"Die Gesamtmiete fuer das Haus betraegt %.2f Euro.%n\" , h1 . gesamtMieteHaus ()); System . out . printf ( \"%n%n------------------- Test sortieren() -----------------------%n%n\" ); h1 . sortieren (); h1 . print (); } } Video zu Wohnung Pizza Erstellen Sie ein package klausurvorbereitung.pizza . Erstellen Sie in diesem package eine Klasse Pizza mit den privaten Objektvariablen - name vom Typ String und - preis vom Typ float . einem parametrisierten Konstruktor Pizza(String name, float preis) . Die Werte der Parameter werden verwendet, um den Objektvariablen Werte zuzuweisen. Gettern f\u00fcr die Objektvariablen ( getName() , getPreis() ) \u00dcberschreiben Sie die Objektmethode toString() , die Details der Pizza in folgender Form als String zur\u00fcckgibt (Beispielwerte): Die Pizza Salami kostet 6 .90 Euro. und einer Objektmethode print() , die den von toString() zur\u00fcckgegebenen String auf der Konsole ausgibt. \u00dcberschreiben Sie die Objektmethode equals(Object o) . Diese Methode gibt true zur\u00fcck, wenn der Name name des aufrufenden Objektes gleich dem Namen name des als Parameter \u00fcbergebenen Objektes ist; false sonst. Tipp : Die Gleichheit von zwei Strings s1 und s2 k\u00f6nnen Sie mithilfe von s1.equals(s2) ermitteln. ( hashCode() muss nicht \u00fcberschrieben werden). Erstellen Sie im gleichen package eine Klasse Testklasse mit main() -Methode. Geben Sie in der main() -Methode Folgendes ein: System . out . printf ( \"%n%n------------------------- Test Pizza ---------------------------%n%n\" ); Pizza p1 = new Pizza ( \"Salami\" , 6.9f ); Pizza p2 = new Pizza ( \"Margheritha\" , 5.9f ); Pizza p3 = new Pizza ( \"Tonno\" , 6.9f ); Pizza p4 = new Pizza ( \"Hawaii\" , 6.9f ); Pizza p5 = new Pizza ( \"Calzone\" , 7.9f ); Pizza p6 = new Pizza ( \"Salami\" , 6.9f ); p1 . print (); p2 . print (); p3 . print (); p4 . print (); p5 . print (); System . out . println ( \"p1 gleich p2 ? : \" + p1 . equals ( p2 )); System . out . println ( \"p1 gleich p1 ? : \" + p1 . equals ( p1 )); System . out . println ( \"p1 gleich p6 ? : \" + p1 . equals ( p6 )); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: ------------------------- Test Pizza --------------------------- Die Pizza Salami kostet 6 ,90 Euro. Die Pizza Margheritha kostet 5 ,90 Euro. Die Pizza Tonno kostet 6 ,90 Euro. Die Pizza Hawaii kostet 6 ,90 Euro. Die Pizza Calzone kostet 7 ,90 Euro. p1 gleich p2 ? : false p1 gleich p1 ? : true p1 gleich p6 ? : true Erstellen Sie im gleichen package eine Klasse Pizzaverkauf mit den privaten Objektvariablen - pizza vom Typ Pizza und - anzVerkaeufe vom Typ int . einem parametrisierten Konstruktor Pizzaverkauf(Pizza pizza) . Mit dem Parameterwert pizza wird die Objektvariable pizza initialisiert. Der Wert der Objektvariablen anzVerkaeufe wird auf 0 gesetzt. einer Objektmethode verkaufen() . Darin wird der Wert der Objektvariablen anzVerkaeufe um 1 erh\u00f6ht. Gettern f\u00fcr die Objektvariablen, also getAnzVerkaeufe() und getPizza() . einer Objektmethode umsatz() . Diese Methode gibt ein double zur\u00fcck. Der Wert berechnet sich aus der Anzahl der Verk\u00e4ufe der Pizza ( anzVerkaeufe ) mal dem Preis der Pizza. einer Objektmethode toString() die Details der Pizzaverkaeufe in folgender Form als String zur\u00fcckgibt (Beispielwerte): Pizza Salami wurde 0 mal zum Preis von 6 .90 Euro verkauft. und einer Objektmethode print() , die den von toString() zur\u00fcckgegebenen String auf der Konsole ausgibt F\u00fcgen Sie in der main() -Methode der Testklasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n--------------------- Test Pizzaverkauf ------------------------%n%n\" ); Pizzaverkauf pv1 = new Pizzaverkauf ( p1 ); pv1 . print (); pv1 . verkaufen (); pv1 . print (); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: --------------------- Test Pizzaverkauf ------------------------ Pizza Salami wurde 0 mal zum Preis von 6 ,90 Euro verkauft. Pizza Salami wurde 1 mal zum Preis von 6 ,90 Euro verkauft. Erstellen Sie im gleichen package eine Klasse Speisekarte mit der privaten Objektvariablen - angebot vom Typ Pizza[] einem parameterlosen Konstruktor Speisekarte() . In diesem Konstruktor wird f\u00fcr angebot ein Pizza -Array der L\u00e4nge 0 erzeugt. einer Objektmethode pizzaHinzufuegen(Pizza pizza) . Diese Methode f\u00fcgt die als Parameter \u00fcbergebene pizza dem angebot-Array hinzu. Beachten Sie: Um dem angebot -Array eine neue Pizza hinzuzuf\u00fcgen, muss die L\u00e4nge des Arrays um 1 erh\u00f6ht werden. - Kopieren Sie sich dazu das alte angebot -Array. - Erzeugen Sie dann ein neues angebot -Array, das um 1 l\u00e4nger ist als das alte. - Kopieren Sie das bisherige Angebot zur\u00fcck in das neue angebot -Array. - F\u00fcgen Sie die neue Pizza (Parameter pizza ) als letztes Element im neuen angebot -Array hinzu. einer Objektmethode getLength() . Diese Methode gibt die L\u00e4nge des angebot -Arrays zur\u00fcck. einer Objektmethode pizzaIstImAngebot(Pizza pizza) . Diese Methode gibt ein true zur\u00fcck, wenn die als Parameter \u00fcbergebene pizza im angebot -Array enthalten ist. Pr\u00fcfen Sie die Gleichheit mithilfe der equals() -Methode von Pizza . einer Objektmethode pizzaLoeschen(Pizza pizza) . Diese Methode l\u00f6scht die als Parameter \u00fcbergebene pizza aus dem angebot -Array (wenn Sie darin enthalten ist). Beachten Sie: Nach dem L\u00f6schen der Pizza aus dem angebot -Array soll das angebot -Array wieder um 1 kleiner sein als vorher (falls die zu l\u00f6schende Pizza \u00fcberhaupt im angebot -Array enthalten war). - Kopieren Sie also das alte angebot -Array au\u00dfer die zu l\u00f6schende Pizza. - Ihre Kopie ist dann das neue angebot -Array. einer Objektmethode getPizzaAtIndex(int index) . Diese Methode gibt die Pizza zur\u00fcck, die im angebot -Array beim Index index eingetragen ist. Pr\u00fcfen Sie, ob der \u00fcbergebene Parameter ein g\u00fcltiger Index aus dem angebot -Array ist. Wenn nicht, geben Sie null zur\u00fcck. \u00dcberschreiben Sie die Objektmethode toString() , die die Details der Speisekarte in folgender Form als String zur\u00fcckgibt (Beispielwerte): ====== Speisekarte ====== Salami 6 ,90 Euro Margheritha 5 ,90 Euro Tonno 6 ,90 Euro Hawaii 6 ,90 Euro Calzone 7 ,90 Euro und einer Objektmethode print() , die den von toString() zur\u00fcckgegebenen String auf der Konsole ausgibt F\u00fcgen Sie in der main() -Methode der Testklasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n--------------------- Test Speisekarte -------------------------%n%n\" ); Speisekarte s1 = new Speisekarte (); s1 . pizzaHinzufuegen ( p1 ); s1 . pizzaHinzufuegen ( p2 ); s1 . pizzaHinzufuegen ( p3 ); s1 . pizzaHinzufuegen ( p4 ); s1 . pizzaHinzufuegen ( p5 ); s1 . print (); s1 . pizzaLoeschen ( p3 ); s1 . print (); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: --------------------- Test Speisekarte ------------------------- ====== Speisekarte ====== Salami 6 ,90 Euro Margheritha 5 ,90 Euro Tonno 6 ,90 Euro Hawaii 6 ,90 Euro Calzone 7 ,90 Euro ====== Speisekarte ====== Salami 6 ,90 Euro Margheritha 5 ,90 Euro Hawaii 6 ,90 Euro Calzone 7 ,90 Euro Zusatz Erstellen Sie im gleichen package eine Klasse Pizzaria mit einem parametrisierten Konstruktor Pizzeria(Speisekarte karte) . In diesem Konstruktor wird der privaten Objektvariablen - verkaeufe vom Typ Pizzaverkauf[] . das verkaeufe -Array erzeugt und hat die gleiche L\u00e4nge wie das angebot -Array der Speisekarte karte (siehe getLength() -Methode aus Speisekarte ). - jedes Element des verkaeufe -Arrays zeigt auf ein Pizzaverkauf -Objekt. Erzeugen Sie alle Pizzaverkauf -Objekte. \u00dcbergeben Sie dem Pizzaverkauf -Konstruktor dazu die jeweiligen Pizza -Objekte aus der Speisekarte karte . einer Objektmethode bestellen() . Diese Methode gibt ein int zur\u00fcck. In dieser Methode soll zuf\u00e4llig ein Index aus dem verkaeufe -Array erzeugt werden. Nutzen Sie dazu die Klasse Random aus dem java.util -Paket. Verwenden Sie die Objektmethode nextInt(int bound) der Klasse Random . Wenden Sie nextInt() so an, dass auch tats\u00e4chlich ein g\u00fcltiger Index des verkaeufe -Arrays erzeugt wird. Geben Sie diesen zuf\u00e4llig erzeugten Index zur\u00fcck (das Bestellen entspricht also dem Nennen einer Nummer aus der Speisekarte). einer Objektmethode verkaufen(int index) . Durch den Aufruf der Methode wird die Pizza verkauft, die im verkaeufe -Array am Index index steht. Nutzen Sie f\u00fcr den Verkauf die verkaufen() -Methode der Klasse Pizzaverkauf. \u00dcberpr\u00fcfen Sie, ob der als Parameter \u00fcbergebene Wert f\u00fcr index tats\u00e4chlich einem Index im verkaeufe -Array entspricht. einer Objektmethode tagesVerkauf(int anzVerkaeufe) . In dieser Methode wird anzVerkaeufe oft eine Pizza verkauft ( verkaufen(int index) ). Welche Pizza verkauft wird (also welcher index ), wird durch die Methode bestellen() jeweils zuf\u00e4llig ermittelt. einer Objektmethode print() . Diese Methode erzeugt folgende Ausgabe (Beispielwerte): Salami : *********************************** Margheritha : ************************************ Hawaii : ***************************************** Calzone : ************************************** Das hei\u00dft, es wird am Anfang der Zeile der Name der Pizza aus dem verkaeufe -Array ausgegeben und danach f\u00fcr die Anzahl der Verk\u00e4ufe jeweils ein * . einer Objektmethode meistverkauftePizza() . Diese Methode gibt die Pizza aus dem verkaeufe -Array zur\u00fcck, die am meisten verkauft wurde. einer Objektmethode gesamtEinnahmen() . Diese Methode gibt die Summe aller Einnahmen als double zur\u00fcck. Die Einnahmen ergeben sich aus der Summe der Ums\u00e4tze aller Pizzen (Methode umsatz() von Pizzaverkauf ) aus dem verkaeufe -Array. F\u00fcgen Sie in der main() -Methode der Testklasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n------------------------ Test Pizzaria -------------------------%n%n\" ); Pizzeria pz1 = new Pizzeria ( s1 ); pz1 . tagesVerkauf ( 150 ); pz1 . print (); System . out . println (); System . out . print ( \"Meistverkaufte Pizza : \" ); pz1 . meistverkauftePizza (). print (); System . out . printf ( \"Die Gesamteinnahmen betragen %.2f Euro\" , pz1 . gesamtEinnahmen ()); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden (Zufallswerte): ------------------------ Test Pizzaria ------------------------- Salami : ****************************** Margheritha : ******************************************* Hawaii : ******************************************* Calzone : ********************************** Meistverkaufte Pizza : Die Pizza Margheritha kostet 5 ,90 Euro. Die Gesamteinnahmen betragen 1026 ,00 Euro Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 9 Pizza.java package klausurvorbereitung.pizza ; public class Pizza { private String name ; private float preis ; public Pizza ( String name , float preis ) { this . name = name ; this . preis = preis ; } public String getName () { return this . name ; } public float getPreis () { return this . preis ; } @Override public String toString () { return String . format ( \"Die Pizza %s kostet %.2f Euro.\" , this . name , this . preis ); } public void print () { System . out . println ( this . toString ()); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Pizza po = ( Pizza ) o ; return ( this . name . equals ( po . name )); } } Pizzaverkauf.java package klausurvorbereitung.pizza ; public class Pizzaverkauf { private Pizza pizza ; private int anzVerkaeufe ; public Pizzaverkauf ( Pizza pizza ) { this . pizza = pizza ; this . anzVerkaeufe = 0 ; } public void verkaufen () { this . anzVerkaeufe ++ ; } public Pizza getPizza () { return this . pizza ; } public int getAnzVerkaeufe () { return this . anzVerkaeufe ; } public double umsatz () { return this . anzVerkaeufe * this . pizza . getPreis (); } @Override public String toString () { return String . format ( \"Pizza %s wurde %d mal zum Preis von %.2f Euro verkauft.\" , this . pizza . getName (), this . anzVerkaeufe , this . pizza . getPreis ()); } public void print () { System . out . println ( this . toString ()); } } Speisekarte.java package klausurvorbereitung.pizza ; public class Speisekarte { private Pizza [] angebot ; public Speisekarte () { this . angebot = new Pizza [ 0 ] ; } public int getLength () { return this . angebot . length ; } public void pizzaHinzufuegen ( Pizza pizza ) { Pizza [] kopie = new Pizza [ this . angebot . length + 1 ] ; for ( int index = 0 ; index < this . angebot . length ; index ++ ) { kopie [ index ] = this . angebot [ index ] ; } kopie [ kopie . length - 1 ] = pizza ; this . angebot = kopie ; } public boolean pizzaIstImAngebot ( Pizza pizza ) { for ( int index = 0 ; index < this . angebot . length ; index ++ ) { if ( this . angebot [ index ] . equals ( pizza )) { return true ; } } return false ; // System.out.println(\"dead code\"); } public void pizzaLoeschen ( Pizza pizza ) { if ( this . pizzaIstImAngebot ( pizza )) { Pizza [] kopie = new Pizza [ this . angebot . length - 1 ] ; int indexKopie = 0 ; for ( int indexAngebot = 0 ; indexAngebot < this . angebot . length ; indexAngebot ++ ) { if ( ! this . angebot [ indexAngebot ] . equals ( pizza )) { kopie [ indexKopie ] = this . angebot [ indexAngebot ] ; indexKopie ++ ; } } this . angebot = kopie ; } } public Pizza getPizzaAtIndex ( int index ) { if ( index >= 0 && index < this . angebot . length ) { return this . angebot [ index ] ; } else { return null ; } } @Override public String toString () { String s = String . format ( \"====== Speisekarte ======%n\" ); for ( int index = 0 ; index < this . angebot . length ; index ++ ) { s = s + String . format ( \"%-15s %.2f Euro %n\" , this . angebot [ index ] . getName (), this . angebot [ index ] . getPreis ()); } return s ; } public void print () { System . out . println ( this . toString ()); } } Pizzeria.java package klausurvorbereitung.pizza ; import java.util.Random ; public class Pizzeria { private Pizzaverkauf [] verkaeufe ; public Pizzeria ( Speisekarte karte ) { this . verkaeufe = new Pizzaverkauf [ karte . getLength () ] ; for ( int index = 0 ; index < this . verkaeufe . length ; index ++ ) { this . verkaeufe [ index ] = new Pizzaverkauf ( karte . getPizzaAtIndex ( index )); } } public int bestellen () { Random r = new Random (); int index = r . nextInt ( this . verkaeufe . length ); return index ; } public void verkaufen ( int index ) { if ( index >= 0 && index < this . verkaeufe . length ) { this . verkaeufe [ index ] . verkaufen (); } } public void tagesVerkauf ( int anzVerkaeufe ) { for ( int i = 0 ; i < anzVerkaeufe ; i ++ ) { int index = this . bestellen (); this . verkaufen ( index ); } } public void print () { for ( int index = 0 ; index < this . verkaeufe . length ; index ++ ) { Pizza p = this . verkaeufe [ index ] . getPizza (); int anzVerkaeufe = this . verkaeufe [ index ] . getAnzVerkaeufe (); String s = String . format ( \"%-13s : \" , p . getName ()); for ( int stars = 0 ; stars < anzVerkaeufe ; stars ++ ) { s = s + \"*\" ; } System . out . println ( s ); } } public Pizza meistverkauftePizza () { int maxIndex = 0 ; for ( int index = 0 ; index < this . verkaeufe . length ; index ++ ) { if ( this . verkaeufe [ index ] . getAnzVerkaeufe () > this . verkaeufe [ maxIndex ] . getAnzVerkaeufe ()) { maxIndex = index ; } } return this . verkaeufe [ maxIndex ] . getPizza (); } public double gesamtEinnahmen () { double gesamtEinnahmen = 0.0 ; for ( int index = 0 ; index < this . verkaeufe . length ; index ++ ) { gesamtEinnahmen += this . verkaeufe [ index ] . umsatz (); } return gesamtEinnahmen ; } } Testklasse.java package klausurvorbereitung.pizza ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n------------------------- Test Pizza ---------------------------%n%n\" ); Pizza p1 = new Pizza ( \"Salami\" , 6.9f ); Pizza p2 = new Pizza ( \"Margheritha\" , 5.9f ); Pizza p3 = new Pizza ( \"Tonno\" , 6.9f ); Pizza p4 = new Pizza ( \"Hawaii\" , 6.9f ); Pizza p5 = new Pizza ( \"Calzone\" , 7.9f ); Pizza p6 = new Pizza ( \"Salami\" , 6.9f ); p1 . print (); p2 . print (); p3 . print (); p4 . print (); p5 . print (); System . out . println ( \"p1 gleich p2 ? : \" + p1 . equals ( p2 )); System . out . println ( \"p1 gleich p1 ? : \" + p1 . equals ( p1 )); System . out . println ( \"p1 gleich p6 ? : \" + p1 . equals ( p6 )); System . out . printf ( \"%n%n--------------------- Test Pizzaverkauf ------------------------%n%n\" ); Pizzaverkauf pv1 = new Pizzaverkauf ( p1 ); pv1 . print (); pv1 . verkaufen (); pv1 . print (); System . out . printf ( \"%n%n--------------------- Test Speisekarte -------------------------%n%n\" ); Speisekarte s1 = new Speisekarte (); s1 . pizzaHinzufuegen ( p1 ); s1 . pizzaHinzufuegen ( p2 ); s1 . pizzaHinzufuegen ( p3 ); s1 . pizzaHinzufuegen ( p4 ); s1 . pizzaHinzufuegen ( p5 ); s1 . print (); s1 . pizzaLoeschen ( p3 ); s1 . print (); System . out . printf ( \"%n%n------------------------ Test Pizzaria -------------------------%n%n\" ); Pizzeria pz1 = new Pizzeria ( s1 ); pz1 . tagesVerkauf ( 150 ); pz1 . print (); System . out . println (); System . out . print ( \"Meistverkaufte Pizza : \" ); pz1 . meistverkauftePizza (). print (); System . out . printf ( \"Die Gesamteinnahmen betragen %.2f Euro\" , pz1 . gesamtEinnahmen ()); } } Power Implementieren Sie eine Klasse Power . Idee : Die Klasse Power implementiert die Potenz . Eine Potenz besteht aus einer Basis ( base ) und dem Exponenten ( exp ): base^exp, z.B. 8^4 = 8 \u2219 8 \u2219 8 \u2219 8 Objektvariablen sind base und exp vom Typ int . Beide Objektvariablen sind nur innerhalb der Klasse sichtbar! Implementieren Sie getter f\u00fcr die Basis ( getBase() ) und f\u00fcr den Exponenten ( getExp() ) (Sichtbarkeit public ). Implementieren Sie f\u00fcr die Klasse Power einen parametrisierten Konstruktor Power(int base, int exp) . Die Werte der Parameter werden verwendet, um den Objektvariablen Werte zuzuweisen. Implementieren Sie eine Objektmethode getValue() , die ein double zur\u00fcckgibt. Die Methode gibt den Wert der Potenz zur\u00fcck, also z.B. f\u00fcr 8^4 den Wert 4096.0 . Beachten Sie: Die Verwendung der Math -Klasse ist nicht erlaubt! \u00dcberschreiben Sie die Methode toString() , so dass eine Potenz in der Form (base, exp) als String zur\u00fcckgegeben wird, wobei base und exp die Werte der jeweiligen Objektvariablen sein sollen, also z.B. (8, 4) . Implementieren Sie eine Objektmethode print() , die mithilfe von toString() eine Potenz auf der Konsole ausgibt. Erstellen Sie eine Klasse PowerTest mit main() -Methode. Erzeugen Sie in der main() -Methode folgende f\u00fcnf Objekte der Klasse Power : 3^4 , -3^4 , 3^0 , 3^(-4) , -3^(-4) . Wenden Sie jeweils die Methode print() an und geben Sie au\u00dferdem jeweils den Wert der Potenz auf die Konsole aus. Es sollte eine Ausgabe in ungef\u00e4hr der folgenden Form erfolgen: ( 3 ,4 ) ( 3 ,4 ) = 81 .0 ( -3,4 ) ( -3,4 ) = 81 .0 ( 3 ,0 ) ( 3 ,0 ) = 1 .0 ( 3 ,-4 ) ( 3 ,-4 ) = 0 .012345679012345678 ( -3,-4 ) ( -3,-4 ) = 0 .012345679012345678 Erstellen Sie eine Klasse PowerOfTwo . Diese Klasse erbt von Power . Idee : Ein Objekt der Klasse PowerOfTwo ist eine Potenz zur Basis 2 , also z.B. 2^4 . Implementieren Sie einen parametrisierten Konstruktor PowerOfTwo(int exp) . Beachten Sie, dass der Basis der Wert 2 zugewiesen wird. Implementieren Sie eine Objektmethode printBinary() . Diese Methode gibt die Potenz als Bin\u00e4rzahl (bestehend aus Einsen und Nullen) auf die Konsole aus, z.B. 2^4 : 1 0 0 0 0 . Tipp : es kommt vorne immer eine 1 und danach kommen so viele Nullen, wie der Exponent gro\u00df ist. Wenn der Exponent kliner als 0 ist, dann geben Sie Zahl ist kleiner als 1 auf die Konsole aus. Die Bin\u00e4rzahl f\u00fcr eine Potenz kleiner als 0 muss also nicht ermittelt werden. Erzeugen Sie in der main() -Methode der Klasse PowerTest folgende drei Objekte der Klasse PowerOfTwo : 2^4 , 2^(-4) , 2^0 und rufen Sie jeweils die Methoden print() und printBinary() auf. Es sollte eine Ausgabe in ungef\u00e4hr der folgenden Form erfolgen: ( 2 ,4 ) 1 0 0 0 0 ( 2 ,-4 ) Zahl ist kleiner als 1 ( 2 ,0 ) 1 Erstellen Sie eine Klasse PowerArray . Objektvariable ist p vom Typ Power[] . p ist nur innerhalb der Klasse sichtbar! Implementieren Sie einen parametrisierten Konstruktor PowerArray(int length) . Darin wird das p -Array erzeugt. Die L\u00e4nge von p entspricht dem Wert von length . Implementieren Sie eine Objektmethode fillArray() . Bei Aufruf der Methode soll das Array p mit Objekten der Klasse Power gef\u00fcllt werden. Die Werte der Objektvariablen der Power -Objekte werden zuf\u00e4llig mit Hilfe der Random -Klasse erzeugt (um die Random -Klasse verwenden zu k\u00f6nnen, m\u00fcssen Sie diese aus dem java.util -Paket importieren). Beachten Sie folgende Anforderungen: Sowohl die Basis als auch der Exponent k\u00f6nnen Werte aus dem Wertebereich 1..5 (jeweils inklusive) annehmen Die Basis soll nie einen gr\u00f6\u00dferen Wert als der Exponent haben (aber es k\u00f6nnen beide gleich sein). Implementieren Sie eine Objektmethode createArrayOfValues() . Diese Methode liefert ein double[] -Array zur\u00fcck, das alle Werte der Potenzen aus dem p -Array enth\u00e4lt. Implementieren Sie eine Objektmethode getIndexExponent(int exponent) , die den Index des (ersten) Elementes zur\u00fcckliefert, bei dem das Power -Objekt den Exponenten hat, der als Parameter der Methode \u00fcbergeben wird. Existiert ein solches Objekt nicht im Array, wird -1 zur\u00fcckgegeben. \u00dcberschreiben Sie die Methode toString() , so dass das p -Array in der Form (Beispiel) [ ( 2 ,5 ) , ( 2 ,3 ) , ( 3 ,3 ) , ( 1 ,5 ) , ( 2 ,3 ) , ( 1 ,3 ) , ( 1 ,3 ) , ( 1 ,2 ) , ( 3 ,5 ) , ( 2 ,3 ) ] als String zur\u00fcckgegeben wird. Implementieren Sie eine Methode print() , die mithilfe von toString() das p -Array auf die Konsole ausgibt. Implementieren Sie eine Methode sort() , die das p -Array nach den Gr\u00f6\u00dfen der Werte der Potenzen ordnet \u2013 vom kleinsten Wert zum gr\u00f6\u00dften Wert. Die Verwendung der Arrays -Klasse aus dem java.util -Paket ist nicht gestattet. Sollten 2 Potenzen den gleichen Wert haben, z.B. 1^2 und 1^4 , dann soll die Potenz mit dem h\u00f6heren Exponent gr\u00f6\u00dfer sein als die Potenz mit dem kleineren Exponenten. Erzeugen Sie in der main() -Methode der Klasse PowerTest ein Objekt der Klasse PowerArray , so dass das p -Array die L\u00e4nge 10 hat. Rufen Sie f\u00fcr dieses Objekt die Objektmethoden fillArray() , print() , sort() und wieder print() auf. Testen Sie au\u00dferdem (mindestens) einmal die getIndexExponent() - und die createArrayOfValues() - Methode (um das Array of Values auf der Konsole auszugeben, verwenden Sie die statische toString() -Methode der Arrays -Klasse ( import java.util.Arrays; ). Es sollte eine Ausgabe in ungef\u00e4hr der folgenden Form erfolgen (Zufallswerte): [ ( 1 ,5 ) , ( 1 ,2 ) , ( 3 ,5 ) , ( 3 ,4 ) , ( 4 ,4 ) , ( 1 ,5 ) , ( 1 ,2 ) , ( 3 ,4 ) , ( 2 ,3 ) , ( 3 ,5 ) ] [ ( 1 ,2 ) , ( 1 ,2 ) , ( 1 ,5 ) , ( 1 ,5 ) , ( 2 ,3 ) , ( 3 ,4 ) , ( 3 ,4 ) , ( 3 ,5 ) , ( 3 ,5 ) , ( 4 ,4 ) ] Index : 5 Index : -1 [ 1 .0, 1 .0, 1 .0, 1 .0, 8 .0, 81 .0, 81 .0, 243 .0, 243 .0, 256 .0 ] eine m\u00f6gliche L\u00f6sung f\u00fcr Power Power.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class Power { private int base ; private int exp ; Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public int getBase () { return this . base ; } public int getExp () { return this . exp ; } public double getValue () { double value = 1.0 ; if ( this . exp >= 0 ) { for ( int i = 1 ; i <= this . exp ; i ++ ) { value *= this . base ; } } else { for ( int i = 1 ; i <=- this . exp ; i ++ ) { value *= this . base ; } value = 1.0 / value ; } return value ; } @Override public String toString () { return \"(\" + this . base + \",\" + this . exp + \")\" ; } public void print () { System . out . println ( this . toString ()); } } PowerOfTwo.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class PowerOfTwo extends Power { public PowerOfTwo ( int exp ) { super ( 2 , exp ); } public void printBinary () { if ( this . getExp () < 0 ) { System . out . println ( \"Zahl ist kleiner als 1\" ); } else { String s = \"1\" ; for ( int i = 1 ; i <= this . getExp (); i ++ ) { s += \" 0\" ; } System . out . println ( s ); } } } PowerArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 import java.util.Random ; public class PowerArray { private Power [] p ; public PowerArray ( int length ) { this . p = new Power [ length ] ; } public void fillArray () { Random r = new Random (); for ( int i = 0 ; i < this . p . length ; i ++ ) { int nr1 = r . nextInt ( 5 ) + 1 ; int nr2 = r . nextInt ( 5 ) + 1 ; if ( nr1 > nr2 ) { this . p [ i ] = new Power ( nr2 , nr1 ); } else { this . p [ i ] = new Power ( nr1 , nr2 ); } } } public double [] createArrayOfValues () { double [] values = new double [ this . p . length ] ; for ( int i = 0 ; i < this . p . length ; i ++ ) { values [ i ] = this . p [ i ] . getValue (); } return values ; } public int getIndexExponent ( int exponent ) { final int NOT_FOUND = - 1 ; for ( int i = 0 ; i < this . p . length ; i ++ ) { if ( this . p [ i ] . getExp () == exponent ) { return i ; } } return NOT_FOUND ; } @Override public String toString () { String s = \"[ \" ; for ( int i = 0 ; i < this . p . length ; i ++ ) { if ( i < this . p . length - 1 ) { s += this . p [ i ] . toString () + \", \" ; } else { s += this . p [ i ] . toString (); } } s += \" ]\" ; return s ; } public void print () { System . out . println ( this . toString ()); } public void sort () { for ( int bubble = 0 ; bubble < this . p . length - 1 ; bubble ++ ) { for ( int i = 0 ; i < this . p . length - 1 - bubble ; i ++ ) { if (( this . p [ i ] . getValue () > this . p [ i + 1 ] . getValue ()) || (( this . p [ i ] . getValue () == this . p [ i + 1 ] . getValue () && this . p [ i ] . getExp () > this . p [ i + 1 ] . getExp ()))) { Power temp = this . p [ i ] ; this . p [ i ] = this . p [ i + 1 ] ; this . p [ i + 1 ] = temp ; } } } } } PowerTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.util.Arrays ; public class PowerTest { public static void main ( String [] args ) { // Objekte erzeugen Power p1 = new Power ( 3 , 4 ); Power p2 = new Power ( - 3 , 4 ); Power p3 = new Power ( 3 , 0 ); Power p4 = new Power ( 3 , - 4 ); Power p5 = new Power ( - 3 , - 4 ); System . out . printf ( \"%n%n---------------------- Ausgaben fuer Power ---------------------------%n%n\" ); p1 . print (); System . out . println ( p1 . toString () + \" = \" + p1 . getValue ()); p2 . print (); System . out . println ( p2 . toString () + \" = \" + p2 . getValue ()); p3 . print (); System . out . println ( p3 . toString () + \" = \" + p3 . getValue ()); p4 . print (); System . out . println ( p4 . toString () + \" = \" + p4 . getValue ()); p5 . print (); System . out . println ( p5 . toString () + \" = \" + p5 . getValue ()); System . out . printf ( \"%n%n-------------------- Ausgaben fuer PowerOfTwo -------------------------%n%n\" ); PowerOfTwo p21 = new PowerOfTwo ( 4 ); p21 . print (); p21 . printBinary (); PowerOfTwo p22 = new PowerOfTwo ( - 4 ); p22 . print (); p22 . printBinary (); PowerOfTwo p23 = new PowerOfTwo ( 0 ); p23 . print (); p23 . printBinary (); System . out . printf ( \"%n%n-------------------- Ausgaben fuer PowerArray -------------------------%n%n\" ); PowerArray pa = new PowerArray ( 10 ); pa . fillArray (); pa . print (); pa . sort (); pa . print (); System . out . println ( \"Index : \" + pa . getIndexExponent ( 4 )); System . out . println ( \"Index : \" + pa . getIndexExponent ( 0 )); double [] values = pa . createArrayOfValues (); System . out . println ( Arrays . toString ( values )); } } Video zu Pizza Computer Implementieren Sie eine Klasse Computer . Objektvariablen sind hersteller vom Typ String , ram vom Typ int und platte vom Typ int . Die Objektvariablen sind in der Klasse und allen abgeleiteten Klassen sichtbar! Schreiben Sie f\u00fcr alle Objektvariablen Getter ( getRam() , getPlatte() , getHersteller() ). Schreiben Sie einen parametrisierten Konstruktor Computer(String hersteller, int ram, int platte) . Die Parameterwerte werden genutzt, um den Objektvariablen die entsprechenden Werte zuzuweisen. Schreiben Sie eine Objektmethode gleicherHersteller(Computer c) , die ein true zur\u00fcckgibt, wenn c vom gleichen Hersteller ist, wie das aufrufende Objekt. Ansonsten wird ein false zur\u00fcckgegeben. Schreiben Sie eine Objektmethode gleicherHersteller(String hersteller) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt den Hersteller hat, der als Parameterwert der Methode \u00fcbergeben wird. Ansonsten wird ein false zur\u00fcckgegeben. \u00dcberschreiben Sie die Methode toString() , so dass der Computer in folgender Form angezeigt wird (Beispielwerte): lenovo mit 8 RAM und 256 SSD Schreiben Sie eine Methode print() , die mit Hilfe von toString() eine Ausgabe auf der Konsole erzeugt. Erstellen Sie eine Klasse Testklasse mit main() -Methode. Erzeugen Sie in der main() -Methode f\u00fcnf Objekte der Klasse Computer : lenovo mit 8 RAM und 256 SSD lenovo mit 16 RAM und 512 SSD apple mit 4 RAM und 256 SSD apple mit 8 RAM und 512 SSD dell mit 8 RAM und 256 SSD Wenden Sie jeweils die Methode print() an, wenden Sie die Methode gleicherHersteller(Computer c) f\u00fcr den ersten Computer an und vergleichen ihn mit dem zweiten und dem dritten. Geben Sie jeweils den Wert des Vergleiches aus. Es sollten folgende Ausgaben auf der Konsole erzeugt werden: --------------------- Test Computer -------------------- lenovo mit 8 RAM und 256 SSD lenovo mit 16 RAM und 512 SSD apple mit 4 RAM und 256 SSD apple mit 8 RAM und 512 SSD dell mit 8 RAM und 256 SSD c1 und c2 gleicher Hersteller ? : true c1 und c3 gleicher Hersteller ? : false Erstellen Sie eine Klasse Notebook . Diese Klasse erbt von der Klasse Computer . Zus\u00e4tzliche Objektvariable der Klasse Notebook ist monitor vom Typ int . Die Objektvariablen sind in der Klasse und allen abgeleiteten Klassen sichtbar! Implementieren Sie einen parametrisierten Konstruktor Notebook(String hersteller, int ram, int platte, int monitor) . Die Parameterwerte werden genutzt, um den Objektvariablen des zur\u00fcckgegebenen Objektes die entsprechenden Werte zuzuweisen. \u00dcberschreiben Sie die Methode toString() , so dass eine Zeichenkette der Form ( hersteller, ram, platte, monitor ) zur\u00fcckgegeben wird (die entsprechenden Werte werden eingesetzt - siehe Ausgabe der main() -Methode unten). Erzeugen Sie in der main() -Methode der Testklasse zwei Objekte der Klasse Notebook (Beispielwerte siehe n\u00e4chste Zeile) und rufen Sie jeweils die print() -Methode auf. Es sollten folgende Ausgaben auf der Konsole erzeugt werden: --------------------- Test Notebook -------------------- ( lenovo, 8 , 256 , 13 ) ( lenovo, 16 , 512 , 15 ) Erstellen Sie eine Klasse NotebookArray . Schreiben Sie einen parametrisierten Konstruktor NotebookArray(int anzahl) . Darin wird das notebooks -Array mit der L\u00e4nge anzahl erzeugt (es wird noch nicht mit Notebook -Objekten bef\u00fcllt - das macht die n\u00e4chste Methode). Schreiben Sie eine Objektmethode konfigurieren() . Bei Aufruf der Methode wird das Array notebooks mit Objekten der Klasse Notebook bef\u00fcllt. Beachten Sie folgende Anforderungen: Objektvariable ist notebooks vom Typ Notebook[] . Die Objektvariable ist nur innerhalb der Klasse sichtbar! das notebooks -Array wird vollst\u00e4ndig bef\u00fcllt 2. f\u00fcr das Erzeugen der Objekte wird eine Zufallszahl aus dem Bereich [0, 1, 2, 3, 4] ( 4 inklusive) erzeugt. Nutzen Sie dazu die Klasse Random aus dem java.util -Paket. Mithilfe von nextInt(int exclusiveBorder) wird eine Zufallszahl erzeugt. Je nach Wert der Zufallszahl wird ein anderes Notebook erzeugt: Wert 0 -> zu erzeugendes Objekt: (\"lenovo\", 8, 256, 13) Wert 1 -> zu erzeugendes Objekt: (\"lenovo\", 16, 512, 15) Wert 2 -> zu erzeugendes Objekt: (\"apple\", 4, 256, 13) Wert 3 -> zu erzeugendes Objekt: (\"apple\", 8, 512, 13) Wert 4 -> zu erzeugendes Objekt: (\"dell\", 8, 512, 15) \u00dcberschreiben Sie die Objektmethode toString() . Diese Methode gibt einen String in der Form (Beispielwerte): [ 5 : ( lenovo, 8 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( lenovo, 16 , 512 , 15 ) , ( lenovo, 8 , 256 , 13 ) , ( apple, 8 , 512 , 13 )] zur\u00fcck. Beachten Sie: die eckigen Klammern zu Beginn und Ende des Strings 2. die Angabe der Anzahl der Elemente am Anfang (im obigen Beispiel 5 : ) 3. das Komma zwischen den Elementen (aber nicht nach dem letzten Element) Schreiben Sie eine Methode print() , die den in toString() erzeugten String auf die Konsole ausgibt. Schreiben Sie eine Objektmethode getHersteller(String hersteller) . Diese Methode gibt ein Objekt vom Typ NotebookArray zur\u00fcck. Das notebooks -Array des erzeugten Objektes enth\u00e4lt genau alle Notebooks aus dem notebooks -Array des aufrufenden Objektes, die von dem Hersteller sind, der als Parameterwert \u00fcbergeben wird. Beispiel: Angenommen, das notebooks -Array des aufrufenden Objektes sieht so aus: [ 10 : ( lenovo, 16 , 512 , 15 ) , ( apple, 8 , 512 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( lenovo, 16 , 512 , 15 ) , ( lenovo, 16 , 512 , 15 ) , ( lenovo, 16 , 512 , 15 ) , ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) ] Dann w\u00fcrde bei Aufruf der Methode getHersteller(\"apple\") das zur\u00fcckgegebene NotebookArray -Objekt folgendes notebooks -Array haben: [ ( apple, 8 , 512 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) ] , bei Aufruf der Methode getHersteller(\"lenovo\") das zur\u00fcckgegebene NotebookArray -Objekt folgendes notebooks -Array: [ ( lenovo, 16 , 512 , 15 ) , ( lenovo, 8 , 256 , 13 ) , ( lenovo, 16 , 512 , 15 ) , ( lenovo, 16 , 512 , 15 ) , ( lenovo, 16 , 512 , 15 ) ] und bei Aufruf der Methode getHersteller(\"dell\") das zur\u00fcckgegebene NotebookArray -Objekt ein leeres notebooks -Array: [ ] Schreiben Sie eine Objektmethode sortRamPlatte() . Diese Methode sortiert das notebooks -Array wie folgt: aufsteigend nach RAM-Gr\u00f6\u00dfe (kleinste RAM-Gr\u00f6\u00dfe zuerst) 2. ist die RAM-Gr\u00f6\u00dfer zweier Notebooks gleich, entscheidet die Plattengr\u00f6\u00dfe (kleinste Plattengr\u00f6\u00dfe zuerst) Erzeugen Sie in der main() -Methode der Testklasse ein Objekt der Klasse NotebookArray , so dass das notebooks -Array die L\u00e4nge 10 hat. Rufen Sie f\u00fcr dieses Objekt die Objektmethoden konfigurieren() , print() , sortRamPlatte() und print() auf. Testen Sie au\u00dferdem die getHersteller() -Methode f\u00fcr alle drei Hersteller und geben Sie jeweils das erzeugte Array aus. Es sollten folgende Ausgaben auf der Konsole erzeugt werden ( Zufallswerte! ): ------------------ Test NotebookArray ------------------ [ 10 : ( apple, 8 , 512 , 13 ) , ( lenovo, 16 , 512 , 15 ) , ( apple, 4 , 256 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) , ( dell, 8 , 512 , 15 ) , ( apple, 4 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( apple, 8 , 512 , 13 )] [ 10 : ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( dell, 8 , 512 , 15 ) , ( apple, 8 , 512 , 13 ) , ( apple, 8 , 512 , 13 ) , ( lenovo, 16 , 512 , 15 )] [ 3 : ( lenovo, 8 , 256 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( lenovo, 16 , 512 , 15 )] [ 6 : ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( apple, 8 , 512 , 13 ) , ( apple, 8 , 512 , 13 )] [ 1 : ( dell, 8 , 512 , 15 )] eine m\u00f6gliche L\u00f6sung f\u00fcr Computer Computer.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package loesungen.probeklausuren.probeklausur2 ; public class Computer { protected String hersteller ; protected int ram ; protected int platte ; public String getHersteller () { return this . hersteller ; } public int getRam () { return this . ram ; } public int getPlatte () { return this . platte ; } public Computer ( String hersteller , int ram , int platte ) { this . hersteller = hersteller ; this . ram = ram ; this . platte = platte ; } public boolean gleicherHersteller ( Computer c ) { return this . hersteller . equals ( c . hersteller ); // es geht auch: return this.hersteller == c.hersteller; } public boolean gleicherHersteller ( String hersteller ) { return this . hersteller . equals ( hersteller ); // es geht auch: return this.hersteller == hersteller; } @Override public String toString () { return this . hersteller + \" mit \" + this . ram + \" RAM und \" + this . platte + \" SSD\" ; } public void print () { System . out . println ( this . toString ()); } } Notebook.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package loesungen.probeklausuren.probeklausur2 ; public class Notebook extends Computer { protected int monitor ; public Notebook ( String hersteller , int ram , int platte , int monitor ) { super ( hersteller , ram , platte ); this . monitor = monitor ; } @Override public String toString () { return \"(\" + this . hersteller + \", \" + this . ram + \", \" + this . platte + \", \" + this . monitor + \")\" ; } } NotebookArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 package loesungen.probeklausuren.probeklausur2 ; import java.util.Random ; public class NotebookArray { private Notebook [] notebooks ; public NotebookArray ( int anzahl ) { this . notebooks = new Notebook [ anzahl ] ; } public void konfigurieren () { Random r = new Random (); for ( int i = 0 ; i < this . notebooks . length ; i ++ ) { int auswahl = r . nextInt ( 5 ); // folgendes kann natuerlich auch mit if..else geloest werden this . notebooks [ i ] = switch ( auswahl ) { case 0 -> new Notebook ( \"lenovo\" , 8 , 256 , 13 ); case 1 -> new Notebook ( \"lenovo\" , 16 , 512 , 15 ); case 2 -> new Notebook ( \"apple\" , 4 , 256 , 13 ); case 3 -> new Notebook ( \"apple\" , 8 , 512 , 13 ); case 4 -> new Notebook ( \"dell\" , 8 , 512 , 15 ); default -> null ; }; } } @Override public String toString () { String s = \"[ \" + this . notebooks . length + \" : \" ; for ( int i = 0 ; i < this . notebooks . length ; i ++ ) { if ( i < this . notebooks . length - 1 ) { s += this . notebooks [ i ] . toString () + \", \" ; } else { s += this . notebooks [ i ] . toString (); } } s += \"]\" ; return s ; } public void print () { System . out . println ( this . toString ()); } public NotebookArray getHersteller ( String hersteller ) { int anzahl = 0 ; for ( int i = 0 ; i < this . notebooks . length ; i ++ ) { if ( this . notebooks [ i ] . gleicherHersteller ( hersteller )) { anzahl ++ ; } } NotebookArray na = new NotebookArray ( anzahl ); int indexNA = 0 ; for ( int i = 0 ; i < this . notebooks . length ; i ++ ) { if ( this . notebooks [ i ] . gleicherHersteller ( hersteller )) { na . notebooks [ indexNA ++] = this . notebooks [ i ] ; } } return na ; } public void sortRamPlatte () { for ( int bubble = 0 ; bubble < this . notebooks . length - 1 ; bubble ++ ) { for ( int i = 0 ; i < this . notebooks . length - 1 - bubble ; i ++ ) { if (( this . notebooks [ i ] . getRam () > this . notebooks [ i + 1 ] . getRam ()) || ( this . notebooks [ i ] . getRam () == this . notebooks [ i + 1 ] . getRam () && this . notebooks [ i ] . getPlatte () > this . notebooks [ i + 1 ] . getPlatte ())) { Notebook temp = this . notebooks [ i ] ; this . notebooks [ i ] = this . notebooks [ i + 1 ] ; this . notebooks [ i + 1 ] = temp ; } } } } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package loesungen.probeklausuren.probeklausur2 ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n--------------------- Test Computer --------------------%n%n\" ); Computer c1 = new Computer ( \"lenovo\" , 8 , 256 ); Computer c2 = new Computer ( \"lenovo\" , 16 , 512 ); Computer c3 = new Computer ( \"apple\" , 4 , 256 ); Computer c4 = new Computer ( \"apple\" , 8 , 512 ); Computer c5 = new Computer ( \"dell\" , 8 , 256 ); c1 . print (); c2 . print (); c3 . print (); c4 . print (); c5 . print (); System . out . println ( \"c1 und c2 gleicher Hersteller ? : \" + c1 . gleicherHersteller ( c2 )); System . out . println ( \"c1 und c3 gleicher Hersteller ? : \" + c1 . gleicherHersteller ( c3 )); System . out . printf ( \"%n%n--------------------- Test Notebook --------------------%n%n\" ); Notebook n1 = new Notebook ( \"lenovo\" , 8 , 256 , 13 ); Notebook n2 = new Notebook ( \"lenovo\" , 16 , 512 , 15 ); n1 . print (); n2 . print (); System . out . printf ( \"%n%n------------------ Test NotebookArray ------------------%n%n\" ); NotebookArray na = new NotebookArray ( 10 ); na . konfigurieren (); na . print (); na . sortRamPlatte (); na . print (); NotebookArray lenovo = na . getHersteller ( \"lenovo\" ); lenovo . print (); NotebookArray apple = na . getHersteller ( \"apple\" ); apple . print (); NotebookArray dell = na . getHersteller ( \"dell\" ); dell . print (); } } Uhrzeit Implementieren Sie eine Klasse Uhrzeit . Objektvariablen sind stunden vom Typ int , minuten vom Typ int und sekunden vom Typ int . Die Objektvariablen sind nur in der Klasse sichtbar! Schreiben Sie einen parametrisierten Konstruktor Uhrzeit(int sekunden) . \u00dcbergeben wird eine beliebige Anzahl von Sekunden. Aus diesem Wert wird die Uhrzeit berechnet. Beispiel 1: Angenommen, es wird der Wert 83 \u00fcbergeben, dann sind das 0 Stunden, 1 Minute ( 60 Sekunden) und 23 Sekunden. Beispiel 2: Angenommen, es wird der Wert 3662 \u00fcbergeben, dann sind das 1 Stunde ( 3600 Sekunden), 1 Minute ( 60 Sekunden) und 2 Sekunden. Beispiel 3: Angenommen, es wird der Wert 86399 \u00fcbergeben, dann sind das 23 Stunden ( 23x3600 Sekunden), 59 Minuten ( 59x60 Sekunden) und 59 Sekunden. Die Stunden sollen immer im Bereich 0..23 sein, d.h. f\u00fcr einen Stunden-Wert gr\u00f6\u00dfer als 24 nehmen Sie einfach den Modulo-24 -Wert. Initialisieren Sie die Objektvariablen mit den berechneten Werten. Schreiben Sie eine Objektmethode uhrzeitInSekunden() . Diese Methode gibt die Uhrzeit in Sekunden als int zur\u00fcck. Der Wert der zur\u00fcckgegebenen Sekunden berechnet sich aus den Stunden multipliziert mit 3600 plus den Minuten multipliziert mit 60 plus den Sekunden des aufrufenden Uhrzeit -Objektes. Schreiben Sie eine Objektmethode frueher(Uhrzeit u) , die ein true zur\u00fcckgibt, wenn die Uhrzeit des aufrufenden Objektes fr\u00fcher liegt als der Wert von u ; false sonst. Schreiben Sie eine Objektmethode jetztPlusXSekunden(int sekunden) , die ein neues Uhrzeit -Objekt zur\u00fcckgibt. Die Uhrzeit des neuen Objektes ergibt sich aus der Uhrzeit des aufrufenden Objektes plus der Anzahl der Sekunden, die als Parameter \u00fcbergeben werden. Schreiben Sie eine Objektmethode differenzInSekunden(Uhrzeit u) , die die Anzahl in Sekunden ( int ) zur\u00fcckgibt, die zwischen der Uhrzeit des aufrufenden Objektes und u liegen. Geben Sie die Anzahl stets als positiven Wert zur\u00fcck! Sie k\u00f6nnen dazu die Methode Math.abs(int wert) verwenden, die den absoluten Betrag von wert zur\u00fcckgibt. \u00dcberschreiben Sie die Methode toString() , so dass der Wert des aufrufenden Objektes in der Form hh:mm:ss als String zur\u00fcckgegeben wird, z.B. 23:59:59 . Achten Sie darauf, dass die Stunden, Minuten und Sekunden f\u00fchrende Nullen enthalten k\u00f6nnen, also z.B. 01:02:03 ! Schreiben Sie eine Methode print() , die den von toString() erzeugten String auf die Konsole ausgibt. Erstellen Sie eine Klasse Testklasse mit main() -Methode. Erzeugen Sie in der main() -Methode vier Objekte der Klasse Uhrzeit . Verwenden Sie als Parameterwerte: 83 , 3662 , 86399 und 172799 . Wenden Sie jeweils die Methoden System.out.print() und print() aus Uhrzeit so an, dass folgende Ausgabe entsteht: z1 : 00 :01:23 z2 : 01 :01:02 z3 : 23 :59:59 z4 : 23 :59:59 Wenden Sie au\u00dferdem jeweils die Methoden System.out.println() sowie frueher() , jetztPlusXSekunden() , differenzInSekunden() (und evtl. toString() ) aus Uhrzeit so an, dass folgende Ausgabe entsteht: z1 frueher als z2 ? true z3 frueher als z4 ? false z1 plus 40 Sekunden : 00 :02:03 z2 plus 3598 Sekunden : 02 :01:00 z3-z2 in Sekunden : 82737 Erstellen Sie eine Klasse UhrzeitArray . Objektvariable uhren ist ein Array, das Elemente von Uhrzeit aufnimmt. Die Variable ist nur innerhalb der Klasse sichtbar. Schreiben Sie einen parametrisierten Konstruktor UhrzeitArray(int laenge) . Innerhalb des Konstruktors wird das Array erzeugt, auf das die Objektvariable uhren referenziert. Das Array hat die L\u00e4nge laenge (Parameterwert). Schreiben Sie eine Objektmethode fill() , die das uhren -Array vollst\u00e4ndig mit Uhrzeit -Objekten bef\u00fcllt. Die Parameterwerte der Uhrzeit -Objekte werden zuf\u00e4llig erzeugt. Erzeugen Sie ein Objekt der Klasse Random (daf\u00fcr muss java.util.Random importiert werden) und erzeugen Sie die Parameter-Werte f\u00fcr die Uhrzeit -Objekte zuf\u00e4llig (unter Verwendung des Random -Objektes) aus dem Bereich [0, ..., 86399] ( 0 und 86399 jeweils inklusive) \u00dcberschreiben Sie die Objektmethode toString() , so dass das uhren -Array wie folgt als Zeichenkette zur\u00fcckgegeben wird (Beispielwerte): (( 06 :38:30 ) , ( 01 :59:32 ) , ( 07 :16:48 ) , ( 01 :37:58 ) , ( 18 :16:06 ) , ( 07 :50:33 ) , ( 01 :41:47 ) , ( 05 :07:41 ) , ( 12 :38:08 ) , ( 02 :00:04 )) Also die Uhrzeit jeweils in runden Klammern und durch Komma getrennt sowie das ganze Array in runden Klammern. Schreiben Sie eine Objektmethode print() , so dass auf der Konsole die durch toString() erzeugte eine Zeichenkette ausgegeben wird. Schreiben Sie eine Objektmethode spaeteste() . Diese Methode gibt die gr\u00f6\u00dfte (sp\u00e4teste) Uhrzeit aus dem Array uhren zur\u00fcck. Schreiben Sie eine Objektmethode zwischen(Uhrzeit frueh, Uhrzeit spaet) . Diese Methode gibt ein UhrzeitArray -Objekt zur\u00fcck. Das zur\u00fcckgegebene UhrzeitArray -Objekt enth\u00e4lt alle Uhrzeit -Objekte aus dem Array uhren , welche zwischen den beiden Uhrzeiten frueh und spaet liegen. Schreiben Sie eine Objektmethode sortieren() . Diese Methode sortiert das uhren -Array aufsteigend beginnend mit der kleinsten Uhrzeit. Schreiben Sie eine Objektmethode kleinsterAbstand() . Diese Methode gibt ein UhrzeitArray der L\u00e4nge 2 zur\u00fcck. Es enth\u00e4lt die beiden Uhrzeit en aus dem Array uhren , welche den kleinsten Abstand (Differenz in Sekunden) haben. Sie k\u00f6nnen beim Schreiben der Methode davon ausgehen, dass das uhren -Array bereits sortiert ist! Erzeugen Sie in der main() -Methode ein Objekt der Klasse UhrzeitArray . Das Array soll die L\u00e4nge 10 haben. Rufen Sie die fill() - und dann die print() -Methode auf. Es entsteht folgende Ausgabe (Zufallswerte): (( 06 :38:30 ) , ( 01 :59:32 ) , ( 07 :16:48 ) , ( 01 :37:58 ) , ( 18 :16:06 ) , ( 07 :50:33 ) , ( 01 :41:47 ) , ( 05 :07:41 ) , ( 12 :38:08 ) , ( 02 :00:04 )) Wenden Sie jeweils die Methoden System.out.print() sowie spaeteste() so an, dass folgende Ausgabe entsteht (Zufallswerte): spaeteste : 18 :16:06 Wenden Sie jeweils die Methoden System.out.print() sowie sortieren() und print() so an, dass folgende Ausgabe entsteht (Zufallswerte): sortiert : (( 01 :37:58 ) , ( 01 :41:47 ) , ( 01 :59:32 ) , ( 02 :00:04 ) , ( 05 :07:41 ) , ( 06 :38:30 ) , ( 07 :16:48 ) , ( 07 :50:33 ) , ( 12 :38:08 ) , ( 18 :16:06 )) Erzeugen Sie zwei weitere Uhrzeit -Objekte frueh (Parameterwert 36000 ) und spaet (Parameterwert 72000 ) und rufen Sie damit die Objektmethoden zwischen(frueh, spaet) und print() auf, so dass folgende Ausgabe entsteht (Zufallswerte): frueh : 10 :00:00 spaet : 20 :00:00 zwischen : (( 12 :38:08 ) , ( 18 :16:06 )) Wenden Sie jeweils die Methoden System.out.print() sowie kleinsterAbstand() und print() so an, dass folgende Ausgabe entsteht (Zufallswerte): kleinster Abstand : (( 01 :59:32 ) , ( 02 :00:04 )) Zur Kontrolle: ungef\u00e4hre Ausgabe auf der Konsole (in Teil 2 Zufallswerte): --------------- Teil 1 --------------- z1 : 00 :01:23 z2 : 01 :01:02 z3 : 23 :59:59 z4 : 23 :59:59 z1 frueher als z2 ? true z3 frueher als z4 ? false z1 plus 40 Sekunden : 00 :02:03 z2 plus 3598 Sekunden : 02 :01:00 z3-z2 in Sekunden : 82737 --------------- Teil 2 --------------- (( 06 :38:30 ) , ( 01 :59:32 ) , ( 07 :16:48 ) , ( 01 :37:58 ) , ( 18 :16:06 ) , ( 07 :50:33 ) , ( 01 :41:47 ) , ( 05 :07:41 ) , ( 12 :38:08 ) , ( 02 :00:04 )) spaeteste : 18 :16:06 sortiert : (( 01 :37:58 ) , ( 01 :41:47 ) , ( 01 :59:32 ) , ( 02 :00:04 ) , ( 05 :07:41 ) , ( 06 :38:30 ) , ( 07 :16:48 ) , ( 07 :50:33 ) , ( 12 :38:08 ) , ( 18 :16:06 )) frueh : 10 :00:00 spaet : 20 :00:00 zwischen : (( 12 :38:08 ) , ( 18 :16:06 )) kleinster Abstand : (( 01 :59:32 ) , ( 02 :00:04 )) eine m\u00f6gliche L\u00f6sung f\u00fcr Uhrzeit Uhrzeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 package loesungen.probeklausuren.probeklausur3 ; public class Uhrzeit { private int stunden ; private int minuten ; private int sekunden ; public Uhrzeit ( int sekunden ) { final int STUNDE = 3600 ; final int MINUTE = 60 ; this . stunden = ( sekunden / STUNDE ) % 24 ; int rest = sekunden % STUNDE ; this . minuten = rest / MINUTE ; rest = rest % MINUTE ; this . sekunden = rest ; } public int uhrZeitInSekunden () { final int STUNDE = 3600 ; final int MINUTE = 60 ; int sekunden = this . stunden * STUNDE + this . minuten * MINUTE + this . sekunden ; return sekunden ; } public boolean frueher ( Uhrzeit u ) { return this . uhrZeitInSekunden () < u . uhrZeitInSekunden (); } public boolean spaeter ( Uhrzeit u ) { return this . uhrZeitInSekunden () > u . uhrZeitInSekunden (); } public Uhrzeit jetztPlusXSekunden ( int sekunden ) { int jetzt = this . uhrZeitInSekunden (); int neu = jetzt + sekunden ; return new Uhrzeit ( neu ); } public int differenzInSekunden ( Uhrzeit u ) { int uhrzeit1 = this . uhrZeitInSekunden (); int uhrzeit2 = u . uhrZeitInSekunden (); int diff = Math . abs ( uhrzeit1 - uhrzeit2 ); return diff ; } @Override public String toString () { String s = \"\" ; if ( this . stunden < 10 ) { s = s + \"0\" ; } s = s + this . stunden + \":\" ; if ( this . minuten < 10 ) { s = s + \"0\" ; } s = s + this . minuten + \":\" ; if ( this . sekunden < 10 ) { s = s + \"0\" ; } s = s + this . sekunden ; return s ; } public void print () { System . out . println ( this . toString ()); } } UhrzeitArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 package loesungen.probeklausuren.probeklausur3 ; import java.util.Random ; public class UhrzeitArray { private Uhrzeit [] uhren ; public UhrzeitArray ( int laenge ) { this . uhren = new Uhrzeit [ laenge ] ; } public void fill () { Random r = new Random (); for ( int i = 0 ; i < this . uhren . length ; i ++ ) { int zufSekunden = r . nextInt ( 86400 ); this . uhren [ i ] = new Uhrzeit ( zufSekunden ); } } public void print () { String s = \"(\" ; for ( int i = 0 ; i < this . uhren . length ; i ++ ) { if ( i < this . uhren . length - 1 ) { s = s + \"(\" + this . uhren [ i ] . toString () + \"), \" ; } else { s = s + \"(\" + this . uhren [ i ] . toString () + \")\" ; } } s = s + \")\" ; System . out . println ( s ); } public Uhrzeit frueheste () { Uhrzeit frueheste = this . uhren [ 0 ] ; for ( int i = 1 ; i < this . uhren . length ; i ++ ) { if ( this . uhren [ i ] . frueher ( frueheste )) { frueheste = this . uhren [ i ] ; } } return frueheste ; } public UhrzeitArray zwischen ( Uhrzeit frueh , Uhrzeit spaet ) { int anzZwischen = 0 ; for ( Uhrzeit u : this . uhren ) { if ( frueh . frueher ( u ) && u . frueher ( spaet )) { anzZwischen ++ ; } } UhrzeitArray ua = new UhrzeitArray ( anzZwischen ); int uaIndex = 0 ; for ( int i = 0 ; i < this . uhren . length ; i ++ ) { if ( frueh . frueher ( this . uhren [ i ] ) && this . uhren [ i ] . frueher ( spaet )) { ua . uhren [ uaIndex ] = this . uhren [ i ] ; uaIndex ++ ; } } return ua ; } public void sortieren () { for ( int bubble = 0 ; bubble < this . uhren . length - 1 ; bubble ++ ) { for ( int i = 0 ; i < this . uhren . length - 1 - bubble ; i ++ ) { if ( this . uhren [ i + 1 ] . frueher ( this . uhren [ i ] )) { Uhrzeit temp = this . uhren [ i ] ; this . uhren [ i ] = this . uhren [ i + 1 ] ; this . uhren [ i + 1 ] = temp ; } } } } public UhrzeitArray kleinsterAbstand () { this . sortieren (); Uhrzeit u1 = this . uhren [ 0 ] ; Uhrzeit u2 = this . uhren [ 1 ] ; int kleinsterAbstand = u1 . differenzInSekunden ( u2 ); for ( int i = 1 ; i < this . uhren . length - 1 ; i ++ ) { if ( this . uhren [ i ] . differenzInSekunden ( this . uhren [ i + 1 ] ) < kleinsterAbstand ) { u1 = this . uhren [ i ] ; u2 = this . uhren [ i + 1 ] ; kleinsterAbstand = u1 . differenzInSekunden ( u2 ); } } UhrzeitArray ua = new UhrzeitArray ( 2 ); ua . uhren [ 0 ] = u1 ; ua . uhren [ 1 ] = u2 ; return ua ; } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package loesungen.probeklausuren.probeklausur3 ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n---------------------- Test Uhrzeit --------------------------%n%n\" ); Uhrzeit z1 = new Uhrzeit ( 83 ); Uhrzeit z2 = new Uhrzeit ( 3662 ); Uhrzeit z3 = new Uhrzeit ( 86399 ); Uhrzeit z4 = new Uhrzeit ( 172799 ); System . out . print ( \"z1 : \" ); z1 . print (); System . out . print ( \"z2 : \" ); z2 . print (); System . out . print ( \"z3 : \" ); z3 . print (); System . out . print ( \"z4 : \" ); z4 . print (); System . out . println ( \"z1 frueher als z2 ? \" + z1 . frueher ( z2 )); System . out . println ( \"z3 frueher als z4 ? \" + z3 . frueher ( z4 )); System . out . println ( \"z1 plus 40 Sekunden : \" + z1 . jetztPlusXSekunden ( 40 )); System . out . println ( \"z2 plus 3598 Sekunden : \" + z2 . jetztPlusXSekunden ( 3598 )); System . out . println ( \"z3-z2 in Sekunden : \" + z3 . differenzInSekunden ( z2 )); System . out . printf ( \"%n%n------------------- Test UhrzeitArray ------------------------%n%n\" ); UhrzeitArray ua = new UhrzeitArray ( 10 ); ua . fill (); ua . print (); System . out . println ( \"frueheste : \" + ua . frueheste ()); Uhrzeit frueh = new Uhrzeit ( 36000 ); Uhrzeit spaet = new Uhrzeit ( 72000 ); UhrzeitArray zwischen = ua . zwischen ( frueh , spaet ); System . out . print ( \"frueh : \" ); frueh . print (); System . out . print ( \"spaet : \" ); spaet . print (); System . out . print ( \"zwischen : \" ); zwischen . print (); ua . sortieren (); ua . print (); UhrzeitArray kleinsterAbstand = ua . kleinsterAbstand (); System . out . print ( \"kleinster Abstand : \" ); kleinsterAbstand . print (); } } L\u00e4nder und Kontinente Implementieren Sie eine Klasse Land . Objektvariablen sind name vom Typ String (Name des Landes) , groesse vom Typ int (Gr\u00f6\u00dfe des Landes) und einwohner vom Typ int (Anzahl der Einwohner des Landes) . Die Objektvariablen sind nur in der Klasse sichtbar! Schreiben Sie f\u00fcr alle drei Objektvariablen Getter ( getName() , getGroesse() , `getEinwohner())! Schreiben Sie eine Objektmethode erzeugeName() . Diese Methode gibt einen String zur\u00fcck, der sich aus einem gro\u00dfen Buchstaben und einer Ziffer zusammensetzt, also z.B. K8 , L1 , J4 usw. Sowohl der Gro\u00dfbuchstabe als auch die Ziffer sollen mithilfe der Klasse Random zuf\u00e4llig erzeugt werden. Tipps: um die Klasse Random verwenden zu k\u00f6nnen, m\u00fcssen Sie sie aus dem java.util -Paket importieren, - verwenden Sie sowohl zum Erzeugen des Gro\u00dfbuchstabens als auch zum Erzeugen der Ziffer die Objektmethode nextInt(int bound) der Klasse Random , - der ASCII-Code von A ist 65 , der von Z ist 90 (es sind 26 verschiedene Buchstaben) - bei den Ziffern sind alle 10 Ziffern [0, \u2026,9] m\u00f6glich Schreiben Sie f\u00fcr die Klasse Land einen parameterlosen Konstruktor. In diesem Konstruktor wird die Objektvariable name mithilfe der erzeugeName() -Methode initialisiert, - die Objektvariable groesse wird mit einem Zufallswert aus dem Wertebereich [1, \u2026, 100] (100 verschiedene Zahlen, 1 und 100 inklusive) initialisiert und - die Objektvariable einwohner mit einem Zufallswert aus dem Wertebereich [1, \u2026, 1000] (1000 verschiedene Zahlen, 1 und 1000 inklusive) initialisiert. - Nutzen Sie erneut die Klasse Random und die Methode nextInt(bound) . Schreiben Sie eine Objektmethode ewDichte() . Diese Methode gibt ein double zur\u00fcck und gibt die Anzahl der einwohner pro groesse an. \u00dcberschreiben Sie die Objektmethode toString() so, dass ein Land in der folgenden Form als ein String zur\u00fcckgegeben wird (Zufallswerte): A3 : 37 km2 : 91 ew : 2 ,4595 Zuerst der Name des Landes und dann : , - dann die Groesse des Landes gefolgt von km2 : , - dann die Anzahl der Einwohner des Landes gefolgt von ew : und - dann die Einwohnerdichte mit vier Stellen nach dem Komma. Der String soll so formatiert sein, dass die Doppelpunkte : und das Komma bei der Einwohnerdichte bei der Ausgabe mehrerer Strings untereinander stehen!, also z.B. so: G5 : 76 km2 : 25 ew : 0 ,3289 W0 : 60 km2 : 18 ew : 0 ,3000 S9 : 6 km2 : 585 ew : 97 ,5000 H1 : 4 km2 : 965 ew : 241 ,2500 Schreiben Sie eine Objektmethode print() . Diese Methode gibt den durch toString() erzeugten String auf der Konsole aus. Schreiben Sie die Objektmethode istGroesser(Land land) . Diese Methode gibt ein true zur\u00fcck, wenn bei dem aufrufenden Objekt der Wert von groesse gr\u00f6\u00dfer ist als von land . Ansonsten false . Schreiben Sie die Objektmethode hatMehrEinwohner(Land land) . Diese Methode gibt ein true zur\u00fcck, wenn bei dem aufrufenden Objekt der Wert von einwohner gr\u00f6\u00dfer ist als von land . Ansonsten false . Schreiben Sie die Objektmethode nameIstGroesser(Land land) . Diese Methode gibt ein true zur\u00fcck, wenn bei dem aufrufenden Objekt der Wert von name lexikografisch gr\u00f6\u00dfer ist als von land . Ansonsten false. Tipp: f\u00fcr zwei Strings s1 und s2 gilt, dass s1 lexikografisch gr\u00f6\u00dfer ist, wenn der Wert von s1.compareTo(s2) einem positiven int -Wert etspricht. \u00dcberschreiben Sie die Objektmethode equals(Object o) . Diese Methode gibt ein true zur\u00fcck, wenn das aufrufende Objekt den gleichen Namen hat wie o . Sonst false . Schreiben Sie eine Klasse Testklasse mit main() -Methode. Erzeugen Sie in der main() -Methode in einer Schleife 10 Objekte der Klasse Land und rufen (auch in der Schleife) jeweils die print() -Methode auf. Es entsteht folgende Ausgabe (Beispielwerte sind zuf\u00e4llig und unterscheiden sich!): J6 : 34 km2 : 198 ew : 5 ,8235 B4 : 72 km2 : 171 ew : 2 ,3750 Z8 : 93 km2 : 712 ew : 7 ,6559 W2 : 75 km2 : 149 ew : 1 ,9867 O0 : 100 km2 : 576 ew : 5 ,7600 Q5 : 21 km2 : 210 ew : 10 ,0000 O9 : 71 km2 : 533 ew : 7 ,5070 B8 : 52 km2 : 57 ew : 1 ,0962 K4 : 71 km2 : 830 ew : 11 ,6901 A9 : 98 km2 : 288 ew : 2 ,9388 Erzeugen Sie 1 Objekt von Land und rufen Sie f\u00fcr dieses Objekt die print() -Methode auf. Erzeugen Sie in einer Schleife so lange ein weiteres Objekt von Land , bis die beiden Objekte laut equals() -Methode gleich sind. Z\u00e4hlen Sie mit, wie viele Objekte von Land Sie erzeugen mussten, bis ein gleiches Objekt gefunden wurde. Geben Sie das gefundene Objekt mithilfe der print() -Methode aus und wie viele Objekte erzeugt wurden. Es entsteht folgende Ausgabe (Beispielwerte sind zuf\u00e4llig und unterscheiden sich!): I1 : 28 km2 : 914 ew : 32 ,6429 I1 : 80 km2 : 1 ew : 0 ,0125 43 andere Laender erzeugt Erzeugen Sie zwei Objekte l1 und l2 von Land und wenden Sie die Methoden istGroesser() , hatMehrEinwohner() und nameIstGroesser() so an, dass folgende Ausgabe entsteht (Zufallswerte!): l1 : T0 : 30 km2 : 237 ew : 7 ,9000 l2 : K0 : 29 km2 : 328 ew : 11 ,3103 l1 groesser als l2 ? : true l1 mehr Einwohner als l2 ? : false l1 lexikografisch groesser als l2 ? : true Schreiben Sie eine Klasse Kontinent . Objektvariablen dieser Klasse sind: laender vom Typ Land[] und kontinent vom Typ char . Beide Objektvariablen sind nur innerhalb der Klasse sichtbar! Schreiben Sie einen parametrisierten Konstruktor Kontinent(char kontinent, int anzahlLaender) . Innerhalb des Konstruktors werden: der Parameterwert kontinent verwendet, um die Objektvariable kontinent zu initialisieren, - das Array erzeugt, auf das die Objektvariable laender referenziert. Das Array hat die L\u00e4nge anzahlLaender , - sowie das laender -Array vollst\u00e4ndig mit Objekten vom Typ Land bef\u00fcllt. Schreiben Sie eine Objektmethode getAnzLaender() . Diese Methode gibt die Anzahl der L\u00e4nder im laender -Array als int zur\u00fcck. Schreiben Sie eine Objektmethode getLaender() . Diese Methode gibt eine Referenz auf das laender -Array zur\u00fcck. Schreiben Sie eine Objektmethode getLandAtIndex(int index) . Diese Methode gibt das Land zur\u00fcck, das im laender -Array unter dem Index index gespeichert ist. Sollte index kein korrekter Index aus dem laender -Array sein, wird null zur\u00fcckgegeben. Schreiben Sie eine Objektmethode getSummen() . Diese Methode gibt ein int -Array der L\u00e4nge 2 zur\u00fcck. Der erste Eintrag in diesem Array ist die Summe der Gr\u00f6\u00dfen aller L\u00e4nder im laender -Array und der zweite Eintrag ist die Summe der Einwohner aller L\u00e4nder im laender -Array. \u00dcberschreiben Sie die Objektmethode toString() so, dass ein String in der folgenden Form zur\u00fcckgegeben wird (Zufallswerte!): Kontinent a -------------------------- S2 : 81 km2 : 918 ew : 11 ,3333 Z7 : 14 km2 : 453 ew : 32 ,3571 O4 : 35 km2 : 713 ew : 20 ,3714 Q9 : 14 km2 : 728 ew : 52 ,0000 F1 : 23 km2 : 714 ew : 31 ,0435 K9 : 67 km2 : 630 ew : 9 ,4030 W5 : 35 km2 : 128 ew : 3 ,6571 Summen : 269 : 4284 es wird Kontinent und der Name des Kontinents in der ersten Zeile ausgegeben, dann kommt eine Trennlinie (egal, wie lang), dann kommen untereinander alle L\u00e4nder aus dem laender-Array, dann kommt eine Lehrzeile und dann kommen die Summen der Gr\u00f6\u00dfen der L\u00e4nder und die Summen der Einwohner (beliebig formatiert) Schreiben Sie eine Objektmethode print() . Diese Methode gibt den durch toString() erzeugten String auf der Konsole aus. Schreiben Sie eine Objektmethode sortiere(int nach) . Diese Methode sortiert das laender -Array aufsteigend von klein nach gro\u00df. Der Parameter nach hat folgende Bedeutung: Ist der Wert von nach 0 , dann wird das Array nach der groesse der L\u00e4nder sortiert. Ist der Wert von nach 1 , dann wird das Array nach der Anzahl der einwohner der L\u00e4nder sortiert. Ist der Wert von nach 2 , dann wird das Array nach der Einwohnerdichte ( ewDichte ) der L\u00e4nder sortiert. F\u00fcr jeden anderen Wert von nach (also alles au\u00dfer 0,1,2 ) wird das Array lexikografisch nach den Namen der L\u00e4nder sortiert. Erzeugen Sie in der main() -Methode ein Array, in dem jedes Element vom Typ Kontinent ist. Das Array hat die L\u00e4nge 5 . Bef\u00fcllen Sie dieses Array mit Kontinent -Objekten in einer Schleife(!) wie folgt: Die f\u00fcnf Kontinente haben die Namen a , b , c , d , e (der ASCII-Code von a ist 97 , der von b ist 98 usw. ). Der erste Kontinent hat 7 L\u00e4nder, der zweite hat 8, der dritte 9, der vierte 10 und der f\u00fcnfte Kontinent hat 11 L\u00e4nder. Rufen Sie f\u00fcr alle Kontinente jeweils die print() -Methode auf. Es entsteht folgende Ausgabe (Zufallswerte!): Kontinent a -------------------------- S2 : 81 km2 : 918 ew : 11 ,3333 Z7 : 14 km2 : 453 ew : 32 ,3571 O4 : 35 km2 : 713 ew : 20 ,3714 Q9 : 14 km2 : 728 ew : 52 ,0000 F1 : 23 km2 : 714 ew : 31 ,0435 K9 : 67 km2 : 630 ew : 9 ,4030 W5 : 35 km2 : 128 ew : 3 ,6571 Summen : 269 : 4284 Kontinent b -------------------------- R8 : 65 km2 : 337 ew : 5 ,1846 L9 : 57 km2 : 732 ew : 12 ,8421 T0 : 74 km2 : 796 ew : 10 ,7568 P4 : 13 km2 : 481 ew : 37 ,0000 L5 : 48 km2 : 575 ew : 11 ,9792 Q2 : 35 km2 : 538 ew : 15 ,3714 M8 : 72 km2 : 865 ew : 12 ,0139 T0 : 29 km2 : 855 ew : 29 ,4828 Summen : 393 : 5179 Kontinent c -------------------------- I9 : 91 km2 : 84 ew : 0 ,9231 X9 : 41 km2 : 842 ew : 20 ,5366 V7 : 31 km2 : 120 ew : 3 ,8710 O3 : 48 km2 : 990 ew : 20 ,6250 P6 : 27 km2 : 565 ew : 20 ,9259 J7 : 54 km2 : 810 ew : 15 ,0000 S9 : 72 km2 : 401 ew : 5 ,5694 C4 : 29 km2 : 486 ew : 16 ,7586 I2 : 6 km2 : 393 ew : 65 ,5000 Summen : 399 : 4691 Kontinent d -------------------------- C0 : 44 km2 : 122 ew : 2 ,7727 E2 : 8 km2 : 925 ew : 115 ,6250 I1 : 12 km2 : 585 ew : 48 ,7500 X9 : 13 km2 : 583 ew : 44 ,8462 Z6 : 10 km2 : 24 ew : 2 ,4000 J1 : 20 km2 : 161 ew : 8 ,0500 I2 : 75 km2 : 432 ew : 5 ,7600 Y8 : 69 km2 : 224 ew : 3 ,2464 H1 : 45 km2 : 410 ew : 9 ,1111 P1 : 24 km2 : 332 ew : 13 ,8333 Summen : 320 : 3798 Kontinent e -------------------------- J6 : 22 km2 : 358 ew : 16 ,2727 N9 : 95 km2 : 471 ew : 4 ,9579 G5 : 94 km2 : 524 ew : 5 ,5745 G0 : 72 km2 : 753 ew : 10 ,4583 L3 : 84 km2 : 49 ew : 0 ,5833 M8 : 39 km2 : 13 ew : 0 ,3333 K7 : 22 km2 : 881 ew : 40 ,0455 Y3 : 58 km2 : 355 ew : 6 ,1207 H3 : 28 km2 : 2 ew : 0 ,0714 V2 : 67 km2 : 94 ew : 1 ,4030 S9 : 15 km2 : 392 ew : 26 ,1333 Summen : 596 : 3892 Rufen Sie f\u00fcr den ersten Kontinent im Array nacheinander die Methoden sortiere(0) , print() , sortiere(1) , print() , sortiere(2) , print() , sortiere(3) , print() auf. Es entsteht folgende Ausgabe (Zufallswerte!): Kontinent a // keine Ausgabe, nur Info: Kontinent unsortiert -------------------------- S2 : 81 km2 : 918 ew : 11 ,3333 Z7 : 14 km2 : 453 ew : 32 ,3571 O4 : 35 km2 : 713 ew : 20 ,3714 Q9 : 14 km2 : 728 ew : 52 ,0000 F1 : 23 km2 : 714 ew : 31 ,0435 K9 : 67 km2 : 630 ew : 9 ,4030 W5 : 35 km2 : 128 ew : 3 ,6571 Kontinent a // keine Ausgabe, nur Info: nach groesse sortiert -------------------------- Z7 : 14 km2 : 453 ew : 32 ,3571 Q9 : 14 km2 : 728 ew : 52 ,0000 F1 : 23 km2 : 714 ew : 31 ,0435 O4 : 35 km2 : 713 ew : 20 ,3714 W5 : 35 km2 : 128 ew : 3 ,6571 K9 : 67 km2 : 630 ew : 9 ,4030 S2 : 81 km2 : 918 ew : 11 ,3333 Kontinent a // keine Ausgabe, nur Info: nach einwohner sortiert -------------------------- W5 : 35 km2 : 128 ew : 3 ,6571 Z7 : 14 km2 : 453 ew : 32 ,3571 K9 : 67 km2 : 630 ew : 9 ,4030 O4 : 35 km2 : 713 ew : 20 ,3714 F1 : 23 km2 : 714 ew : 31 ,0435 Q9 : 14 km2 : 728 ew : 52 ,0000 S2 : 81 km2 : 918 ew : 11 ,3333 Kontinent a // keine Ausgabe, nur Info: nach ewDichte sortiert -------------------------- W5 : 35 km2 : 128 ew : 3 ,6571 K9 : 67 km2 : 630 ew : 9 ,4030 S2 : 81 km2 : 918 ew : 11 ,3333 O4 : 35 km2 : 713 ew : 20 ,3714 F1 : 23 km2 : 714 ew : 31 ,0435 Z7 : 14 km2 : 453 ew : 32 ,3571 Q9 : 14 km2 : 728 ew : 52 ,0000 Kontinent a // keine Ausgabe, nur Info: nach name sortiert -------------------------- F1 : 23 km2 : 714 ew : 31 ,0435 K9 : 67 km2 : 630 ew : 9 ,4030 O4 : 35 km2 : 713 ew : 20 ,3714 Q9 : 14 km2 : 728 ew : 52 ,0000 S2 : 81 km2 : 918 ew : 11 ,3333 W5 : 35 km2 : 128 ew : 3 ,6571 Z7 : 14 km2 : 453 ew : 32 ,3571 Schreiben Sie eine Klasse Welt . Objektvariable dieser Klasse ist kontinente vom Typ Kontinent[] . Die Objektvariable ist nur innerhalb der Klasse sichtbar! Schreiben Sie einen parametrisierten Konstruktor Welt(Kontinent[] kontinente) . Die Referenz des Parameters wird der Objektvariablen zugewiesen. Schreiben Sie eine Objektmethode getAlleLaender() . Diese Methode gibt ein Land -Array zur\u00fcck, in dem alle L\u00e4nder aus dem kontinente -Array enthalten sind. Schreiben Sie eine Objektmethode printAlleLaender(Land[] alleLaender) , die das als Parameter \u00fcbergebene Array in der folgenden Form ausgibt (Zufallswerte!): F1 : 23 km2 : 714 ew : 31 ,0435 K9 : 67 km2 : 630 ew : 9 ,4030 O4 : 35 km2 : 713 ew : 20 ,3714 Q9 : 14 km2 : 728 ew : 52 ,0000 S2 : 81 km2 : 918 ew : 11 ,3333 W5 : 35 km2 : 128 ew : 3 ,6571 Z7 : 14 km2 : 453 ew : 32 ,3571 R8 : 65 km2 : 337 ew : 5 ,1846 L9 : 57 km2 : 732 ew : 12 ,8421 T0 : 74 km2 : 796 ew : 10 ,7568 P4 : 13 km2 : 481 ew : 37 ,0000 L5 : 48 km2 : 575 ew : 11 ,9792 Es sind mehr L\u00e4nder \u2013 ist hier gek\u00fcrzt. Also einfach alle L\u00e4nder untereinander. Schreiben Sie eine Objektmethode enthaeltDoppel() . Diese Methode gibt ein true zur\u00fcck, wenn das kontinente -Array L\u00e4nder enth\u00e4lt, die den gleichen Namen haben, also laut equals() gleich sind. Ansonsten false . Schreiben Sie eine Objektmethode groesstestLand() . Diese Methode gibt das gr\u00f6\u00dfte Land (gr\u00f6\u00dfte groesse ) aller L\u00e4nder im kontinente -Array zur\u00fcck. Schreiben Sie eine Objektmethode alleLaenderGroesserAls(int groesse) , die ein Land[] zur\u00fcckgibt. Das zur\u00fcckgegebene Land[] enth\u00e4lt alle L\u00e4nder aus dem kontinente -Array, die gr\u00f6\u00dfer sind als der Parameterwert groesse . Testen Sie in der main() -Methode die Methoden getAlleLaender() und printAlleLaender() der Klasse Welt , so dass f\u00fcr die Methoden folgende Ausgaben entstehen (Zufallswerte!): L6 : 37 km2 : 122 ew : 3 ,2973 M9 : 22 km2 : 351 ew : 15 ,9545 O4 : 84 km2 : 717 ew : 8 ,5357 P4 : 93 km2 : 759 ew : 8 ,1613 Q3 : 3 km2 : 771 ew : 257 ,0000 R1 : 48 km2 : 610 ew : 12 ,7083 V3 : 40 km2 : 153 ew : 3 ,8250 E8 : 58 km2 : 195 ew : 3 ,3621 I9 : 19 km2 : 875 ew : 46 ,0526 Z6 : 47 km2 : 188 ew : 4 ,0000 Y6 : 75 km2 : 858 ew : 11 ,4400 C7 : 26 km2 : 676 ew : 26 ,0000 V8 : 1 km2 : 470 ew : 470 ,0000 Q8 : 92 km2 : 214 ew : 2 ,3261 T7 : 52 km2 : 544 ew : 10 ,4615 U1 : 46 km2 : 939 ew : 20 ,4130 C9 : 22 km2 : 594 ew : 27 ,0000 Z5 : 94 km2 : 353 ew : 3 ,7553 G6 : 9 km2 : 237 ew : 26 ,3333 D8 : 85 km2 : 910 ew : 10 ,7059 I5 : 15 km2 : 521 ew : 34 ,7333 V7 : 58 km2 : 546 ew : 9 ,4138 V8 : 25 km2 : 535 ew : 21 ,4000 I4 : 91 km2 : 407 ew : 4 ,4725 W1 : 92 km2 : 278 ew : 3 ,0217 M4 : 30 km2 : 494 ew : 16 ,4667 R5 : 8 km2 : 912 ew : 114 ,0000 O1 : 15 km2 : 858 ew : 57 ,2000 S3 : 46 km2 : 463 ew : 10 ,0652 M9 : 43 km2 : 624 ew : 14 ,5116 P5 : 35 km2 : 704 ew : 20 ,1143 Y2 : 2 km2 : 243 ew : 121 ,5000 X9 : 79 km2 : 928 ew : 11 ,7468 Z4 : 36 km2 : 311 ew : 8 ,6389 C6 : 2 km2 : 249 ew : 124 ,5000 J6 : 6 km2 : 683 ew : 113 ,8333 G8 : 18 km2 : 3 ew : 0 ,1667 W3 : 24 km2 : 502 ew : 20 ,9167 K9 : 81 km2 : 996 ew : 12 ,2963 A0 : 46 km2 : 950 ew : 20 ,6522 K9 : 99 km2 : 84 ew : 0 ,8485 T5 : 93 km2 : 488 ew : 5 ,2473 X1 : 40 km2 : 555 ew : 13 ,8750 Q9 : 18 km2 : 631 ew : 35 ,0556 I9 : 22 km2 : 867 ew : 39 ,4091 Rufen Sie die Methoden enthaeltDoppel() , groesstesLand() , alleLaenderGroesserAls(50) und printAlleLaender() so auf, dass folgende Ausgaben entstehen (Zufallswerte!): Enthaelt Doppel? : true groesstes Land : K9 : 99 km2 : 84 ew : 0 ,8485 Alle Laender groesser als 50 : O4 : 84 km2 : 717 ew : 8 ,5357 P4 : 93 km2 : 759 ew : 8 ,1613 E8 : 58 km2 : 195 ew : 3 ,3621 Y6 : 75 km2 : 858 ew : 11 ,4400 Q8 : 92 km2 : 214 ew : 2 ,3261 T7 : 52 km2 : 544 ew : 10 ,4615 Z5 : 94 km2 : 353 ew : 3 ,7553 D8 : 85 km2 : 910 ew : 10 ,7059 V7 : 58 km2 : 546 ew : 9 ,4138 I4 : 91 km2 : 407 ew : 4 ,4725 W1 : 92 km2 : 278 ew : 3 ,0217 X9 : 79 km2 : 928 ew : 11 ,7468 K9 : 81 km2 : 996 ew : 12 ,2963 K9 : 99 km2 : 84 ew : 0 ,8485 T5 : 93 km2 : 488 ew : 5 ,2473 eine m\u00f6gliche L\u00f6sung f\u00fcr L\u00e4nder und Kontinente Land.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 package klausur ; import java.util.Random ; public class Land { private String name ; private int groesse ; private int einwohner ; public String getName () { return this . name ; } public int getGroesse () { return this . groesse ; } public int getEinwohner () { return this . einwohner ; } public String erzeugeName () { Random r = new Random (); int ascii = r . nextInt ( 26 ) + 65 ; char c = ( char ) ascii ; String s = \"\" + c ; int nr = r . nextInt ( 10 ); s += nr ; return s ; } public Land () { this . name = this . erzeugeName (); Random r = new Random (); this . groesse = r . nextInt ( 100 ) + 1 ; this . einwohner = r . nextInt ( 1000 ) + 1 ; } public double ewDichte () { double ewDichte = ( double ) this . einwohner / ( double ) this . groesse ; return ewDichte ; } @Override public String toString () { String s = String . format ( \"%s : %3d km2 : %4d ew : %8.4f\" , this . name , this . groesse , this . einwohner , this . ewDichte ()); return s ; } public void print () { System . out . println ( this . toString ()); } public boolean istGroesser ( Land l ) { return this . groesse > l . groesse ; } public boolean hatMehrEinwohner ( Land l ) { return this . einwohner > l . einwohner ; } public boolean nameIstGroesser ( Land l ) { return this . name . compareTo ( l . name ) > 0 ; } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Land lo = ( Land ) o ; return this . name . equals ( lo . name ); } } Kontinent.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 package klausur ; public class Kontinent { private Land [] laender ; private char kontinent ; public Kontinent ( char kontinent , int anzahlLaender ) { this . kontinent = kontinent ; this . laender = new Land [ anzahlLaender ] ; for ( int index = 0 ; index < this . laender . length ; index ++ ) { this . laender [ index ] = new Land (); } } public int getAnzLaender () { return this . laender . length ; } public Land [] getLaender () { return this . laender ; } public Land getLandAtIndex ( int index ) { if ( index >= 0 && index < this . getAnzLaender ()) { return this . laender [ index ] ; } else { return null ; } } /* public char getKontinent() { return this.kontinent; } */ public int [] getSummen () { int summeEw = 0 ; int summeQm = 0 ; for ( int index = 0 ; index < this . laender . length ; index ++ ) { summeEw += this . laender [ index ] . getEinwohner (); summeQm += this . laender [ index ] . getGroesse (); } int [] summen = { summeQm , summeEw }; return summen ; } @Override public String toString () { String s = String . format ( \"Kontinent %c %n\" , this . kontinent ); s += String . format ( \"--------------------------%n\" ); for ( int index = 0 ; index < this . laender . length ; index ++ ) { s += String . format ( \"%24s %n\" , this . laender [ index ] ); } return s ; } public void print () { System . out . println ( this . toString ()); } public void sortiere ( int nach ) { for ( int bubble = 1 ; bubble < this . laender . length ; bubble ++ ) { for ( int index = 0 ; index < this . laender . length - bubble ; index ++ ) { if ( nach == 0 && this . laender [ index ] . istGroesser ( this . laender [ index + 1 ] ) || nach == 1 && this . laender [ index ] . hatMehrEinwohner ( this . laender [ index + 1 ] ) || nach == 2 && this . laender [ index ] . ewDichte () > this . laender [ index + 1 ] . ewDichte () || nach != 0 && nach != 1 && nach != 2 && this . laender [ index ] . nameIstGroesser ( this . laender [ index + 1 ] )) { Land tmp = this . laender [ index ] ; this . laender [ index ] = this . laender [ index + 1 ] ; this . laender [ index + 1 ] = tmp ; } } } } } Kontinent.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 package klausur ; public class Welt { private Kontinent [] kontinente ; public Welt ( Kontinent [] kontinente ) { this . kontinente = kontinente ; } public int anzahlLaender () { int anzahl = 0 ; for ( int index = 0 ; index < this . kontinente . length ; index ++ ) { anzahl += this . kontinente [ index ] . getAnzLaender (); } return anzahl ; } public Land [] getAlleLaender () { Land [] alleLaender = new Land [ this . anzahlLaender () ] ; int indexAlle = 0 ; for ( int kontinent = 0 ; kontinent < this . kontinente . length ; kontinent ++ ) { for ( int index = 0 ; index < this . kontinente [ kontinent ] . getAnzLaender (); index ++ ) { alleLaender [ indexAlle ++] = this . kontinente [ kontinent ] . getLandAtIndex ( index ); } } return alleLaender ; } /* * war nicht gefordert */ public Land [] sortiereAlleLaenderNachName () { Land [] alleLaender = this . getAlleLaender (); for ( int bubble = 1 ; bubble < alleLaender . length ; bubble ++ ) { for ( int index = 0 ; index < alleLaender . length - bubble ; index ++ ) { if ( alleLaender [ index ] . nameIstGroesser ( alleLaender [ index + 1 ] )) { Land tmp = alleLaender [ index ] ; alleLaender [ index ] = alleLaender [ index + 1 ] ; alleLaender [ index + 1 ] = tmp ; } } } return alleLaender ; } public void printAlleLaender ( Land [] alleLaender ) { for ( int index = 0 ; index < alleLaender . length ; index ++ ) { System . out . println ( alleLaender [ index ] ); } } public boolean enthaeltDoppel () { Land [] alleLaender = this . getAlleLaender (); for ( int index1 = 0 ; index1 < alleLaender . length - 1 ; index1 ++ ) { for ( int index2 = index1 + 1 ; index2 < alleLaender . length ; index2 ++ ) { if ( alleLaender [ index1 ] . equals ( alleLaender [ index2 ] )) { return true ; } } } return false ; } public Land [] alleLaenderGroesserAls ( int groesse ) { Land [] alleLaender = this . getAlleLaender (); int anzahl = 0 ; for ( int index = 0 ; index < alleLaender . length ; index ++ ) { if ( alleLaender [ index ] . getGroesse () > groesse ) { anzahl ++ ; } } Land [] laender = new Land [ anzahl ] ; int indexLaender = 0 ; for ( int index = 0 ; index < alleLaender . length ; index ++ ) { if ( alleLaender [ index ] . getGroesse () > groesse ) { laender [ indexLaender ++] = alleLaender [ index ] ; } } return laender ; } public Land groesstesLand () { Land [] alleLaender = this . getAlleLaender (); int indexGroesstes = 0 ; for ( int index = 1 ; index < alleLaender . length ; index ++ ) { if ( alleLaender [ index ] . istGroesser ( alleLaender [ indexGroesstes ] )) { indexGroesstes = index ; } } return alleLaender [ indexGroesstes ] ; } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 package klausur ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n------------------ Test Land ------------------%n%n\" ); for ( int i = 0 ; i < 10 ; i ++ ) { new Land (). print (); } System . out . printf ( \"%n%n----------------- Land equals -----------------%n%n\" ); Land l1 = new Land (); Land l2 = new Land (); int anz = 0 ; while ( ! l1 . equals ( l2 )) { l2 = new Land (); anz ++ ; } l1 . print (); l2 . print (); System . out . println ( anz + \" andere Laender erzeugt\" ); System . out . printf ( \"%n%n----------------- Land Vergleiche -----------------%n%n\" ); l1 = new Land (); l2 = new Land (); System . out . print ( \"l1 : \" ); l1 . print (); System . out . print ( \"l2 : \" ); l2 . print (); System . out . println (); System . out . println ( \"l1 groesser als l2 ? : \" + l1 . istGroesser ( l2 )); System . out . println ( \"l1 mehr Einwohner als l2 ? : \" + l1 . hatMehrEinwohner ( l2 )); System . out . println ( \"l1 lexikografisch groesser als l2 ? : \" + l1 . nameIstGroesser ( l2 )); System . out . printf ( \"%n%n----------------- Kontinent ------------------%n%n\" ); final int ANZAHL_KONTINENTE = 5 ; final int ASCII_KLEIN_A = 97 ; Kontinent [] ka = new Kontinent [ ANZAHL_KONTINENTE ] ; for ( int index = 0 ; index < ANZAHL_KONTINENTE ; index ++ ) { char c = ( char )( index + ASCII_KLEIN_A ); int anzahlLaender = index + 7 ; ka [ index ] = new Kontinent ( c , anzahlLaender ); ka [ index ] . print (); int [] summen = ka [ index ] . getSummen (); System . out . println ( \"Summen : \" + summen [ 0 ] + \" : \" + summen [ 1 ] ); System . out . println (); } System . out . printf ( \"%n%n----------------- sortieren ------------------%n%n\" ); ka [ 0 ] . print (); ka [ 0 ] . sortiere ( 0 ); ka [ 0 ] . print (); ka [ 0 ] . sortiere ( 1 ); ka [ 0 ] . print (); ka [ 0 ] . sortiere ( 2 ); ka [ 0 ] . print (); ka [ 0 ] . sortiere ( 3 ); ka [ 0 ] . print (); System . out . printf ( \"%n%n----------------- Welt ------------------%n%n\" ); Welt welt = new Welt ( ka ); Land [] alleLaender = welt . getAlleLaender (); welt . printAlleLaender ( alleLaender ); System . out . println (); System . out . println ( \"Enthaelt Doppel? : \" + welt . enthaeltDoppel ()); Land groesstes = welt . groesstesLand (); System . out . println ( \"groesstes Land : \" + groesstes . toString ()); Land [] groesser = welt . alleLaenderGroesserAls ( 50 ); System . out . println ( \"Alle Laender groesser als 50 :\" ); welt . printAlleLaender ( groesser ); } } MyString Information: Wir bauen in Ans\u00e4tzen die Klasse String nach, d.h. wir bauen uns einen eigenen Datentypen f\u00fcr Zeichenketten: MyString . Ein Objekt von MyString ist intern ein char[] (wir nennen es wort ). Von der Klasse String selbst verwenden wir nur zwei Methoden: charAt(index) und length() , und zwar in dem Konstruktor von MyString , dem ein String als Parameter \u00fcbergeben wird \u2192 das steht aber nochmal explizit dort Ansonsten verwenden wir von String keine weiteren Methoden (ist nicht erlaubt, w\u00e4re aber auch nirgendwo hilfreich) Wir erstellen insgesamt nur 2 Klassen: MyString und Testklasse . Implementieren Sie eine Klasse MyString . Objektvariable ist wort vom Typ char[] (unsere Zeichenkette - Array von Zeichen) . Die Objektvariable ist nur in der Klasse sichtbar! Schreiben Sie f\u00fcr MyString einen parameterlosen Konstruktor. In diesem Konstruktor wird das wort -Array erzeugt mit der L\u00e4nge 0 . Schreiben Sie f\u00fcr MyString einen parametrisierten Konstruktor, dem ein einzelnes Zeichen ( char ) als Parameter \u00fcbergeben wird. In diesem Konstruktor wird das wort -Array erzeugt mit der L\u00e4nge 1 und das einzelne Zeichen wird in das wort -Array gespeichert. Schreiben Sie f\u00fcr MyString einen parametrisierten Konstruktor, dem ein String als Parameter \u00fcbergeben wird. In diesem Konstruktor wird das wort -Array erzeugt mit der L\u00e4nge des Strings und jedes einzelne Zeichen des Strings wird in das wort -Array gespeichert. Hierzu nutzen Sie die Methoden charAt(index) und length() der Klasse String . \u00dcberschreiben Sie die Objektmethode toString() so, dass alle Zeichen aus dem wort -Array als ein String zur\u00fcckgegeben werden, also z.B. Schreiben Sie eine Objektmethode print() . Diese Methode gibt den durch toString() erzeugten String auf der Konsole aus. Schreiben Sie die Objektmethode getLength() . Diese Methode gibt die L\u00e4nge des wort -Arrays zur\u00fcck. Schreiben Sie die Objektmethode getCharAt(int index) . Diese Methode gibt ein Leerzeichen zur\u00fcck, wenn der \u00fcbergebene index kein Index des wort -Arrays ist. Ansonsten wird das Zeichen zur\u00fcckgegeben, das im wort -Array unter dem Index index gespeichert ist. Schreiben Sie die Objektmethode contains(char c) . Diese Methode gibt ein true zur\u00fcck, wenn c im wort -Array vorkommt. Ansonsten false . \u00dcberschreiben Sie die Objektmethode equals(Object o) . Diese Methode gibt ein true zur\u00fcck, wenn das aufrufende Objekt die gleiche wort -L\u00e4nge hat wie o und auch alle Zeichen in den beiden wort -Arrays elementweise gleich sind (also Index f\u00fcr Index). Sonst false . Schreiben Sie eine Klasse Testklasse mit main() -Methode. Erzeugen Sie in der main() -Methode ein Objekt s1 von MyString mithilfe des parameterlosen Konstruktors, ein Objekt s2 von MyString, dem der einzelne Buchstabe a \u00fcbergeben wird, ein Objekt s3 von MyString, dem die Zeichenkette hallo \u00fcbergeben wird, rufen Sie f\u00fcr alle drei Objekte die print()-Methode auf. Es entsteht folgende Ausgabe: // das hier geh\u00f6rt nicht zur Ausgabe, soll nur zeigen, dass zun\u00e4chst eine Leerzeile kommt a hallo Wenden Sie die getCharAt() -Methode an und lassen sich f\u00fcr das dritte MyString -Objekt ( s3 ) den Buchstaben auf der Konsole ausgeben, der am Index 1 gespeichert ist. Wenden Sie die contains() -Methode 2 Mal an und lassen sich f\u00fcr das dritte MyString -Objekt auf der Konsole ausgebenden, ob der Buchstabe a in dessen wort-Array gespeichert ist und ob der Buchstabe b in dessen wort-Array gespeichert ist. Es entsteht folgende Ausgabe: a a in hallo ? true b in hallo ? false Erzeugen Sie zwei weitere Objekte s4 und s5 von MyString , einmal mit der Zeichenkette hallo und einmal mit der Zeichenkette halLo und vergleichen Sie beide Objekte mithilfe der equals() -Methode mit dem dritten MyString -Objekt s3 . Es entstehen folgende Ausgaben: s3 gleich s4 ? true s3 gleich s4 ? false weiter mit MyString : Schreiben Sie eine Objektmethode getAsciiCodeOfCharAt(int index) . Diese Methode gibt den Ascii-Code des Zeichens zur\u00fcck, das im wort -Array unter dem Index index gespeichert ist. Ist index kein Index aus dem wort -Array, wird -1 zur\u00fcckgegeben. Schreiben Sie eine Objektmethode append(char c) . Diese Methode h\u00e4ngt das Zeichen c an das wort -Array, d.h. danach ist das wort -Array um 1 l\u00e4nger als vor Aufruf der Methode. Schreiben Sie eine Objektmethode append(MyString s) . Diese Methode h\u00e4ngt alle Zeichen aus s (aus dessen wort -Array) an das wort -Array des aufrufenden Objektes. Tipp: Verwenden Sie dazu die append(char c) -Methode. Schreiben Sie eine Objektmethode concat(MyString s1, MyString s2) . Diese Methode gibt ein (neues) MyString -Objekt zur\u00fcck, in dem das wort -Array alle Zeichen aus s1 und s2 enth\u00e4lt. (Diese concat() -Methode entspricht s1+s2 f\u00fcr Strings): Schreiben Sie die Objektmethode firstIndexOf(char c) . Diese Methode gibt den Index zur\u00fcck, an dem das Zeichen c zum ersten Mal im wort -Array vorkommt. Kommt das Zeichen c nicht im wort -Array vor, wird -1 zur\u00fcckgegeben. Schreiben Sie die Objektmethode lastIndexOf(char c) . Diese Methode gibt den Index zur\u00fcck, an dem das Zeichen c zum letzten Mal im wort -Array vorkommt. Kommt das Zeichen c nicht im wort -Array vor, wird -1 zur\u00fcckgegeben. Schreiben Sie eine Objektmethode substring(int beginIndex) . Diese Methode gibt ein (neues) MyString -Objekt zur\u00fcck. Das neue MyString -Objekt enth\u00e4lt im wort -Array alle Zeichen aus dem wort -Array des aufrufenden Objektes ab dem Index beginIndex (inklusive). Ist beginIndex kein korrekter Index aus dem wort -Array des aufrufenden Objektes, wird ein MyString -Objekt mit leerem wort -Array zur\u00fcckgegeben. weiter mit Testklasse : Testen Sie die getAsciiCodeOfCharAt() -Methode, indem Sie sich den Ascii-Code des Zeichens von s3 auf dem Index 1 ausgeben lassen: Ascii-Code Zeichen aus s3 mit Index 1 = 97 Testen Sie die append(char) -Methode, indem Sie an s3 das Zeichen c h\u00e4ngen: halloc Testen Sie die append(MyString) -Methode, indem Sie sich ein weiteres MyString -Objekt s6 mit ballo erzeugen und dieses Objekt an s3 h\u00e4ngen: hallocballo Testen Sie die concat() -Methode, indem Sie sich ein weiteres MyString -Objekt s7 mit leerem wort -Array erzeugen und f\u00fcr dieses Objekt die concat() -Methode aufrufen, wobei Sie die Objekte s4 und s6 \u00fcbergeben: halloballo Testen Sie die firstIndexOf() - und die lastIndexOf() - Methode, indem Sie jeweils in s3 nach dem Buchstaben l suchen (kleines L): erstes l in s3 am Index 2 letztes l in s3 am Index 9 Testen Sie die substring() -Methode, indem Sie den Teilstring ab Index 5 f\u00fcr s3 ausgeben: cballo weiter mit MyString : Schreiben Sie eine Objektmethode substring(int beginIndex, int endIndex) . Diese Methode gibt ein (neues) MyString -Objekt zur\u00fcck. Das neue MyString -Objekt enth\u00e4lt im wort -Array alle Zeichen aus dem wort -Array des aufrufenden Objektes ab dem Index beginIndex (inklusive) bis zum Index endIndex (exklusive). Ist beginIndex kein korrekter Index aus dem wort -Array des aufrufenden Objektes oder ist beginIndex gr\u00f6\u00dfer gleich endIndex , wird ein MyString -Objekt mit leerem wort -Array zur\u00fcckgegeben. Schreiben Sie eine Objektmethode toUpperCase() , die ein (neues) MyString -Objekt zur\u00fcckgibt. Alle Kleinbuchstaben aus dem aufrufenden Objekt sind im neuen Objekt Gro\u00dfbuchstaben. Tipps: Bei der Umwandlung m\u00fcssen Sie sich nur um die Kleinbuchstaben k\u00fcmmern, alle anderen Zeichen werden direkt \u00fcbernommen. Kleinbuchstaben haben die Ascii-Codes 97 ( a ) \u2013 122 ( z ) Gro\u00dfbuchstaben haben die Ascii-Codes 65 ( A ) \u2013 90 (`Z) Schreiben Sie eine Objektmethode reverse() , die ein (neues) MyString -Objekt zur\u00fcckgibt. In diesem neuen Objekt ist die Zeichenfolge im wort -Array genau umgekehrt wie im aufrufenden Objekt. Schreiben Sie die Objektmethode contains(MyString s) . Diese Methode gibt ein true zur\u00fcck, wenn das wort -Array von s im wort -Array des aufrufenden Objektes vorkommt. Ansonsten false . weiter mit Testklasse : Testen Sie Sie alle 4 Methoden substring(int beginIndex, int endIndex) , toUpperCase() , reverse() und contains(MyString s) : -------------------- Teil 3 ---------------------------- s3 : hallocballo s3 substring ( 3 ,7 ) : locb s3 toUpperCase () : HALLOCBALLO s3 reverse () : ollabcollah s4 : locba s4 in s3 ? : true eine m\u00f6gliche L\u00f6sung f\u00fcr MyString MyString.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 package klausurvorbereitung.mystring ; public class MyString { private char [] wort ; public MyString () { this . wort = new char [ 0 ] ; } public MyString ( char letter ) { this . wort = new char [ 1 ] ; this . wort [ 0 ] = letter ; } public MyString ( String wort ) { this . wort = new char [ wort . length () ] ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { this . wort [ index ] = wort . charAt ( index ); } } @Override public String toString () { String s = \"\" ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { s += this . wort [ index ] ; } return s ; } public void print () { System . out . println ( this . toString ()); } public int getLength () { return this . wort . length ; } public char getCharAt ( int index ) { if ( index < 0 || index > this . wort . length ) { return ' ' ; } else { return this . wort [ index ] ; } } public boolean contains ( char c ) { for ( int index = 0 ; index < this . wort . length ; index ++ ) { if ( this . wort [ index ]== c ) return true ; } return false ; } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; MyString so = ( MyString ) o ; if ( this . getLength () != so . getLength ()) return false ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { if ( this . wort [ index ] != so . wort [ index ] ) return false ; } return true ; } public int getAsciiCodeOfCharAt ( int index ) { if ( index < 0 || index > this . wort . length ) { return - 1 ; } else { return ( int ) this . wort [ index ] ; } } public void append ( char c ) { char [] newWord = new char [ this . getLength () + 1 ] ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { newWord [ index ] = this . getCharAt ( index ); } newWord [ this . getLength () ] = c ; this . wort = newWord ; } public void append ( MyString s ) { for ( int index = 0 ; index < s . getLength (); index ++ ) { this . append ( s . getCharAt ( index )); } } public MyString concat ( MyString s1 , MyString s2 ) { MyString s = new MyString (); s . append ( s1 ); s . append ( s2 ); return s ; } public int firstIndexOf ( char c ) { final int NOT_FOUND = - 1 ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { if ( this . wort [ index ] == c ) return index ; } return NOT_FOUND ; } public int lastIndexOf ( char c ) { final int NOT_FOUND = - 1 ; for ( int index = this . wort . length - 1 ; index >= 0 ; index -- ) { if ( this . wort [ index ] == c ) return index ; } return NOT_FOUND ; } public MyString substring ( int beginIndex ) { if ( beginIndex < 0 || beginIndex >= this . getLength ()) { return new MyString (); } else { MyString s = new MyString ( this . getCharAt ( beginIndex )); for ( int index = beginIndex + 1 ; index < this . getLength (); index ++ ) { s . append ( this . getCharAt ( index )); } return s ; } } public MyString substring ( int beginIndex , int endIndex ) { if ( beginIndex < 0 || beginIndex >= this . getLength ()) { return new MyString (); } else { MyString s = new MyString ( this . getCharAt ( beginIndex )); for ( int index = beginIndex + 1 ; ( index < this . getLength () && index < endIndex ); index ++ ) { s . append ( this . getCharAt ( index )); } return s ; } } public MyString toUpperCase () { final int FROM_LOWER_TO_UPPER = 32 ; MyString s = new MyString (); for ( int index = 0 ; index < this . getLength (); index ++ ) { char c = this . getCharAt ( index ); int ascii = ( int ) c ; if ( ascii >= 97 && ascii <= 122 ) { ascii = ascii - FROM_LOWER_TO_UPPER ; c = ( char ) ascii ; } s . append ( c ); } return s ; } public MyString reverse () { MyString s = new MyString (); for ( int index = this . wort . length - 1 ; index >= 0 ; index -- ) { s . append ( this . getCharAt ( index )); } return s ; } public boolean contains ( MyString s ) { if ( this . getLength () < s . getLength ()) return false ; if ( this . equals ( s )) return true ; boolean noMatch = true ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { if ( this . wort [ index ]== s . getCharAt ( 0 )) { for ( int i = 1 ; i < s . getLength () && noMatch ; i ++ ) { if ( index + i >= this . getLength () || this . wort [ index + i ] != s . wort [ i ] ) { noMatch = false ; } } return true ; } noMatch = true ; } return false ; } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package klausurvorbereitung.mystring ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n------------------ Teil 1 a) --------------------------%n%n\" ); MyString s1 = new MyString (); s1 . print (); MyString s2 = new MyString ( 'a' ); s2 . print (); MyString s3 = new MyString ( \"hallo\" ); s3 . print (); System . out . printf ( \"%n%n------------------ Teil 1 b) --------------------------%n%n\" ); char c1 = s3 . getCharAt ( 1 ); System . out . println ( c1 ); System . out . println ( \"a in hallo ? \" + s3 . contains ( 'a' )); System . out . println ( \"b in hallo ? \" + s3 . contains ( 'b' )); System . out . printf ( \"%n%n------------------ Teil 1 c) --------------------------%n%n\" ); MyString s4 = new MyString ( \"hallo\" ); s4 . print (); MyString s5 = new MyString ( \"halLo\" ); s5 . print (); System . out . println ( \"s3 gleich s4 ? \" + s3 . equals ( s4 )); System . out . println ( \"s3 gleich s4 ? \" + s3 . equals ( s5 )); System . out . printf ( \"%n%n-------------------- Teil 2 ----------------------------%n%n\" ); int i1 = s3 . getAsciiCodeOfCharAt ( 1 ); System . out . println ( \"Ascii-Code Zeichen aus s3 mit Index 1 = \" + i1 ); s3 . append ( 'c' ); s3 . print (); MyString s6 = new MyString ( \"ballo\" ); s3 . append ( s6 ); s3 . print (); MyString s7 = new MyString (); s7 = s7 . concat ( s4 , s6 ); s7 . print (); int i2 = s3 . firstIndexOf ( 'l' ); System . out . println ( \"erstes l in s3 am Index \" + i2 ); i2 = s3 . lastIndexOf ( 'l' ); System . out . println ( \"letztes l in s3 am Index \" + i2 ); MyString s8 = s3 . substring ( 5 ); s8 . print (); System . out . printf ( \"%n%n-------------------- Teil 3 ----------------------------%n%n\" ); System . out . print ( \"s3 : \" ); s3 . print (); MyString s9 = s3 . substring ( 3 , 7 ); System . out . print ( \"s3 substring(3,7) : \" ); s9 . print (); s9 = s3 . toUpperCase (); System . out . print ( \"s3 toUpperCase() : \" ); s9 . print (); s9 = s3 . reverse (); System . out . print ( \"s3 reverse() : \" ); s9 . print (); s4 = new MyString ( \"locba\" ); System . out . print ( \"s4 : \" ); s4 . print (); System . out . println ( \"s4 in s3 ? : \" + s3 . contains ( s4 )); } } Ausdr\u00fccke \u00b6 gleich 12 Welche der folgenden Ausdr\u00fccke haben den Wert 12? a ) 12 % 13 b ) 24 % 2 c ) 24 /2 d ) 25 /2 Versuchen Sie zun\u00e4chst, die richtige Antwort im Kopf zu ermitteln und erstellen dann ein geeignetes Programm, das Ihnen den jeweiligen Wert des Ausdrucks ausgibt. Pre- und Postoperator Welchen Wert hat die Variable c nach Ausf\u00fchren der Anweisungen? int a = 300 ; int b = a++ ; int c = --b ; Begr\u00fcnden Sie die richtige Antwort! Was passiert durch die Anweisungen? Schleifen \u00b6 Laufvariablen Welche der Schleifen gibt alle Elemente des Arrays nums aus? Das Array enth\u00e4lt genau 4 Zahlen. a ) for ( int i = 0 ; i < nums.length ; i++ ) { System.out.println ( nums [ i ]) ; } b ) for ( int i = 0 ; i < = 3 ; i++ ) { System.out.println ( nums [ i ]) ; } c ) for ( int i = 1 ; i < = 3 ; i++ ) { System.out.println ( nums [ i ]) ; } d ) for ( int i = 0 ; i < = 3 ; i++ ) { System.out.println ( nums [ 0 ]) ; } e ) for ( int i = nums.length - 1 ; i > = 0 ; i-- ) { System.out.println ( nums [ i ]) ; } Quadratzahl Schreiben Sie eine Methode istQuadratzahl(int zahl) , die ein true zur\u00fcckgibt, wenn zahl eine Quadratzahl ist und ein false sonst. Die Math -Klasse soll nicht verwendet werden. Primzahl Schreiben Sie eine Methode printPrimzahlenBisN(int n) , die alle Primzahlen bis n auf die Konsole ausgibt. Schreiben Sie sich dazu eine Hilfsmethode istPrimzahl(int zahl) , die ein true zur\u00fcckgibt, wenn zahl eine Primzahl ist und ein false , wenn nicht. int-Zahl umdrehen Schreiben Sie eine Methode int reverseInt(int number) , die die \u00fcbergebene number umdreht und die umgedrehte int -Zahl zur\u00fcckgibt, also z.B. aus 1234 wird 4321 . Weitere Beispiele: aus -123 wird -321 und aus 1200 wird 21 . Zahlen raten Schreiben Sie folgendes Programm. Mithilfe von Random \"denkt\" sich das Programm eine Zahl zwischen 0 und 100 aus. Sie k\u00f6nnen \u00fcber die Konsole dann eine Zahl eingeben. Das Programm sagt Ihnen, ob die \"gedachte\" Zahl gr\u00f6\u00dfer oder kleiner als die von Ihnen eingegebene Zahl ist. Sie geben solange eine Zahl ein, bis Sie die \"gedachte\" Zahl erraten haben. Bin\u00e4rzahl Schreiben Sie eine Methode, die eine short -Zahl in eine Bin\u00e4rzahl umwandelt. Diese Bin\u00e4rzahl speichern Sie als long . Z.B. ist 32 bin\u00e4r 100000 , 63 ist 111111 , 48 ist 110000 usw. Arrays \u00b6 Sotierte Arrays zusammenf\u00fcgen Implementieren Sie eine Methode, die zwei als Parameter \u00fcbergebene sortierte int -Arrays zu einem sortierten int -Array zusammenf\u00fcgt. Geben Sie das neue sortierte Array zur\u00fcck. Unsortierte Arrays sortiert zusammenf\u00fcgen Implementieren Sie eine Methode, die zwei als Parameter \u00fcbergebene unsortierte int -Arrays zu einem sortierten int -Array zusammenf\u00fcgt. Geben Sie das neue sortierte Array zur\u00fcck. Explode Implementieren Sie eine Methode int[] explode(int number) . Diese Methode erstellt ein int[] -Array, das wie folgt bef\u00fcllt ist: Bsp. number=5 \u2192 {1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5} . F\u00fcr jede Zahl x gibt es also x Eintr\u00e4ge im Array bis einschlie\u00dflich number .","title":"\u00dcbungen"},{"location":"uebungen/#ubungen","text":"","title":"\u00dcbungen"},{"location":"uebungen/#ubungsblatter-wochenweise","text":"\u00dcbung 1 (20.10.2021) Vorbereitung Installieren Sie - falls noch nicht geschehen - das Java Davelopment Kit (JDK) (siehe Java ). Installieren Sie BlueJ (siehe IDE ). Starten Sie BlueJ und \u00f6ffnen Sie ( Project --> Open Project... ) das Projekt picture (im BlueJ-Ordner unter examples ). Klicken Sie dann den Compile -Button. Klicken Sie mit der rechten Maustaste auf die Klasse Picture (das orangene K\u00e4stchen mit der Beschriftung Picture ) und erzeugen Sie davon ein Objekt picture1 . Klicken Sie mit der rechten Maustaste auf das Objekt picture1 und rufen Sie die Methode draw() auf. Klicken Sie erneut mit der rechten Maustaste auf die Klasse Picture und \u00f6ffnen Sie den Editor mit Open Editor . Es erscheint das Java-Programm (der Quellcode ) der Klasse Picture : Picture.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /** * This class represents a simple picture. You can draw the picture using * the draw method. But wait, there's more: being an electronic picture, it * can be changed. You can set it to black-and-white display and back to * colors (only after it's been drawn, of course). * * This class was written as an early example for teaching Java with BlueJ. * * @author Michael K\u00f6lling and David J. Barnes * @version 1.1 (24 May 2001) */ public class Picture { private Square wall ; private Square window ; private Triangle roof ; private Circle sun ; /** * Constructor for objects of class Picture */ public Picture () { // nothing to do... instance variables are automatically set to null } /** * Draw this picture. */ public void draw () { wall = new Square (); wall . moveVertical ( 80 ); wall . changeSize ( 100 ); wall . makeVisible (); window = new Square (); window . changeColor ( \"black\" ); window . moveHorizontal ( 20 ); window . moveVertical ( 100 ); window . makeVisible (); roof = new Triangle (); roof . changeSize ( 50 , 140 ); roof . moveHorizontal ( 60 ); roof . moveVertical ( 70 ); roof . makeVisible (); sun = new Circle (); sun . changeColor ( \"yellow\" ); sun . moveHorizontal ( 180 ); sun . moveVertical ( - 10 ); sun . changeSize ( 60 ); sun . makeVisible (); } /** * Change this picture to black/white display */ public void setBlackAndWhite () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"black\" ); window . changeColor ( \"white\" ); roof . changeColor ( \"black\" ); sun . changeColor ( \"black\" ); } } /** * Change this picture to use color display */ public void setColor () { if ( wall != null ) // only if it's painted already... { wall . changeColor ( \"red\" ); window . changeColor ( \"black\" ); roof . changeColor ( \"green\" ); sun . changeColor ( \"yellow\" ); } } } Wir schauen uns diese Klasse ein wenig genauer an und diskutieren einige Details (Objektvariablen, Objektmethoden, Kommentare, ...). Durchf\u00fchrung F\u00fcr diese \u00dcbung interessiert uns nur die Methode draw() . Die Methodenaufrufe, die wir bis jetzt immer einzeln vorgenommen haben, werden nun \"aufgeschrieben\" - wir programmieren ! \u00c4ndern Sie Farben und Positionen der einzelnen Objekte! Wenn Sie Ihre \u00c4nderungen ausprobieren wollen, m\u00fcssen Sie die Klasse neu compilieren . Durch das Compilieren gehen die erzeugten Objekte verloren. Warum ist das wohl so? Lassen Sie die Sonne langsam untergehen. Welche Objektmethode kommt daf\u00fcr infrage? F\u00fcr welches Objekt muss diese Objektmethode aufgerufen werden? Tipp: Derzeit ist es recht m\u00fchsam, die \u00c4nderungen zu testen. Wir m\u00fcssen die Klasse Picture compilieren, dann ein Objekt dieser Klasse erzeugen und dann f\u00fcr dieses Objekt die Methode draw() aufrufen. Wir wollen diesen Vorgang etwas vereinfachen und erstellen uns dazu eine Testklasse . Klicken Sie mit der rechten Maustaste auf die Klasse Picture und w\u00e4hlen Sie Create Test Class aus. Klicken Sie mit der rechten Maustaste auf diese neue Testklasse PictureTest und w\u00e4hlen Sie Create Test Method ... aus. Geben Sie als Namen f\u00fcr diese Testmethode drawTest an und best\u00e4tigen Sie die Eingabe mit OK . Nun wird ein Test \"aufgenommen\". Klicken Sie mit der rechten Maustaste auf die Klasse Picture und erzeugen Sie von dieser Klasse eine Objekt picture1 . F\u00fcr dieses Objekt rufen Sie die draw() -Methode auf. Klicken Sie dann im Hauptfenster auf der linken Seite unter recording den Button End . Sie haben nun einen Test erzeugt, den Sie leicht aufrufen k\u00f6nnen. \u00c4ndern Sie Ihre draw() -Methode, compilieren Sie die Klasse Picture und w\u00e4hlen Sie nun mit der rechten Maustaste f\u00fcr die Klasse PictureTest die Methode drawTest() aus und rufen diese auf. \u00dcbung 2 (27.10.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung2 . Erstellen Sie darin eine Klasse Uebung2 . Ersetzen Sie den gesamten Code der Klasse Uebung2 durch folgenden Code: public class Uebung2 { public Uebung2 () { } public void printLesson2 () { // Schreiben Sie Ihren gesamten Code in diese Methode // und fuehren Sie diese Methode aus } } Deklarieren und initialisieren Sie in der printLesson2() -Methode jeweils eine Variable mit dem Datentyp int , long , char , byte , short , float , double , boolean und String . Geben Sie alle Werte einzeln durch Aufruf der println() -Methode aus. Erzeugen Sie dabei folgende Ausgabe (Werte nur Beispiele): Wert vom Typ int : 123 Wert vom Typ long : 456789 Wert vom Typ char : a Wert vom Typ byte : 127 Wert vom Typ short : 32767 Wert vom Typ float : 4 .23 Wert vom Typ double : 6 .98 Wert vom Typ boolean : true Wert vom Typ String : Hallo! Setzen Sie den Wert Ihrer int -Variablen auf 2147483647 . Geben Sie den Wert auf der Konsole aus, z.B.: Wert von i : 2147483647 Erh\u00f6hen Sie nun den Wert der Variablen um 1 und geben Sie den Wert erneut aus. Was passiert? Warum? Wiederholen Sie das gleiche mit einer `long-Variablen. Weisen Sie Ihrer char -Variablen den Wert 65 zu. Geben Sie den Wert Ihrer char -Variablen aus. Was passiert? Warum? Deklarieren Sie zwei weitere int -Variablen und weisen Sie diesen Variablen Werte zu. Erzeugen Sie unter Verwendung der Werte dieser beiden Variablen folgende Ausgabe (wir nehmen an, die beiden Werte sind 17 und 4 ): 17 geteilt durch 4 ergibt 4 . Es bleibt ein Rest von 1 \u00c4ndern Sie das Programm so, dass bei einer ganzzahligen Division ohne Rest die Ausgabe in der Form ist (z.B. f\u00fcr die Werte 16 und 4 ): 16 geteilt durch 4 ergibt 4 ohne Rest. F\u00fcgen Sie (mindestens) zwei weitere Anweisungen hinzu, sodass mit Hilfe der println() -Methode folgende Ausgaben (f\u00fcr die Beispielwerte 17 und 4 ) erscheinen: 17 /4 = 4 17 mod 4 = 1 Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2 public class Uebung2 { public Uebung2 () { } public void printLesson2 () { // Schreiben Sie Ihren gesamten Code in diese Methode // und fuehren Sie diese Methode aus int in = 123 ; long lo = 456789 ; char ch = 'a' ; byte by = 127 ; short sh = 32767 ; float fl = 4.23f ; double d1 = 6.98 ; boolean b1 = true ; String s1 = \"Hallo!\" ; System . out . println ( \" --- Aufgabe 3 -------\" ); System . out . println (); System . out . println ( \"Wert vom Typ int : \" + in ); System . out . println ( \"Wert vom Typ long : \" + lo ); System . out . println ( \"Wert vom Typ char : \" + ch ); System . out . println ( \"Wert vom Typ byte : \" + by ); System . out . println ( \"Wert vom Typ short : \" + sh ); System . out . println ( \"Wert vom Typ float : \" + fl ); System . out . println ( \"Wert vom Typ double : \" + d1 ); System . out . println ( \"Wert vom Typ boolean : \" + b1 ); System . out . println ( \"Wert vom Typ String : \" + s1 ); System . out . println (); System . out . println ( \" --- Aufgabe 4 -------\" ); System . out . println (); in = 2147483647 ; System . out . println ( \"Wert vom Typ int : \" + in ); in = in + 1 ; // in++; System . out . println ( \"Wert vom Typ int : \" + in ); System . out . println (); System . out . println ( \" --- Aufgabe 5 -------\" ); System . out . println (); lo = 2147483647L ; System . out . println ( \"Wert vom Typ long : \" + lo ); lo = lo + 1 ; System . out . println ( \"Wert vom Typ long : \" + lo ); System . out . println (); System . out . println ( \" --- Aufgabe 6 -------\" ); System . out . println (); ch = 65 ; System . out . println ( \"Wert vom Typ char : \" + ch ); System . out . println (); System . out . println ( \" --- Aufgabe 7 -------\" ); System . out . println (); int nr1 = 17 ; int nr2 = 4 ; int quotient = nr1 / nr2 ; int rest = nr1 % nr2 ; if ( rest == 0 ) { System . out . println ( nr1 + \" geteilt durch \" + nr2 + \" ergibt \" + quotient + \" ohne Rest.\" ); } else { System . out . println ( nr1 + \" geteilt durch \" + nr2 + \" ergibt \" + quotient + \". Es bleibt ein Rest von \" + rest ); } System . out . println (); System . out . println ( \" --- Aufgabe 8 -------\" ); System . out . println (); int number1 = 17 ; int number2 = 4 ; int result = number1 / number2 ; System . out . println ( number1 + \"/\" + number2 + \" = \" + result ); int rest = number1 % number2 ; System . out . println ( number1 + \" mod \" + number2 + \" = \" + rest ); } } \u00dcbung 3 (3.11.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung3 . Erstellen Sie darin eine Klasse Uebung3 . Ersetzen Sie den gesamten Code der Klasse Uebung3 durch folgenden Code: public class Uebung3 { public Uebung3 () { } public void myLesson3Method () { // Definieren Sie alle Ihre Methoden au\u00dferhalb dieser Methode // Rufen Sie alle Ihre Methoden hier auf } } Schreiben Sie eine Umrechnung f\u00fcr eine gegebene Anzahl von Sekunden ( printSeconds(int seconds) ), z.B. printSeconds(3456789) : 3456789 Sekunden sind 40 Tage, 13 Minuten, 9 Sekunden. Aber z.B. printSeconds(2345678) : 2345678 Sekunden sind 27 Tage, 3 Stunden, 34 Minuten, 38 Sekunden. Aber z.B. printSeconds(123456) : 123456 Sekunden sind 1 Tag, 10 Stunden, 17 Minuten, 36 Sekunden. Aber z.B. printSeconds(12345) : 12345 Sekunden sind 3 Stunden, 25 Minuten, 45 Sekunden. Die printSeconds() -Methode gibt selbst etwas aus. Welchen R\u00fcckgabetyp hat sie? Schreiben Sie eine weitere Methode computeSeconds(int seconds) , die genau die gleiche Funktionalit\u00e4t hat, aber den Ausgabestring nicht auf die Konsole ausgibt, sondern zur\u00fcck. Wie k\u00f6nnten (und sollten!) Sie die computeSeconds() -Methode in der printSeconds() -Methode verwenden? Warum? Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 3 public class Uebung3 { public Uebung3 () { } public void printSeconds ( int seconds ) { int minute = 60 ; int hour = 60 * minute ; // 3600 int day = 24 * hour ; // 86400 int days = seconds / day ; int remainingSeconds = seconds - ( days * day ); int hours = remainingSeconds / hour ; remainingSeconds = remainingSeconds - ( hours * hour ); int minutes = remainingSeconds / minute ; remainingSeconds = remainingSeconds - ( minutes * minute ); /* System.out.println(seconds + \" Sekunden sind \" + days + \" Tage, \" + hours + \" Stunden, \" + minutes + \" Minuten, \" + remainingSeconds + \" Sekunden.\"); */ String output = seconds + \" Sekunden sind \" ; if ( days == 1 ) { output = output + \" 1 Tag, \" ; } else { if ( days > 1 ) { output = output + days + \" Tage, \" ; } } if ( hours == 1 ) { output = output + \" 1 Stunde, \" ; } else { if ( hours > 1 ) { output = output + hours + \" Stunden, \" ; } } if ( minutes == 1 ) { output = output + \" 1 Minute, \" ; } else { if ( minutes > 1 ) { output = output + minutes + \" Minuten, \" ; } } if ( remainingSeconds == 1 ) { output = output + \" 1 Sekunde.\" ; } else { if ( remainingSeconds > 1 ) { output = output + remainingSeconds + \" Sekunden.\" ; } } System . out . println ( output ); } public void myLesson3Method () { printSeconds ( 3456789 ); printSeconds ( 2345678 ); printSeconds ( 123456 ); printSeconds ( 12345 ); } } \u00dcbung 4 (10.11.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung4 . Erstellen Sie darin eine Klasse Uebung4 . Ersetzen Sie den gesamten Code der Klasse Uebung4 durch folgenden Code: public class Uebung4 { public Uebung4 () { } public void myLesson4Method () { // Definieren Sie alle Ihre Methoden au\u00dferhalb dieser Methode // Rufen Sie alle Ihre Methoden hier auf } } Schreiben Sie eine Methode isPrime(int number) , die ein true zur\u00fcckgibt, wenn number eine Primzahl ist und ein false , wenn nicht. Eine Primzahl ist eine nat\u00fcrliche Zahl gr\u00f6\u00dfer als 1 , die nur durch 1 und sich selbst teilbar ist. Schreiben Sie eine Methode printprimeNumbers(int maximum) , die alle Primzahlen von 1 bis einschlie\u00dflich maximum wie folgt auf der Konsole ausgibt (Bsp. f\u00fcr maximum=61 ): Zahl : 61 .2 3 .5 .7 ...11 .13 ...17 .19 ...23 .....29 .31 .....37 ...41 .43 ...47 .....53 .....59 .61 d.h. es werden die Zahlen, die Primzahlen sind, ausgegeben und f\u00fcr die anderen Zahlen erscheint nur ein Punkt. Verwenden Sie in der Methode printPrimenumbers(int) die Methode isPrime(int) . Zusatzaufgabe (gute Wiederholung/Vertiefung von \u00dcbung 3) Schreiben Sie eine Methode isLeapYear(int year) , die ein true zur\u00fcckgibt, wenn year ein Schaltjahr ist und ein false , wenn nicht. Ein Jahr ist ein Schaltjahr, wenn die Jahreszahl durch 4 teilbar ist, aber nicht durch 100 , au\u00dfer sie ist durch 400 teilbar. Schreiben Sie eine Methode printleapYear(int year) , die f\u00fcr year auf die Konsole ausgibt (Beispielwerte): 2021 ist kein Schaltjahr. 2020 war ein Schaltjahr. 2000 war ein Schaltjahr. 2024 wird ein Schaltjahr. 2025 wird kein Schaltjahr. Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 4 public class Uebung4 { public Uebung4 () { } public boolean isPrime ( int number ) { if ( number > 1 ) { for ( int i = 2 ; i < number ; i ++ ) { if ( number % i == 0 ) //ob i number ganzzahlig teilt (Division ohne Rest) { return false ; } } return true ; } else { return false ; } } public void myLesson4Method () { //System.out.println(isPrime(1)); printPrimeNumbers ( 61 ); } public void printPrimeNumbers ( int maximum ) { for ( int i = 2 ; i <= maximum ; i ++ ) { if ( isPrime ( i )) { System . out . print ( i + \" \" ); } else { System . out . print ( \". \" ); } } } } \u00dcbung 5 (17.11.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung5 . Erstellen Sie darin eine Klasse Uebung5 . Ersetzen Sie den gesamten Code der Klasse Uebung5 durch folgenden Code: public class Uebung5 { public Uebung5 () { } public void start () { // Definieren Sie alle Ihre Methoden au\u00dferhalb dieser Methode // Rufen Sie alle Ihre Methoden hier auf } } Wir schreiben uns zwei Methoden, die mathematische Funktionen umsetzen. Die eine Funktion berechnet die Potenz base^exp und die andere Funktion bereechnet die Quadratwurzel einer Zahl. Ziel der \u00dcbung ist es insbesondere, uns vorab die algorithmische Idee zu \u00fcberlegen. Programmieren Sie also nicht gleich los, sondern \u00fcberlegen Sie gemeinsam, wie Sie die beiden Funktionen umsetzen wollen! Schreiben Sie eine Methode public double pow(int base, int exp) . Dabei steht pow f\u00fcr power . Es soll base^exp berechnet werden. \u00dcberlegen Sie sich zun\u00e4chst z.B.: Wenn exp positiv ist, dann wollen wir base * base * ... * base berechnen, wobei base exp oft miteinander multipliziert wird. Welche Kontrollstruktur verwenden wir? Was sind die einzelnen \"Teile\" dieser Kontrollstruktur? Wir m\u00fcssen uns irgendwie das product dieser Multiplikationen merken. Wie ist der initiale Wert von product und warum? Funktioniert Ihre Idee auch, wenn exp den Wert 0 hat? Warum bzw. warum nicht? Wenn exp negativ ist, dann ist base^-exp = 1/(base^exp) . Was m\u00fcssen wir \u00e4ndern? Warum ist der R\u00fcckgabetyp double ? Warum nicht int ? Implementieren Sie eine Methode public void printPow(int base, int exp) , um Werte der Methodenaufrufe von pow() auf die Konsole auszugeben! Rufen Sie printPow(int base, int exp) in start() auf! Zusatzaufgabe (falls noch Zeit ist) Schreiben Sie eine Methode public double sqrt(int number) , die die Quadratwurzel der Zahl number berechnet. Wir verfolgen dabei folgende Idee ( Heron-Verfahren ): Wir stellen uns ein Rechteck vor, dessen Seitenl\u00e4ngen number und 1 sind. Die Fl\u00e4che dieses Rechtecks ist also number . Nun versuchen wir, aus diesem Rechteck ein Quadrat zu machen (rein virtuell nat\u00fcrlich). Der Fl\u00e4cheninhalt von diesem Quadrat soll number sein/bleiben. Ein Quadrat mit dem Fl\u00e4cheninhalt numbeer hat die Seitenl\u00e4ngen sqrt(number) , also das, was wir wollen. Um aus dem Rechteck ein Quadrat zu machen, gehen wir schrittweise vor: die eine Seite des Rechteckes/Quadrates wird der Mittelwert aus den Seiten des Rechtecks. Nun berechnen wir die andere Seite indem wir den Fl\u00e4cheninhalt des Rechtecks ( number ) durch die neue Seitenl\u00e4nge teilen. Somit haben wir 2 neue Seitenl\u00e4ngen, das Rechteck beh\u00e4lt aber den Fl\u00e4cheninhalt number . Wir berechnen erneut die neue Seitenl\u00e4nge des Rechtecks, indem wir den Mittelwert der beiden Seitenl\u00e4ngen berechnen und ermitteln dann wieder die andere Seitenl\u00e4nge, indem wir den Fl\u00e4cheninhalt durch die Seitenl\u00e4nge teilen. Die beiden Seitenl\u00e4ngen n\u00e4hern sich dann zunehmend an und sind irgendwann fast identisch, also ein Quadrat. Wie lange m\u00fcssen wir das wiederholen? Was ist am Ende unser Ergebnis? Von welchem Datentyp sollten die Seitenl\u00e4ngen sein? \u00dcberlegen Sie sich das Vorgehen genau, ehe Sie programmieren! Beispiel zur Berechnung der Wurzel aus 8: Implementieren Sie eine Methode public void printSqrt(int number) , um Werte der Methodenaufrufe von sqrt() auf die Konsole auszugeben! Rufen Sie printSqrt(int number) in start() auf! Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 5 public class Uebung5 { public double pow ( int base , int exp ) { double product = 1.0 ; if ( exp < 0 ) { for ( int nr = 1 ; nr <= - exp ; nr ++ ) // -exp ! { product = product * base ; } product = 1.0 / product ; } else { for ( int nr = 1 ; nr <= exp ; nr ++ ) { product = product * base ; } } return product ; } public double powDifferentSolution ( int base , int exp ) { double product = 1.0 ; int copyExp = exp ; if ( exp < 0 ) { copyExp = - exp ; } for ( int nr = 1 ; nr <= copyExp ; nr ++ ) { product = product * base ; } if ( exp < 0 ) { product = 1.0 / product ; } return product ; } public double sqrt ( int number ) { double area = number ; double a = number ; double b = 1.0 ; double epsilon = 0.00000001 ; while ( ( a - b ) * ( a - b ) > epsilon ) { a = ( a + b ) / 2.0 ; b = area / a ; } return a ; } public void start () { int base = 2 ; int exp = 4 ; double result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = 2 ; exp = 0 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = 2 ; exp = - 4 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = - 2 ; exp = 4 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = - 2 ; exp = - 4 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = - 2 ; exp = 3 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); base = - 2 ; exp = - 3 ; result = pow ( base , exp ); System . out . println ( base + \"^\" + exp + \" = \" + result ); System . out . println ( sqrt ( 4 )); System . out . println ( sqrt ( 8 )); System . out . println ( sqrt ( 2 )); } } \u00dcbung 6 (24.11.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung6 . Erstellen Sie darin eine Klasse Konto . Erstellen Sie eine Testklasse KontoTest und f\u00fcgen Sie darin folgende Methode ein: @Test public void testKonto () { // hier die Kontoobjekte erzeugen // und die Objektmethoden anwenden } Erstellen Sie in der Klasse Konto zwei Objektvariablen guthaben vom Typ double \u2192 nur in der Klasse sichtbar! pin vom Typ int \u2192 ebenfalls nur in der Klasse sichtbar! Erstellen Sie in der Klasse Konto einen Konstruktor f\u00fcr Konto diesem Konstruktor wird als Parameter int pPin \u00fcbergeben mit dem Wert des Parameters wird innerhalb des Konstruktors der Wert von pin initialisiert Initialisieren Sie im Konstruktor auch die Objektvariable guthaben . Sie bekommt den Wert 0.0 (hierf\u00fcr haben wir also keinen Parameter, wir setzen den initialen Wert einfach generell auf 0.0 ) Erstellen Sie in der Klasse Konto eine Objektmethode einzahlen(double betrag) diese Objektmethode ist public und gibt nichts zur\u00fcck in dieser Methode wird der Wert der Objektvariablen guthaben um den Wert von betrag erh\u00f6ht erzeugen Sie in dieser Methode au\u00dferdem eine Ausgabe in der Form: Es wurden 100 ,00 Euro eingezahlt. falls der betrag den Wert 100.0 hatte. Die Formatierung des Betrages wird bei Ihnen anders aussehen - siehe dazu auch Zusatzaufgabe . Geben Sie in der testKonto() -Methode der Testklasse KontoTest ein: Konto k1 = new Konto ( 1234 ); k1 . einzahlen ( 100.0 ); k1 . einzahlen ( 50.0 ); k1 . einzahlen ( 150.0 ); und f\u00fchren Sie die testKonto() -Methode aus. Es sollten folgende Ausgaben erzeugt werden: Es wurden 100 ,00 Euro eingezahlt. Es wurden 50 ,00 Euro eingezahlt. Es wurden 150 ,00 Euro eingezahlt. Erstellen Sie in der Klasse Konto eine Objektmethode kontoauszug(int pPin) diese Objektmethode ist public und gibt nichts zur\u00fcck einen kontoauszug(int pPin) k\u00f6nnen Sie nur \"ziehen\", wenn der Parameterwert von pPin mit dem Wert der Objektvariablen pin \u00fcbereinstimmt wird der richtige Wert f\u00fcr die pin \u00fcbergeben, geben Sie das guthaben in der folgenden Form aus: Ihr aktuelles Guthaben betraegt 300 ,00 Euro. falls guthaben den Wert von 300.0 hat. wird ein falscher Wert f\u00fcr die pin \u00fcbergeben, geben Sie folgende Ausgabe aus: Falsche PIN! Erweitern Sie die testKonto() -Methode der Testklasse um folgende Anweisungen: k1 . kontoauszug ( 1235 ); // Falsche PIN! k1 . kontoauszug ( 1234 ); und f\u00fchren Sie die testKonto() -Methode aus. Es sollten folgende (weitere) Ausgaben erzeugt werden: Falsche PIN! Ihr aktuelles Guthaben betraegt 300 ,00 Euro. Erstellen Sie in der Klasse Konto eine Objektmethode auszahlen(int pPin, double betrag) diese Objektmethode ist public und gibt nichts zur\u00fcck es kann nur etwas ausgezahlt werden, wenn der Parameterwert von pPin mit dem Wert der Objektvariablen pin \u00fcbereinstimmt stimmen die Werte nicht \u00fcberein, geben Sie erneut Falsche PIN! aus. stimmt der pin -Wert, dann m\u00fcssen Sie pr\u00fcfen, ob das guthaben reicht, um betrag auszuzahlen. Ist nicht genug guthaben vorhanden, dann geben Sie aus Ihr Guthaben reicht nicht, um 400 ,00 Euro auszuzahlen. falls betrag den Wert 400.0 hatte. wenn der pin -Wert stimmt und genug guthaben vorhanden ist, um den betrag auszuzahlen, dann reduzieren Sie guthaben um den entsprechenden betrag und geben aus Es wurden 100 ,00 Euro ausgezahlt. falls der betrag den Wert 100.0 hatte. Erweitern Sie die testKonto() -Methode der Testklasse um folgende Anweisungen: k1 . auszahlen ( 1235 , 100.0 ); // Falsche PIN! k1 . auszahlen ( 1234 , 100.0 ); k1 . kontoauszug ( 1234 ); k1 . auszahlen ( 1234 , 300.0 ); // Guthaben reicht nicht k1 . auszahlen ( 1234 , 200.0 ); k1 . kontoauszug ( 1234 ); und f\u00fchren Sie die testKonto() -Methode aus. Es sollten folgende (weitere) Ausgaben erzeugt werden: Falsche PIN! Es wurden 100 ,00 Euro ausgezahlt. Ihr aktuelles Guthaben betraegt 200 ,00 Euro. Ihr Guthaben reicht nicht, um 300 ,00 Euro auszuzahlen. Es wurden 200 ,00 Euro ausgezahlt. Ihr aktuelles Guthaben betraegt 0 ,00 Euro. Angenommen, die gesamte Testmethode sieht jetzt so aus: @Test public void testKonto () { Konto k1 = new Konto ( 1234 ); k1 . einzahlen ( 100.0 ); k1 . einzahlen ( 50.0 ); k1 . einzahlen ( 150.0 ); k1 . kontoauszug ( 1235 ); // Falsche PIN! k1 . kontoauszug ( 1234 ); k1 . auszahlen ( 1235 , 100.0 ); // Falsche PIN! k1 . auszahlen ( 1234 , 100.0 ); k1 . kontoauszug ( 1234 ); k1 . auszahlen ( 1234 , 300.0 ); k1 . auszahlen ( 1234 , 200.0 ); k1 . kontoauszug ( 1234 ); k1 . einzahlen ( 150.0 ); k1 . kontoauszug ( 1234 ); } dann sollte die Ausgabe ungef\u00e4hr so aussehen (wahrscheinlich nur eine Stelle nach dem Komma/Punkt): Es wurden 100 ,00 Euro eingezahlt. Es wurden 50 ,00 Euro eingezahlt. Es wurden 150 ,00 Euro eingezahlt. Falsche PIN! Ihr aktuelles Guthaben betraegt 300 ,00 Euro. Falsche PIN! Es wurden 100 ,00 Euro ausgezahlt. Ihr aktuelles Guthaben betraegt 200 ,00 Euro. Ihr Guthaben reicht nicht, um 300 ,00 Euro auszuzahlen. Es wurden 200 ,00 Euro ausgezahlt. Ihr aktuelles Guthaben betraegt 0 ,00 Euro. Zusatzaufgabe (falls noch Zeit ist): Informieren Sie sich \u00fcber die System.out.printf() -Methode, um stets genau 2 Stellen nach dem Komma des Betrages auszugeben (siehe hier ). Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 6 Konto.java public class Konto { private double guthaben ; private int pin ; public Konto ( int pin ) { this . pin = pin ; this . guthaben = 0.0 ; System . out . println ( \"Neues Konto eroeffnet\" ); // Ausnahme, dass hier Ausgabe!! // \"Das ist des Teufels\" } public void einzahlen ( double betrag ) { this . guthaben = betrag + this . guthaben ; System . out . println ( \"Es wurden \" + betrag + \"0 Euro eingezahlt.\" ); } public void auszahlen ( int pin , double betrag ) { if ( pin == this . pin ) // if(pin == this.pin && this.guthaben <= betrag) dann w\u00e4re es k\u00fcrzer, //aber wir k\u00f6nnen nicht sehen, wo der fehler liegt, deswegen besser einzeln...) { if ( betrag > this . guthaben ) { System . out . println ( \"Ihr Guthaben reicht nicht, um \" + betrag + \"0 Euro auszuzahlen.\" ); } else { this . guthaben = this . guthaben - betrag ; System . out . println ( \"Es wurden \" + betrag + \"0 Euro ausgezahlt.\" ); } } else { System . out . println ( \"Falsche PIN!\" ); } } public void kontoauszug ( int pin ) { if ( pin == this . pin ) { System . out . println ( \"Ihr aktuelles Guthaben betr\u00e4gt \" + this . guthaben + \"0 Euro.\" ); } else { System . out . println ( \"Falsche PIN!\" ); } } } KontoTest.java import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; public class KontoTest { @Test public void testKonto () { Konto k1 = new Konto ( 1234 ); k1 . einzahlen ( 100.0 ); k1 . einzahlen ( 50.0 ); k1 . einzahlen ( 150.0 ); k1 . kontoauszug ( 1235 ); // Falsche PIN! k1 . kontoauszug ( 1234 ); k1 . auszahlen ( 1235 , 100.0 ); // Falsche PIN! k1 . auszahlen ( 1234 , 100.0 ); k1 . kontoauszug ( 1234 ); k1 . auszahlen ( 1234 , 300.0 ); // Guthaben reicht nicht k1 . auszahlen ( 1234 , 200.0 ); k1 . kontoauszug ( 1234 ); k1 . einzahlen ( 150.0 ); k1 . kontoauszug ( 1234 ); // hier die Kontoobjekte erzeugen // und die Objektmethoden anwenden } @Test public void teststart () { } } \u00dcbung 7 (1.12.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung7 . Erstellen Sie darin eine Klasse Rectangle . Erstellen Sie eine Testklasse RectangleTest und f\u00fcgen Sie darin folgende Methode ein: @Test public void testRectangle () { // hier die Rectangleobjekte erzeugen // und die Objektmethoden anwenden } Erstellen Sie in der Klasse Rectangle zwei Objektvariablen a vom Typ int \u2192 nur in der Klasse sichtbar! b vom Typ int \u2192 ebenfalls nur in der Klasse sichtbar! a und b repr\u00e4sentieren die Seiten des Rechtecks. Erstellen Sie f\u00fcr die Klasse Rectangle einen parameterlosen Konstruktor Rectangle() . Dieser setzt f\u00fcr die Seite a den Wert 10 und f\u00fcr die Seite b den Wert 20 . Erstellen Sie au\u00dferdem einen parametrisierten Konstruktor Rectangle(int a, int b) . Dieser verwendet die Werte der Parameter, um den Objektvariablen Werte zuzuweisen. Erstellen Sie eine Objektmethode area() , die den Fl\u00e4cheninhalt des Rechtecks als int zur\u00fcckgibt. Erstellen Sie eine Objektmethode perimeter() , die den Umfang des Rechtecks als int zur\u00fcckgibt. Erstellen Sie eine Objektmethode toString() , die Informationen \u00fcber das Rechtecks als String in z.B. der folgenden Form (Beispielwerte): Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) zur\u00fcckgibt. Implementieren Sie eine Objektmethode public void print() , die den durch toString() erzeugten String auf die Konsole ausgibt. Geben Sie in der testRectangle() -Methode der RectangleTest -Klasse ein: // Objekte erzeugen Rectangle r1 = new Rectangle (); Rectangle r2 = new Rectangle ( 12 , 18 ); Rectangle r3 = new Rectangle ( 40 , 5 ); Rectangle r4 = new Rectangle ( 20 , 10 ); Rectangle r5 = new Rectangle ( 11 , 21 ); System . out . printf ( \"%n%n--------------- print()-Methode -----------------%n%n\" ); r1 . print (); r2 . print (); r3 . print (); r4 . print (); r5 . print (); und rufen Sie die testRectangle() auf. Es sollten folgende Ausgaben erzeugt werden: --------------- print () -Methode ----------------- Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) Rectangle : ( a = 12 , b = 18 , area = 216 , perimeter = 60 ) Rectangle : ( a = 40 , b = 5 , area = 200 , perimeter = 90 ) Rectangle : ( a = 20 , b = 10 , area = 200 , perimeter = 60 ) Rectangle : ( a = 11 , b = 21 , area = 231 , perimeter = 64 ) Erstellen Sie eine Methode sidesAreEqual(Rectangle r) , die ein true zur\u00fcckgibt, wenn die Seiten des aufrufenden Objektes gleich der Seiten des Rechtecks r sind; false sonst. Sie k\u00f6nnen entscheiden, dass das Rechteck auch gedreht noch gleiche Seiten haben soll, also a=10, b=20 ist nicht nur mit a=10, b=20 gleich, sondern auch mit a=20, b=10 . Wenn die Seiten ungleich sind, gibt die Methode ein false zur\u00fcck. Erstellen Sie eine Methode areasAreEqual(Rectangle r) , die ein true zur\u00fcckgibt, wenn der Fl\u00e4cheninhalt des aufrufenden Objektes gleich dem Fl\u00e4cheninhalt des Rechtecks r ist; false sonst. Erstellen Sie eine Methode perimetersAreEqual(Rectangle r) , die ein true zur\u00fcckgibt, wenn der Umfang des aufrufenden Objektes gleich dem Umfang des Rechtecks r ist; false sonst. Erstellen Sie eine Methode printComparison(Rectangle r) , die die Vergleiche mit r auf die Konsole ausgibt, z.B.: this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 12 , b = 18 , area = 216 , perimeter = 60 ) sides are not equal areas are not equal perimeters are equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 40 , b = 5 , area = 200 , perimeter = 90 ) sides are not equal areas are equal perimeters are not equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 20 , b = 10 , area = 200 , perimeter = 60 ) sides are equal areas are equal perimeters are equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 11 , b = 21 , area = 231 , perimeter = 64 ) sides are not equal areas are not equal perimeters are not equal F\u00fcgen Sie in der testRectangle() -Methode der RectangleTest -Klasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n---------- printComparison()-Methode ------------%n%n\" ); r1 . printComparison ( r2 ); r1 . printComparison ( r3 ); r1 . printComparison ( r4 ); r1 . printComparison ( r5 ); und rufen Sie die testRectangle() -Methode auf. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: ---------- printComparison () -Methode ------------ this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 12 , b = 18 , area = 216 , perimeter = 60 ) sides are not equal areas are not equal perimeters are equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 40 , b = 5 , area = 200 , perimeter = 90 ) sides are not equal areas are equal perimeters are not equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 20 , b = 10 , area = 200 , perimeter = 60 ) sides are equal areas are equal perimeters are equal this Rectangle : ( a = 10 , b = 20 , area = 200 , perimeter = 60 ) the other Rectangle : ( a = 11 , b = 21 , area = 231 , perimeter = 64 ) sides are not equal areas are not equal perimeters are not equal Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 7 Rectangle.java public class Rectangle { private int a ; private int b ; // a,b repr\u00e4sentieren Seiten des Rechtecks public Rectangle () { this . a = 10 ; this . b = 20 ; } public Rectangle ( int a , int b ) { this . a = a ; this . b = b ; } public int area () { return this . a * this . b ; } public int perimeter () { return 2 * this . a + 2 * this . b ; } public String toString () { /*String output = \"Rectangle : ( a=\" + this.a + \", b=\" + this.b + \", area=\"; output = output + \" this.area() + \", perimeter=\" + this.perimeter() + \" )\" */ String output = String . format ( \"Rectangle : ( a=%2d, b=%2d, area=%3d, perimeter=%2d )\" , this . a , this . b , this . area (), this . perimeter () ); return output ; } public void print () { System . out . println ( this . toString ()); } public boolean sidesAreEqual ( Rectangle r ) { boolean equals = false ; if (( this . a == r . a && this . b == r . b ) || ( this . a == r . b && this . b == r . a )) { equals = true ; } return equals ; } public boolean areasAreEqual ( Rectangle r ) { return ( this . area () == r . area ()); } public boolean perimetersAreEqual ( Rectangle r ) { return ( this . perimeter () == r . perimeter ()); } public void printComparison ( Rectangle r ) { System . out . printf ( \"%-9s %s %n\" , \"this\" , this . toString ()); System . out . printf ( \"%-9s %s %n\" , \"the other\" , r . toString ()); if ( this . sidesAreEqual ( r )) { System . out . println ( \"sides are equal\" ); } else { System . out . println ( \"sides are not equal\" ); } if ( this . areasAreEqual ( r )) { System . out . println ( \"areas are equal\" ); } else { System . out . println ( \"areas are not equal\" ); } if ( this . perimetersAreEqual ( r )) { System . out . println ( \"perimeters are equal\" ); } else { System . out . println ( \"perimeters are not equal\" ); } System . out . println (); } } RectangleTest.java import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.AfterEach ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; public class RectangleTest { @Test public void testRectangle () { // Objekte erzeugen Rectangle r1 = new Rectangle (); Rectangle r2 = new Rectangle ( 12 , 18 ); Rectangle r3 = new Rectangle ( 40 , 5 ); Rectangle r4 = new Rectangle ( 20 , 10 ); Rectangle r5 = new Rectangle ( 11 , 21 ); System . out . printf ( \"%n%n--------------- print()-Methode -----------------%n%n\" ); r1 . print (); r2 . print (); r3 . print (); r4 . print (); r5 . print (); System . out . printf ( \"%n%n---------- printComparison()-Methode ------------%n%n\" ); r1 . printComparison ( r2 ); r1 . printComparison ( r3 ); r1 . printComparison ( r4 ); r1 . printComparison ( r5 ); } } \u00dcbung 8 (8.12.2021) \u00d6ffnen Sie BlueJ und erstellen Sie ein neues Projekt uebung8 . Erstellen Sie darin eine Klasse Date . Erstellen Sie eine Programmklasse Programclass und f\u00fcgen Sie darin folgende Methode ein: public void start () { // hier die Rectangleobjekte erzeugen // und die Objektmethoden anwenden } Erstellen Sie in der Klasse Date drei Objektvariablen day vom Typ int \u2192 nur in der Klasse sichtbar! month vom Typ int \u2192 ebenfalls nur in der Klasse sichtbar! year vom Typ int \u2192 ebenfalls nur in der Klasse sichtbar! Erstellen Sie f\u00fcr die Klasse Date einen parameterlosen Konstruktor public Date() . Dieser setzt das \"Datum\" auf den 1.1.1900 . Erstellen Sie au\u00dferdem einen parametrisierten Konstruktor public Date(int day, int month, int year) . Dieser verwendet die Werte der Parameter, um den Objektvariablen Werte zuzuweisen. Erstellen Sie eine Objektmethode public String toString() , die das Datum in der Form (Beispielwerte) \"1.1.1900\" als String zur\u00fcckgibt. Implementieren Sie eine Objektmethode public void print() , die den durch toString() erzeugten String auf die Konsole ausgibt. Geben Sie in der start() -Methode der Programclass -Klasse ein: // Date-Objekte erzeugen Date d1 = new Date ( 11 , 11 , 2000 ); Date d2 = new Date ( 20 , 10 , 2020 ); Date d3 = new Date (); System . out . printf ( \"%n%n--------------- print()-Methode Date -----------------%n%n\" ); d1 . print (); d2 . print (); d3 . print (); und rufen Sie die start() -Methode auf. Es sollten folgende Ausgaben erzeugt werden: --------------- print () -Methode Date ----------------- 11 .11.2000 20 .10.2020 1 .1.1900 Erstellen Sie im Projekt eine weitere Klasse Fruit . Erstellen Sie in der Klasse Fruit zwei Objektvariablen name vom Typ String \u2192 nur in der Klasse sichtbar! expiry vom Typ Date \u2192 ebenfalls nur in der Klasse sichtbar! Erstellen Sie f\u00fcr die Klasse Fruit einen prametrisierten Konstruktor public Fruit(String name, Date expiry) . Dieser verwendet die Werte der Parameter, um den Objektvariablen Werte zuzuweisen. Erstellen Sie eine Objektmethode public String toString() , die die Frucht in der Form (Beispielwerte) \"Banana expires on 11.11.2000\" als String zur\u00fcckgibt. Implementieren Sie eine Objektmethode public void print() , die den durch toString() erzeugten String auf die Konsole ausgibt. Geben Sie in der start() -Methode der Programclass -Klasse ein: // Fruit-Objekte erzeugen Fruit banana = new Fruit ( \"Banana\" , d1 ); Fruit apple = new Fruit ( \"Apple\" , d2 ); Fruit pear = new Fruit ( \"Pear\" , d3 ); System . out . printf ( \"%n%n--------------- print()-Methode Fruit -----------------%n%n\" ); banana . print (); apple . print (); pear . print (); und rufen Sie die start() -Methode auf. Es sollten folgende Ausgaben erzeugt werden: --------------- print () -Methode Fruit ----------------- Banana expires on 11 .11.2000 Apple expires on 20 .10.2020 Pear expires on 1 .1.1900 Erweiteren Sie die Klasse Date um folgende Methode public void later(int days) . Bei Anwendung dieser Methode soll zum aktuellen Datum die als Parameter \u00fcbergebenen days hinzugef\u00fcgt werden. Dabei ist Folgendes zu beachten: Die Anzahl von days kann auch mehrere Jahre und mehrere Monate umfassen. Das soll eine Wiederholung von \u00dcbung 3 sein - aber nicht gleich dort nachgucken, sondern nochmal \u00fcberlegen! Wir nehmen an, dass jeder Monat nur 30 Tage hat und ein Jahr immer nur 365 . Erweiteren Sie die Klasse Fruit um die Methode public Date getExpiryDate() . Geben Sie in der start() -Methode der Programclass -Klasse ein: System . out . printf ( \"%n%n------------ later() und getExpiryDate ----------------%n%n\" ); d1 . later ( 12 ); d2 . later ( 123 ); d3 . later ( 1234 ); d1 . print (); d2 . print (); d3 . print (); banana . print (); apple . print (); pear . print (); banana . getExpiryDate (). later ( 12 ); apple . getExpiryDate (). later ( 123 ); pear . getExpiryDate (). later ( 1234 ); d1 . print (); d2 . print (); d3 . print (); Was stellen Sie fest? L\u00e4uft etwas schief? Was sind die Probleme? Worin liegen sie begr\u00fcndet? Haben Sie Ideen, wie Sie diese Probleme vermeiden k\u00f6nnten? ( \u00dcbrings: das Thema, das wir hier ein wenig n\u00e4her beleuchten, nennt sich immutable objects ) Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 8 Date.java public class Date { private int day ; private int month ; private int year ; public Date ( int day , int month , int year ) { this . day = day ; this . month = month ; this . year = year ; } public Date () { this . day = 1 ; this . month = 1 ; this . year = 1900 ; } /* * Die folgende Implementierung stellt eine M\u00f6glichkeit dar, * ein sp\u00e4teres Datum zu bestimmen. Diese Methode \u00e4ndert aber * das Objekt selbst, d.h. die Werte der Objektvariablen * werden neu gesetzt. Dadurch wird das Objekt ver\u00e4nderlich. */ public void later ( int days ) { int years = days / 365 ; int remainder = days % 365 ; int months = remainder / 30 ; remainder = remainder % 30 ; this . year += years ; this . day += remainder ; this . month += months ; if ( this . day > 30 ) { this . month ++ ; this . day %= 30 ; } if ( this . month > 12 ) { this . year ++ ; this . month %= 12 ; } } /* * Die folgende Implementierung stellt eine M\u00f6glichkeit dar, * ein sp\u00e4teres Datum zu bestimmen. Diese Methode \u00e4ndert aber * das Objekt selbst, d.h. die Werte der Objektvariablen * werden neu gesetzt. Dadurch wird das Objekt ver\u00e4nderlich. */ public Date laterImmutable ( int days ) { int years = days / 365 ; int remainder = days % 365 ; int months = remainder / 30 ; remainder = remainder % 30 ; // nur noch lesenden Zugriff auf die // Werte der Objektvariablen --> // Werte bleiben unver\u00e4ndert int newYears = this . year + years ; int newDays = this . day + remainder ; int newMonths = this . month + months ; if ( newDays > 30 ) { newMonths ++ ; newDays %= 30 ; } if ( newMonths > 12 ) { newYears ++ ; newMonths %= 12 ; } return new Date ( newDays , newMonths , newYears ); } public String toString () { return this . day + \".\" + this . month + \".\" + this . year ; } public void print () { System . out . println ( this . toString ()); } } Fruit.java public class Fruit { private String name ; private Date expiry ; public Fruit ( String name , Date expiry ) { this . name = name ; this . expiry = expiry ; // man k\u00f6nnte hier \u00fcberlegen, ob man wirklich die Referenz auf // das \u00fcbergebene Date-Objekt speichern m\u00f6chte oder lieber // eine eigene Kopie des Objektes erzeugen und diese speichern // dazu fehlen allerdings die Getter der Date-Objektvariablen :-( } public String toString () { return this . name + \" expires on \" + this . expiry . toString (); } public void print () { System . out . println ( this . toString () ); } public Date getExpiryDate () { return this . expiry ; // hier w\u00e4re es auch besser, nicht die Referenz, sondern // ein neues Date-Objekt zur\u00fcckzugeben // dazu fehlen allerdings die Getter der Date-Objektvariablen :-( } } Programclass.java public class Programclass { public void start () { Date d1 = new Date ( 11 , 11 , 2000 ); Date d2 = new Date ( 20 , 10 , 2020 ); Date d3 = new Date (); System . out . printf ( \"%n%n--------------- print()-Methode Date -----------------%n%n\" ); d1 . print (); d2 . print (); d3 . print (); Fruit banana = new Fruit ( \"Banana\" , d1 ); Fruit apple = new Fruit ( \"Apple\" , d2 ); Fruit pear = new Fruit ( \"Pear\" , d3 ); System . out . printf ( \"%n%n--------------- print()-Methode Fruit -----------------%n%n\" ); banana . print (); apple . print (); pear . print (); System . out . printf ( \"%n%n------------ later() und getExpiryDate ----------------%n%n\" ); d1 . later ( 12 ); d2 . later ( 123 ); d3 . later ( 1234 ); d1 . print (); d2 . print (); d3 . print (); banana . print (); apple . print (); pear . print (); banana . getExpiryDate (). later ( 12 ); apple . getExpiryDate (). later ( 123 ); pear . getExpiryDate (). later ( 1234 ); d1 . print (); d2 . print (); d3 . print (); } } \u00dcbung 9 (15.12.2021) Diese \u00dcbung wird nicht am Rechner durchgef\u00fchrt, sondern es geht um Programmverst\u00e4ndinis und algorithmische Ideen! Zun\u00e4chst ein Beispiel f\u00fcr eine \u201cErkl\u00e4ren Sie den folgenden Code in einem Satz\u201d -Aufgabe: if ( a < b ) { System . out . print ( a ); } else { System . out . print ( b ); } Antwort: Der kleinere Wert der Variablen a und b wird ausgegeben. Was wird durch folgenden Code auf der Konsole ausgegeben?: public class PrinterClass { public static void main ( String [] args ) { System . out . print ( \"answer=\" ); System . out . println ( 40 + 2 ); } } Was wird durch folgenden Code auf der Konsole ausgegeben?: int number = 3 ; while ( number == 3 ) { System . out . print ( number + \" + \" ); number ++ ; } Was wird durch folgenden Code auf der Konsole ausgegeben?: for ( int count = 0 ; count < 4 ; count -- ) { System . out . print ( count ); } Erkl\u00e4ren Sie den folgenden Code in einem Satz. int sum = 0 ; for ( int n = 1 ; n <= 20 ; n ++ ) { sum = sum + n ; } System . out . println ( sum ); Erkl\u00e4ren Sie den folgenden Code in einem Satz. if ( a < b ) { if ( b < c ) { System . out . println ( c ); } else { System . out . println ( b ); } } else if ( a < c ) { System . out . println ( c ); } else { System . out . println ( a ); } Welche Kombination von Werten sorgt daf\u00fcr, dass b ausgegeben wird? Was macht der folgende Code? public class Student { private String name ; private int age ; public Student ( String name , int age ) { this . name = name ; this . age = age ; } public int getAge ( ) { return age ; } public int hadBirthday ( ) { return age = age + 1 ; } public void main ( ) { Student willi = new Student ( \"Willi\" , 25 ) ; willi . hadBirthday ( ) ; System . out . print ( willi . getAge ( ) ) ; } } Welchen Wert liefert rect2.area( ) ? public class Rectangle { private int x1 , y1 , x2 , y2 ; public Rectangle ( int x1 , int y1 , int x2 , int y2 ) { this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; } public int width () { return this . x2 - this . x1 ; } public int height () { return this . y2 - this . y1 ; } public double area () { return this . width () * this . height (); } public void main () { Rectangle rect1 = new Rectangle ( 0 , 0 , 10 , 10 ); System . out . println ( rect1 . area ()); Rectangle rect2 = new Rectangle ( 5 , 5 , 10 , 10 ); System . out . println ( rect2 . area ()); } } Was macht der folgende Code? public class Vehicle { String producer , type ; int topSpeed , currentSpeed ; public Vehicle ( String p , String t , int tp ) { this . producer = p ; this . type = t ; this . topSpeed = tp ; this . currentSpeed = 0 ; } public int accelerate ( int kmh ) { if ( ( this . currentSpeed + kmh ) > this . topSpeed ) { this . currentSpeed = this . topSpeed ; } else { this . currentSpeed = this . currentSpeed + kmh ; } return this . currentSpeed ; } public static void main ( String args [ ] ) { Vehicle v = new Vehicle ( \"Audi\" , \"A6\" , 200 ) ; v . accelerate ( 10 ) ; } } Was wird durch folgenden Code auf der Konsole ausgegeben? int iNum = 3 ; for ( int iX = 0 ; iX < iNum ; iX ++ ) { for ( int iY = 0 ; iY < iNum ; iY ++ ) { System . out . print ( \"*\" ); } System . out . println (); } Was wird durch folgenden Code auf der Konsole ausgegeben? public class PrintPattern { public void printMethod ( int numberOfRows ) { for ( int row = 1 ; row <= numberOfRows ; row ++ ) { for ( int col = 1 ; col <= row ; col ++ ) { System . out . print ( '*' ) ; } System . out . println ( ) ; } } public void main ( ) { PrintPattern p = new PrintPattern (); p . printMethod ( 3 ) ; } } Was berechnet der folgende Code? public int calculate ( int number1 , int number2 ) { int result = number1 ; for ( int i = 2 ; i <= number2 ; i += 1 ) { result = result * number1 ; } return result ; } Was wird durch folgenden Code auf der Konsole ausgegeben? int n = 4 ; for ( int row = 1 ; row <= n ; row ++ ) { for ( int column = 1 ; column <= n ; column ++ ) { if ( row == 1 || row == n || column == 1 || column == n ) System . out . print ( \"* \" ); else System . out . print ( \" \" ); } System . out . println ( ); } } \u00dcbung 10 (22.12.2021) Wir nutzen von nun an Eclipse in den \u00dcbungen und in den Vorlesungen. Bitte installieren! Erstellen Sie ein package uebungen.uebung10 . Erstellen Sie in diesem package eine Klasse Programmklasse mit main() -Methode und eine Klasse Uebung10 . Implementieren Sie in der Klasse Uebung10 folgende Methoden: Implementieren Sie eine public void print(char[] ca) -Methode, so dass das char[] ca auf die Konsole ausgegeben wird. Achten Sie darauf, dass hinter dem letzten Element kein Komma steht. Testen Sie Ihre Methode auch f\u00fcr ein leeres Array. Bsp: print(['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c']) Ausgabe auf Konsole: [a, b, c, a, c, a, b, c] Kopieren Sie die print -Methode vollst\u00e4ndig und \u00e4ndern Sie den Typ des Parameters von char[] in int[] . (Die Methode ist jetzt \u00fcberladen und print() kann jetzt entweder ein char[] oder ein int[] \u00fcbergeben werden, welches auf die Konsole ausgegeben wird.) Implementieren Sie eine Methode public char[] stringToCharArray(String s) . Diese Methode wandelt einen String in ein char[] um, so dass jedes Zeichen des Strings im char[] enthalten ist. Das char[] wird zur\u00fcckgegeben. Tipps: die L\u00e4nge eines Strings wird mit der Objektmethode length() ermittelt. Die einzelnen Zeichen eines Strings k\u00f6nnen mithilfe der charAt(index) -Objektmethode von Strings ermittelt werden. Siehe String Bsp.: stringToCharArray(\"hallo!\") \u2192 ['h','a','l','l','o','!'] Implementieren Sie eine Methode public int[] reverse(int[] iarr) , der ein int -Array \u00fcbergeben wird und die die Reihenfolge der Elemente des Arrays umdreht (das letzte zuerst usw.) Das neuerstellte Array wird zur\u00fcckgegeben. Bsp.: reverse([4,2,8,1,6,2,4,1,8]) \u2192 [8,1,4,2,6,1,8,2,4] reverse([4]) \u2192 [4] Erzeugen Sie in der main() -Methode der Programmklasse ein char -Array mit den Werten ['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c'] , ein int -Array mit den Werten [4,2,8,1,6,2,4,1,8] und ein Objekt der Klasse Uebung10 und testen Sie alle Methoden der Klasse Uebung10 . Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 10 Programclass.java package uebungen.uebung10 ; public class Programclass { public static void main ( String [] args ) { char [] ca1 = { 'a' , 'b' , 'c' , 'a' , 'c' , 'a' , 'b' , 'c' }; char [] ca2 = new char [ 0 ] ; int [] ia1 = { 4 , 2 , 8 , 1 , 6 , 2 , 4 , 1 , 8 }; int [] ia2 = { 4 }; Uebung10 u1 = new Uebung10 (); u1 . print ( ca1 ); u1 . print ( ca2 ); u1 . print ( ia1 ); u1 . print ( ia2 ); char [] ca3 = u1 . stringToCharArray ( \"Hallo FIW!\" ); u1 . print ( ca3 ); int [] ia3 = u1 . reverse ( ia1 ); u1 . print ( ia1 ); u1 . print ( ia3 ); } } Uebung10.java package uebungen.uebung10 ; public class Uebung10 { public void print ( char [] ca ) { String s = \"[ \" ; if ( ca . length == 0 ) { s = s + \"]\" ; } else { for ( int index = 0 ; index < ca . length - 1 ; index ++ ) { s = s + ca [ index ] + \", \" ; } s = s + ca [ ca . length - 1 ] + \" ]\" ; } System . out . println ( s ); } public void print ( int [] ia ) { String s = \"[ \" ; if ( ia . length == 0 ) { s = s + \"]\" ; } else { for ( int index = 0 ; index < ia . length - 1 ; index ++ ) { s = s + ia [ index ] + \", \" ; } s = s + ia [ ia . length - 1 ] + \" ]\" ; } System . out . println ( s ); } public char [] stringToCharArray ( String s ) { char [] ca = new char [ s . length () ] ; for ( int index = 0 ; index < ca . length ; index ++ ) { ca [ index ] = s . charAt ( index ); } return ca ; } public int [] reverse ( int [] iarr ) { int [] ia = new int [ iarr . length ] ; for ( int index = 0 ; index < ia . length ; index ++ ) { ia [ index ] = iarr [ iarr . length - 1 - index ] ; } return ia ; } } \u00dcbung 11 (05.01.2022) Sie k\u00f6nnen einfach Ihre L\u00f6sung (die Klassen) aus \u00dcbung 10 weiterverwenden. Implementieren Sie in der Klasse Uebung10 (oder wenn Sie doch eine neue Klasse Uebung11 haben, dann darein) folgende Methoden: Implementieren Sie eine Methode public char[] filter(char[] carr, char filter) , der als Parameter ein char -Array und ein char \u00fcbergeben wird. Die Methode soll ein char -Array zur\u00fcckgeben, das dem als Parameter \u00fcbergeben Array entspricht, au\u00dfer dass jedes Vorkommen des als Parameter \u00fcbergeben carr entfernt wurde Bsp: filter(['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c'], 'c') \u2192 ['a', 'b', 'a', 'a', 'b'] Implementieren Sie eine Methode public int[] minAndMax(int[] iarr) , der ein int -Array als Parameter \u00fcbergeben wird und die ein zweielementiges Array zur\u00fcckgibt. Das erste Element des zur\u00fcckgegeben Arrays ist das Minimum des als Parameter \u00fcbergebenen Arrays und das zweite Element ist das Maximum. Bsp.: minAndMax([4,2,8,1,6,2,4,1,8]) \u2192 [1,8] minAndMax([4]) \u2192 [4,4] Zusatz: Implementieren Sie eine Methode public boolean containsDoublets(char[] ca) die ein true zur\u00fcckgibt, wenn mindestens ein Wert in ca mindestens zwei Mal vorkommt (wenn Sie schon dabei sind, k\u00f6nnen Sie sich auch \u00fcberlegen, wenn genau ein Wert genau zwei Mal vorkommt - oder mindestens ein Wert genau zwei Mal - oder genau ein Wert mindestens zwei Mal) und false sonst. Erzeugen Sie in der main() -Methode der Programmklasse ein char -Array mit den Werten ['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c'] , ein int -Array mit den Werten [4,2,8,1,6,2,4,1,8] und ein Objekt der Klasse Uebung10 (oder Uebung11 - siehe oben) und testen Sie alle Methoden der Klasse Uebung10 (oder Uebung11 - siehe oben). Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 11 (weiter Klasse Uebung10.java verwendet) Programclass.java package uebungen.uebung10 ; public class Programclass { public static void main ( String [] args ) { char [] ca1 = { 'a' , 'b' , 'c' , 'a' , 'c' , 'a' , 'b' , 'c' }; char [] ca2 = new char [ 0 ] ; int [] ia1 = { 4 , 2 , 8 , 1 , 6 , 2 , 4 , 1 , 8 }; int [] ia2 = { 4 }; Uebung10 u1 = new Uebung10 (); u1 . print ( ca1 ); u1 . print ( ca2 ); u1 . print ( ia1 ); u1 . print ( ia2 ); char [] ca3 = u1 . stringToCharArray ( \"Hallo FIW!\" ); u1 . print ( ca3 ); int [] ia3 = u1 . reverse ( ia1 ); u1 . print ( ia1 ); u1 . print ( ia3 ); System . out . printf ( \"%n%n------------ Uebung 11 filter()---------------%n%n\" ); u1 . print ( ca1 ); char [] ca4 = u1 . filter ( ca1 , 'c' ); u1 . print ( ca4 ); char [] ca5 = u1 . filter ( ca1 , 'a' ); u1 . print ( ca5 ); char [] ca6 = u1 . filter ( ca1 , 'b' ); u1 . print ( ca6 ); char [] ca7 = u1 . filter ( ca1 , 'd' ); u1 . print ( ca7 ); System . out . println (); u1 . print ( ca3 ); char [] ca8 = u1 . filter ( ca3 , 'l' ); u1 . print ( ca8 ); char [] ca9 = u1 . stringToCharArray ( \"superlangerTeststringzumFiltern kann auch Leerzeichen enthalten oder alle m\u00f6glichen Zeichen ?%$\u00a7!*\" ); u1 . print ( ca9 ); u1 . print ( u1 . filter ( ca9 , 'e' )); System . out . printf ( \"%n%n------------ Uebung 11 minAndMax()---------------%n%n\" ); u1 . print ( ia1 ); int [] mm1 = u1 . minAndMax ( ia1 ); u1 . print ( mm1 ); System . out . println (); u1 . print ( ia2 ); int [] mm2 = u1 . minAndMax ( ia2 ); u1 . print ( mm2 ); } } Uebung10.java package uebungen.uebung10 ; public class Uebung10 { public void print ( char [] ca ) { String s = \"[ \" ; if ( ca . length == 0 ) { s = s + \"]\" ; } else { for ( int index = 0 ; index < ca . length - 1 ; index ++ ) { s = s + ca [ index ] + \", \" ; } s = s + ca [ ca . length - 1 ] + \" ]\" ; } System . out . println ( s ); } public void print ( int [] ia ) { String s = \"[ \" ; if ( ia . length == 0 ) { s = s + \"]\" ; } else { for ( int index = 0 ; index < ia . length - 1 ; index ++ ) { s = s + ia [ index ] + \", \" ; } s = s + ia [ ia . length - 1 ] + \" ]\" ; } System . out . println ( s ); } public char [] stringToCharArray ( String s ) { char [] ca = new char [ s . length () ] ; for ( int index = 0 ; index < ca . length ; index ++ ) { ca [ index ] = s . charAt ( index ); } return ca ; } public int [] reverse ( int [] iarr ) { int [] ia = new int [ iarr . length ] ; for ( int index = 0 ; index < ia . length ; index ++ ) { ia [ index ] = iarr [ iarr . length - 1 - index ] ; } return ia ; } public char [] filter ( char [] carr , char filter ) { /* * neues Array erzeugen -- Idee: * 1. neues Array erzeugen (char[]) * 2. aber wie lang ist das neue Array? * 3. Laenge von neuen Array ist (Laenge von carr - Anzahl des Vorkommens von filter in carr) */ // wie oft kommt filter in carr vor? int counter = 0 ; for ( int index = 0 ; index < carr . length ; index ++ ) { if ( carr [ index ] == filter ) { counter ++ ; } } // jetzt wissen wir, wie oft filter in carr vorkommt: counter int laengeVomNeuenArray = carr . length - counter ; // jetzt kann das neue Array erzeugt werden (jetzt kennen wir die Laenge) char [] filterArray = new char [ laengeVomNeuenArray ] ; /* * neues Array befuellen -- Idee: * 1. wir laufen durch das komplette carr (for-Schleife) * 2. fuer jedes Element aus carr pruefen, ob es dem filter entspricht * 2a. wenn es nicht filter entspricht, dann kopieren * 2b. wenn es filter entspricht, dann wird es nicht kopiert * 3. wichtig: unterschiedlich indexCarr und indexNeuesArray (haben ja auch unter- * schiedliche Laengen) */ // jetzt befuellen - zunaechst for-Schleife fuer carr int indexFilterArray = 0 ; for ( int indexCarr = 0 ; indexCarr < carr . length ; indexCarr ++ ) { if ( carr [ indexCarr ] != filter ) { // dann kopieren (sonst nicht) // das geht nicht: --> filterArray[indexCarr] = carr[indexCarr]; filterArray [ indexFilterArray ] = carr [ indexCarr ] ; indexFilterArray ++ ; } } return filterArray ; } public int [] minAndMax ( int [] iarr ) { // wir koennen davon ausgehen, dass iarr.length mind. 1 ist int curMin = iarr [ 0 ] ; int curMax = iarr [ 0 ] ; for ( int index = 0 ; index < iarr . length ; index ++ ) { if ( iarr [ index ] < curMin ) { curMin = iarr [ index ] ; // iarr[index] ist nun mein neues aktuelles Minimum } if ( iarr [ index ] > curMax ) { curMax = iarr [ index ] ; // iarr[index] ist nun mein neues aktuelles Maximum } } // entweder so: /* * int[] minAndMax = new int[2]; * minAndMax[0] = curMin; * minAndMax[1] = curMax; * return minAndMax; */ // oder so: /* * int[] minAndMax = { curMin, curMax }; * return minAndMax; */ // oder so: return new int [] { curMin , curMax }; } } \u00dcbung 12 (12.01.2022) siehe Moodle \u00dcbung 13 (19.01.2022) Erstellen Sie ein package uebungen.uebung13 . Erstellen Sie in diesem package eine Klasse Lottery mit der privaten Objektvariablen drawingResults vom Typ int[] . Information : Lottery steht f\u00fcr eine Lotterie, bei der aus 9 Zahlen (1..9) 5 Zahlen zuf\u00e4llig gelost werden (5 aus 9). Das Array drawingResults dient zum Speichern der gezogenen 5 Zahlen. Schreiben Sie f\u00fcr die Klasse Lottery einen parameterlosen Konstruktor. In diesem Konstruktor wird das Array drawingResults mit der L\u00e4nge 5 erzeugt. Schreiben Sie eine Objektmethode contains(int number) . Diese Methode gibt ein true zur\u00fcck, wenn number in drawingResults enthalten ist und false sonst. Schreiben Sie eine Objektmethode drawing() . In dieser Methode werden die 5 Zufallszahlen gezogen (5 aus 9). Sie ben\u00f6tigen daf\u00fcr ein Objekt der Klasse Random ( Random muss aus java.util importiert werden). \u201eZiehen\u201c Sie nun zuf\u00e4llig 5 Zufallszahlen aus dem Bereich 1..9 (1 und 9 inklusive) und speichern Sie diese im Array drawingResults . Achtung : Die gleiche Zahl darf nicht doppelt gezogen (gespeichert) werden! D.h. die 5 im Array gespeicherten Zufallszahlen m\u00fcssen sich voneinander unterscheiden! Schreiben Sie eine Objektmethode sort() . Diese Methode sortiert das Array drawingResults aufsteigend (von klein nach gro\u00df). \u00dcberschreiben Sie die Objektmethode toString() , die das drawingResult -Array als String in folgender Form zur\u00fcckgibt (Beispielwerte f\u00fcr den Fall, dass 1, 3, 5, 6, 7 gezogen wurden): ( 1 - 3 - 5 6 7 - - ) das dawingResult -Array wird zun\u00e4chst sortiert 2. ist die Zahl im Array enthalten, wird sie als Wert angezeigt 3. ist die Zahl nicht enthalten, wird ein - angezeigt 4. d.h. es werden immer die 5 gezogenen Zahlen ausgegeben und 4 Striche. Schreiben Sie eine Objektmethode print() , die den von toString() zur\u00fcckgegebenen String auf der Konsole ausgibt. \u00dcberschreiben Sie die Objektmethode equals(Object o) . Diese Methode gibt true zur\u00fcck, wenn wenn bei dem aufrufenden Objekt die gleichen Zahlen gezogen wurden, wie bei o . Sonst false ( hashCode() muss nicht \u00fcberschrieben werden). Tipp : Implementieren Sie die Methode am einfachsten so, dass Sie die beiden drawingResult -Arrays erst sortieren und dann die sortierten Arrays elementweise miteinander vergleichen. Erstellen Sie im gleichen package eine Klasse Programmklasse mit main() -Methode. Erzeugen Sie in der main() -Methode in einer Schleife 10 Objekte der Klasse Lottery und rufen (auch in der Schleife) jeweils die drawing() und die print() -Methode auf. Es entsteht folgende Ausgabe (Beispielwerte sind zuf\u00e4llig und unterscheiden sich!): ( 1 - 3 - 5 6 7 - - ) ( 1 2 3 - 5 - 7 - - ) ( 1 - 3 - - 6 7 8 - ) ( - - 3 4 5 6 - - 9 ) ( 1 2 3 4 - - - - 9 ) ( 1 2 - 4 - 6 - 8 - ) ( - 2 3 - - - 7 8 9 ) ( 1 2 3 - - 6 - - 9 ) ( 1 - - 4 5 - 7 8 - ) ( - 2 3 - 5 - - 8 9 ) Erzeugen Sie ein Objekt von Lottery und rufen f\u00fcr dieses Objekt die drawing() -Methode auf. Erzeugen Sie in einer Schleife so lange ein weiteres Objekt von Lottery und rufen daf\u00fcr die drawing() -Methode auf, bis die beiden Objekte die gleichen gezogenen Zahlen enthalten, d.h. laut equals() -Methode gleich sind. Geben Sie dann beide Objekte mithilfe der print() -Methode aus. Es entsteht folgende Ausgabe (zuf\u00e4llige Beispielwerte): ( 1 - 3 - - 6 - 8 9 ) ( 1 - 3 - - 6 - 8 9 ) Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 13 Programmklasse.java package uebungen.uebung13 ; public class Programmklasse { public static void main ( String [] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { Lottery lo1 = new Lottery (); lo1 . drawing (); lo1 . print (); } System . out . println (); Lottery lo2 = new Lottery (); lo2 . drawing (); lo2 . print (); Lottery lo3 = new Lottery (); lo3 . drawing (); while ( ! lo2 . equals ( lo3 )) { lo3 . drawing (); } lo3 . print (); } } Lottery.java package uebungen.uebung13 ; import java.util.Random ; public class Lottery { private int [] drawingResults ; public Lottery () { this . drawingResults = new int [ 5 ] ; } public boolean contains ( int number ) { boolean contains = false ; for ( int index = 0 ; index < this . drawingResults . length && ! contains ; index ++ ) { if ( this . drawingResults [ index ] == number ) { contains = true ; } } return contains ; } public void drawing () { Random r = new Random (); for ( int index = 0 ; index < this . drawingResults . length ; index ++ ) { int zufZahl = r . nextInt ( 9 ) + 1 ; while ( this . contains ( zufZahl )) { zufZahl = r . nextInt ( 9 ) + 1 ; } this . drawingResults [ index ] = zufZahl ; } } public void sort () { for ( int bubble = 1 ; bubble <= drawingResults . length - 1 ; bubble ++ ) { for ( int index = 0 ; index < drawingResults . length - bubble ; index ++ ) { if ( this . drawingResults [ index ] > this . drawingResults [ index + 1 ] ) { int tmp = this . drawingResults [ index ] ; this . drawingResults [ index ] = this . drawingResults [ index + 1 ] ; this . drawingResults [ index + 1 ] = tmp ; } } } } @Override public String toString () { this . sort (); String s = \"( \" ; /* for (int index = 0; index < drawingResults.length; index++) { s = s + this.drawingResults[index] + \" \"; } */ for ( int number = 1 ; number < 10 ; number ++ ) { if ( this . contains ( number )) { s = s + number + \" \" ; } else { s = s + \"- \" ; } } s = s + \")\" ; return s ; } public void print () { System . out . println ( this . toString ()); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( this . getClass () != o . getClass ()) return false ; Lottery lo = ( Lottery ) o ; this . sort (); lo . sort (); for ( int index = 0 ; index < drawingResults . length ; index ++ ) { if ( this . drawingResults [ index ] != lo . drawingResults [ index ] ) { return false ; } } return true ; } }","title":"\u00dcbungsbl\u00e4tter (wochenweise)"},{"location":"uebungen/#selbstandiges-uben","text":"Falls Sie noch Lust und Zeit haben, ein wenig selbst\u00e4ndig zu \u00fcben, hier einige Aufgaben:","title":"Selbst\u00e4ndiges \u00dcben"},{"location":"uebungen/#probeklausuren","text":"Punkt2D und Punkt3D Erstellen Sie ein package klausurvorbereitung1 . Erstellen Sie in diesem package eine Klasse Punkt3D mit drei privaten Objektvariablen x , y und z , jeweils vom Typ int , einem parametrisierten Konstruktor Punkt3D(int x, int y, int z) . Mit den Parameterwerten werden die Objektvariablen initialisiert. Getter f\u00fcr die drei Objektvariablen ( getX() , getY() und getZ() ). \u00dcberschreiben Sie die Methode toString() , so dass folgende textuelle Rer\u00e4sentation als String erzeugt wird (Beispielwerte): ( 5 ,2,3 ) also in runden Klammern die Werte von x , y und z durch Komma getrennt. Schreiben Sie eine Objektmethode print() , die den durch toString() erzeugten String auf die Konsole ausgibt. \u00dcberschreiben Sie die Methode equals(Object o) so, dass zwei Punkt3D -Objekte gleich sind, wenn ihre Objektvariablen x , y und z jeweils paarweise den gleichen Wert besitzen. Schreiben Sie eine Objektmethode xIsSmaller(Punkt3D p) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren x -Wert hat als p ; false sonst. Schreiben Sie eine Objektmethode yIsSmaller(Punkt3D p) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren y -Wert hat als p ; false sonst. Schreiben Sie eine Objektmethode zIsSmaller(Punkt3D p) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren z -Wert hat als p ; false sonst. Erstellen Sie im gleichen package eine Klasse Punkt2D . Diese Klasse erbt von Punkt3D . Bei einem Objekt vom Typ Punkt2D ist der Wert von z stets 0 ! Schreiben Sie einen parametrisierten Konstruktor Punkt2D(int x, int y) . Verwenden Sie die Parameterwerte, um den entsprechenden Objektvariablen Werte zuzuweisen und setzen Sie den Wert von z auf 0 . \u00dcberschreiben Sie die Methode toString() , so dass folgende textuelle Rer\u00e4sentation als String erzeugt wird (Beispielwerte): ( 5 ,2 ) also in runden Klammern die Werte von x und y durch Komma getrennt. ( der Wert von z wird nicht mehr ausgewertet, er ist ja immer 0 ). Testen Sie die Klassen Punkt3D und Punkt2D in einer Testklasse mit main() -Methode wie folgt: Erzeugen Sie ein Random -Objekt. Sie m\u00fcssen dazu die Klasse Random aus dem java.util -Paket importieren. innerhalb einer Schleife soll nun Folgendes passieren: Erstellen Sie ein Array vom Typ Punkt2D . Es hat die L\u00e4nge 3 . Sie erzeugen sich f\u00fcr x , y und z jeweils Zufallszahlen aus dem Bereich [0, ... ,9] ( 0 und 9 inklusive, also 10 m\u00f6gliche Zufallszahlen). - wenn z den Wert 0 hat, dann erzeugen Sie mit den zuf\u00e4llig erzeugten Werten von x und y ein Objekt vom Typ Punkt2D und speichern dieses im Array. Rufen Sie daf\u00fcr die print() -Methode auf. - wenn z einen Wert ungleich 0 hat, dann erzeugen Sie mit den zuf\u00e4llig erzeugten Werten von x , y und z ein Objekt vom Typ Punkt3D und rufen daf\u00fcr die print() -Methode auf. Ein solches Objekt wird nicht weiter gespeichert. - diesen Prozess wiederholen Sie so lange, bis das Punkt2D[] -Array bef\u00fcllt ist, bis Sie also drei Punkt2D -Objekte erzeugt und im Array gespeichert haben. Eine m\u00f6gliche Ausgabe k\u00f6nnte so sein (Zufallswerte): ---------------- Punkt2D und Punkt3D --------------- ( 3 ,8,9 ) ( 3 ,3,4 ) ( 1 ,2,3 ) ( 7 ,6,7 ) ( 0 ,4,7 ) ( 9 ,0,8 ) ( 0 ,3,8 ) ( 3 ,3,9 ) ( 7 ,2,1 ) ( 2 ,4 ) ( 1 ,8 ) ( 6 ,4,7 ) ( 2 ,1,2 ) ( 7 ,4,1 ) ( 7 ,1,1 ) ( 0 ,2,2 ) ( 6 ,4,9 ) ( 1 ,2,7 ) ( 3 ,9,8 ) ( 2 ,3 ) das letzte Objekt ist immer ein Punkt2D -Objekt, denn nach dem dritten Punkt2D -Objekt h\u00f6ren Sie ja auf, Objekte zu erzeugen (Schleifenende). Erstellen Sie im gleichen package eine Klasse Strecke mit den privaten Objektvariablen start und ende , jeweils vom Typ Punkt2D , einem parametrisierten Konstruktor Strecke(Punkt2D start, Punkt2D ende) . Mit den Parameterwerten werden die Objektvariablen initialisiert. einem weiteren parametrisierten Konstruktor Strecke(int x1, int y1, int x2, int y2) . Mit den Parameterwerten x1 und y1 erzeugen Sie sich ein Punkt2D -Objekt, das den start -Punkt bildet und mit den Parameterwerten x2 und y2 erzeugen Sie sich ein Punkt2D -Objekt, das den ende -Punkt bildet. Schreiben Sie eine Objektmethode laenge() , die die L\u00e4nge der Strecke als double zur\u00fcckgibt. Sie k\u00f6nnen dazu die Methoden Math.abs(number) f\u00fcr den absoluten Betrag von number und Math.sqrt(number) f\u00fcr die Quadratwurzel von number (als double ) verwenden. Tipp: \u00dcberschreiben Sie die Methode toString() , so dass folgende textuelle Rer\u00e4sentation der Strecke als String erzeugt wird (Beispielwerte): Strecke [ start =( 2 ,4 ) , ende =( 1 ,8 ) , Laenge = 4 ,1231cm ] also die Start- und Endpunkte ausgegeben werden und die L\u00e4nge der Strecke in eckigen Klammern nach dem Wort Strecke . Schreiben Sie eine Objektmethode print() , die den durch toString() erzeugten String auf die Konsole ausgibt. Testen Sie die Klasse Strecke in der Testklasse mit main() -Methode wie folgt: Erzeugen Sie 3 Objekte der Klasse Strecke . W\u00e4hlen Sie als start -Punkt der ersten Strecke, den ersten Punkt aus dem Punkt2D -Array aus dem ersten Teil der Aufgabe, als ende -Punkt den zweiten Punkt aus dem Punkt2D -Array aus dem ersten Teil, - als start -Punkt der zweiten Strecke, den zweiten Punkt aus dem Punkt2D -Array aus dem ersten Teil der Aufgabe, als ende -Punkt den dritten Punkt aus dem Punkt2D -Array aus dem ersten Teil, - als start -Punkt der dritten Strecke, den dritten Punkt aus dem Punkt2D -Array aus dem ersten Teil der Aufgabe, als ende -Punkt den ersten Punkt aus dem Punkt2D -Array aus dem ersten Teil. Wenden Sie f\u00fcr alle drei Strecke -Objekte die print() -Methode an. Es sollte folgende Ausgabe erzeugt werden (Beispielwerte): -------------------- Strecke ----------------------- Strecke [ start =( 7 ,1 ) , ende =( 6 ,4 ) , Laenge = 3 ,1623cm ] Strecke [ start =( 6 ,4 ) , ende =( 4 ,6 ) , Laenge = 2 ,8284cm ] Strecke [ start =( 4 ,6 ) , ende =( 7 ,1 ) , Laenge = 5 ,8310cm ] Erstellen Sie im gleichen package eine Klasse PunkteArray mit dem parametrisierten Konstruktor PunkteArray(int anzahl) , dem die Anzahl der Punkte, also die L\u00e4nge des punkte -Arrays \u00fcbergeben wird. Erzeugen Sie unter Verwendung dieser anzahl das punkte -Array. Schreiben Sie eine Objektmethode contains(Punkt2D p) . Diese Methode gibt ein true zur\u00fcck, wenn p im punkte -Array enthalten ist und false sonst. Tipp: Beachten Sie, dass es sein kann, dass nicht alle Elemente im punkte -Array tats\u00e4chlich ein Objekt enthalten. Es kann also sein, dass manche Referenzvariablen this.punkte[index] den Wert null haben. Mithilfe von this.punkte[index] != null k\u00f6nnen Sie pr\u00fcfen, ob this.punkte[index] nicht auf null zeigt. Schreiben Sie eine Objektmethode fillArray() . Diese Methode bef\u00fcllt das punkte -Array vollst\u00e4ndig mit Punkte2D -Objekten. Beachten Sie: der privaten Objektvariablen punkte vom Typ Punkt2D[] , die Werte f\u00fcr x und y aller Objekte sollen jeweils zuf\u00e4llig mithilfe von Random erzeugt werden. Der Wertebereich ist dabei jeweils [0, ... ,9] (also 0 und 9 inklusive, insgesamt 10 verschiedene Zufallszahlen), - Punkt2D -Objekte d\u00fcrfen nicht doppelt im punkte -Array vorkommen, d.h. es gibt keine zwei Punkte p1 und p2 im punkte -Array f\u00fcr die p1.equals(p2) den Wert true hat. \u00dcberschreiben Sie die Methode toString() , so dass folgende textuelle Rer\u00e4sentation des PunkteArray als String erzeugt wird (Beispielwerte): [ ( 6 ,7 ) , ( 3 ,2 ) , ( 1 ,4 ) , ( 5 ,0 ) , ( 4 ,6 ) , ( 9 ,5 ) , ( 1 ,5 ) , ( 0 ,3 ) , ( 4 ,9 ) , ( 6 ,9 ) , ( 5 ,2 ) , ( 1 ,9 ) , ( 7 ,6 ) , ( 2 ,3 ) , ( 4 ,4 ) ] also alle Punkte in eckigen Klammern durch Komma getrennt. Schreiben Sie eine Objektmethode print() , die den durch toString() erzeugten String auf die Konsole ausgibt. Hinweis: (f\u00fcr die folgenden Methoden) Ein Polygon ist ein geschlossener Linienezug aus Strecken. Die folgende Abbildung zeigt ein Polygon, das aus den Strecken (p1, p2) , (p2, p3) , (p3, p4) , (p4, p5) und (p5, p1) besteht. Es gibt darin also 5 Punkte und 5 Strecken: Schreiben Sie eine Objektmethode createPolygon() , die ein Strecke[] zur\u00fcckgibt. Das Strecke[] ist genau so lang wie das punkte -Array. Das Strecke[] wird mit Objekten vom Typ Strecke vollst\u00e4ndig bef\u00fcllt. Dabei sind die start - und ende -Punkte immer die Nachbarpunkte aus dem punkte -Array. Jeder Punkt aus dem punkte -Array wird also zwei Mal verwendet, einmal als ende -Punkt einer Strecke und einmal als start -Punkt der n\u00e4chsten Strecke im Strecke[] . Beachten Sie, dass der start -Punkt der letzten Strecke im Strecke[] der letzte Punkte im punkte -Array und der ende -Punkt dieser Strecke der erste Punkt im punkte -Array ist - siehe Skizze: Schreiben Sie eine Objektmethode gesamtLaenge() , die die Gesamtl\u00e4nge aller Strecken im Polygon ermittelt und diese als double zur\u00fcckgibt. Tipp: Sie m\u00fcssen sich in der Methode erst mithilfe der createPolygon() -Methode das Polygon erzeugen. Schreiben Sie eine Objektmethode amWeitestenLinks() , die den Punkt2D aus dem punkte -Array zur\u00fcckgibt, der am weitesten links von allen ist (den kleinsten x -Wert von allen hat). Geben Sie diesen Punkt zur\u00fcck. Schreiben Sie eine Objektmethode amWeitestenOben() , die den Punkt2D aus dem punkte -Array zur\u00fcckgibt, der am weitesten oben von allen ist (den kleinsten y -Wert von allen hat). Geben Sie diesen Punkt zur\u00fcck. Schreiben Sie eine Objektmethode laengsteStrecke() , die die l\u00e4ngste Strecke aller Strecken im Polygon ermittelt und diese zur\u00fcckgibt. Tipp: Sie m\u00fcssen sich in der Methode erst mithilfe der createPolygon() -Methode das Polygon erzeugen. Schreiben Sie eine Objektmethode printStrecken() . Diese Methode gibt alle Strecken aus dem Polygon auf die Konsole aus. Au\u00dferdem wird die Gesamtl\u00e4nge aller Strecken aus dem Polygon, der am weitesten links stehende Punkt aus dem punkte -Array und der am weitesten oben stehende Punkt aus dem punkte -Array ausgegeben. Tipp: Sie m\u00fcssen sich in der Methode erst mithilfe der createPolygon() -Methode das Polygon erzeugen. Es sollte folgende Ausgabe erfolgen (Beispielwerte): Strecke [ start =( 0 ,1 ) , ende =( 2 ,1 ) , Laenge = 2 ,0000cm ] Strecke [ start =( 2 ,1 ) , ende =( 5 ,7 ) , Laenge = 6 ,7082cm ] Strecke [ start =( 5 ,7 ) , ende =( 8 ,7 ) , Laenge = 3 ,0000cm ] Strecke [ start =( 8 ,7 ) , ende =( 7 ,4 ) , Laenge = 3 ,1623cm ] Strecke [ start =( 7 ,4 ) , ende =( 8 ,1 ) , Laenge = 3 ,1623cm ] Strecke [ start =( 8 ,1 ) , ende =( 1 ,1 ) , Laenge = 7 ,0000cm ] Strecke [ start =( 1 ,1 ) , ende =( 4 ,6 ) , Laenge = 5 ,8310cm ] Strecke [ start =( 4 ,6 ) , ende =( 2 ,9 ) , Laenge = 3 ,6056cm ] Strecke [ start =( 2 ,9 ) , ende =( 9 ,4 ) , Laenge = 8 ,6023cm ] Strecke [ start =( 9 ,4 ) , ende =( 6 ,8 ) , Laenge = 5 ,0000cm ] Strecke [ start =( 6 ,8 ) , ende =( 9 ,8 ) , Laenge = 3 ,0000cm ] Strecke [ start =( 9 ,8 ) , ende =( 5 ,6 ) , Laenge = 4 ,4721cm ] Strecke [ start =( 5 ,6 ) , ende =( 8 ,4 ) , Laenge = 3 ,6056cm ] Strecke [ start =( 8 ,4 ) , ende =( 6 ,5 ) , Laenge = 2 ,2361cm ] Strecke [ start =( 6 ,5 ) , ende =( 0 ,1 ) , Laenge = 7 ,2111cm ] Gesamtlaenge der Strecken : 68 ,5964cm am weitesten links : ( 0 ,1 ) am weitesten oben : ( 0 ,1 ) laengste : Strecke [ start =( 2 ,9 ) , ende =( 9 ,4 ) , Laenge = 8 ,6023cm ] Testen Sie die Klasse PunkteArray in der Testklasse mit main() -Methode wie folgt: Erzeugen Sie ein Objekt der Klasse PunkteArray und \u00fcbergeben Sie als Anzahl der punkte den Wert 15 . Rufen Sie f\u00fcr diese Objekt die Methoden fillArray() , print() und printStrecken() auf. Es sollten folgende Ausgaben erzeugt werden (Beispielwerte): ------------------ PunkteArray --------------------- [ ( 0 ,1 ) , ( 2 ,1 ) , ( 5 ,7 ) , ( 8 ,7 ) , ( 7 ,4 ) , ( 8 ,1 ) , ( 1 ,1 ) , ( 4 ,6 ) , ( 2 ,9 ) , ( 9 ,4 ) , ( 6 ,8 ) , ( 9 ,8 ) , ( 5 ,6 ) , ( 8 ,4 ) , ( 6 ,5 ) ] Strecke [ start =( 0 ,1 ) , ende =( 2 ,1 ) , Laenge = 2 ,0000cm ] Strecke [ start =( 2 ,1 ) , ende =( 5 ,7 ) , Laenge = 6 ,7082cm ] Strecke [ start =( 5 ,7 ) , ende =( 8 ,7 ) , Laenge = 3 ,0000cm ] Strecke [ start =( 8 ,7 ) , ende =( 7 ,4 ) , Laenge = 3 ,1623cm ] Strecke [ start =( 7 ,4 ) , ende =( 8 ,1 ) , Laenge = 3 ,1623cm ] Strecke [ start =( 8 ,1 ) , ende =( 1 ,1 ) , Laenge = 7 ,0000cm ] Strecke [ start =( 1 ,1 ) , ende =( 4 ,6 ) , Laenge = 5 ,8310cm ] Strecke [ start =( 4 ,6 ) , ende =( 2 ,9 ) , Laenge = 3 ,6056cm ] Strecke [ start =( 2 ,9 ) , ende =( 9 ,4 ) , Laenge = 8 ,6023cm ] Strecke [ start =( 9 ,4 ) , ende =( 6 ,8 ) , Laenge = 5 ,0000cm ] Strecke [ start =( 6 ,8 ) , ende =( 9 ,8 ) , Laenge = 3 ,0000cm ] Strecke [ start =( 9 ,8 ) , ende =( 5 ,6 ) , Laenge = 4 ,4721cm ] Strecke [ start =( 5 ,6 ) , ende =( 8 ,4 ) , Laenge = 3 ,6056cm ] Strecke [ start =( 8 ,4 ) , ende =( 6 ,5 ) , Laenge = 2 ,2361cm ] Strecke [ start =( 6 ,5 ) , ende =( 0 ,1 ) , Laenge = 7 ,2111cm ] Gesamtlaenge der Strecken : 68 ,5964cm am weitesten links : ( 0 ,1 ) am weitesten oben : ( 0 ,1 ) laengste : Strecke [ start =( 2 ,9 ) , ende =( 9 ,4 ) , Laenge = 8 ,6023cm ] Eine m\u00f6gliche L\u00f6sung f\u00fcr Punkt2D, Punkt3D Punkt3D.java package klausurvorbereitung.punkte ; public class Punkt3D { private int x ; private int y ; private int z ; public Punkt3D ( int x , int y , int z ) { this . x = x ; this . y = y ; this . z = z ; } public int getX () { return this . x ; } public int getY () { return this . y ; } public int getZ () { return this . z ; } @Override public String toString () { return String . format ( \"(%d,%d,%d)\" , this . x , this . y , this . z ); } public void print () { System . out . println ( this . toString ()); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Punkt3D p = ( Punkt3D ) o ; return this . x == p . x && this . y == p . y && this . z == p . z ; } public boolean xIsSmaller ( Punkt3D p ) { return this . x < p . x ; } public boolean yIsSmaller ( Punkt3D p ) { return this . y < p . y ; } public boolean zIsSmaller ( Punkt3D p ) { return this . z < p . z ; } } Punkt2D.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package klausurvorbereitung.punkte ; public class Punkt2D extends Punkt3D { public Punkt2D ( int x , int y ) { super ( x , y , 0 ); } @Override public String toString () { return String . format ( \"(%d,%d)\" , this . getX (), this . getY ()); } } Strecke.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package klausurvorbereitung.punkte ; public class Strecke { private Punkt2D start ; private Punkt2D ende ; public Strecke ( Punkt2D start , Punkt2D ende ) { this . start = start ; this . ende = ende ; } public Strecke ( int x1 , int y1 , int x2 , int y2 ) { this . start = new Punkt2D ( x1 , y1 ); this . ende = new Punkt2D ( x2 , y2 ); } public double laenge () { int diffX = Math . abs ( start . getX () - ende . getX ()); int diffY = Math . abs ( start . getY () - ende . getY ()); int diffX2 = diffX * diffX ; int diffY2 = diffY * diffY ; double laenge = Math . sqrt ( diffX2 + diffY2 ); return laenge ; } @Override public String toString () { String s = String . format ( \"Strecke [start=%s, ende=%s, Laenge=%7.4fcm]\" , start . toString (), ende . toString (), this . laenge ()); return s ; } public void print () { System . out . println ( this . toString ()); } } PunkteArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 package klausurvorbereitung.punkte ; import java.util.Random ; public class PunkteArray { private Punkt2D [] punkte ; public PunkteArray ( int anzahl ) { this . punkte = new Punkt2D [ anzahl ] ; } public boolean contains ( Punkt2D p ) { for ( int index = 0 ; index < this . punkte . length ; index ++ ) { if ( this . punkte [ index ] != null && this . punkte [ index ] . equals ( p )) { return true ; } } return false ; } public void fillArray () { Random r = new Random (); for ( int index = 0 ; index < this . punkte . length ; index ++ ) { int x = r . nextInt ( 10 ); int y = r . nextInt ( 10 ); Punkt2D p = new Punkt2D ( x , y ); while ( this . contains ( p )) { x = r . nextInt ( 10 ); y = r . nextInt ( 10 ); p = new Punkt2D ( x , y ); } this . punkte [ index ] = p ; } } @Override public String toString () { String s = \"[ \" ; for ( int index = 0 ; index < this . punkte . length ; index ++ ) { if ( index < this . punkte . length - 1 ) { s += this . punkte [ index ] . toString () + \", \" ; } else { s += this . punkte [ index ] . toString (); } } s += \" ]\" ; return s ; } public void print () { System . out . println ( this . toString ()); } public Strecke [] createPolygon () { Strecke [] polygon = new Strecke [ this . punkte . length ] ; for ( int index = 0 ; index < this . punkte . length - 1 ; index ++ ) { polygon [ index ] = new Strecke ( this . punkte [ index ] , this . punkte [ index + 1 ] ); } int index = this . punkte . length - 1 ; polygon [ index ] = new Strecke ( this . punkte [ index ] , this . punkte [ 0 ] ); return polygon ; } public void printStrecken () { Strecke [] polygon = this . createPolygon (); for ( int index = 0 ; index < polygon . length ; index ++ ) { polygon [ index ] . print (); } System . out . printf ( \"Gesamtlaenge der Strecken : %7.4fcm %n\" , this . gesamtLaenge ()); System . out . printf ( \"am weitesten links : %s %n\" , this . amWeitestenLinks (). toString ()); System . out . printf ( \"am weitesten oben : %s %n\" , this . amWeitestenOben (). toString ()); System . out . printf ( \"laengste : %s %n\" , this . laengsteStrecke (). toString ()); } public double gesamtLaenge () { Strecke [] polygon = this . createPolygon (); double gesamtLaenge = 0.0 ; for ( int index = 0 ; index < polygon . length ; index ++ ) { gesamtLaenge += polygon [ index ] . laenge (); } return gesamtLaenge ; } public Punkt2D amWeitestenLinks () { int indexLinks = 0 ; for ( int index = 0 ; index < this . punkte . length - 1 ; index ++ ) { if ( this . punkte [ index ] . xIsSmaller ( this . punkte [ indexLinks ] )) { indexLinks = index ; } } return this . punkte [ indexLinks ] ; } public Punkt2D amWeitestenOben () { int indexOben = 0 ; for ( int index = 0 ; index < this . punkte . length - 1 ; index ++ ) { if ( this . punkte [ index ] . yIsSmaller ( this . punkte [ indexOben ] )) { indexOben = index ; } } return this . punkte [ indexOben ] ; } public Strecke laengsteStrecke () { Strecke [] polygon = this . createPolygon (); int indexLaengste = 0 ; for ( int index = 0 ; index < polygon . length ; index ++ ) { if ( polygon [ index ] . laenge () > polygon [ indexLaengste ] . laenge ()) { indexLaengste = index ; } } return polygon [ indexLaengste ] ; } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package klausurvorbereitung.punkte ; import java.util.Random ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n---------------- Punkt2D und Punkt3D ---------------%n%n\" ); Random r = new Random (); Punkt2D [] pa = new Punkt2D [ 3 ] ; int anz2D = 0 ; while ( anz2D < 3 ) { int x = r . nextInt ( 10 ); int y = r . nextInt ( 10 ); int z = r . nextInt ( 10 ); Punkt3D p ; if ( z == 0 ) { pa [ anz2D ] = new Punkt2D ( x , y ); pa [ anz2D ] . print (); anz2D ++ ; } else { p = new Punkt3D ( x , y , z ); p . print (); } } System . out . printf ( \"%n%n-------------------- Strecke -----------------------%n%n\" ); Strecke s1 = new Strecke ( pa [ 0 ] , pa [ 1 ] ); Strecke s2 = new Strecke ( pa [ 1 ] , pa [ 2 ] ); Strecke s3 = new Strecke ( pa [ 2 ] , pa [ 0 ] ); s1 . print (); s2 . print (); s3 . print (); System . out . printf ( \"%n%n------------------ PunkteArray ---------------------%n%n\" ); PunkteArray parr = new PunkteArray ( 15 ); parr . fillArray (); parr . print (); parr . printStrecken (); } } Wohnung Erstellen Sie ein package klausurvorbereitung.wohnung . Erstellen Sie in diesem package eine Klasse Wohnung mit den privaten Objektvariablen - qm vom Typ int , (entspricht der Gr\u00f6\u00dfe der Wohnung in m^2) - anzZimmer vom Typ int , - etage vom Typ int und - qmMiete vom Typ double (entspricht dem Mietpreis pro m^2). einem parametrisierten Konstruktor Wohnung(int qm, int anzZimmer, int etage, double qmMiete). Die Werte der Parameter werden verwendet, um den Objektvariablen Werte zuzuweisen. Gettern f\u00fcr alle Objektvariablen ( getQm() , getAnzZimmer() , getEtage() , getQmMiete() ) einer Objektmethode gesamtMiete() , die die Gesamtmiete der Wohnung berechnet ( qm * qmMiete ) und diesen double -Wert zur\u00fcckgibt. einer Objektmethode billiger(Wohnung w) , die ein true zur\u00fcckgibt, wenn die Gesamtmiete des aufrufenden Objektes kleiner ist als die Gesamtmiete von w ; false sonst. einer Objektmethode teurer(Wohnung w) , die ein true zur\u00fcckgibt, wenn die Gesamtmiete des aufrufenden Objektes gr\u00f6\u00dfer ist als die Gesamtmiete von w ; false sonst. einer Objektmethode toString() die Details der Wohnung in folgender Form (ab inkl. 1. Etage aufw\u00e4rts) als String zur\u00fcckgibt (Beispielwerte): 2 -Zimmer Wohnung mit 40 qm in der 4 . Etage. Monatliche Miete: 360 .00 Euro Achtung! Sollte sich die Wohnung in der 0.Etage befinden, geben Sie die Details bitte wie folgt zur\u00fcck (Beispielwerte): 1 -Zimmer Wohnung mit 60 qm im Erdgeschoss. Monatliche Miete: 750 .00 Euro ` und einer Objektmethode print() , die den von toString() zur\u00fcckgegebenen String auf der Konsole ausgibt Erstellen Sie im gleichen package eine Klasse Testklasse mit main() -Methode. Geben Sie in der main() -Methode Folgendes ein: System . out . printf ( \"%n%n--------------------- Test Wohnung -------------------------%n%n\" ); Wohnung w1 = new Wohnung ( 70 , 3 , 4 , 12.50 ); Wohnung w2 = new Wohnung ( 40 , 1 , 0 , 9.50 ); Wohnung w3 = new Wohnung ( 90 , 4 , 2 , 11.10 ); Wohnung w4 = new Wohnung ( 60 , 2 , 0 , 9.00 ); w1 . print (); w2 . print (); w3 . print (); w4 . print (); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: --------------------- Test Wohnung ------------------------- 3 -Zimmer Wohnung mit 70qm in der 4 . Etage. Monatliche Miete: 875 ,00 Euro 1 -Zimmer Wohnung mit 40qm im Erdgeschoss. Monatliche Miete: 380 ,00 Euro 4 -Zimmer Wohnung mit 90qm in der 2 . Etage. Monatliche Miete: 999 ,00 Euro 2 -Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 540 ,00 Euro Erstellen Sie im gleichen package eine Klasse Dachgeschosswohnung . Diese erbt von Wohnung . Implementieren Sie einen parametrisierten Konstruktor Dachgeschosswohnung(int qm, int anzZimmer, double qmMiete) . Bei Aufruf des Konstruktors werden die entsprechenden Objektvariablen mit den Parameterwerten initialisiert. Die Objektvariable etage bekommt stets den Wert 5 . \u00dcberschreiben Sie die Methode toString() , so dass eine Zeichenkette der Form (Beispielwerte) 4 -Zimmer DG-Wohnung mit 100 qm in der 5 . Etage. Monatliche Miete: 1250 .00 Euro zur\u00fcckgegeben wird. F\u00fcgen Sie in der main() -Methode der Testklasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n--------------- Test Dachgeschosswohnung -------------------%n%n\" ); Dachgeschosswohnung dg1 = new Dachgeschosswohnung ( 70 , 3 , 15.50 ); Dachgeschosswohnung dg2 = new Dachgeschosswohnung ( 100 , 4 , 17.25 ); dg1 . print (); dg2 . print (); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: --------------- Test Dachgeschosswohnung ------------------- 3 -Zimmer DG-Wohnung mit 70qm in der 5 . Etage. Monatliche Miete: 1085 ,00 Euro 4 -Zimmer DG-Wohnung mit 100qm in der 5 . Etage. Monatliche Miete: 1725 ,00 Euro Erstellen Sie im gleichen package eine Klasse Haus . Objektvariable ist wohnungen vom Typ Wohnung[] und nur in der Klasse sichtbar. Implementieren Sie eine Objektmethode neueWohnung() . Diese Methode gibt ein Objekt vom Typ Wohnung zur\u00fcck. In dieser Methode wird zun\u00e4chst ein Random -Objekt erzeugt. Mithilfe dieses Random -Objektes und der Objektmethode nextInt(int bound) der Klasse Random sollen zun\u00e4chst nacheinander folgende Werte zuf\u00e4llig erzeugt werden: Ein Wert f\u00fcr eine Quadratmeteranzahl qm aus dem Wertebereich [20, 40, 60, 80, 100] ( \u2192 also zuf\u00e4llig eine dieser 5 Zahlen), Ein Wert f\u00fcr die Anzahl der Zimmer anzZimmer aus dem Wertebereich [1, 2, 3, 4, 5] ( \u2192 also zuf\u00e4llig eine dieser 5 Zahlen), Ein Wert f\u00fcr die Etage etage aus dem Wertebereich [0, 1, 2, 3, 4, 5] ( \u2192 also zuf\u00e4llig eine dieser 6 Zahlen), Ein Wert f\u00fcr den Mietpreis pro Quadratmeter qmMiete aus dem Wertebereich [8.0, 8.5, 9.0, 9.5, 10.0, 10.5, 11.0, 11.5, 12.0, 12.5] ( \u2192 also zuf\u00e4llig eine dieser 10 Zahlen \u2013 Achtung hier double , Sie k\u00f6nnen aber trotzdem nextInt(int bound) verwenden, m\u00fcssen dann aber geeignet multiplizieren und addieren). Erzeugen Sie mit diesen Werten ein neues Wohnung -Objekt und geben Sie dieses Objekt zur\u00fcck. Implementieren Sie einen parametrisierten Konstruktor Haus(int anzWohnungen) . Darin wird das wohnungen -Array erzeugt. Die L\u00e4nge von wohnungen entspricht dem Wert von anzWohnungen . Bef\u00fcllen Sie das wohnungen -Array vollst\u00e4ndig mit Objekten vom Typ Wohnungen . Rufen Sie dazu f\u00fcr jedes Element des wohnungen -Arrays die Objektmethode neueWohnung() auf. Tipp : Jedes Element des wohnungen -Arrays ist nach dem Bef\u00fcllen mit Objekten vom Typ Wohnung eine Referenzvariable auf ein Wohnung -Objekt, d.h. z.B. ist this.wohnungen[0] vom Typ Wohnung und zeigt auf ein Wohnung -Objekt. Die folgende Abbildung verdeutlicht das f\u00fcr den Fall, dass das wohnungen -Array die L\u00e4nge 10 hat: Implementieren Sie eine Objektmethode print() . Bei Aufruf der Methode soll das wohnungen -Array wie folgt ausgegeben werden (Beispielwerte f\u00fcr Array-L\u00e4nge 5 :) Das Haus besteht aus : 5 -Zimmer Wohnung mit 80qm im Erdgeschoss. Monatliche Miete: 1000 ,00 Euro 4 -Zimmer Wohnung mit 60qm in der 5 . Etage. Monatliche Miete: 480 ,00 Euro 2 -Zimmer Wohnung mit 80qm in der 5 . Etage. Monatliche Miete: 880 ,00 Euro 5 -Zimmer Wohnung mit 100qm in der 2 . Etage. Monatliche Miete: 1100 ,00 Euro 3 -Zimmer Wohnung mit 80qm im Erdgeschoss. Monatliche Miete: 920 ,00 Euro F\u00fcgen Sie in der main() -Methode der Testklasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n---------------------- Test Haus ---------------------------%n%n\" ); Haus h1 = new Haus ( 10 ); h1 . print (); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden (Zufallswerte!): ---------------------- Test Haus --------------------------- Das Haus besteht aus : 1 -Zimmer Wohnung mit 80qm in der 4 . Etage. Monatliche Miete: 840 ,00 Euro 3 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 4 -Zimmer Wohnung mit 80qm in der 3 . Etage. Monatliche Miete: 1000 ,00 Euro 5 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 2 -Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 510 ,00 Euro 3 -Zimmer Wohnung mit 60qm in der 4 . Etage. Monatliche Miete: 600 ,00 Euro 4 -Zimmer Wohnung mit 20qm in der 3 . Etage. Monatliche Miete: 250 ,00 Euro 4 -Zimmer Wohnung mit 100qm in der 5 . Etage. Monatliche Miete: 850 ,00 Euro 5 -Zimmer Wohnung mit 20qm in der 2 . Etage. Monatliche Miete: 160 ,00 Euro 2 -Zimmer Wohnung mit 40qm in der 2 . Etage. Monatliche Miete: 400 ,00 Euro Zusatz: Erweitern Sie die Klasse Haus um folgende Objektmethoden: eine Objektmethode wohnungenInEtage(int etage) . Diese Methode gibt ein Wohnung[] -Array zur\u00fcck. Das zur\u00fcckgegebene Wohnung[] -Array soll alle Wohnungen aus dem wohnungen -Array enthalten, die in der Etage liegen, die der Methode als Parameter \u00fcbergeben wird ( etage ). Befindet sich keine Wohnung in der als Parameter \u00fcbergeben Etage, so wird ein Wohnung[] -Array der L\u00e4nge 0 zur\u00fcckgegeben. eine Objektmethode print(Wohnung[] warr) . Diese Methode gibt das als Parameter \u00fcbergebene warr -Array auf der Konsole aus, in der Form (Bsp.:): 2 -Zimmer Wohnung mit 100 qm in der 2 . Etage. Monatliche Miete: 1250 .00 Euro 5 -Zimmer Wohnung mit 100 qm in der 2 . Etage. Monatliche Miete: 1000 .00 Euro Testen der beiden Methoden in main() : System . out . printf ( \"%n%n----- Test wohnungenInEtage() und print(Wohnung[]) ---------%n%n\" ); for ( int etage = 0 ; etage < 6 ; etage ++ ) { System . out . println ( \"Etage \" + etage + \" ---------------------------------------\" ); h1 . print ( h1 . wohnungenInEtage ( etage )); System . out . println (); } sollte folgende Ausgbabe erzeugen (Zufallswerte): ----- Test wohnungenInEtage () und print ( Wohnung []) --------- Etage 0 --------------------------------------- 2 -Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 510 ,00 Euro Etage 1 --------------------------------------- Etage 2 --------------------------------------- 5 -Zimmer Wohnung mit 20qm in der 2 . Etage. Monatliche Miete: 160 ,00 Euro 2 -Zimmer Wohnung mit 40qm in der 2 . Etage. Monatliche Miete: 400 ,00 Euro Etage 3 --------------------------------------- 3 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 4 -Zimmer Wohnung mit 80qm in der 3 . Etage. Monatliche Miete: 1000 ,00 Euro 5 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 4 -Zimmer Wohnung mit 20qm in der 3 . Etage. Monatliche Miete: 250 ,00 Euro Etage 4 --------------------------------------- 1 -Zimmer Wohnung mit 80qm in der 4 . Etage. Monatliche Miete: 840 ,00 Euro 3 -Zimmer Wohnung mit 60qm in der 4 . Etage. Monatliche Miete: 600 ,00 Euro Etage 5 --------------------------------------- 4 -Zimmer Wohnung mit 100qm in der 5 . Etage. Monatliche Miete: 850 ,00 Euro eine Objektmethode teuersteWohnung() . Diese Methode gibt die Wohnung aus dem wohnungen -Array zur\u00fcck, die die h\u00f6chste Gesamtmiete von allen Wohnungen aus dem wohnungen -Array hat. Testen der Methode in main() : System . out . printf ( \"%n%n--------------- Test teuersteWohnung() ---------------------%n%n\" ); Wohnung teuerste = h1 . teuersteWohnung (); teuerste . print (); sollte folgende Ausgbabe erzeugen (Zufallswerte): --------------- Test teuersteWohnung () --------------------- 4 -Zimmer Wohnung mit 80qm in der 3 . Etage. Monatliche Miete: 1000 ,00 Euro eine Objektmethode gesamtMieteHaus() . Diese Methode gibt die Summe der Mieten aller Wohnungen im wohnungen -Array als double zur\u00fcck. Testen der Methode in main() : System . out . printf ( \"%n%n---------------- Test gesamtMieteHaus() --------------------%n%n\" ); System . out . printf ( \"Die Gesamtmiete fuer das Haus betraegt %.2f Euro.%n\" , h1 . gesamtMieteHaus ()); sollte folgende Ausgbabe erzeugen (Zufallswerte): ---------------- Test gesamtMieteHaus () -------------------- Die Gesamtmiete fuer das Haus betraegt 5690 ,00 Euro. eine Objektmethode sortieren() . Diese Methode sortiert das wohnungen -Array nach Gesamtmieten aufsteigend (beginnend mit der billigsten Wohnung und endend mit der teuersten). Testen der Methode in main() : System . out . printf ( \"%n%n------------------- Test sortieren() -----------------------%n%n\" ); h1 . sortieren (); h1 . print (); sollte folgende Ausgbabe erzeugen (Zufallswerte): ------------------- Test sortieren () ----------------------- Das Haus besteht aus : 5 -Zimmer Wohnung mit 20qm in der 2 . Etage. Monatliche Miete: 160 ,00 Euro 4 -Zimmer Wohnung mit 20qm in der 3 . Etage. Monatliche Miete: 250 ,00 Euro 2 -Zimmer Wohnung mit 40qm in der 2 . Etage. Monatliche Miete: 400 ,00 Euro 2 -Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 510 ,00 Euro 3 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 5 -Zimmer Wohnung mit 60qm in der 3 . Etage. Monatliche Miete: 540 ,00 Euro 3 -Zimmer Wohnung mit 60qm in der 4 . Etage. Monatliche Miete: 600 ,00 Euro 1 -Zimmer Wohnung mit 80qm in der 4 . Etage. Monatliche Miete: 840 ,00 Euro 4 -Zimmer Wohnung mit 100qm in der 5 . Etage. Monatliche Miete: 850 ,00 Euro 4 -Zimmer Wohnung mit 80qm in der 3 . Etage. Monatliche Miete: 1000 ,00 Euro Eine m\u00f6gliche L\u00f6sung f\u00fcr Wohnung Wohnung.java package klausurvorbereitung.wohnung ; public class Wohnung { private int qm ; private int anzZimmer ; private int etage ; private double qmMiete ; public Wohnung ( int qm , int anzZimmer , int etage , double qmMiete ) { this . qm = qm ; this . anzZimmer = anzZimmer ; this . etage = etage ; this . qmMiete = qmMiete ; } public int getQm () { return this . qm ; } public int getAnzZimmer () { return this . anzZimmer ; } public int getEtage () { return this . etage ; } public double getQmMiete () { return this . qmMiete ; } public double gesamtMiete () { return this . qm * this . qmMiete ; } public boolean billiger ( Wohnung w ) { return this . gesamtMiete () < w . gesamtMiete (); } public boolean teurer ( Wohnung w ) { return this . gesamtMiete () > w . gesamtMiete (); } public String toString () { String s = \"\" ; if ( this . etage == 0 ) { s = String . format ( \"%d-Zimmer Wohnung mit %d qm im Erdgeschoss. Monatliche Miete: %.2f Euro\" , this . anzZimmer , this . qm , this . gesamtMiete () ); } else { s = String . format ( \"%d-Zimmer Wohnung mit %d qm in der %d. Etage. Monatliche Miete: %.2f Euro\" , this . anzZimmer , this . qm , this . etage , this . gesamtMiete () ); } return s ; } public void print () { System . out . println ( this . toString ()); } } Dachgeschoss.java package klausurvorbereitung.wohnung ; public class Dachgeschosswohnung extends Wohnung { // alle Objektvariablen von Wohnung geerbt // qm, anzZimmer, etage, qmMiete // alle Objektmethoden von Wohnung geerbt public Dachgeschosswohnung ( int qm , int anzZimmer , double qmMiete ) { super ( qm , anzZimmer , 5 , qmMiete ); // Konstruktor Wohnung } @Override public String toString () { String s = \"\" ; s = String . format ( \"%d-Zimmer Wohnung mit %d qm in der %d. Etage. Monatliche Miete: %.2f Euro\" , this . getAnzZimmer (), this . getQm (), this . getEtage (), this . gesamtMiete () ); return s ; } } Haus.java package klausurvorbereitung.wohnung ; import java.util.Random ; public class Haus { private Wohnung [] wohnungen ; public Wohnung neueWohnung () { Random r = new Random (); int qm = r . nextInt ( 5 ) * 20 + 20 ; int anzZimmer = r . nextInt ( 5 ) + 1 ; int etage = r . nextInt ( 6 ); double qmMiete = r . nextInt ( 10 ) * 0.5 + 8.0 ; return new Wohnung ( qm , anzZimmer , etage , qmMiete ); } public Haus ( int anzWohnungen ) { this . wohnungen = new Wohnung [ anzWohnungen ] ; for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { this . wohnungen [ index ] = this . neueWohnung (); } } public void print () { System . out . println ( \"Das Haus besteht aus :\" ); for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { this . wohnungen [ index ] . print (); // print()-Methode von Wohnung } } public Wohnung [] wohnungenInEtage ( int etage ) { int anzWohnungenInEtage = 0 ; for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { if ( this . wohnungen [ index ] . getEtage () == etage ) { anzWohnungenInEtage ++ ; } } Wohnung [] wohnungenInEtage = new Wohnung [ anzWohnungenInEtage ] ; int indexWIE = 0 ; for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { if ( this . wohnungen [ index ] . getEtage () == etage ) { wohnungenInEtage [ indexWIE ] = this . wohnungen [ index ] ; indexWIE ++ ; } } return wohnungenInEtage ; } public void print ( Wohnung [] warr ) { for ( int index = 0 ; index < warr . length ; index ++ ) { warr [ index ] . print (); // print()-Methode von Wohnung } } public Wohnung teuersteWohnung () { int indexMax = 0 ; for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { if ( this . wohnungen [ index ] . teurer ( this . wohnungen [ indexMax ] )) { indexMax = index ; } } return this . wohnungen [ indexMax ] ; } public double gesamtMieteHaus () { double gesamtMieteHaus = 0.0 ; for ( int index = 0 ; index < this . wohnungen . length ; index ++ ) { gesamtMieteHaus = gesamtMieteHaus + this . wohnungen [ index ] . gesamtMiete (); } return gesamtMieteHaus ; } public void sortieren () { for ( int bubble = 1 ; bubble < this . wohnungen . length ; bubble ++ ) { for ( int index = 0 ; index < this . wohnungen . length - bubble ; index ++ ) { if ( this . wohnungen [ index ] . teurer ( this . wohnungen [ index + 1 ] )) { Wohnung tmp = this . wohnungen [ index ] ; this . wohnungen [ index ] = this . wohnungen [ index + 1 ] ; this . wohnungen [ index + 1 ] = tmp ; } } } } } Testklasse.java package klausurvorbereitung.wohnung ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n--------------------- Test Wohnung -------------------------%n%n\" ); Wohnung w1 = new Wohnung ( 70 , 3 , 4 , 12.50 ); Wohnung w2 = new Wohnung ( 40 , 1 , 0 , 9.50 ); Wohnung w3 = new Wohnung ( 90 , 4 , 2 , 11.10 ); Wohnung w4 = new Wohnung ( 60 , 2 , 0 , 9.00 ); w1 . print (); w2 . print (); w3 . print (); w4 . print (); System . out . printf ( \"%n%n--------------- Test Dachgeschosswohnung -------------------%n%n\" ); Dachgeschosswohnung dg1 = new Dachgeschosswohnung ( 70 , 3 , 15.50 ); Dachgeschosswohnung dg2 = new Dachgeschosswohnung ( 100 , 4 , 17.25 ); dg1 . print (); dg2 . print (); System . out . printf ( \"%n%n---------------------- Test Haus ---------------------------%n%n\" ); Haus h1 = new Haus ( 10 ); h1 . print (); System . out . printf ( \"%n%n----- Test wohnungenInEtage() und print(Wohnung[]) ---------%n%n\" ); for ( int etage = 0 ; etage < 6 ; etage ++ ) { System . out . println ( \"Etage \" + etage + \" ---------------------------------------\" ); h1 . print ( h1 . wohnungenInEtage ( etage )); System . out . println (); } System . out . printf ( \"%n%n--------------- Test teuersteWohnung() ---------------------%n%n\" ); Wohnung teuerste = h1 . teuersteWohnung (); teuerste . print (); System . out . printf ( \"%n%n---------------- Test gesamtMieteHaus() --------------------%n%n\" ); System . out . printf ( \"Die Gesamtmiete fuer das Haus betraegt %.2f Euro.%n\" , h1 . gesamtMieteHaus ()); System . out . printf ( \"%n%n------------------- Test sortieren() -----------------------%n%n\" ); h1 . sortieren (); h1 . print (); } } Video zu Wohnung Pizza Erstellen Sie ein package klausurvorbereitung.pizza . Erstellen Sie in diesem package eine Klasse Pizza mit den privaten Objektvariablen - name vom Typ String und - preis vom Typ float . einem parametrisierten Konstruktor Pizza(String name, float preis) . Die Werte der Parameter werden verwendet, um den Objektvariablen Werte zuzuweisen. Gettern f\u00fcr die Objektvariablen ( getName() , getPreis() ) \u00dcberschreiben Sie die Objektmethode toString() , die Details der Pizza in folgender Form als String zur\u00fcckgibt (Beispielwerte): Die Pizza Salami kostet 6 .90 Euro. und einer Objektmethode print() , die den von toString() zur\u00fcckgegebenen String auf der Konsole ausgibt. \u00dcberschreiben Sie die Objektmethode equals(Object o) . Diese Methode gibt true zur\u00fcck, wenn der Name name des aufrufenden Objektes gleich dem Namen name des als Parameter \u00fcbergebenen Objektes ist; false sonst. Tipp : Die Gleichheit von zwei Strings s1 und s2 k\u00f6nnen Sie mithilfe von s1.equals(s2) ermitteln. ( hashCode() muss nicht \u00fcberschrieben werden). Erstellen Sie im gleichen package eine Klasse Testklasse mit main() -Methode. Geben Sie in der main() -Methode Folgendes ein: System . out . printf ( \"%n%n------------------------- Test Pizza ---------------------------%n%n\" ); Pizza p1 = new Pizza ( \"Salami\" , 6.9f ); Pizza p2 = new Pizza ( \"Margheritha\" , 5.9f ); Pizza p3 = new Pizza ( \"Tonno\" , 6.9f ); Pizza p4 = new Pizza ( \"Hawaii\" , 6.9f ); Pizza p5 = new Pizza ( \"Calzone\" , 7.9f ); Pizza p6 = new Pizza ( \"Salami\" , 6.9f ); p1 . print (); p2 . print (); p3 . print (); p4 . print (); p5 . print (); System . out . println ( \"p1 gleich p2 ? : \" + p1 . equals ( p2 )); System . out . println ( \"p1 gleich p1 ? : \" + p1 . equals ( p1 )); System . out . println ( \"p1 gleich p6 ? : \" + p1 . equals ( p6 )); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: ------------------------- Test Pizza --------------------------- Die Pizza Salami kostet 6 ,90 Euro. Die Pizza Margheritha kostet 5 ,90 Euro. Die Pizza Tonno kostet 6 ,90 Euro. Die Pizza Hawaii kostet 6 ,90 Euro. Die Pizza Calzone kostet 7 ,90 Euro. p1 gleich p2 ? : false p1 gleich p1 ? : true p1 gleich p6 ? : true Erstellen Sie im gleichen package eine Klasse Pizzaverkauf mit den privaten Objektvariablen - pizza vom Typ Pizza und - anzVerkaeufe vom Typ int . einem parametrisierten Konstruktor Pizzaverkauf(Pizza pizza) . Mit dem Parameterwert pizza wird die Objektvariable pizza initialisiert. Der Wert der Objektvariablen anzVerkaeufe wird auf 0 gesetzt. einer Objektmethode verkaufen() . Darin wird der Wert der Objektvariablen anzVerkaeufe um 1 erh\u00f6ht. Gettern f\u00fcr die Objektvariablen, also getAnzVerkaeufe() und getPizza() . einer Objektmethode umsatz() . Diese Methode gibt ein double zur\u00fcck. Der Wert berechnet sich aus der Anzahl der Verk\u00e4ufe der Pizza ( anzVerkaeufe ) mal dem Preis der Pizza. einer Objektmethode toString() die Details der Pizzaverkaeufe in folgender Form als String zur\u00fcckgibt (Beispielwerte): Pizza Salami wurde 0 mal zum Preis von 6 .90 Euro verkauft. und einer Objektmethode print() , die den von toString() zur\u00fcckgegebenen String auf der Konsole ausgibt F\u00fcgen Sie in der main() -Methode der Testklasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n--------------------- Test Pizzaverkauf ------------------------%n%n\" ); Pizzaverkauf pv1 = new Pizzaverkauf ( p1 ); pv1 . print (); pv1 . verkaufen (); pv1 . print (); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: --------------------- Test Pizzaverkauf ------------------------ Pizza Salami wurde 0 mal zum Preis von 6 ,90 Euro verkauft. Pizza Salami wurde 1 mal zum Preis von 6 ,90 Euro verkauft. Erstellen Sie im gleichen package eine Klasse Speisekarte mit der privaten Objektvariablen - angebot vom Typ Pizza[] einem parameterlosen Konstruktor Speisekarte() . In diesem Konstruktor wird f\u00fcr angebot ein Pizza -Array der L\u00e4nge 0 erzeugt. einer Objektmethode pizzaHinzufuegen(Pizza pizza) . Diese Methode f\u00fcgt die als Parameter \u00fcbergebene pizza dem angebot-Array hinzu. Beachten Sie: Um dem angebot -Array eine neue Pizza hinzuzuf\u00fcgen, muss die L\u00e4nge des Arrays um 1 erh\u00f6ht werden. - Kopieren Sie sich dazu das alte angebot -Array. - Erzeugen Sie dann ein neues angebot -Array, das um 1 l\u00e4nger ist als das alte. - Kopieren Sie das bisherige Angebot zur\u00fcck in das neue angebot -Array. - F\u00fcgen Sie die neue Pizza (Parameter pizza ) als letztes Element im neuen angebot -Array hinzu. einer Objektmethode getLength() . Diese Methode gibt die L\u00e4nge des angebot -Arrays zur\u00fcck. einer Objektmethode pizzaIstImAngebot(Pizza pizza) . Diese Methode gibt ein true zur\u00fcck, wenn die als Parameter \u00fcbergebene pizza im angebot -Array enthalten ist. Pr\u00fcfen Sie die Gleichheit mithilfe der equals() -Methode von Pizza . einer Objektmethode pizzaLoeschen(Pizza pizza) . Diese Methode l\u00f6scht die als Parameter \u00fcbergebene pizza aus dem angebot -Array (wenn Sie darin enthalten ist). Beachten Sie: Nach dem L\u00f6schen der Pizza aus dem angebot -Array soll das angebot -Array wieder um 1 kleiner sein als vorher (falls die zu l\u00f6schende Pizza \u00fcberhaupt im angebot -Array enthalten war). - Kopieren Sie also das alte angebot -Array au\u00dfer die zu l\u00f6schende Pizza. - Ihre Kopie ist dann das neue angebot -Array. einer Objektmethode getPizzaAtIndex(int index) . Diese Methode gibt die Pizza zur\u00fcck, die im angebot -Array beim Index index eingetragen ist. Pr\u00fcfen Sie, ob der \u00fcbergebene Parameter ein g\u00fcltiger Index aus dem angebot -Array ist. Wenn nicht, geben Sie null zur\u00fcck. \u00dcberschreiben Sie die Objektmethode toString() , die die Details der Speisekarte in folgender Form als String zur\u00fcckgibt (Beispielwerte): ====== Speisekarte ====== Salami 6 ,90 Euro Margheritha 5 ,90 Euro Tonno 6 ,90 Euro Hawaii 6 ,90 Euro Calzone 7 ,90 Euro und einer Objektmethode print() , die den von toString() zur\u00fcckgegebenen String auf der Konsole ausgibt F\u00fcgen Sie in der main() -Methode der Testklasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n--------------------- Test Speisekarte -------------------------%n%n\" ); Speisekarte s1 = new Speisekarte (); s1 . pizzaHinzufuegen ( p1 ); s1 . pizzaHinzufuegen ( p2 ); s1 . pizzaHinzufuegen ( p3 ); s1 . pizzaHinzufuegen ( p4 ); s1 . pizzaHinzufuegen ( p5 ); s1 . print (); s1 . pizzaLoeschen ( p3 ); s1 . print (); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: --------------------- Test Speisekarte ------------------------- ====== Speisekarte ====== Salami 6 ,90 Euro Margheritha 5 ,90 Euro Tonno 6 ,90 Euro Hawaii 6 ,90 Euro Calzone 7 ,90 Euro ====== Speisekarte ====== Salami 6 ,90 Euro Margheritha 5 ,90 Euro Hawaii 6 ,90 Euro Calzone 7 ,90 Euro Zusatz Erstellen Sie im gleichen package eine Klasse Pizzaria mit einem parametrisierten Konstruktor Pizzeria(Speisekarte karte) . In diesem Konstruktor wird der privaten Objektvariablen - verkaeufe vom Typ Pizzaverkauf[] . das verkaeufe -Array erzeugt und hat die gleiche L\u00e4nge wie das angebot -Array der Speisekarte karte (siehe getLength() -Methode aus Speisekarte ). - jedes Element des verkaeufe -Arrays zeigt auf ein Pizzaverkauf -Objekt. Erzeugen Sie alle Pizzaverkauf -Objekte. \u00dcbergeben Sie dem Pizzaverkauf -Konstruktor dazu die jeweiligen Pizza -Objekte aus der Speisekarte karte . einer Objektmethode bestellen() . Diese Methode gibt ein int zur\u00fcck. In dieser Methode soll zuf\u00e4llig ein Index aus dem verkaeufe -Array erzeugt werden. Nutzen Sie dazu die Klasse Random aus dem java.util -Paket. Verwenden Sie die Objektmethode nextInt(int bound) der Klasse Random . Wenden Sie nextInt() so an, dass auch tats\u00e4chlich ein g\u00fcltiger Index des verkaeufe -Arrays erzeugt wird. Geben Sie diesen zuf\u00e4llig erzeugten Index zur\u00fcck (das Bestellen entspricht also dem Nennen einer Nummer aus der Speisekarte). einer Objektmethode verkaufen(int index) . Durch den Aufruf der Methode wird die Pizza verkauft, die im verkaeufe -Array am Index index steht. Nutzen Sie f\u00fcr den Verkauf die verkaufen() -Methode der Klasse Pizzaverkauf. \u00dcberpr\u00fcfen Sie, ob der als Parameter \u00fcbergebene Wert f\u00fcr index tats\u00e4chlich einem Index im verkaeufe -Array entspricht. einer Objektmethode tagesVerkauf(int anzVerkaeufe) . In dieser Methode wird anzVerkaeufe oft eine Pizza verkauft ( verkaufen(int index) ). Welche Pizza verkauft wird (also welcher index ), wird durch die Methode bestellen() jeweils zuf\u00e4llig ermittelt. einer Objektmethode print() . Diese Methode erzeugt folgende Ausgabe (Beispielwerte): Salami : *********************************** Margheritha : ************************************ Hawaii : ***************************************** Calzone : ************************************** Das hei\u00dft, es wird am Anfang der Zeile der Name der Pizza aus dem verkaeufe -Array ausgegeben und danach f\u00fcr die Anzahl der Verk\u00e4ufe jeweils ein * . einer Objektmethode meistverkauftePizza() . Diese Methode gibt die Pizza aus dem verkaeufe -Array zur\u00fcck, die am meisten verkauft wurde. einer Objektmethode gesamtEinnahmen() . Diese Methode gibt die Summe aller Einnahmen als double zur\u00fcck. Die Einnahmen ergeben sich aus der Summe der Ums\u00e4tze aller Pizzen (Methode umsatz() von Pizzaverkauf ) aus dem verkaeufe -Array. F\u00fcgen Sie in der main() -Methode der Testklasse folgende Anweisungen hinzu: System . out . printf ( \"%n%n------------------------ Test Pizzaria -------------------------%n%n\" ); Pizzeria pz1 = new Pizzeria ( s1 ); pz1 . tagesVerkauf ( 150 ); pz1 . print (); System . out . println (); System . out . print ( \"Meistverkaufte Pizza : \" ); pz1 . meistverkauftePizza (). print (); System . out . printf ( \"Die Gesamteinnahmen betragen %.2f Euro\" , pz1 . gesamtEinnahmen ()); und f\u00fchren Sie die Testklasse aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden (Zufallswerte): ------------------------ Test Pizzaria ------------------------- Salami : ****************************** Margheritha : ******************************************* Hawaii : ******************************************* Calzone : ********************************** Meistverkaufte Pizza : Die Pizza Margheritha kostet 5 ,90 Euro. Die Gesamteinnahmen betragen 1026 ,00 Euro Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 9 Pizza.java package klausurvorbereitung.pizza ; public class Pizza { private String name ; private float preis ; public Pizza ( String name , float preis ) { this . name = name ; this . preis = preis ; } public String getName () { return this . name ; } public float getPreis () { return this . preis ; } @Override public String toString () { return String . format ( \"Die Pizza %s kostet %.2f Euro.\" , this . name , this . preis ); } public void print () { System . out . println ( this . toString ()); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Pizza po = ( Pizza ) o ; return ( this . name . equals ( po . name )); } } Pizzaverkauf.java package klausurvorbereitung.pizza ; public class Pizzaverkauf { private Pizza pizza ; private int anzVerkaeufe ; public Pizzaverkauf ( Pizza pizza ) { this . pizza = pizza ; this . anzVerkaeufe = 0 ; } public void verkaufen () { this . anzVerkaeufe ++ ; } public Pizza getPizza () { return this . pizza ; } public int getAnzVerkaeufe () { return this . anzVerkaeufe ; } public double umsatz () { return this . anzVerkaeufe * this . pizza . getPreis (); } @Override public String toString () { return String . format ( \"Pizza %s wurde %d mal zum Preis von %.2f Euro verkauft.\" , this . pizza . getName (), this . anzVerkaeufe , this . pizza . getPreis ()); } public void print () { System . out . println ( this . toString ()); } } Speisekarte.java package klausurvorbereitung.pizza ; public class Speisekarte { private Pizza [] angebot ; public Speisekarte () { this . angebot = new Pizza [ 0 ] ; } public int getLength () { return this . angebot . length ; } public void pizzaHinzufuegen ( Pizza pizza ) { Pizza [] kopie = new Pizza [ this . angebot . length + 1 ] ; for ( int index = 0 ; index < this . angebot . length ; index ++ ) { kopie [ index ] = this . angebot [ index ] ; } kopie [ kopie . length - 1 ] = pizza ; this . angebot = kopie ; } public boolean pizzaIstImAngebot ( Pizza pizza ) { for ( int index = 0 ; index < this . angebot . length ; index ++ ) { if ( this . angebot [ index ] . equals ( pizza )) { return true ; } } return false ; // System.out.println(\"dead code\"); } public void pizzaLoeschen ( Pizza pizza ) { if ( this . pizzaIstImAngebot ( pizza )) { Pizza [] kopie = new Pizza [ this . angebot . length - 1 ] ; int indexKopie = 0 ; for ( int indexAngebot = 0 ; indexAngebot < this . angebot . length ; indexAngebot ++ ) { if ( ! this . angebot [ indexAngebot ] . equals ( pizza )) { kopie [ indexKopie ] = this . angebot [ indexAngebot ] ; indexKopie ++ ; } } this . angebot = kopie ; } } public Pizza getPizzaAtIndex ( int index ) { if ( index >= 0 && index < this . angebot . length ) { return this . angebot [ index ] ; } else { return null ; } } @Override public String toString () { String s = String . format ( \"====== Speisekarte ======%n\" ); for ( int index = 0 ; index < this . angebot . length ; index ++ ) { s = s + String . format ( \"%-15s %.2f Euro %n\" , this . angebot [ index ] . getName (), this . angebot [ index ] . getPreis ()); } return s ; } public void print () { System . out . println ( this . toString ()); } } Pizzeria.java package klausurvorbereitung.pizza ; import java.util.Random ; public class Pizzeria { private Pizzaverkauf [] verkaeufe ; public Pizzeria ( Speisekarte karte ) { this . verkaeufe = new Pizzaverkauf [ karte . getLength () ] ; for ( int index = 0 ; index < this . verkaeufe . length ; index ++ ) { this . verkaeufe [ index ] = new Pizzaverkauf ( karte . getPizzaAtIndex ( index )); } } public int bestellen () { Random r = new Random (); int index = r . nextInt ( this . verkaeufe . length ); return index ; } public void verkaufen ( int index ) { if ( index >= 0 && index < this . verkaeufe . length ) { this . verkaeufe [ index ] . verkaufen (); } } public void tagesVerkauf ( int anzVerkaeufe ) { for ( int i = 0 ; i < anzVerkaeufe ; i ++ ) { int index = this . bestellen (); this . verkaufen ( index ); } } public void print () { for ( int index = 0 ; index < this . verkaeufe . length ; index ++ ) { Pizza p = this . verkaeufe [ index ] . getPizza (); int anzVerkaeufe = this . verkaeufe [ index ] . getAnzVerkaeufe (); String s = String . format ( \"%-13s : \" , p . getName ()); for ( int stars = 0 ; stars < anzVerkaeufe ; stars ++ ) { s = s + \"*\" ; } System . out . println ( s ); } } public Pizza meistverkauftePizza () { int maxIndex = 0 ; for ( int index = 0 ; index < this . verkaeufe . length ; index ++ ) { if ( this . verkaeufe [ index ] . getAnzVerkaeufe () > this . verkaeufe [ maxIndex ] . getAnzVerkaeufe ()) { maxIndex = index ; } } return this . verkaeufe [ maxIndex ] . getPizza (); } public double gesamtEinnahmen () { double gesamtEinnahmen = 0.0 ; for ( int index = 0 ; index < this . verkaeufe . length ; index ++ ) { gesamtEinnahmen += this . verkaeufe [ index ] . umsatz (); } return gesamtEinnahmen ; } } Testklasse.java package klausurvorbereitung.pizza ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n------------------------- Test Pizza ---------------------------%n%n\" ); Pizza p1 = new Pizza ( \"Salami\" , 6.9f ); Pizza p2 = new Pizza ( \"Margheritha\" , 5.9f ); Pizza p3 = new Pizza ( \"Tonno\" , 6.9f ); Pizza p4 = new Pizza ( \"Hawaii\" , 6.9f ); Pizza p5 = new Pizza ( \"Calzone\" , 7.9f ); Pizza p6 = new Pizza ( \"Salami\" , 6.9f ); p1 . print (); p2 . print (); p3 . print (); p4 . print (); p5 . print (); System . out . println ( \"p1 gleich p2 ? : \" + p1 . equals ( p2 )); System . out . println ( \"p1 gleich p1 ? : \" + p1 . equals ( p1 )); System . out . println ( \"p1 gleich p6 ? : \" + p1 . equals ( p6 )); System . out . printf ( \"%n%n--------------------- Test Pizzaverkauf ------------------------%n%n\" ); Pizzaverkauf pv1 = new Pizzaverkauf ( p1 ); pv1 . print (); pv1 . verkaufen (); pv1 . print (); System . out . printf ( \"%n%n--------------------- Test Speisekarte -------------------------%n%n\" ); Speisekarte s1 = new Speisekarte (); s1 . pizzaHinzufuegen ( p1 ); s1 . pizzaHinzufuegen ( p2 ); s1 . pizzaHinzufuegen ( p3 ); s1 . pizzaHinzufuegen ( p4 ); s1 . pizzaHinzufuegen ( p5 ); s1 . print (); s1 . pizzaLoeschen ( p3 ); s1 . print (); System . out . printf ( \"%n%n------------------------ Test Pizzaria -------------------------%n%n\" ); Pizzeria pz1 = new Pizzeria ( s1 ); pz1 . tagesVerkauf ( 150 ); pz1 . print (); System . out . println (); System . out . print ( \"Meistverkaufte Pizza : \" ); pz1 . meistverkauftePizza (). print (); System . out . printf ( \"Die Gesamteinnahmen betragen %.2f Euro\" , pz1 . gesamtEinnahmen ()); } } Power Implementieren Sie eine Klasse Power . Idee : Die Klasse Power implementiert die Potenz . Eine Potenz besteht aus einer Basis ( base ) und dem Exponenten ( exp ): base^exp, z.B. 8^4 = 8 \u2219 8 \u2219 8 \u2219 8 Objektvariablen sind base und exp vom Typ int . Beide Objektvariablen sind nur innerhalb der Klasse sichtbar! Implementieren Sie getter f\u00fcr die Basis ( getBase() ) und f\u00fcr den Exponenten ( getExp() ) (Sichtbarkeit public ). Implementieren Sie f\u00fcr die Klasse Power einen parametrisierten Konstruktor Power(int base, int exp) . Die Werte der Parameter werden verwendet, um den Objektvariablen Werte zuzuweisen. Implementieren Sie eine Objektmethode getValue() , die ein double zur\u00fcckgibt. Die Methode gibt den Wert der Potenz zur\u00fcck, also z.B. f\u00fcr 8^4 den Wert 4096.0 . Beachten Sie: Die Verwendung der Math -Klasse ist nicht erlaubt! \u00dcberschreiben Sie die Methode toString() , so dass eine Potenz in der Form (base, exp) als String zur\u00fcckgegeben wird, wobei base und exp die Werte der jeweiligen Objektvariablen sein sollen, also z.B. (8, 4) . Implementieren Sie eine Objektmethode print() , die mithilfe von toString() eine Potenz auf der Konsole ausgibt. Erstellen Sie eine Klasse PowerTest mit main() -Methode. Erzeugen Sie in der main() -Methode folgende f\u00fcnf Objekte der Klasse Power : 3^4 , -3^4 , 3^0 , 3^(-4) , -3^(-4) . Wenden Sie jeweils die Methode print() an und geben Sie au\u00dferdem jeweils den Wert der Potenz auf die Konsole aus. Es sollte eine Ausgabe in ungef\u00e4hr der folgenden Form erfolgen: ( 3 ,4 ) ( 3 ,4 ) = 81 .0 ( -3,4 ) ( -3,4 ) = 81 .0 ( 3 ,0 ) ( 3 ,0 ) = 1 .0 ( 3 ,-4 ) ( 3 ,-4 ) = 0 .012345679012345678 ( -3,-4 ) ( -3,-4 ) = 0 .012345679012345678 Erstellen Sie eine Klasse PowerOfTwo . Diese Klasse erbt von Power . Idee : Ein Objekt der Klasse PowerOfTwo ist eine Potenz zur Basis 2 , also z.B. 2^4 . Implementieren Sie einen parametrisierten Konstruktor PowerOfTwo(int exp) . Beachten Sie, dass der Basis der Wert 2 zugewiesen wird. Implementieren Sie eine Objektmethode printBinary() . Diese Methode gibt die Potenz als Bin\u00e4rzahl (bestehend aus Einsen und Nullen) auf die Konsole aus, z.B. 2^4 : 1 0 0 0 0 . Tipp : es kommt vorne immer eine 1 und danach kommen so viele Nullen, wie der Exponent gro\u00df ist. Wenn der Exponent kliner als 0 ist, dann geben Sie Zahl ist kleiner als 1 auf die Konsole aus. Die Bin\u00e4rzahl f\u00fcr eine Potenz kleiner als 0 muss also nicht ermittelt werden. Erzeugen Sie in der main() -Methode der Klasse PowerTest folgende drei Objekte der Klasse PowerOfTwo : 2^4 , 2^(-4) , 2^0 und rufen Sie jeweils die Methoden print() und printBinary() auf. Es sollte eine Ausgabe in ungef\u00e4hr der folgenden Form erfolgen: ( 2 ,4 ) 1 0 0 0 0 ( 2 ,-4 ) Zahl ist kleiner als 1 ( 2 ,0 ) 1 Erstellen Sie eine Klasse PowerArray . Objektvariable ist p vom Typ Power[] . p ist nur innerhalb der Klasse sichtbar! Implementieren Sie einen parametrisierten Konstruktor PowerArray(int length) . Darin wird das p -Array erzeugt. Die L\u00e4nge von p entspricht dem Wert von length . Implementieren Sie eine Objektmethode fillArray() . Bei Aufruf der Methode soll das Array p mit Objekten der Klasse Power gef\u00fcllt werden. Die Werte der Objektvariablen der Power -Objekte werden zuf\u00e4llig mit Hilfe der Random -Klasse erzeugt (um die Random -Klasse verwenden zu k\u00f6nnen, m\u00fcssen Sie diese aus dem java.util -Paket importieren). Beachten Sie folgende Anforderungen: Sowohl die Basis als auch der Exponent k\u00f6nnen Werte aus dem Wertebereich 1..5 (jeweils inklusive) annehmen Die Basis soll nie einen gr\u00f6\u00dferen Wert als der Exponent haben (aber es k\u00f6nnen beide gleich sein). Implementieren Sie eine Objektmethode createArrayOfValues() . Diese Methode liefert ein double[] -Array zur\u00fcck, das alle Werte der Potenzen aus dem p -Array enth\u00e4lt. Implementieren Sie eine Objektmethode getIndexExponent(int exponent) , die den Index des (ersten) Elementes zur\u00fcckliefert, bei dem das Power -Objekt den Exponenten hat, der als Parameter der Methode \u00fcbergeben wird. Existiert ein solches Objekt nicht im Array, wird -1 zur\u00fcckgegeben. \u00dcberschreiben Sie die Methode toString() , so dass das p -Array in der Form (Beispiel) [ ( 2 ,5 ) , ( 2 ,3 ) , ( 3 ,3 ) , ( 1 ,5 ) , ( 2 ,3 ) , ( 1 ,3 ) , ( 1 ,3 ) , ( 1 ,2 ) , ( 3 ,5 ) , ( 2 ,3 ) ] als String zur\u00fcckgegeben wird. Implementieren Sie eine Methode print() , die mithilfe von toString() das p -Array auf die Konsole ausgibt. Implementieren Sie eine Methode sort() , die das p -Array nach den Gr\u00f6\u00dfen der Werte der Potenzen ordnet \u2013 vom kleinsten Wert zum gr\u00f6\u00dften Wert. Die Verwendung der Arrays -Klasse aus dem java.util -Paket ist nicht gestattet. Sollten 2 Potenzen den gleichen Wert haben, z.B. 1^2 und 1^4 , dann soll die Potenz mit dem h\u00f6heren Exponent gr\u00f6\u00dfer sein als die Potenz mit dem kleineren Exponenten. Erzeugen Sie in der main() -Methode der Klasse PowerTest ein Objekt der Klasse PowerArray , so dass das p -Array die L\u00e4nge 10 hat. Rufen Sie f\u00fcr dieses Objekt die Objektmethoden fillArray() , print() , sort() und wieder print() auf. Testen Sie au\u00dferdem (mindestens) einmal die getIndexExponent() - und die createArrayOfValues() - Methode (um das Array of Values auf der Konsole auszugeben, verwenden Sie die statische toString() -Methode der Arrays -Klasse ( import java.util.Arrays; ). Es sollte eine Ausgabe in ungef\u00e4hr der folgenden Form erfolgen (Zufallswerte): [ ( 1 ,5 ) , ( 1 ,2 ) , ( 3 ,5 ) , ( 3 ,4 ) , ( 4 ,4 ) , ( 1 ,5 ) , ( 1 ,2 ) , ( 3 ,4 ) , ( 2 ,3 ) , ( 3 ,5 ) ] [ ( 1 ,2 ) , ( 1 ,2 ) , ( 1 ,5 ) , ( 1 ,5 ) , ( 2 ,3 ) , ( 3 ,4 ) , ( 3 ,4 ) , ( 3 ,5 ) , ( 3 ,5 ) , ( 4 ,4 ) ] Index : 5 Index : -1 [ 1 .0, 1 .0, 1 .0, 1 .0, 8 .0, 81 .0, 81 .0, 243 .0, 243 .0, 256 .0 ] eine m\u00f6gliche L\u00f6sung f\u00fcr Power Power.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class Power { private int base ; private int exp ; Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public int getBase () { return this . base ; } public int getExp () { return this . exp ; } public double getValue () { double value = 1.0 ; if ( this . exp >= 0 ) { for ( int i = 1 ; i <= this . exp ; i ++ ) { value *= this . base ; } } else { for ( int i = 1 ; i <=- this . exp ; i ++ ) { value *= this . base ; } value = 1.0 / value ; } return value ; } @Override public String toString () { return \"(\" + this . base + \",\" + this . exp + \")\" ; } public void print () { System . out . println ( this . toString ()); } } PowerOfTwo.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class PowerOfTwo extends Power { public PowerOfTwo ( int exp ) { super ( 2 , exp ); } public void printBinary () { if ( this . getExp () < 0 ) { System . out . println ( \"Zahl ist kleiner als 1\" ); } else { String s = \"1\" ; for ( int i = 1 ; i <= this . getExp (); i ++ ) { s += \" 0\" ; } System . out . println ( s ); } } } PowerArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 import java.util.Random ; public class PowerArray { private Power [] p ; public PowerArray ( int length ) { this . p = new Power [ length ] ; } public void fillArray () { Random r = new Random (); for ( int i = 0 ; i < this . p . length ; i ++ ) { int nr1 = r . nextInt ( 5 ) + 1 ; int nr2 = r . nextInt ( 5 ) + 1 ; if ( nr1 > nr2 ) { this . p [ i ] = new Power ( nr2 , nr1 ); } else { this . p [ i ] = new Power ( nr1 , nr2 ); } } } public double [] createArrayOfValues () { double [] values = new double [ this . p . length ] ; for ( int i = 0 ; i < this . p . length ; i ++ ) { values [ i ] = this . p [ i ] . getValue (); } return values ; } public int getIndexExponent ( int exponent ) { final int NOT_FOUND = - 1 ; for ( int i = 0 ; i < this . p . length ; i ++ ) { if ( this . p [ i ] . getExp () == exponent ) { return i ; } } return NOT_FOUND ; } @Override public String toString () { String s = \"[ \" ; for ( int i = 0 ; i < this . p . length ; i ++ ) { if ( i < this . p . length - 1 ) { s += this . p [ i ] . toString () + \", \" ; } else { s += this . p [ i ] . toString (); } } s += \" ]\" ; return s ; } public void print () { System . out . println ( this . toString ()); } public void sort () { for ( int bubble = 0 ; bubble < this . p . length - 1 ; bubble ++ ) { for ( int i = 0 ; i < this . p . length - 1 - bubble ; i ++ ) { if (( this . p [ i ] . getValue () > this . p [ i + 1 ] . getValue ()) || (( this . p [ i ] . getValue () == this . p [ i + 1 ] . getValue () && this . p [ i ] . getExp () > this . p [ i + 1 ] . getExp ()))) { Power temp = this . p [ i ] ; this . p [ i ] = this . p [ i + 1 ] ; this . p [ i + 1 ] = temp ; } } } } } PowerTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.util.Arrays ; public class PowerTest { public static void main ( String [] args ) { // Objekte erzeugen Power p1 = new Power ( 3 , 4 ); Power p2 = new Power ( - 3 , 4 ); Power p3 = new Power ( 3 , 0 ); Power p4 = new Power ( 3 , - 4 ); Power p5 = new Power ( - 3 , - 4 ); System . out . printf ( \"%n%n---------------------- Ausgaben fuer Power ---------------------------%n%n\" ); p1 . print (); System . out . println ( p1 . toString () + \" = \" + p1 . getValue ()); p2 . print (); System . out . println ( p2 . toString () + \" = \" + p2 . getValue ()); p3 . print (); System . out . println ( p3 . toString () + \" = \" + p3 . getValue ()); p4 . print (); System . out . println ( p4 . toString () + \" = \" + p4 . getValue ()); p5 . print (); System . out . println ( p5 . toString () + \" = \" + p5 . getValue ()); System . out . printf ( \"%n%n-------------------- Ausgaben fuer PowerOfTwo -------------------------%n%n\" ); PowerOfTwo p21 = new PowerOfTwo ( 4 ); p21 . print (); p21 . printBinary (); PowerOfTwo p22 = new PowerOfTwo ( - 4 ); p22 . print (); p22 . printBinary (); PowerOfTwo p23 = new PowerOfTwo ( 0 ); p23 . print (); p23 . printBinary (); System . out . printf ( \"%n%n-------------------- Ausgaben fuer PowerArray -------------------------%n%n\" ); PowerArray pa = new PowerArray ( 10 ); pa . fillArray (); pa . print (); pa . sort (); pa . print (); System . out . println ( \"Index : \" + pa . getIndexExponent ( 4 )); System . out . println ( \"Index : \" + pa . getIndexExponent ( 0 )); double [] values = pa . createArrayOfValues (); System . out . println ( Arrays . toString ( values )); } } Video zu Pizza Computer Implementieren Sie eine Klasse Computer . Objektvariablen sind hersteller vom Typ String , ram vom Typ int und platte vom Typ int . Die Objektvariablen sind in der Klasse und allen abgeleiteten Klassen sichtbar! Schreiben Sie f\u00fcr alle Objektvariablen Getter ( getRam() , getPlatte() , getHersteller() ). Schreiben Sie einen parametrisierten Konstruktor Computer(String hersteller, int ram, int platte) . Die Parameterwerte werden genutzt, um den Objektvariablen die entsprechenden Werte zuzuweisen. Schreiben Sie eine Objektmethode gleicherHersteller(Computer c) , die ein true zur\u00fcckgibt, wenn c vom gleichen Hersteller ist, wie das aufrufende Objekt. Ansonsten wird ein false zur\u00fcckgegeben. Schreiben Sie eine Objektmethode gleicherHersteller(String hersteller) , die ein true zur\u00fcckgibt, wenn das aufrufende Objekt den Hersteller hat, der als Parameterwert der Methode \u00fcbergeben wird. Ansonsten wird ein false zur\u00fcckgegeben. \u00dcberschreiben Sie die Methode toString() , so dass der Computer in folgender Form angezeigt wird (Beispielwerte): lenovo mit 8 RAM und 256 SSD Schreiben Sie eine Methode print() , die mit Hilfe von toString() eine Ausgabe auf der Konsole erzeugt. Erstellen Sie eine Klasse Testklasse mit main() -Methode. Erzeugen Sie in der main() -Methode f\u00fcnf Objekte der Klasse Computer : lenovo mit 8 RAM und 256 SSD lenovo mit 16 RAM und 512 SSD apple mit 4 RAM und 256 SSD apple mit 8 RAM und 512 SSD dell mit 8 RAM und 256 SSD Wenden Sie jeweils die Methode print() an, wenden Sie die Methode gleicherHersteller(Computer c) f\u00fcr den ersten Computer an und vergleichen ihn mit dem zweiten und dem dritten. Geben Sie jeweils den Wert des Vergleiches aus. Es sollten folgende Ausgaben auf der Konsole erzeugt werden: --------------------- Test Computer -------------------- lenovo mit 8 RAM und 256 SSD lenovo mit 16 RAM und 512 SSD apple mit 4 RAM und 256 SSD apple mit 8 RAM und 512 SSD dell mit 8 RAM und 256 SSD c1 und c2 gleicher Hersteller ? : true c1 und c3 gleicher Hersteller ? : false Erstellen Sie eine Klasse Notebook . Diese Klasse erbt von der Klasse Computer . Zus\u00e4tzliche Objektvariable der Klasse Notebook ist monitor vom Typ int . Die Objektvariablen sind in der Klasse und allen abgeleiteten Klassen sichtbar! Implementieren Sie einen parametrisierten Konstruktor Notebook(String hersteller, int ram, int platte, int monitor) . Die Parameterwerte werden genutzt, um den Objektvariablen des zur\u00fcckgegebenen Objektes die entsprechenden Werte zuzuweisen. \u00dcberschreiben Sie die Methode toString() , so dass eine Zeichenkette der Form ( hersteller, ram, platte, monitor ) zur\u00fcckgegeben wird (die entsprechenden Werte werden eingesetzt - siehe Ausgabe der main() -Methode unten). Erzeugen Sie in der main() -Methode der Testklasse zwei Objekte der Klasse Notebook (Beispielwerte siehe n\u00e4chste Zeile) und rufen Sie jeweils die print() -Methode auf. Es sollten folgende Ausgaben auf der Konsole erzeugt werden: --------------------- Test Notebook -------------------- ( lenovo, 8 , 256 , 13 ) ( lenovo, 16 , 512 , 15 ) Erstellen Sie eine Klasse NotebookArray . Schreiben Sie einen parametrisierten Konstruktor NotebookArray(int anzahl) . Darin wird das notebooks -Array mit der L\u00e4nge anzahl erzeugt (es wird noch nicht mit Notebook -Objekten bef\u00fcllt - das macht die n\u00e4chste Methode). Schreiben Sie eine Objektmethode konfigurieren() . Bei Aufruf der Methode wird das Array notebooks mit Objekten der Klasse Notebook bef\u00fcllt. Beachten Sie folgende Anforderungen: Objektvariable ist notebooks vom Typ Notebook[] . Die Objektvariable ist nur innerhalb der Klasse sichtbar! das notebooks -Array wird vollst\u00e4ndig bef\u00fcllt 2. f\u00fcr das Erzeugen der Objekte wird eine Zufallszahl aus dem Bereich [0, 1, 2, 3, 4] ( 4 inklusive) erzeugt. Nutzen Sie dazu die Klasse Random aus dem java.util -Paket. Mithilfe von nextInt(int exclusiveBorder) wird eine Zufallszahl erzeugt. Je nach Wert der Zufallszahl wird ein anderes Notebook erzeugt: Wert 0 -> zu erzeugendes Objekt: (\"lenovo\", 8, 256, 13) Wert 1 -> zu erzeugendes Objekt: (\"lenovo\", 16, 512, 15) Wert 2 -> zu erzeugendes Objekt: (\"apple\", 4, 256, 13) Wert 3 -> zu erzeugendes Objekt: (\"apple\", 8, 512, 13) Wert 4 -> zu erzeugendes Objekt: (\"dell\", 8, 512, 15) \u00dcberschreiben Sie die Objektmethode toString() . Diese Methode gibt einen String in der Form (Beispielwerte): [ 5 : ( lenovo, 8 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( lenovo, 16 , 512 , 15 ) , ( lenovo, 8 , 256 , 13 ) , ( apple, 8 , 512 , 13 )] zur\u00fcck. Beachten Sie: die eckigen Klammern zu Beginn und Ende des Strings 2. die Angabe der Anzahl der Elemente am Anfang (im obigen Beispiel 5 : ) 3. das Komma zwischen den Elementen (aber nicht nach dem letzten Element) Schreiben Sie eine Methode print() , die den in toString() erzeugten String auf die Konsole ausgibt. Schreiben Sie eine Objektmethode getHersteller(String hersteller) . Diese Methode gibt ein Objekt vom Typ NotebookArray zur\u00fcck. Das notebooks -Array des erzeugten Objektes enth\u00e4lt genau alle Notebooks aus dem notebooks -Array des aufrufenden Objektes, die von dem Hersteller sind, der als Parameterwert \u00fcbergeben wird. Beispiel: Angenommen, das notebooks -Array des aufrufenden Objektes sieht so aus: [ 10 : ( lenovo, 16 , 512 , 15 ) , ( apple, 8 , 512 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( lenovo, 16 , 512 , 15 ) , ( lenovo, 16 , 512 , 15 ) , ( lenovo, 16 , 512 , 15 ) , ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) ] Dann w\u00fcrde bei Aufruf der Methode getHersteller(\"apple\") das zur\u00fcckgegebene NotebookArray -Objekt folgendes notebooks -Array haben: [ ( apple, 8 , 512 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) ] , bei Aufruf der Methode getHersteller(\"lenovo\") das zur\u00fcckgegebene NotebookArray -Objekt folgendes notebooks -Array: [ ( lenovo, 16 , 512 , 15 ) , ( lenovo, 8 , 256 , 13 ) , ( lenovo, 16 , 512 , 15 ) , ( lenovo, 16 , 512 , 15 ) , ( lenovo, 16 , 512 , 15 ) ] und bei Aufruf der Methode getHersteller(\"dell\") das zur\u00fcckgegebene NotebookArray -Objekt ein leeres notebooks -Array: [ ] Schreiben Sie eine Objektmethode sortRamPlatte() . Diese Methode sortiert das notebooks -Array wie folgt: aufsteigend nach RAM-Gr\u00f6\u00dfe (kleinste RAM-Gr\u00f6\u00dfe zuerst) 2. ist die RAM-Gr\u00f6\u00dfer zweier Notebooks gleich, entscheidet die Plattengr\u00f6\u00dfe (kleinste Plattengr\u00f6\u00dfe zuerst) Erzeugen Sie in der main() -Methode der Testklasse ein Objekt der Klasse NotebookArray , so dass das notebooks -Array die L\u00e4nge 10 hat. Rufen Sie f\u00fcr dieses Objekt die Objektmethoden konfigurieren() , print() , sortRamPlatte() und print() auf. Testen Sie au\u00dferdem die getHersteller() -Methode f\u00fcr alle drei Hersteller und geben Sie jeweils das erzeugte Array aus. Es sollten folgende Ausgaben auf der Konsole erzeugt werden ( Zufallswerte! ): ------------------ Test NotebookArray ------------------ [ 10 : ( apple, 8 , 512 , 13 ) , ( lenovo, 16 , 512 , 15 ) , ( apple, 4 , 256 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) , ( dell, 8 , 512 , 15 ) , ( apple, 4 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( apple, 8 , 512 , 13 )] [ 10 : ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( dell, 8 , 512 , 15 ) , ( apple, 8 , 512 , 13 ) , ( apple, 8 , 512 , 13 ) , ( lenovo, 16 , 512 , 15 )] [ 3 : ( lenovo, 8 , 256 , 13 ) , ( lenovo, 8 , 256 , 13 ) , ( lenovo, 16 , 512 , 15 )] [ 6 : ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 4 , 256 , 13 ) , ( apple, 8 , 512 , 13 ) , ( apple, 8 , 512 , 13 ) , ( apple, 8 , 512 , 13 )] [ 1 : ( dell, 8 , 512 , 15 )] eine m\u00f6gliche L\u00f6sung f\u00fcr Computer Computer.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package loesungen.probeklausuren.probeklausur2 ; public class Computer { protected String hersteller ; protected int ram ; protected int platte ; public String getHersteller () { return this . hersteller ; } public int getRam () { return this . ram ; } public int getPlatte () { return this . platte ; } public Computer ( String hersteller , int ram , int platte ) { this . hersteller = hersteller ; this . ram = ram ; this . platte = platte ; } public boolean gleicherHersteller ( Computer c ) { return this . hersteller . equals ( c . hersteller ); // es geht auch: return this.hersteller == c.hersteller; } public boolean gleicherHersteller ( String hersteller ) { return this . hersteller . equals ( hersteller ); // es geht auch: return this.hersteller == hersteller; } @Override public String toString () { return this . hersteller + \" mit \" + this . ram + \" RAM und \" + this . platte + \" SSD\" ; } public void print () { System . out . println ( this . toString ()); } } Notebook.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package loesungen.probeklausuren.probeklausur2 ; public class Notebook extends Computer { protected int monitor ; public Notebook ( String hersteller , int ram , int platte , int monitor ) { super ( hersteller , ram , platte ); this . monitor = monitor ; } @Override public String toString () { return \"(\" + this . hersteller + \", \" + this . ram + \", \" + this . platte + \", \" + this . monitor + \")\" ; } } NotebookArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 package loesungen.probeklausuren.probeklausur2 ; import java.util.Random ; public class NotebookArray { private Notebook [] notebooks ; public NotebookArray ( int anzahl ) { this . notebooks = new Notebook [ anzahl ] ; } public void konfigurieren () { Random r = new Random (); for ( int i = 0 ; i < this . notebooks . length ; i ++ ) { int auswahl = r . nextInt ( 5 ); // folgendes kann natuerlich auch mit if..else geloest werden this . notebooks [ i ] = switch ( auswahl ) { case 0 -> new Notebook ( \"lenovo\" , 8 , 256 , 13 ); case 1 -> new Notebook ( \"lenovo\" , 16 , 512 , 15 ); case 2 -> new Notebook ( \"apple\" , 4 , 256 , 13 ); case 3 -> new Notebook ( \"apple\" , 8 , 512 , 13 ); case 4 -> new Notebook ( \"dell\" , 8 , 512 , 15 ); default -> null ; }; } } @Override public String toString () { String s = \"[ \" + this . notebooks . length + \" : \" ; for ( int i = 0 ; i < this . notebooks . length ; i ++ ) { if ( i < this . notebooks . length - 1 ) { s += this . notebooks [ i ] . toString () + \", \" ; } else { s += this . notebooks [ i ] . toString (); } } s += \"]\" ; return s ; } public void print () { System . out . println ( this . toString ()); } public NotebookArray getHersteller ( String hersteller ) { int anzahl = 0 ; for ( int i = 0 ; i < this . notebooks . length ; i ++ ) { if ( this . notebooks [ i ] . gleicherHersteller ( hersteller )) { anzahl ++ ; } } NotebookArray na = new NotebookArray ( anzahl ); int indexNA = 0 ; for ( int i = 0 ; i < this . notebooks . length ; i ++ ) { if ( this . notebooks [ i ] . gleicherHersteller ( hersteller )) { na . notebooks [ indexNA ++] = this . notebooks [ i ] ; } } return na ; } public void sortRamPlatte () { for ( int bubble = 0 ; bubble < this . notebooks . length - 1 ; bubble ++ ) { for ( int i = 0 ; i < this . notebooks . length - 1 - bubble ; i ++ ) { if (( this . notebooks [ i ] . getRam () > this . notebooks [ i + 1 ] . getRam ()) || ( this . notebooks [ i ] . getRam () == this . notebooks [ i + 1 ] . getRam () && this . notebooks [ i ] . getPlatte () > this . notebooks [ i + 1 ] . getPlatte ())) { Notebook temp = this . notebooks [ i ] ; this . notebooks [ i ] = this . notebooks [ i + 1 ] ; this . notebooks [ i + 1 ] = temp ; } } } } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package loesungen.probeklausuren.probeklausur2 ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n--------------------- Test Computer --------------------%n%n\" ); Computer c1 = new Computer ( \"lenovo\" , 8 , 256 ); Computer c2 = new Computer ( \"lenovo\" , 16 , 512 ); Computer c3 = new Computer ( \"apple\" , 4 , 256 ); Computer c4 = new Computer ( \"apple\" , 8 , 512 ); Computer c5 = new Computer ( \"dell\" , 8 , 256 ); c1 . print (); c2 . print (); c3 . print (); c4 . print (); c5 . print (); System . out . println ( \"c1 und c2 gleicher Hersteller ? : \" + c1 . gleicherHersteller ( c2 )); System . out . println ( \"c1 und c3 gleicher Hersteller ? : \" + c1 . gleicherHersteller ( c3 )); System . out . printf ( \"%n%n--------------------- Test Notebook --------------------%n%n\" ); Notebook n1 = new Notebook ( \"lenovo\" , 8 , 256 , 13 ); Notebook n2 = new Notebook ( \"lenovo\" , 16 , 512 , 15 ); n1 . print (); n2 . print (); System . out . printf ( \"%n%n------------------ Test NotebookArray ------------------%n%n\" ); NotebookArray na = new NotebookArray ( 10 ); na . konfigurieren (); na . print (); na . sortRamPlatte (); na . print (); NotebookArray lenovo = na . getHersteller ( \"lenovo\" ); lenovo . print (); NotebookArray apple = na . getHersteller ( \"apple\" ); apple . print (); NotebookArray dell = na . getHersteller ( \"dell\" ); dell . print (); } } Uhrzeit Implementieren Sie eine Klasse Uhrzeit . Objektvariablen sind stunden vom Typ int , minuten vom Typ int und sekunden vom Typ int . Die Objektvariablen sind nur in der Klasse sichtbar! Schreiben Sie einen parametrisierten Konstruktor Uhrzeit(int sekunden) . \u00dcbergeben wird eine beliebige Anzahl von Sekunden. Aus diesem Wert wird die Uhrzeit berechnet. Beispiel 1: Angenommen, es wird der Wert 83 \u00fcbergeben, dann sind das 0 Stunden, 1 Minute ( 60 Sekunden) und 23 Sekunden. Beispiel 2: Angenommen, es wird der Wert 3662 \u00fcbergeben, dann sind das 1 Stunde ( 3600 Sekunden), 1 Minute ( 60 Sekunden) und 2 Sekunden. Beispiel 3: Angenommen, es wird der Wert 86399 \u00fcbergeben, dann sind das 23 Stunden ( 23x3600 Sekunden), 59 Minuten ( 59x60 Sekunden) und 59 Sekunden. Die Stunden sollen immer im Bereich 0..23 sein, d.h. f\u00fcr einen Stunden-Wert gr\u00f6\u00dfer als 24 nehmen Sie einfach den Modulo-24 -Wert. Initialisieren Sie die Objektvariablen mit den berechneten Werten. Schreiben Sie eine Objektmethode uhrzeitInSekunden() . Diese Methode gibt die Uhrzeit in Sekunden als int zur\u00fcck. Der Wert der zur\u00fcckgegebenen Sekunden berechnet sich aus den Stunden multipliziert mit 3600 plus den Minuten multipliziert mit 60 plus den Sekunden des aufrufenden Uhrzeit -Objektes. Schreiben Sie eine Objektmethode frueher(Uhrzeit u) , die ein true zur\u00fcckgibt, wenn die Uhrzeit des aufrufenden Objektes fr\u00fcher liegt als der Wert von u ; false sonst. Schreiben Sie eine Objektmethode jetztPlusXSekunden(int sekunden) , die ein neues Uhrzeit -Objekt zur\u00fcckgibt. Die Uhrzeit des neuen Objektes ergibt sich aus der Uhrzeit des aufrufenden Objektes plus der Anzahl der Sekunden, die als Parameter \u00fcbergeben werden. Schreiben Sie eine Objektmethode differenzInSekunden(Uhrzeit u) , die die Anzahl in Sekunden ( int ) zur\u00fcckgibt, die zwischen der Uhrzeit des aufrufenden Objektes und u liegen. Geben Sie die Anzahl stets als positiven Wert zur\u00fcck! Sie k\u00f6nnen dazu die Methode Math.abs(int wert) verwenden, die den absoluten Betrag von wert zur\u00fcckgibt. \u00dcberschreiben Sie die Methode toString() , so dass der Wert des aufrufenden Objektes in der Form hh:mm:ss als String zur\u00fcckgegeben wird, z.B. 23:59:59 . Achten Sie darauf, dass die Stunden, Minuten und Sekunden f\u00fchrende Nullen enthalten k\u00f6nnen, also z.B. 01:02:03 ! Schreiben Sie eine Methode print() , die den von toString() erzeugten String auf die Konsole ausgibt. Erstellen Sie eine Klasse Testklasse mit main() -Methode. Erzeugen Sie in der main() -Methode vier Objekte der Klasse Uhrzeit . Verwenden Sie als Parameterwerte: 83 , 3662 , 86399 und 172799 . Wenden Sie jeweils die Methoden System.out.print() und print() aus Uhrzeit so an, dass folgende Ausgabe entsteht: z1 : 00 :01:23 z2 : 01 :01:02 z3 : 23 :59:59 z4 : 23 :59:59 Wenden Sie au\u00dferdem jeweils die Methoden System.out.println() sowie frueher() , jetztPlusXSekunden() , differenzInSekunden() (und evtl. toString() ) aus Uhrzeit so an, dass folgende Ausgabe entsteht: z1 frueher als z2 ? true z3 frueher als z4 ? false z1 plus 40 Sekunden : 00 :02:03 z2 plus 3598 Sekunden : 02 :01:00 z3-z2 in Sekunden : 82737 Erstellen Sie eine Klasse UhrzeitArray . Objektvariable uhren ist ein Array, das Elemente von Uhrzeit aufnimmt. Die Variable ist nur innerhalb der Klasse sichtbar. Schreiben Sie einen parametrisierten Konstruktor UhrzeitArray(int laenge) . Innerhalb des Konstruktors wird das Array erzeugt, auf das die Objektvariable uhren referenziert. Das Array hat die L\u00e4nge laenge (Parameterwert). Schreiben Sie eine Objektmethode fill() , die das uhren -Array vollst\u00e4ndig mit Uhrzeit -Objekten bef\u00fcllt. Die Parameterwerte der Uhrzeit -Objekte werden zuf\u00e4llig erzeugt. Erzeugen Sie ein Objekt der Klasse Random (daf\u00fcr muss java.util.Random importiert werden) und erzeugen Sie die Parameter-Werte f\u00fcr die Uhrzeit -Objekte zuf\u00e4llig (unter Verwendung des Random -Objektes) aus dem Bereich [0, ..., 86399] ( 0 und 86399 jeweils inklusive) \u00dcberschreiben Sie die Objektmethode toString() , so dass das uhren -Array wie folgt als Zeichenkette zur\u00fcckgegeben wird (Beispielwerte): (( 06 :38:30 ) , ( 01 :59:32 ) , ( 07 :16:48 ) , ( 01 :37:58 ) , ( 18 :16:06 ) , ( 07 :50:33 ) , ( 01 :41:47 ) , ( 05 :07:41 ) , ( 12 :38:08 ) , ( 02 :00:04 )) Also die Uhrzeit jeweils in runden Klammern und durch Komma getrennt sowie das ganze Array in runden Klammern. Schreiben Sie eine Objektmethode print() , so dass auf der Konsole die durch toString() erzeugte eine Zeichenkette ausgegeben wird. Schreiben Sie eine Objektmethode spaeteste() . Diese Methode gibt die gr\u00f6\u00dfte (sp\u00e4teste) Uhrzeit aus dem Array uhren zur\u00fcck. Schreiben Sie eine Objektmethode zwischen(Uhrzeit frueh, Uhrzeit spaet) . Diese Methode gibt ein UhrzeitArray -Objekt zur\u00fcck. Das zur\u00fcckgegebene UhrzeitArray -Objekt enth\u00e4lt alle Uhrzeit -Objekte aus dem Array uhren , welche zwischen den beiden Uhrzeiten frueh und spaet liegen. Schreiben Sie eine Objektmethode sortieren() . Diese Methode sortiert das uhren -Array aufsteigend beginnend mit der kleinsten Uhrzeit. Schreiben Sie eine Objektmethode kleinsterAbstand() . Diese Methode gibt ein UhrzeitArray der L\u00e4nge 2 zur\u00fcck. Es enth\u00e4lt die beiden Uhrzeit en aus dem Array uhren , welche den kleinsten Abstand (Differenz in Sekunden) haben. Sie k\u00f6nnen beim Schreiben der Methode davon ausgehen, dass das uhren -Array bereits sortiert ist! Erzeugen Sie in der main() -Methode ein Objekt der Klasse UhrzeitArray . Das Array soll die L\u00e4nge 10 haben. Rufen Sie die fill() - und dann die print() -Methode auf. Es entsteht folgende Ausgabe (Zufallswerte): (( 06 :38:30 ) , ( 01 :59:32 ) , ( 07 :16:48 ) , ( 01 :37:58 ) , ( 18 :16:06 ) , ( 07 :50:33 ) , ( 01 :41:47 ) , ( 05 :07:41 ) , ( 12 :38:08 ) , ( 02 :00:04 )) Wenden Sie jeweils die Methoden System.out.print() sowie spaeteste() so an, dass folgende Ausgabe entsteht (Zufallswerte): spaeteste : 18 :16:06 Wenden Sie jeweils die Methoden System.out.print() sowie sortieren() und print() so an, dass folgende Ausgabe entsteht (Zufallswerte): sortiert : (( 01 :37:58 ) , ( 01 :41:47 ) , ( 01 :59:32 ) , ( 02 :00:04 ) , ( 05 :07:41 ) , ( 06 :38:30 ) , ( 07 :16:48 ) , ( 07 :50:33 ) , ( 12 :38:08 ) , ( 18 :16:06 )) Erzeugen Sie zwei weitere Uhrzeit -Objekte frueh (Parameterwert 36000 ) und spaet (Parameterwert 72000 ) und rufen Sie damit die Objektmethoden zwischen(frueh, spaet) und print() auf, so dass folgende Ausgabe entsteht (Zufallswerte): frueh : 10 :00:00 spaet : 20 :00:00 zwischen : (( 12 :38:08 ) , ( 18 :16:06 )) Wenden Sie jeweils die Methoden System.out.print() sowie kleinsterAbstand() und print() so an, dass folgende Ausgabe entsteht (Zufallswerte): kleinster Abstand : (( 01 :59:32 ) , ( 02 :00:04 )) Zur Kontrolle: ungef\u00e4hre Ausgabe auf der Konsole (in Teil 2 Zufallswerte): --------------- Teil 1 --------------- z1 : 00 :01:23 z2 : 01 :01:02 z3 : 23 :59:59 z4 : 23 :59:59 z1 frueher als z2 ? true z3 frueher als z4 ? false z1 plus 40 Sekunden : 00 :02:03 z2 plus 3598 Sekunden : 02 :01:00 z3-z2 in Sekunden : 82737 --------------- Teil 2 --------------- (( 06 :38:30 ) , ( 01 :59:32 ) , ( 07 :16:48 ) , ( 01 :37:58 ) , ( 18 :16:06 ) , ( 07 :50:33 ) , ( 01 :41:47 ) , ( 05 :07:41 ) , ( 12 :38:08 ) , ( 02 :00:04 )) spaeteste : 18 :16:06 sortiert : (( 01 :37:58 ) , ( 01 :41:47 ) , ( 01 :59:32 ) , ( 02 :00:04 ) , ( 05 :07:41 ) , ( 06 :38:30 ) , ( 07 :16:48 ) , ( 07 :50:33 ) , ( 12 :38:08 ) , ( 18 :16:06 )) frueh : 10 :00:00 spaet : 20 :00:00 zwischen : (( 12 :38:08 ) , ( 18 :16:06 )) kleinster Abstand : (( 01 :59:32 ) , ( 02 :00:04 )) eine m\u00f6gliche L\u00f6sung f\u00fcr Uhrzeit Uhrzeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 package loesungen.probeklausuren.probeklausur3 ; public class Uhrzeit { private int stunden ; private int minuten ; private int sekunden ; public Uhrzeit ( int sekunden ) { final int STUNDE = 3600 ; final int MINUTE = 60 ; this . stunden = ( sekunden / STUNDE ) % 24 ; int rest = sekunden % STUNDE ; this . minuten = rest / MINUTE ; rest = rest % MINUTE ; this . sekunden = rest ; } public int uhrZeitInSekunden () { final int STUNDE = 3600 ; final int MINUTE = 60 ; int sekunden = this . stunden * STUNDE + this . minuten * MINUTE + this . sekunden ; return sekunden ; } public boolean frueher ( Uhrzeit u ) { return this . uhrZeitInSekunden () < u . uhrZeitInSekunden (); } public boolean spaeter ( Uhrzeit u ) { return this . uhrZeitInSekunden () > u . uhrZeitInSekunden (); } public Uhrzeit jetztPlusXSekunden ( int sekunden ) { int jetzt = this . uhrZeitInSekunden (); int neu = jetzt + sekunden ; return new Uhrzeit ( neu ); } public int differenzInSekunden ( Uhrzeit u ) { int uhrzeit1 = this . uhrZeitInSekunden (); int uhrzeit2 = u . uhrZeitInSekunden (); int diff = Math . abs ( uhrzeit1 - uhrzeit2 ); return diff ; } @Override public String toString () { String s = \"\" ; if ( this . stunden < 10 ) { s = s + \"0\" ; } s = s + this . stunden + \":\" ; if ( this . minuten < 10 ) { s = s + \"0\" ; } s = s + this . minuten + \":\" ; if ( this . sekunden < 10 ) { s = s + \"0\" ; } s = s + this . sekunden ; return s ; } public void print () { System . out . println ( this . toString ()); } } UhrzeitArray.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 package loesungen.probeklausuren.probeklausur3 ; import java.util.Random ; public class UhrzeitArray { private Uhrzeit [] uhren ; public UhrzeitArray ( int laenge ) { this . uhren = new Uhrzeit [ laenge ] ; } public void fill () { Random r = new Random (); for ( int i = 0 ; i < this . uhren . length ; i ++ ) { int zufSekunden = r . nextInt ( 86400 ); this . uhren [ i ] = new Uhrzeit ( zufSekunden ); } } public void print () { String s = \"(\" ; for ( int i = 0 ; i < this . uhren . length ; i ++ ) { if ( i < this . uhren . length - 1 ) { s = s + \"(\" + this . uhren [ i ] . toString () + \"), \" ; } else { s = s + \"(\" + this . uhren [ i ] . toString () + \")\" ; } } s = s + \")\" ; System . out . println ( s ); } public Uhrzeit frueheste () { Uhrzeit frueheste = this . uhren [ 0 ] ; for ( int i = 1 ; i < this . uhren . length ; i ++ ) { if ( this . uhren [ i ] . frueher ( frueheste )) { frueheste = this . uhren [ i ] ; } } return frueheste ; } public UhrzeitArray zwischen ( Uhrzeit frueh , Uhrzeit spaet ) { int anzZwischen = 0 ; for ( Uhrzeit u : this . uhren ) { if ( frueh . frueher ( u ) && u . frueher ( spaet )) { anzZwischen ++ ; } } UhrzeitArray ua = new UhrzeitArray ( anzZwischen ); int uaIndex = 0 ; for ( int i = 0 ; i < this . uhren . length ; i ++ ) { if ( frueh . frueher ( this . uhren [ i ] ) && this . uhren [ i ] . frueher ( spaet )) { ua . uhren [ uaIndex ] = this . uhren [ i ] ; uaIndex ++ ; } } return ua ; } public void sortieren () { for ( int bubble = 0 ; bubble < this . uhren . length - 1 ; bubble ++ ) { for ( int i = 0 ; i < this . uhren . length - 1 - bubble ; i ++ ) { if ( this . uhren [ i + 1 ] . frueher ( this . uhren [ i ] )) { Uhrzeit temp = this . uhren [ i ] ; this . uhren [ i ] = this . uhren [ i + 1 ] ; this . uhren [ i + 1 ] = temp ; } } } } public UhrzeitArray kleinsterAbstand () { this . sortieren (); Uhrzeit u1 = this . uhren [ 0 ] ; Uhrzeit u2 = this . uhren [ 1 ] ; int kleinsterAbstand = u1 . differenzInSekunden ( u2 ); for ( int i = 1 ; i < this . uhren . length - 1 ; i ++ ) { if ( this . uhren [ i ] . differenzInSekunden ( this . uhren [ i + 1 ] ) < kleinsterAbstand ) { u1 = this . uhren [ i ] ; u2 = this . uhren [ i + 1 ] ; kleinsterAbstand = u1 . differenzInSekunden ( u2 ); } } UhrzeitArray ua = new UhrzeitArray ( 2 ); ua . uhren [ 0 ] = u1 ; ua . uhren [ 1 ] = u2 ; return ua ; } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package loesungen.probeklausuren.probeklausur3 ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n---------------------- Test Uhrzeit --------------------------%n%n\" ); Uhrzeit z1 = new Uhrzeit ( 83 ); Uhrzeit z2 = new Uhrzeit ( 3662 ); Uhrzeit z3 = new Uhrzeit ( 86399 ); Uhrzeit z4 = new Uhrzeit ( 172799 ); System . out . print ( \"z1 : \" ); z1 . print (); System . out . print ( \"z2 : \" ); z2 . print (); System . out . print ( \"z3 : \" ); z3 . print (); System . out . print ( \"z4 : \" ); z4 . print (); System . out . println ( \"z1 frueher als z2 ? \" + z1 . frueher ( z2 )); System . out . println ( \"z3 frueher als z4 ? \" + z3 . frueher ( z4 )); System . out . println ( \"z1 plus 40 Sekunden : \" + z1 . jetztPlusXSekunden ( 40 )); System . out . println ( \"z2 plus 3598 Sekunden : \" + z2 . jetztPlusXSekunden ( 3598 )); System . out . println ( \"z3-z2 in Sekunden : \" + z3 . differenzInSekunden ( z2 )); System . out . printf ( \"%n%n------------------- Test UhrzeitArray ------------------------%n%n\" ); UhrzeitArray ua = new UhrzeitArray ( 10 ); ua . fill (); ua . print (); System . out . println ( \"frueheste : \" + ua . frueheste ()); Uhrzeit frueh = new Uhrzeit ( 36000 ); Uhrzeit spaet = new Uhrzeit ( 72000 ); UhrzeitArray zwischen = ua . zwischen ( frueh , spaet ); System . out . print ( \"frueh : \" ); frueh . print (); System . out . print ( \"spaet : \" ); spaet . print (); System . out . print ( \"zwischen : \" ); zwischen . print (); ua . sortieren (); ua . print (); UhrzeitArray kleinsterAbstand = ua . kleinsterAbstand (); System . out . print ( \"kleinster Abstand : \" ); kleinsterAbstand . print (); } } L\u00e4nder und Kontinente Implementieren Sie eine Klasse Land . Objektvariablen sind name vom Typ String (Name des Landes) , groesse vom Typ int (Gr\u00f6\u00dfe des Landes) und einwohner vom Typ int (Anzahl der Einwohner des Landes) . Die Objektvariablen sind nur in der Klasse sichtbar! Schreiben Sie f\u00fcr alle drei Objektvariablen Getter ( getName() , getGroesse() , `getEinwohner())! Schreiben Sie eine Objektmethode erzeugeName() . Diese Methode gibt einen String zur\u00fcck, der sich aus einem gro\u00dfen Buchstaben und einer Ziffer zusammensetzt, also z.B. K8 , L1 , J4 usw. Sowohl der Gro\u00dfbuchstabe als auch die Ziffer sollen mithilfe der Klasse Random zuf\u00e4llig erzeugt werden. Tipps: um die Klasse Random verwenden zu k\u00f6nnen, m\u00fcssen Sie sie aus dem java.util -Paket importieren, - verwenden Sie sowohl zum Erzeugen des Gro\u00dfbuchstabens als auch zum Erzeugen der Ziffer die Objektmethode nextInt(int bound) der Klasse Random , - der ASCII-Code von A ist 65 , der von Z ist 90 (es sind 26 verschiedene Buchstaben) - bei den Ziffern sind alle 10 Ziffern [0, \u2026,9] m\u00f6glich Schreiben Sie f\u00fcr die Klasse Land einen parameterlosen Konstruktor. In diesem Konstruktor wird die Objektvariable name mithilfe der erzeugeName() -Methode initialisiert, - die Objektvariable groesse wird mit einem Zufallswert aus dem Wertebereich [1, \u2026, 100] (100 verschiedene Zahlen, 1 und 100 inklusive) initialisiert und - die Objektvariable einwohner mit einem Zufallswert aus dem Wertebereich [1, \u2026, 1000] (1000 verschiedene Zahlen, 1 und 1000 inklusive) initialisiert. - Nutzen Sie erneut die Klasse Random und die Methode nextInt(bound) . Schreiben Sie eine Objektmethode ewDichte() . Diese Methode gibt ein double zur\u00fcck und gibt die Anzahl der einwohner pro groesse an. \u00dcberschreiben Sie die Objektmethode toString() so, dass ein Land in der folgenden Form als ein String zur\u00fcckgegeben wird (Zufallswerte): A3 : 37 km2 : 91 ew : 2 ,4595 Zuerst der Name des Landes und dann : , - dann die Groesse des Landes gefolgt von km2 : , - dann die Anzahl der Einwohner des Landes gefolgt von ew : und - dann die Einwohnerdichte mit vier Stellen nach dem Komma. Der String soll so formatiert sein, dass die Doppelpunkte : und das Komma bei der Einwohnerdichte bei der Ausgabe mehrerer Strings untereinander stehen!, also z.B. so: G5 : 76 km2 : 25 ew : 0 ,3289 W0 : 60 km2 : 18 ew : 0 ,3000 S9 : 6 km2 : 585 ew : 97 ,5000 H1 : 4 km2 : 965 ew : 241 ,2500 Schreiben Sie eine Objektmethode print() . Diese Methode gibt den durch toString() erzeugten String auf der Konsole aus. Schreiben Sie die Objektmethode istGroesser(Land land) . Diese Methode gibt ein true zur\u00fcck, wenn bei dem aufrufenden Objekt der Wert von groesse gr\u00f6\u00dfer ist als von land . Ansonsten false . Schreiben Sie die Objektmethode hatMehrEinwohner(Land land) . Diese Methode gibt ein true zur\u00fcck, wenn bei dem aufrufenden Objekt der Wert von einwohner gr\u00f6\u00dfer ist als von land . Ansonsten false . Schreiben Sie die Objektmethode nameIstGroesser(Land land) . Diese Methode gibt ein true zur\u00fcck, wenn bei dem aufrufenden Objekt der Wert von name lexikografisch gr\u00f6\u00dfer ist als von land . Ansonsten false. Tipp: f\u00fcr zwei Strings s1 und s2 gilt, dass s1 lexikografisch gr\u00f6\u00dfer ist, wenn der Wert von s1.compareTo(s2) einem positiven int -Wert etspricht. \u00dcberschreiben Sie die Objektmethode equals(Object o) . Diese Methode gibt ein true zur\u00fcck, wenn das aufrufende Objekt den gleichen Namen hat wie o . Sonst false . Schreiben Sie eine Klasse Testklasse mit main() -Methode. Erzeugen Sie in der main() -Methode in einer Schleife 10 Objekte der Klasse Land und rufen (auch in der Schleife) jeweils die print() -Methode auf. Es entsteht folgende Ausgabe (Beispielwerte sind zuf\u00e4llig und unterscheiden sich!): J6 : 34 km2 : 198 ew : 5 ,8235 B4 : 72 km2 : 171 ew : 2 ,3750 Z8 : 93 km2 : 712 ew : 7 ,6559 W2 : 75 km2 : 149 ew : 1 ,9867 O0 : 100 km2 : 576 ew : 5 ,7600 Q5 : 21 km2 : 210 ew : 10 ,0000 O9 : 71 km2 : 533 ew : 7 ,5070 B8 : 52 km2 : 57 ew : 1 ,0962 K4 : 71 km2 : 830 ew : 11 ,6901 A9 : 98 km2 : 288 ew : 2 ,9388 Erzeugen Sie 1 Objekt von Land und rufen Sie f\u00fcr dieses Objekt die print() -Methode auf. Erzeugen Sie in einer Schleife so lange ein weiteres Objekt von Land , bis die beiden Objekte laut equals() -Methode gleich sind. Z\u00e4hlen Sie mit, wie viele Objekte von Land Sie erzeugen mussten, bis ein gleiches Objekt gefunden wurde. Geben Sie das gefundene Objekt mithilfe der print() -Methode aus und wie viele Objekte erzeugt wurden. Es entsteht folgende Ausgabe (Beispielwerte sind zuf\u00e4llig und unterscheiden sich!): I1 : 28 km2 : 914 ew : 32 ,6429 I1 : 80 km2 : 1 ew : 0 ,0125 43 andere Laender erzeugt Erzeugen Sie zwei Objekte l1 und l2 von Land und wenden Sie die Methoden istGroesser() , hatMehrEinwohner() und nameIstGroesser() so an, dass folgende Ausgabe entsteht (Zufallswerte!): l1 : T0 : 30 km2 : 237 ew : 7 ,9000 l2 : K0 : 29 km2 : 328 ew : 11 ,3103 l1 groesser als l2 ? : true l1 mehr Einwohner als l2 ? : false l1 lexikografisch groesser als l2 ? : true Schreiben Sie eine Klasse Kontinent . Objektvariablen dieser Klasse sind: laender vom Typ Land[] und kontinent vom Typ char . Beide Objektvariablen sind nur innerhalb der Klasse sichtbar! Schreiben Sie einen parametrisierten Konstruktor Kontinent(char kontinent, int anzahlLaender) . Innerhalb des Konstruktors werden: der Parameterwert kontinent verwendet, um die Objektvariable kontinent zu initialisieren, - das Array erzeugt, auf das die Objektvariable laender referenziert. Das Array hat die L\u00e4nge anzahlLaender , - sowie das laender -Array vollst\u00e4ndig mit Objekten vom Typ Land bef\u00fcllt. Schreiben Sie eine Objektmethode getAnzLaender() . Diese Methode gibt die Anzahl der L\u00e4nder im laender -Array als int zur\u00fcck. Schreiben Sie eine Objektmethode getLaender() . Diese Methode gibt eine Referenz auf das laender -Array zur\u00fcck. Schreiben Sie eine Objektmethode getLandAtIndex(int index) . Diese Methode gibt das Land zur\u00fcck, das im laender -Array unter dem Index index gespeichert ist. Sollte index kein korrekter Index aus dem laender -Array sein, wird null zur\u00fcckgegeben. Schreiben Sie eine Objektmethode getSummen() . Diese Methode gibt ein int -Array der L\u00e4nge 2 zur\u00fcck. Der erste Eintrag in diesem Array ist die Summe der Gr\u00f6\u00dfen aller L\u00e4nder im laender -Array und der zweite Eintrag ist die Summe der Einwohner aller L\u00e4nder im laender -Array. \u00dcberschreiben Sie die Objektmethode toString() so, dass ein String in der folgenden Form zur\u00fcckgegeben wird (Zufallswerte!): Kontinent a -------------------------- S2 : 81 km2 : 918 ew : 11 ,3333 Z7 : 14 km2 : 453 ew : 32 ,3571 O4 : 35 km2 : 713 ew : 20 ,3714 Q9 : 14 km2 : 728 ew : 52 ,0000 F1 : 23 km2 : 714 ew : 31 ,0435 K9 : 67 km2 : 630 ew : 9 ,4030 W5 : 35 km2 : 128 ew : 3 ,6571 Summen : 269 : 4284 es wird Kontinent und der Name des Kontinents in der ersten Zeile ausgegeben, dann kommt eine Trennlinie (egal, wie lang), dann kommen untereinander alle L\u00e4nder aus dem laender-Array, dann kommt eine Lehrzeile und dann kommen die Summen der Gr\u00f6\u00dfen der L\u00e4nder und die Summen der Einwohner (beliebig formatiert) Schreiben Sie eine Objektmethode print() . Diese Methode gibt den durch toString() erzeugten String auf der Konsole aus. Schreiben Sie eine Objektmethode sortiere(int nach) . Diese Methode sortiert das laender -Array aufsteigend von klein nach gro\u00df. Der Parameter nach hat folgende Bedeutung: Ist der Wert von nach 0 , dann wird das Array nach der groesse der L\u00e4nder sortiert. Ist der Wert von nach 1 , dann wird das Array nach der Anzahl der einwohner der L\u00e4nder sortiert. Ist der Wert von nach 2 , dann wird das Array nach der Einwohnerdichte ( ewDichte ) der L\u00e4nder sortiert. F\u00fcr jeden anderen Wert von nach (also alles au\u00dfer 0,1,2 ) wird das Array lexikografisch nach den Namen der L\u00e4nder sortiert. Erzeugen Sie in der main() -Methode ein Array, in dem jedes Element vom Typ Kontinent ist. Das Array hat die L\u00e4nge 5 . Bef\u00fcllen Sie dieses Array mit Kontinent -Objekten in einer Schleife(!) wie folgt: Die f\u00fcnf Kontinente haben die Namen a , b , c , d , e (der ASCII-Code von a ist 97 , der von b ist 98 usw. ). Der erste Kontinent hat 7 L\u00e4nder, der zweite hat 8, der dritte 9, der vierte 10 und der f\u00fcnfte Kontinent hat 11 L\u00e4nder. Rufen Sie f\u00fcr alle Kontinente jeweils die print() -Methode auf. Es entsteht folgende Ausgabe (Zufallswerte!): Kontinent a -------------------------- S2 : 81 km2 : 918 ew : 11 ,3333 Z7 : 14 km2 : 453 ew : 32 ,3571 O4 : 35 km2 : 713 ew : 20 ,3714 Q9 : 14 km2 : 728 ew : 52 ,0000 F1 : 23 km2 : 714 ew : 31 ,0435 K9 : 67 km2 : 630 ew : 9 ,4030 W5 : 35 km2 : 128 ew : 3 ,6571 Summen : 269 : 4284 Kontinent b -------------------------- R8 : 65 km2 : 337 ew : 5 ,1846 L9 : 57 km2 : 732 ew : 12 ,8421 T0 : 74 km2 : 796 ew : 10 ,7568 P4 : 13 km2 : 481 ew : 37 ,0000 L5 : 48 km2 : 575 ew : 11 ,9792 Q2 : 35 km2 : 538 ew : 15 ,3714 M8 : 72 km2 : 865 ew : 12 ,0139 T0 : 29 km2 : 855 ew : 29 ,4828 Summen : 393 : 5179 Kontinent c -------------------------- I9 : 91 km2 : 84 ew : 0 ,9231 X9 : 41 km2 : 842 ew : 20 ,5366 V7 : 31 km2 : 120 ew : 3 ,8710 O3 : 48 km2 : 990 ew : 20 ,6250 P6 : 27 km2 : 565 ew : 20 ,9259 J7 : 54 km2 : 810 ew : 15 ,0000 S9 : 72 km2 : 401 ew : 5 ,5694 C4 : 29 km2 : 486 ew : 16 ,7586 I2 : 6 km2 : 393 ew : 65 ,5000 Summen : 399 : 4691 Kontinent d -------------------------- C0 : 44 km2 : 122 ew : 2 ,7727 E2 : 8 km2 : 925 ew : 115 ,6250 I1 : 12 km2 : 585 ew : 48 ,7500 X9 : 13 km2 : 583 ew : 44 ,8462 Z6 : 10 km2 : 24 ew : 2 ,4000 J1 : 20 km2 : 161 ew : 8 ,0500 I2 : 75 km2 : 432 ew : 5 ,7600 Y8 : 69 km2 : 224 ew : 3 ,2464 H1 : 45 km2 : 410 ew : 9 ,1111 P1 : 24 km2 : 332 ew : 13 ,8333 Summen : 320 : 3798 Kontinent e -------------------------- J6 : 22 km2 : 358 ew : 16 ,2727 N9 : 95 km2 : 471 ew : 4 ,9579 G5 : 94 km2 : 524 ew : 5 ,5745 G0 : 72 km2 : 753 ew : 10 ,4583 L3 : 84 km2 : 49 ew : 0 ,5833 M8 : 39 km2 : 13 ew : 0 ,3333 K7 : 22 km2 : 881 ew : 40 ,0455 Y3 : 58 km2 : 355 ew : 6 ,1207 H3 : 28 km2 : 2 ew : 0 ,0714 V2 : 67 km2 : 94 ew : 1 ,4030 S9 : 15 km2 : 392 ew : 26 ,1333 Summen : 596 : 3892 Rufen Sie f\u00fcr den ersten Kontinent im Array nacheinander die Methoden sortiere(0) , print() , sortiere(1) , print() , sortiere(2) , print() , sortiere(3) , print() auf. Es entsteht folgende Ausgabe (Zufallswerte!): Kontinent a // keine Ausgabe, nur Info: Kontinent unsortiert -------------------------- S2 : 81 km2 : 918 ew : 11 ,3333 Z7 : 14 km2 : 453 ew : 32 ,3571 O4 : 35 km2 : 713 ew : 20 ,3714 Q9 : 14 km2 : 728 ew : 52 ,0000 F1 : 23 km2 : 714 ew : 31 ,0435 K9 : 67 km2 : 630 ew : 9 ,4030 W5 : 35 km2 : 128 ew : 3 ,6571 Kontinent a // keine Ausgabe, nur Info: nach groesse sortiert -------------------------- Z7 : 14 km2 : 453 ew : 32 ,3571 Q9 : 14 km2 : 728 ew : 52 ,0000 F1 : 23 km2 : 714 ew : 31 ,0435 O4 : 35 km2 : 713 ew : 20 ,3714 W5 : 35 km2 : 128 ew : 3 ,6571 K9 : 67 km2 : 630 ew : 9 ,4030 S2 : 81 km2 : 918 ew : 11 ,3333 Kontinent a // keine Ausgabe, nur Info: nach einwohner sortiert -------------------------- W5 : 35 km2 : 128 ew : 3 ,6571 Z7 : 14 km2 : 453 ew : 32 ,3571 K9 : 67 km2 : 630 ew : 9 ,4030 O4 : 35 km2 : 713 ew : 20 ,3714 F1 : 23 km2 : 714 ew : 31 ,0435 Q9 : 14 km2 : 728 ew : 52 ,0000 S2 : 81 km2 : 918 ew : 11 ,3333 Kontinent a // keine Ausgabe, nur Info: nach ewDichte sortiert -------------------------- W5 : 35 km2 : 128 ew : 3 ,6571 K9 : 67 km2 : 630 ew : 9 ,4030 S2 : 81 km2 : 918 ew : 11 ,3333 O4 : 35 km2 : 713 ew : 20 ,3714 F1 : 23 km2 : 714 ew : 31 ,0435 Z7 : 14 km2 : 453 ew : 32 ,3571 Q9 : 14 km2 : 728 ew : 52 ,0000 Kontinent a // keine Ausgabe, nur Info: nach name sortiert -------------------------- F1 : 23 km2 : 714 ew : 31 ,0435 K9 : 67 km2 : 630 ew : 9 ,4030 O4 : 35 km2 : 713 ew : 20 ,3714 Q9 : 14 km2 : 728 ew : 52 ,0000 S2 : 81 km2 : 918 ew : 11 ,3333 W5 : 35 km2 : 128 ew : 3 ,6571 Z7 : 14 km2 : 453 ew : 32 ,3571 Schreiben Sie eine Klasse Welt . Objektvariable dieser Klasse ist kontinente vom Typ Kontinent[] . Die Objektvariable ist nur innerhalb der Klasse sichtbar! Schreiben Sie einen parametrisierten Konstruktor Welt(Kontinent[] kontinente) . Die Referenz des Parameters wird der Objektvariablen zugewiesen. Schreiben Sie eine Objektmethode getAlleLaender() . Diese Methode gibt ein Land -Array zur\u00fcck, in dem alle L\u00e4nder aus dem kontinente -Array enthalten sind. Schreiben Sie eine Objektmethode printAlleLaender(Land[] alleLaender) , die das als Parameter \u00fcbergebene Array in der folgenden Form ausgibt (Zufallswerte!): F1 : 23 km2 : 714 ew : 31 ,0435 K9 : 67 km2 : 630 ew : 9 ,4030 O4 : 35 km2 : 713 ew : 20 ,3714 Q9 : 14 km2 : 728 ew : 52 ,0000 S2 : 81 km2 : 918 ew : 11 ,3333 W5 : 35 km2 : 128 ew : 3 ,6571 Z7 : 14 km2 : 453 ew : 32 ,3571 R8 : 65 km2 : 337 ew : 5 ,1846 L9 : 57 km2 : 732 ew : 12 ,8421 T0 : 74 km2 : 796 ew : 10 ,7568 P4 : 13 km2 : 481 ew : 37 ,0000 L5 : 48 km2 : 575 ew : 11 ,9792 Es sind mehr L\u00e4nder \u2013 ist hier gek\u00fcrzt. Also einfach alle L\u00e4nder untereinander. Schreiben Sie eine Objektmethode enthaeltDoppel() . Diese Methode gibt ein true zur\u00fcck, wenn das kontinente -Array L\u00e4nder enth\u00e4lt, die den gleichen Namen haben, also laut equals() gleich sind. Ansonsten false . Schreiben Sie eine Objektmethode groesstestLand() . Diese Methode gibt das gr\u00f6\u00dfte Land (gr\u00f6\u00dfte groesse ) aller L\u00e4nder im kontinente -Array zur\u00fcck. Schreiben Sie eine Objektmethode alleLaenderGroesserAls(int groesse) , die ein Land[] zur\u00fcckgibt. Das zur\u00fcckgegebene Land[] enth\u00e4lt alle L\u00e4nder aus dem kontinente -Array, die gr\u00f6\u00dfer sind als der Parameterwert groesse . Testen Sie in der main() -Methode die Methoden getAlleLaender() und printAlleLaender() der Klasse Welt , so dass f\u00fcr die Methoden folgende Ausgaben entstehen (Zufallswerte!): L6 : 37 km2 : 122 ew : 3 ,2973 M9 : 22 km2 : 351 ew : 15 ,9545 O4 : 84 km2 : 717 ew : 8 ,5357 P4 : 93 km2 : 759 ew : 8 ,1613 Q3 : 3 km2 : 771 ew : 257 ,0000 R1 : 48 km2 : 610 ew : 12 ,7083 V3 : 40 km2 : 153 ew : 3 ,8250 E8 : 58 km2 : 195 ew : 3 ,3621 I9 : 19 km2 : 875 ew : 46 ,0526 Z6 : 47 km2 : 188 ew : 4 ,0000 Y6 : 75 km2 : 858 ew : 11 ,4400 C7 : 26 km2 : 676 ew : 26 ,0000 V8 : 1 km2 : 470 ew : 470 ,0000 Q8 : 92 km2 : 214 ew : 2 ,3261 T7 : 52 km2 : 544 ew : 10 ,4615 U1 : 46 km2 : 939 ew : 20 ,4130 C9 : 22 km2 : 594 ew : 27 ,0000 Z5 : 94 km2 : 353 ew : 3 ,7553 G6 : 9 km2 : 237 ew : 26 ,3333 D8 : 85 km2 : 910 ew : 10 ,7059 I5 : 15 km2 : 521 ew : 34 ,7333 V7 : 58 km2 : 546 ew : 9 ,4138 V8 : 25 km2 : 535 ew : 21 ,4000 I4 : 91 km2 : 407 ew : 4 ,4725 W1 : 92 km2 : 278 ew : 3 ,0217 M4 : 30 km2 : 494 ew : 16 ,4667 R5 : 8 km2 : 912 ew : 114 ,0000 O1 : 15 km2 : 858 ew : 57 ,2000 S3 : 46 km2 : 463 ew : 10 ,0652 M9 : 43 km2 : 624 ew : 14 ,5116 P5 : 35 km2 : 704 ew : 20 ,1143 Y2 : 2 km2 : 243 ew : 121 ,5000 X9 : 79 km2 : 928 ew : 11 ,7468 Z4 : 36 km2 : 311 ew : 8 ,6389 C6 : 2 km2 : 249 ew : 124 ,5000 J6 : 6 km2 : 683 ew : 113 ,8333 G8 : 18 km2 : 3 ew : 0 ,1667 W3 : 24 km2 : 502 ew : 20 ,9167 K9 : 81 km2 : 996 ew : 12 ,2963 A0 : 46 km2 : 950 ew : 20 ,6522 K9 : 99 km2 : 84 ew : 0 ,8485 T5 : 93 km2 : 488 ew : 5 ,2473 X1 : 40 km2 : 555 ew : 13 ,8750 Q9 : 18 km2 : 631 ew : 35 ,0556 I9 : 22 km2 : 867 ew : 39 ,4091 Rufen Sie die Methoden enthaeltDoppel() , groesstesLand() , alleLaenderGroesserAls(50) und printAlleLaender() so auf, dass folgende Ausgaben entstehen (Zufallswerte!): Enthaelt Doppel? : true groesstes Land : K9 : 99 km2 : 84 ew : 0 ,8485 Alle Laender groesser als 50 : O4 : 84 km2 : 717 ew : 8 ,5357 P4 : 93 km2 : 759 ew : 8 ,1613 E8 : 58 km2 : 195 ew : 3 ,3621 Y6 : 75 km2 : 858 ew : 11 ,4400 Q8 : 92 km2 : 214 ew : 2 ,3261 T7 : 52 km2 : 544 ew : 10 ,4615 Z5 : 94 km2 : 353 ew : 3 ,7553 D8 : 85 km2 : 910 ew : 10 ,7059 V7 : 58 km2 : 546 ew : 9 ,4138 I4 : 91 km2 : 407 ew : 4 ,4725 W1 : 92 km2 : 278 ew : 3 ,0217 X9 : 79 km2 : 928 ew : 11 ,7468 K9 : 81 km2 : 996 ew : 12 ,2963 K9 : 99 km2 : 84 ew : 0 ,8485 T5 : 93 km2 : 488 ew : 5 ,2473 eine m\u00f6gliche L\u00f6sung f\u00fcr L\u00e4nder und Kontinente Land.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 package klausur ; import java.util.Random ; public class Land { private String name ; private int groesse ; private int einwohner ; public String getName () { return this . name ; } public int getGroesse () { return this . groesse ; } public int getEinwohner () { return this . einwohner ; } public String erzeugeName () { Random r = new Random (); int ascii = r . nextInt ( 26 ) + 65 ; char c = ( char ) ascii ; String s = \"\" + c ; int nr = r . nextInt ( 10 ); s += nr ; return s ; } public Land () { this . name = this . erzeugeName (); Random r = new Random (); this . groesse = r . nextInt ( 100 ) + 1 ; this . einwohner = r . nextInt ( 1000 ) + 1 ; } public double ewDichte () { double ewDichte = ( double ) this . einwohner / ( double ) this . groesse ; return ewDichte ; } @Override public String toString () { String s = String . format ( \"%s : %3d km2 : %4d ew : %8.4f\" , this . name , this . groesse , this . einwohner , this . ewDichte ()); return s ; } public void print () { System . out . println ( this . toString ()); } public boolean istGroesser ( Land l ) { return this . groesse > l . groesse ; } public boolean hatMehrEinwohner ( Land l ) { return this . einwohner > l . einwohner ; } public boolean nameIstGroesser ( Land l ) { return this . name . compareTo ( l . name ) > 0 ; } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Land lo = ( Land ) o ; return this . name . equals ( lo . name ); } } Kontinent.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 package klausur ; public class Kontinent { private Land [] laender ; private char kontinent ; public Kontinent ( char kontinent , int anzahlLaender ) { this . kontinent = kontinent ; this . laender = new Land [ anzahlLaender ] ; for ( int index = 0 ; index < this . laender . length ; index ++ ) { this . laender [ index ] = new Land (); } } public int getAnzLaender () { return this . laender . length ; } public Land [] getLaender () { return this . laender ; } public Land getLandAtIndex ( int index ) { if ( index >= 0 && index < this . getAnzLaender ()) { return this . laender [ index ] ; } else { return null ; } } /* public char getKontinent() { return this.kontinent; } */ public int [] getSummen () { int summeEw = 0 ; int summeQm = 0 ; for ( int index = 0 ; index < this . laender . length ; index ++ ) { summeEw += this . laender [ index ] . getEinwohner (); summeQm += this . laender [ index ] . getGroesse (); } int [] summen = { summeQm , summeEw }; return summen ; } @Override public String toString () { String s = String . format ( \"Kontinent %c %n\" , this . kontinent ); s += String . format ( \"--------------------------%n\" ); for ( int index = 0 ; index < this . laender . length ; index ++ ) { s += String . format ( \"%24s %n\" , this . laender [ index ] ); } return s ; } public void print () { System . out . println ( this . toString ()); } public void sortiere ( int nach ) { for ( int bubble = 1 ; bubble < this . laender . length ; bubble ++ ) { for ( int index = 0 ; index < this . laender . length - bubble ; index ++ ) { if ( nach == 0 && this . laender [ index ] . istGroesser ( this . laender [ index + 1 ] ) || nach == 1 && this . laender [ index ] . hatMehrEinwohner ( this . laender [ index + 1 ] ) || nach == 2 && this . laender [ index ] . ewDichte () > this . laender [ index + 1 ] . ewDichte () || nach != 0 && nach != 1 && nach != 2 && this . laender [ index ] . nameIstGroesser ( this . laender [ index + 1 ] )) { Land tmp = this . laender [ index ] ; this . laender [ index ] = this . laender [ index + 1 ] ; this . laender [ index + 1 ] = tmp ; } } } } } Kontinent.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 package klausur ; public class Welt { private Kontinent [] kontinente ; public Welt ( Kontinent [] kontinente ) { this . kontinente = kontinente ; } public int anzahlLaender () { int anzahl = 0 ; for ( int index = 0 ; index < this . kontinente . length ; index ++ ) { anzahl += this . kontinente [ index ] . getAnzLaender (); } return anzahl ; } public Land [] getAlleLaender () { Land [] alleLaender = new Land [ this . anzahlLaender () ] ; int indexAlle = 0 ; for ( int kontinent = 0 ; kontinent < this . kontinente . length ; kontinent ++ ) { for ( int index = 0 ; index < this . kontinente [ kontinent ] . getAnzLaender (); index ++ ) { alleLaender [ indexAlle ++] = this . kontinente [ kontinent ] . getLandAtIndex ( index ); } } return alleLaender ; } /* * war nicht gefordert */ public Land [] sortiereAlleLaenderNachName () { Land [] alleLaender = this . getAlleLaender (); for ( int bubble = 1 ; bubble < alleLaender . length ; bubble ++ ) { for ( int index = 0 ; index < alleLaender . length - bubble ; index ++ ) { if ( alleLaender [ index ] . nameIstGroesser ( alleLaender [ index + 1 ] )) { Land tmp = alleLaender [ index ] ; alleLaender [ index ] = alleLaender [ index + 1 ] ; alleLaender [ index + 1 ] = tmp ; } } } return alleLaender ; } public void printAlleLaender ( Land [] alleLaender ) { for ( int index = 0 ; index < alleLaender . length ; index ++ ) { System . out . println ( alleLaender [ index ] ); } } public boolean enthaeltDoppel () { Land [] alleLaender = this . getAlleLaender (); for ( int index1 = 0 ; index1 < alleLaender . length - 1 ; index1 ++ ) { for ( int index2 = index1 + 1 ; index2 < alleLaender . length ; index2 ++ ) { if ( alleLaender [ index1 ] . equals ( alleLaender [ index2 ] )) { return true ; } } } return false ; } public Land [] alleLaenderGroesserAls ( int groesse ) { Land [] alleLaender = this . getAlleLaender (); int anzahl = 0 ; for ( int index = 0 ; index < alleLaender . length ; index ++ ) { if ( alleLaender [ index ] . getGroesse () > groesse ) { anzahl ++ ; } } Land [] laender = new Land [ anzahl ] ; int indexLaender = 0 ; for ( int index = 0 ; index < alleLaender . length ; index ++ ) { if ( alleLaender [ index ] . getGroesse () > groesse ) { laender [ indexLaender ++] = alleLaender [ index ] ; } } return laender ; } public Land groesstesLand () { Land [] alleLaender = this . getAlleLaender (); int indexGroesstes = 0 ; for ( int index = 1 ; index < alleLaender . length ; index ++ ) { if ( alleLaender [ index ] . istGroesser ( alleLaender [ indexGroesstes ] )) { indexGroesstes = index ; } } return alleLaender [ indexGroesstes ] ; } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 package klausur ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n------------------ Test Land ------------------%n%n\" ); for ( int i = 0 ; i < 10 ; i ++ ) { new Land (). print (); } System . out . printf ( \"%n%n----------------- Land equals -----------------%n%n\" ); Land l1 = new Land (); Land l2 = new Land (); int anz = 0 ; while ( ! l1 . equals ( l2 )) { l2 = new Land (); anz ++ ; } l1 . print (); l2 . print (); System . out . println ( anz + \" andere Laender erzeugt\" ); System . out . printf ( \"%n%n----------------- Land Vergleiche -----------------%n%n\" ); l1 = new Land (); l2 = new Land (); System . out . print ( \"l1 : \" ); l1 . print (); System . out . print ( \"l2 : \" ); l2 . print (); System . out . println (); System . out . println ( \"l1 groesser als l2 ? : \" + l1 . istGroesser ( l2 )); System . out . println ( \"l1 mehr Einwohner als l2 ? : \" + l1 . hatMehrEinwohner ( l2 )); System . out . println ( \"l1 lexikografisch groesser als l2 ? : \" + l1 . nameIstGroesser ( l2 )); System . out . printf ( \"%n%n----------------- Kontinent ------------------%n%n\" ); final int ANZAHL_KONTINENTE = 5 ; final int ASCII_KLEIN_A = 97 ; Kontinent [] ka = new Kontinent [ ANZAHL_KONTINENTE ] ; for ( int index = 0 ; index < ANZAHL_KONTINENTE ; index ++ ) { char c = ( char )( index + ASCII_KLEIN_A ); int anzahlLaender = index + 7 ; ka [ index ] = new Kontinent ( c , anzahlLaender ); ka [ index ] . print (); int [] summen = ka [ index ] . getSummen (); System . out . println ( \"Summen : \" + summen [ 0 ] + \" : \" + summen [ 1 ] ); System . out . println (); } System . out . printf ( \"%n%n----------------- sortieren ------------------%n%n\" ); ka [ 0 ] . print (); ka [ 0 ] . sortiere ( 0 ); ka [ 0 ] . print (); ka [ 0 ] . sortiere ( 1 ); ka [ 0 ] . print (); ka [ 0 ] . sortiere ( 2 ); ka [ 0 ] . print (); ka [ 0 ] . sortiere ( 3 ); ka [ 0 ] . print (); System . out . printf ( \"%n%n----------------- Welt ------------------%n%n\" ); Welt welt = new Welt ( ka ); Land [] alleLaender = welt . getAlleLaender (); welt . printAlleLaender ( alleLaender ); System . out . println (); System . out . println ( \"Enthaelt Doppel? : \" + welt . enthaeltDoppel ()); Land groesstes = welt . groesstesLand (); System . out . println ( \"groesstes Land : \" + groesstes . toString ()); Land [] groesser = welt . alleLaenderGroesserAls ( 50 ); System . out . println ( \"Alle Laender groesser als 50 :\" ); welt . printAlleLaender ( groesser ); } } MyString Information: Wir bauen in Ans\u00e4tzen die Klasse String nach, d.h. wir bauen uns einen eigenen Datentypen f\u00fcr Zeichenketten: MyString . Ein Objekt von MyString ist intern ein char[] (wir nennen es wort ). Von der Klasse String selbst verwenden wir nur zwei Methoden: charAt(index) und length() , und zwar in dem Konstruktor von MyString , dem ein String als Parameter \u00fcbergeben wird \u2192 das steht aber nochmal explizit dort Ansonsten verwenden wir von String keine weiteren Methoden (ist nicht erlaubt, w\u00e4re aber auch nirgendwo hilfreich) Wir erstellen insgesamt nur 2 Klassen: MyString und Testklasse . Implementieren Sie eine Klasse MyString . Objektvariable ist wort vom Typ char[] (unsere Zeichenkette - Array von Zeichen) . Die Objektvariable ist nur in der Klasse sichtbar! Schreiben Sie f\u00fcr MyString einen parameterlosen Konstruktor. In diesem Konstruktor wird das wort -Array erzeugt mit der L\u00e4nge 0 . Schreiben Sie f\u00fcr MyString einen parametrisierten Konstruktor, dem ein einzelnes Zeichen ( char ) als Parameter \u00fcbergeben wird. In diesem Konstruktor wird das wort -Array erzeugt mit der L\u00e4nge 1 und das einzelne Zeichen wird in das wort -Array gespeichert. Schreiben Sie f\u00fcr MyString einen parametrisierten Konstruktor, dem ein String als Parameter \u00fcbergeben wird. In diesem Konstruktor wird das wort -Array erzeugt mit der L\u00e4nge des Strings und jedes einzelne Zeichen des Strings wird in das wort -Array gespeichert. Hierzu nutzen Sie die Methoden charAt(index) und length() der Klasse String . \u00dcberschreiben Sie die Objektmethode toString() so, dass alle Zeichen aus dem wort -Array als ein String zur\u00fcckgegeben werden, also z.B. Schreiben Sie eine Objektmethode print() . Diese Methode gibt den durch toString() erzeugten String auf der Konsole aus. Schreiben Sie die Objektmethode getLength() . Diese Methode gibt die L\u00e4nge des wort -Arrays zur\u00fcck. Schreiben Sie die Objektmethode getCharAt(int index) . Diese Methode gibt ein Leerzeichen zur\u00fcck, wenn der \u00fcbergebene index kein Index des wort -Arrays ist. Ansonsten wird das Zeichen zur\u00fcckgegeben, das im wort -Array unter dem Index index gespeichert ist. Schreiben Sie die Objektmethode contains(char c) . Diese Methode gibt ein true zur\u00fcck, wenn c im wort -Array vorkommt. Ansonsten false . \u00dcberschreiben Sie die Objektmethode equals(Object o) . Diese Methode gibt ein true zur\u00fcck, wenn das aufrufende Objekt die gleiche wort -L\u00e4nge hat wie o und auch alle Zeichen in den beiden wort -Arrays elementweise gleich sind (also Index f\u00fcr Index). Sonst false . Schreiben Sie eine Klasse Testklasse mit main() -Methode. Erzeugen Sie in der main() -Methode ein Objekt s1 von MyString mithilfe des parameterlosen Konstruktors, ein Objekt s2 von MyString, dem der einzelne Buchstabe a \u00fcbergeben wird, ein Objekt s3 von MyString, dem die Zeichenkette hallo \u00fcbergeben wird, rufen Sie f\u00fcr alle drei Objekte die print()-Methode auf. Es entsteht folgende Ausgabe: // das hier geh\u00f6rt nicht zur Ausgabe, soll nur zeigen, dass zun\u00e4chst eine Leerzeile kommt a hallo Wenden Sie die getCharAt() -Methode an und lassen sich f\u00fcr das dritte MyString -Objekt ( s3 ) den Buchstaben auf der Konsole ausgeben, der am Index 1 gespeichert ist. Wenden Sie die contains() -Methode 2 Mal an und lassen sich f\u00fcr das dritte MyString -Objekt auf der Konsole ausgebenden, ob der Buchstabe a in dessen wort-Array gespeichert ist und ob der Buchstabe b in dessen wort-Array gespeichert ist. Es entsteht folgende Ausgabe: a a in hallo ? true b in hallo ? false Erzeugen Sie zwei weitere Objekte s4 und s5 von MyString , einmal mit der Zeichenkette hallo und einmal mit der Zeichenkette halLo und vergleichen Sie beide Objekte mithilfe der equals() -Methode mit dem dritten MyString -Objekt s3 . Es entstehen folgende Ausgaben: s3 gleich s4 ? true s3 gleich s4 ? false weiter mit MyString : Schreiben Sie eine Objektmethode getAsciiCodeOfCharAt(int index) . Diese Methode gibt den Ascii-Code des Zeichens zur\u00fcck, das im wort -Array unter dem Index index gespeichert ist. Ist index kein Index aus dem wort -Array, wird -1 zur\u00fcckgegeben. Schreiben Sie eine Objektmethode append(char c) . Diese Methode h\u00e4ngt das Zeichen c an das wort -Array, d.h. danach ist das wort -Array um 1 l\u00e4nger als vor Aufruf der Methode. Schreiben Sie eine Objektmethode append(MyString s) . Diese Methode h\u00e4ngt alle Zeichen aus s (aus dessen wort -Array) an das wort -Array des aufrufenden Objektes. Tipp: Verwenden Sie dazu die append(char c) -Methode. Schreiben Sie eine Objektmethode concat(MyString s1, MyString s2) . Diese Methode gibt ein (neues) MyString -Objekt zur\u00fcck, in dem das wort -Array alle Zeichen aus s1 und s2 enth\u00e4lt. (Diese concat() -Methode entspricht s1+s2 f\u00fcr Strings): Schreiben Sie die Objektmethode firstIndexOf(char c) . Diese Methode gibt den Index zur\u00fcck, an dem das Zeichen c zum ersten Mal im wort -Array vorkommt. Kommt das Zeichen c nicht im wort -Array vor, wird -1 zur\u00fcckgegeben. Schreiben Sie die Objektmethode lastIndexOf(char c) . Diese Methode gibt den Index zur\u00fcck, an dem das Zeichen c zum letzten Mal im wort -Array vorkommt. Kommt das Zeichen c nicht im wort -Array vor, wird -1 zur\u00fcckgegeben. Schreiben Sie eine Objektmethode substring(int beginIndex) . Diese Methode gibt ein (neues) MyString -Objekt zur\u00fcck. Das neue MyString -Objekt enth\u00e4lt im wort -Array alle Zeichen aus dem wort -Array des aufrufenden Objektes ab dem Index beginIndex (inklusive). Ist beginIndex kein korrekter Index aus dem wort -Array des aufrufenden Objektes, wird ein MyString -Objekt mit leerem wort -Array zur\u00fcckgegeben. weiter mit Testklasse : Testen Sie die getAsciiCodeOfCharAt() -Methode, indem Sie sich den Ascii-Code des Zeichens von s3 auf dem Index 1 ausgeben lassen: Ascii-Code Zeichen aus s3 mit Index 1 = 97 Testen Sie die append(char) -Methode, indem Sie an s3 das Zeichen c h\u00e4ngen: halloc Testen Sie die append(MyString) -Methode, indem Sie sich ein weiteres MyString -Objekt s6 mit ballo erzeugen und dieses Objekt an s3 h\u00e4ngen: hallocballo Testen Sie die concat() -Methode, indem Sie sich ein weiteres MyString -Objekt s7 mit leerem wort -Array erzeugen und f\u00fcr dieses Objekt die concat() -Methode aufrufen, wobei Sie die Objekte s4 und s6 \u00fcbergeben: halloballo Testen Sie die firstIndexOf() - und die lastIndexOf() - Methode, indem Sie jeweils in s3 nach dem Buchstaben l suchen (kleines L): erstes l in s3 am Index 2 letztes l in s3 am Index 9 Testen Sie die substring() -Methode, indem Sie den Teilstring ab Index 5 f\u00fcr s3 ausgeben: cballo weiter mit MyString : Schreiben Sie eine Objektmethode substring(int beginIndex, int endIndex) . Diese Methode gibt ein (neues) MyString -Objekt zur\u00fcck. Das neue MyString -Objekt enth\u00e4lt im wort -Array alle Zeichen aus dem wort -Array des aufrufenden Objektes ab dem Index beginIndex (inklusive) bis zum Index endIndex (exklusive). Ist beginIndex kein korrekter Index aus dem wort -Array des aufrufenden Objektes oder ist beginIndex gr\u00f6\u00dfer gleich endIndex , wird ein MyString -Objekt mit leerem wort -Array zur\u00fcckgegeben. Schreiben Sie eine Objektmethode toUpperCase() , die ein (neues) MyString -Objekt zur\u00fcckgibt. Alle Kleinbuchstaben aus dem aufrufenden Objekt sind im neuen Objekt Gro\u00dfbuchstaben. Tipps: Bei der Umwandlung m\u00fcssen Sie sich nur um die Kleinbuchstaben k\u00fcmmern, alle anderen Zeichen werden direkt \u00fcbernommen. Kleinbuchstaben haben die Ascii-Codes 97 ( a ) \u2013 122 ( z ) Gro\u00dfbuchstaben haben die Ascii-Codes 65 ( A ) \u2013 90 (`Z) Schreiben Sie eine Objektmethode reverse() , die ein (neues) MyString -Objekt zur\u00fcckgibt. In diesem neuen Objekt ist die Zeichenfolge im wort -Array genau umgekehrt wie im aufrufenden Objekt. Schreiben Sie die Objektmethode contains(MyString s) . Diese Methode gibt ein true zur\u00fcck, wenn das wort -Array von s im wort -Array des aufrufenden Objektes vorkommt. Ansonsten false . weiter mit Testklasse : Testen Sie Sie alle 4 Methoden substring(int beginIndex, int endIndex) , toUpperCase() , reverse() und contains(MyString s) : -------------------- Teil 3 ---------------------------- s3 : hallocballo s3 substring ( 3 ,7 ) : locb s3 toUpperCase () : HALLOCBALLO s3 reverse () : ollabcollah s4 : locba s4 in s3 ? : true eine m\u00f6gliche L\u00f6sung f\u00fcr MyString MyString.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 package klausurvorbereitung.mystring ; public class MyString { private char [] wort ; public MyString () { this . wort = new char [ 0 ] ; } public MyString ( char letter ) { this . wort = new char [ 1 ] ; this . wort [ 0 ] = letter ; } public MyString ( String wort ) { this . wort = new char [ wort . length () ] ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { this . wort [ index ] = wort . charAt ( index ); } } @Override public String toString () { String s = \"\" ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { s += this . wort [ index ] ; } return s ; } public void print () { System . out . println ( this . toString ()); } public int getLength () { return this . wort . length ; } public char getCharAt ( int index ) { if ( index < 0 || index > this . wort . length ) { return ' ' ; } else { return this . wort [ index ] ; } } public boolean contains ( char c ) { for ( int index = 0 ; index < this . wort . length ; index ++ ) { if ( this . wort [ index ]== c ) return true ; } return false ; } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; MyString so = ( MyString ) o ; if ( this . getLength () != so . getLength ()) return false ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { if ( this . wort [ index ] != so . wort [ index ] ) return false ; } return true ; } public int getAsciiCodeOfCharAt ( int index ) { if ( index < 0 || index > this . wort . length ) { return - 1 ; } else { return ( int ) this . wort [ index ] ; } } public void append ( char c ) { char [] newWord = new char [ this . getLength () + 1 ] ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { newWord [ index ] = this . getCharAt ( index ); } newWord [ this . getLength () ] = c ; this . wort = newWord ; } public void append ( MyString s ) { for ( int index = 0 ; index < s . getLength (); index ++ ) { this . append ( s . getCharAt ( index )); } } public MyString concat ( MyString s1 , MyString s2 ) { MyString s = new MyString (); s . append ( s1 ); s . append ( s2 ); return s ; } public int firstIndexOf ( char c ) { final int NOT_FOUND = - 1 ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { if ( this . wort [ index ] == c ) return index ; } return NOT_FOUND ; } public int lastIndexOf ( char c ) { final int NOT_FOUND = - 1 ; for ( int index = this . wort . length - 1 ; index >= 0 ; index -- ) { if ( this . wort [ index ] == c ) return index ; } return NOT_FOUND ; } public MyString substring ( int beginIndex ) { if ( beginIndex < 0 || beginIndex >= this . getLength ()) { return new MyString (); } else { MyString s = new MyString ( this . getCharAt ( beginIndex )); for ( int index = beginIndex + 1 ; index < this . getLength (); index ++ ) { s . append ( this . getCharAt ( index )); } return s ; } } public MyString substring ( int beginIndex , int endIndex ) { if ( beginIndex < 0 || beginIndex >= this . getLength ()) { return new MyString (); } else { MyString s = new MyString ( this . getCharAt ( beginIndex )); for ( int index = beginIndex + 1 ; ( index < this . getLength () && index < endIndex ); index ++ ) { s . append ( this . getCharAt ( index )); } return s ; } } public MyString toUpperCase () { final int FROM_LOWER_TO_UPPER = 32 ; MyString s = new MyString (); for ( int index = 0 ; index < this . getLength (); index ++ ) { char c = this . getCharAt ( index ); int ascii = ( int ) c ; if ( ascii >= 97 && ascii <= 122 ) { ascii = ascii - FROM_LOWER_TO_UPPER ; c = ( char ) ascii ; } s . append ( c ); } return s ; } public MyString reverse () { MyString s = new MyString (); for ( int index = this . wort . length - 1 ; index >= 0 ; index -- ) { s . append ( this . getCharAt ( index )); } return s ; } public boolean contains ( MyString s ) { if ( this . getLength () < s . getLength ()) return false ; if ( this . equals ( s )) return true ; boolean noMatch = true ; for ( int index = 0 ; index < this . wort . length ; index ++ ) { if ( this . wort [ index ]== s . getCharAt ( 0 )) { for ( int i = 1 ; i < s . getLength () && noMatch ; i ++ ) { if ( index + i >= this . getLength () || this . wort [ index + i ] != s . wort [ i ] ) { noMatch = false ; } } return true ; } noMatch = true ; } return false ; } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package klausurvorbereitung.mystring ; public class Testklasse { public static void main ( String [] args ) { System . out . printf ( \"%n%n------------------ Teil 1 a) --------------------------%n%n\" ); MyString s1 = new MyString (); s1 . print (); MyString s2 = new MyString ( 'a' ); s2 . print (); MyString s3 = new MyString ( \"hallo\" ); s3 . print (); System . out . printf ( \"%n%n------------------ Teil 1 b) --------------------------%n%n\" ); char c1 = s3 . getCharAt ( 1 ); System . out . println ( c1 ); System . out . println ( \"a in hallo ? \" + s3 . contains ( 'a' )); System . out . println ( \"b in hallo ? \" + s3 . contains ( 'b' )); System . out . printf ( \"%n%n------------------ Teil 1 c) --------------------------%n%n\" ); MyString s4 = new MyString ( \"hallo\" ); s4 . print (); MyString s5 = new MyString ( \"halLo\" ); s5 . print (); System . out . println ( \"s3 gleich s4 ? \" + s3 . equals ( s4 )); System . out . println ( \"s3 gleich s4 ? \" + s3 . equals ( s5 )); System . out . printf ( \"%n%n-------------------- Teil 2 ----------------------------%n%n\" ); int i1 = s3 . getAsciiCodeOfCharAt ( 1 ); System . out . println ( \"Ascii-Code Zeichen aus s3 mit Index 1 = \" + i1 ); s3 . append ( 'c' ); s3 . print (); MyString s6 = new MyString ( \"ballo\" ); s3 . append ( s6 ); s3 . print (); MyString s7 = new MyString (); s7 = s7 . concat ( s4 , s6 ); s7 . print (); int i2 = s3 . firstIndexOf ( 'l' ); System . out . println ( \"erstes l in s3 am Index \" + i2 ); i2 = s3 . lastIndexOf ( 'l' ); System . out . println ( \"letztes l in s3 am Index \" + i2 ); MyString s8 = s3 . substring ( 5 ); s8 . print (); System . out . printf ( \"%n%n-------------------- Teil 3 ----------------------------%n%n\" ); System . out . print ( \"s3 : \" ); s3 . print (); MyString s9 = s3 . substring ( 3 , 7 ); System . out . print ( \"s3 substring(3,7) : \" ); s9 . print (); s9 = s3 . toUpperCase (); System . out . print ( \"s3 toUpperCase() : \" ); s9 . print (); s9 = s3 . reverse (); System . out . print ( \"s3 reverse() : \" ); s9 . print (); s4 = new MyString ( \"locba\" ); System . out . print ( \"s4 : \" ); s4 . print (); System . out . println ( \"s4 in s3 ? : \" + s3 . contains ( s4 )); } }","title":"Probeklausuren"},{"location":"uebungen/#ausdrucke","text":"gleich 12 Welche der folgenden Ausdr\u00fccke haben den Wert 12? a ) 12 % 13 b ) 24 % 2 c ) 24 /2 d ) 25 /2 Versuchen Sie zun\u00e4chst, die richtige Antwort im Kopf zu ermitteln und erstellen dann ein geeignetes Programm, das Ihnen den jeweiligen Wert des Ausdrucks ausgibt. Pre- und Postoperator Welchen Wert hat die Variable c nach Ausf\u00fchren der Anweisungen? int a = 300 ; int b = a++ ; int c = --b ; Begr\u00fcnden Sie die richtige Antwort! Was passiert durch die Anweisungen?","title":"Ausdr\u00fccke"},{"location":"uebungen/#schleifen","text":"Laufvariablen Welche der Schleifen gibt alle Elemente des Arrays nums aus? Das Array enth\u00e4lt genau 4 Zahlen. a ) for ( int i = 0 ; i < nums.length ; i++ ) { System.out.println ( nums [ i ]) ; } b ) for ( int i = 0 ; i < = 3 ; i++ ) { System.out.println ( nums [ i ]) ; } c ) for ( int i = 1 ; i < = 3 ; i++ ) { System.out.println ( nums [ i ]) ; } d ) for ( int i = 0 ; i < = 3 ; i++ ) { System.out.println ( nums [ 0 ]) ; } e ) for ( int i = nums.length - 1 ; i > = 0 ; i-- ) { System.out.println ( nums [ i ]) ; } Quadratzahl Schreiben Sie eine Methode istQuadratzahl(int zahl) , die ein true zur\u00fcckgibt, wenn zahl eine Quadratzahl ist und ein false sonst. Die Math -Klasse soll nicht verwendet werden. Primzahl Schreiben Sie eine Methode printPrimzahlenBisN(int n) , die alle Primzahlen bis n auf die Konsole ausgibt. Schreiben Sie sich dazu eine Hilfsmethode istPrimzahl(int zahl) , die ein true zur\u00fcckgibt, wenn zahl eine Primzahl ist und ein false , wenn nicht. int-Zahl umdrehen Schreiben Sie eine Methode int reverseInt(int number) , die die \u00fcbergebene number umdreht und die umgedrehte int -Zahl zur\u00fcckgibt, also z.B. aus 1234 wird 4321 . Weitere Beispiele: aus -123 wird -321 und aus 1200 wird 21 . Zahlen raten Schreiben Sie folgendes Programm. Mithilfe von Random \"denkt\" sich das Programm eine Zahl zwischen 0 und 100 aus. Sie k\u00f6nnen \u00fcber die Konsole dann eine Zahl eingeben. Das Programm sagt Ihnen, ob die \"gedachte\" Zahl gr\u00f6\u00dfer oder kleiner als die von Ihnen eingegebene Zahl ist. Sie geben solange eine Zahl ein, bis Sie die \"gedachte\" Zahl erraten haben. Bin\u00e4rzahl Schreiben Sie eine Methode, die eine short -Zahl in eine Bin\u00e4rzahl umwandelt. Diese Bin\u00e4rzahl speichern Sie als long . Z.B. ist 32 bin\u00e4r 100000 , 63 ist 111111 , 48 ist 110000 usw.","title":"Schleifen"},{"location":"uebungen/#arrays","text":"Sotierte Arrays zusammenf\u00fcgen Implementieren Sie eine Methode, die zwei als Parameter \u00fcbergebene sortierte int -Arrays zu einem sortierten int -Array zusammenf\u00fcgt. Geben Sie das neue sortierte Array zur\u00fcck. Unsortierte Arrays sortiert zusammenf\u00fcgen Implementieren Sie eine Methode, die zwei als Parameter \u00fcbergebene unsortierte int -Arrays zu einem sortierten int -Array zusammenf\u00fcgt. Geben Sie das neue sortierte Array zur\u00fcck. Explode Implementieren Sie eine Methode int[] explode(int number) . Diese Methode erstellt ein int[] -Array, das wie folgt bef\u00fcllt ist: Bsp. number=5 \u2192 {1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5} . F\u00fcr jede Zahl x gibt es also x Eintr\u00e4ge im Array bis einschlie\u00dflich number .","title":"Arrays"},{"location":"variablen/","text":"Variablen und Datentypen \u00b6 Sowohl in dem euklidischen Algorithmus als auch bei der (3n+1)-Vermutung haben wir mit Zahlen gerechnet. Diese haben wir in Variablen gespeichert (z.B. a , b , n ). Wir kennen Variablen bereits aus der Mathematik. Dort \"speichern\" wir Werte in diesen Variablen. Das gleiche passiert auch beim Programmieren. Unsere erste Klasse \u00b6 Damit wir das Thema Variablen und Datentypen auch gleich anwenden k\u00f6nnen, schreiben wir nun endlich unser erstes Programm, d.h. wir implementieren unsere erste Klasse. Dazu \u00f6ffnen wir BlueJ und w\u00e4hlen im Men\u00fc Project --> New Project . Es \u00f6ffnet sich ein Dateiauswahlfenster. Unter Location sollten Sie sich einen Ordner aussuchen, in den Sie zuk\u00fcnftig Ihre BlueJ-Projekte speichern, z.B. unter Ihren Dokumenten/Prog1/BlueJ . Als Projektname k\u00f6nnen Sie z.B. variablen nehmen. Es erscheint Klicken Sie auf den Button New Class... und geben Sie Ihrer Klasse den Namen Variablen . Beachten Sie, dass wir Klassennamen stets mit einem Gro\u00dfbuchstaben beginnen! Klicken Sie den Button Compile , dann verschwinden die Streifen im Klassen-Icon. Doppelklicken Sie auf die Klasse Variablen , es \u00f6ffnet sich das Editor-Fenster: Wir schauen uns den darin enthaltenen Code mal etwas genauer an (die erste leere Zeile habe ich gel\u00f6scht, deshalb ist die Zeilennummerierung um 1 versetzt): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Write a description of class Variablen here. * * @author (your name) * @version (a version number or a date) */ public class Variablen { // instance variables - replace the example below with your own private int x ; /** * Constructor for objects of class Variablen */ public Variablen () { // initialise instance variables x = 0 ; } /** * An example of a method - replace this comment with your own * * @param y a sample parameter for a method * @return the sum of x and y */ public int sampleMethod ( int y ) { // put your code here return x + y ; } } Die Zeilen 1 - 6 enthalten einen Kommentar, einen sogenannten JavaDoc-Kommentar . JavaDoc-Kommentare beginnen mit /** und enden mit */ . Dazwischen kann alles stehen und solche Kommentare gehen meistens \u00fcber mehrere Zeilen. Wir werden JavaDoc noch n\u00e4her kennenlernen. In Zeile 7 steht die Klassensignatur. Es handelt sich um eine \u00f6ffentliche Klasse (deshalb public - lernen wir noch) und nach dem Schl\u00fcsselwort class steht der Klassenname Variablen . In Zeile 8 beginnt die Implementierung der Klasse. Diese Implementierung wird durch eine \u00f6ffnende geschweifte Klammer { begonnen und endet in Zeile 32 mit der schlie\u00dfenden geschweiften Klammer } . In Zeile 9 steht ein sogenannter Zeilenkommentar . Ein Zeilenkommentar beginnt mit // und endet automatisch am Ende der Zeile. Hier dient der Kommentar dazu, \u00fcber die Objektvariable x zu informieren, die in Zeile 10 deklariert wird. In Zeile 10 wird eine Variable deklariert . Der Name der Variable ist x . Sie ist vom Datentyp int . Wir k\u00f6nnen nur innerhalb der Klasse Variablen auf diese Variable zugreifen, da sie als private deklariert wird. Zu Variablen und Datentypen kommen wir gleich ausf\u00fchrlich. In den Zeilen 12-14 steht erneut ein JavaDoc-Kommentar - dieses Mal kommentiert er die nachfolgende Methode, den sogenannten Konstruktor . In den Zeilen 15-19 sehen wir die erste Methode der Klasse. Diese Methode ist speziell, denn sie hei\u00dft exakt so, wie die Klasse selbst. Es handelt sich um einen sogenannten Konstruktor . Diese Methode wird aufgerufen, um ein Objekt der Klasse zu erzeugen. Wir werden uns ausf\u00fchrlich mit Konstruktoren besch\u00e4ftigen. Typischerweise werden im Konstruktor alle Objektvariablen initialisiert , d.h. die Objektvariablen bekommen einen initialen Wert. Hier wird der Objektvariablen x der Wert 0 zugewiesen (Zeile 18 ). In den Zeilen 27-31 wird die Methode sampleMethod() implementiert. Dieser Methode wird ein Parameter y vom Typ int \u00fcbergeben. Diese Methode gibt den Wert der Summe von x und y zur\u00fcck. Wir kommen dazu, wenn wir uns ausgiebiger mit Methoden besch\u00e4ftigen. Zun\u00e4chst \u00e4ndern wir dieses Programm, indem wir (fast) alle Kommentare l\u00f6schen und die sampleMethod() -Methode umbenennen und umprogrammieren. Unsere Klasse sieht nun so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); } } Die Implementierung unserer Objektmethode hat sich ge\u00e4ndert: der Name der Methode ist nun printObjectState() , die Methode erwartet keinen Parameter mehr, der R\u00fcckgabetyp (kennen wir noch nicht) der Methode ist nicht mehr int , sondern void und die Implementierung der Methode besteht aus einer einzigen Anweisung System.out.println(x); . Wir klicken auf den Compile -Button, dann erzeugen wir uns ein Objekt von der Klasse Variablen und nennen es variable1 und f\u00fchren f\u00fcr dieses Objekt die Methode printObjectState() aus. Es erscheint Dieses Fenster ist unser Terminal-Fenster (auch Konsole genannt). In diesem Terminal-Fenster wird der Wert der Objektvariablen x ausgegeben. Dieser Wert ist 0 . System.out.println(x); \u00b6 Schauen wir uns System.out.println(x); zun\u00e4chst etwas genauer an. Wir verwenden hier eine Klasse, n\u00e4mlich die Klasse System . Diese Klasse existiert bereits und wurde von den Java-Entwicklern f\u00fcr uns geschrieben. Sie geh\u00f6rt zum Standardpaket von Java, existiert bereits seit der ersten Version von Java und befindet sich im Paket java.lang (zu Paketen kommen wir sp\u00e4ter). Diese Klasse hat eine interessante (Klassen-)Variable, die wir verwenden, n\u00e4mlich out . Diese Variable stellt in unserem (Betriebs-)System die Verbindung zu unserem Standardausgabeger\u00e4t bereit, in unserem Fall die Konsole (das Terminal-Fenster ). Um nun eine Ausgabe auf diese Konsole zu generieren, verwenden wir die Methode println() . Wir sehen hier eine typische Notation in Java, die sogenannte Punktnotation . Mithilfe dieser Punktnotation greifen wir auf Eigenschaften von Klassen und Objekten zu. In unserem Beispiel greifen wir mit System.out auf das Standardausgabeger\u00e4t zu und mit System.out.println() auf die println() -Methode des Ausgabeger\u00e4tes 1 . Die Methode println() erzeugt also eine Ausgabe auf unsere Konsole. Jetzt m\u00fcssen wir nur noch sagen, WAS ausgegeben werden sollen. Dazu \u00fcbergeben wir dieser Methode hier die Variable x . Der Wert dieser Variablen ( 0 ) wird gelesen und ausgegeben. Bei System.out.println(x); handelt es sich um eine Anweisung . Eine Anweisung endet in Java immer mit einem Semikolon ; . Dieses d\u00fcrfen wir nicht vergessen, ansonsten haben wir einen Syntaxfehler und unser Programm kann nicht compiliert und nicht ausgef\u00fchrt werden. println() vs. print() \u00b6 In unserem ersten Programm haben wir die Methode println() verwendet, um etwas auf der Konsole auszugeben. Es gibt noch eine andere M\u00f6glichkeit f\u00fcr die Ausgabe auf die Konsole, n\u00e4mlich die Methode print() , also ohne ln . Das ln steht f\u00fcr Line und gibt an, dass nach der Ausgabe ein Zeilenumbruch erfolgt. Wir \u00e4ndern zun\u00e4chst unser Programm, indem wir die Anweisung System.out.println(x); kopieren und weitere 2x einf\u00fcgen. printObjectState()-Methode mit println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); System . out . println ( x ); System . out . println ( x ); } } Um das \u00dcberpr\u00fcfen unserer \u00c4nderungen zu beschleunigen, klicken wir mit der rechten Maustaste auf die Klasse Variablen und w\u00e4hlen Create Test Class . Es entsteht eine Testklasse VariablenTest (gr\u00fcner Kasten). Wir klicken mit der rechten Maustaste auf diesen gr\u00fcnen Kasten und w\u00e4hlen Create Test Method... . Wir werden nach einem Namen f\u00fcr die testmethode gefragt und w\u00e4hlen testPrintObjectState . Nun wird unser Test \"aufgenommen\". Wir erzeugen ein Objekt der Klasse Variablen , nennen dieses Objekt variable1 und rufen f\u00fcr dieses Objekt die Methode printObjectState() auf. Dann beenden wir die \"Aufnahme\" des Tests, indem wir unter recording auf den Button End klicken. Nun brauchen wir f\u00fcr das Ausf\u00fchren unserer Methode immer nur noch die testPrintObjectState() -Methode der Klasse VariablenTest auszuf\u00fchren (Rechtsklick auf die Klasse und Methode ausw\u00e4hlen). Das ruft die Erzeugung eines Variablen -Objektes auf und f\u00fchrt daf\u00fcr die Methode printObjectState() aus. In unserem Terminal (der Konsole) erscheinen 0 0 0 Eventuell sind bei Ihnen vier 0 untereinander, weil das Terminal noch die 0 vom ersten Test angezeigt hatte. Das k\u00f6nnen Sie verhindern, indem Sie im BlueJ -Men\u00fc Options ausw\u00e4hlen und darin einen Haken bei Clear screen at method call setzen. Das hei\u00dft, dass jede der Ausgaben mithilfe der println() -Methode in einer neuen Zeile erfolgt. Nach jeder Ausgabe erfolgt also ein Zeilenumbruch, der Ausgabecursor wird in die n\u00e4chste Zeile gesetzt. Die n\u00e4chste Ausgabe beginnt am Anfang der neuen Zeile. Wir wollen nun unser Programm \u00e4ndern und verwenden nicht mehr die println() - Methode, sondern print() : printObjectState()-Methode mit print() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . print ( x ); System . out . print ( x ); System . out . print ( x ); } } Wir f\u00fchren den Test erneut aus und erhalten auf der Konsole die Ausgabe: 000 Die print() -Methode gibt also nur den Wert der Variablen x aus, f\u00fchrt aber danach keinen Zeilenumbruch durch. Der Ausgabecursor bleibt hinter dem letzten ausgegebenen Zeichen stehen. Unsere drei Nullen werden in der Konsole deshalb hintereinander ausgegeben. Wir \u00e4ndern nun unser Programm erneut und f\u00fcgen folgende Anweisungen hinzu: System.out.println() . Wir rufen also die println() -Methode auf, ohne eine Zeichenkette zu \u00fcbergeben, die ausgegeben werden soll. Diese Anweisung sorgt einfach daf\u00fcr, dass ein Zeilenumbruch erfolgt. Es wird also nichts ausgegeben, aber der Ausgabecursor an den Beginn der n\u00e4chsten Zeile gesetzt. printObjectState()-Methode mit print() und println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . print ( x ); System . out . println (); System . out . print ( x ); System . out . println (); System . out . print ( x ); System . out . println (); } } Wir f\u00fchren den Test erneut aus und erhalten auf der Konsole die Ausgabe: 0 0 0 \u00dcbung Erzeugen Sie folgende Ausgabe auf der Konsole: 0 0 0 Eine m\u00f6gliche L\u00f6sung 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); System . out . println (); System . out . println ( x ); System . out . println (); System . out . println ( x ); System . out . println (); } } So, jetzt haben wir unser erstes Programm geschrieben und k\u00f6nnen nun Variablen kennenlernen und dieses Konzept auch gleich anwenden. Variablen \u00b6 Eine Variable kann man sich wie eine Kiste vorstellen, in die genau ein Wert passt. Diese Kiste hat einen Namen (den Namen der Variable) und in der Programmierung wird auch noch gesagt, welche Art von Wert dort hineinpasst. Man spricht auch vom Typ der Variablen oder noch besser vom Datentyp . Eine Variable besteht also aus drei Dingen: dem Wert der Variablen (genau einer) dem Datentyp der Variablen (bestimmt den Wertebereich, also die m\u00f6glichen Werte, die die Variable annehmen kann) dem Namen der Variablen (daf\u00fcr gibt es Regeln, wie solche Bezeichner aussehen d\u00fcrfen) Das Erstellen einer Variablen (die Definition einer Variablen ) besteht in der Programmierung aus zwei Schritten: der Variablendeklaration : in der Deklaration wird festgelegt, wie die Variable hei\u00dft und von welchem Datentyp sie ist der Initialisierung : bei der Initialisierung wird der Variablen ihr erster Wert zugewiesen Damit wir einer Variablen ihren Datentyp zuweisen k\u00f6nnen, m\u00fcssen wir die Datentypen zun\u00e4chst kennenlernen, die eine Variable haben kann. Datentypen in Java \u00b6 In Java gibt es acht sogenannte primitive Datentypen . Wir bezeichnen diese primitiven Datentypen als Wertetypen . Eine Variable von einem Wertetyp kann genau einen Wert annehmen. In folgender Tabelle sind diese Datentypen aufgelistet und ihre jeweilige Bedeutung erkl\u00e4rt. Datentyp Bedeutung int eine Variable vom Datentyp int kann ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Die kleinste Zahl vom Typ int ist -2^31 \"klein\" und die gr\u00f6\u00dfte Zahl vom Typ int ist 2^31-1 gro\u00df. int ist der Standard-Typ f\u00fcr ganze Zahlen in Java. int steht f\u00fcr integer . byte eine Variable vom Datentyp byte kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Die kleinste byte -Zahl ist -2^7 klein und die gr\u00f6\u00dfte byte -Zahl ist 2^7-1 gro\u00df. short eine Variable vom Datentyp short kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Im Gegensatz zu byte ist er aber gr\u00f6\u00dfer. Die kleinste short -Zahl ist -2^15 klein und die gr\u00f6\u00dfte short -Zahl ist 2^15-1 gro\u00df. long eine Variable vom Datentyp long kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel gr\u00f6\u00dfer. long wird immer dann verwendet, wenn der Wertebereich von int nicht ausreicht, also entweder f\u00fcr sehr, sehr kleine oder sehr, sehr gro\u00dfe Zahlen. Die kleinste long -Zahl ist -2^63 klein und die gr\u00f6\u00dfte long -Zahl ist 2^63-1 gro\u00df. char Der Datenyp char steht f\u00fcr character . Mit diesem Datentypen werden einzelne Zeichen gespeichert. Der Datentyp char ist ebenfalls ein ganzzahliger Datentyp, nimmt aber nur positive Werte (aus dem Wertebereich 0 bis 65535 an.) Diese Werte sind Zahlenwerte, die der Codierung eines Zeichens entsprechen, z.B. dem Zeichen 'a' . Ein solches Zeichen steht immer in einfachen Hochkommata '' . boolean Der Datentyp boolean kennt nur genau zwei Werte true und false . Eine Variable vom Datentyp boolean kann also entweder genau true sein oder genau false , nichts anderes. double Der Datentyp double ist in Java der Standard-Datentyp f\u00fcr Gleitkommazahlen (also gebrochene Zahlen mit Komma). Die kleinste und gr\u00f6\u00dfte double -Zahl l\u00e4sst sich nicht genau bestimmen, denn das h\u00e4ngt von der Genauigkeit der Angabe hinter dem Komma ab. Es werden aber 64 bit verwendet, um eine double -Zahl zu speichern. float float ist neben double ein weiterer Datentyp f\u00fcr Gleitkommazahlen. Die Genauigkeit der Speicherung als float ist aber nicht so gro\u00df wie bei double , da float nur 32 bit zur Speicherung einer Zahl zur Verf\u00fcgung hat. Deklaration von Variablen \u00b6 Nun, da wir Datentypen kennen, k\u00f6nnen wir Variablen \"erzeugen\". Das \"Erzeugen\" von Variablen besteht aus zwei Schritten: wir vergeben einen Namen f\u00fcr unsere Variable und wir weisen der Variablen einen Datentyp zu. Dieses Erzeugen von Variablen nennt sich Deklaration (oder Variablendeklaration ). Die allgemeine Syntax der Variablendeklaration ist wie folgt: datentyp variablenName ; Wir geben also zuerst den Datentyp an, dann kommt ein Leerschritt, dann den Bezeichner f\u00fcr die Variable (den Namen) und dann folgt ein Semikolon, weil es sich um eine Anweisung handelt. Beispiele: int ganzeZahl ; int number ; long bigNumber ; byte smallNumber ; double nr1 ; float nr2 ; boolean condition ; char character ; F\u00fcr eine Variable wird die Deklaration genau einmal durchgef\u00fchrt. Danach existiert sie und sie kann auch (in Java) nicht ihren Datentypen \u00e4ndern. Noch haben unsere Variablen keine Werte. Das erfolgt erst durch die Initialisierung, also die erste Wertzuweisung. Ehe wir uns das anschauen, \u00fcberlegen wir uns zun\u00e4chst, welche m\u00f6glichen Bezeichner wir f\u00fcr unsere Variablennamen verwenden k\u00f6nnen. Bezeichner \u00b6 Wenn es um Namen geht, die wir in Java selbst vergeben wollen, dann sprechen wir von Bezeichnern . Bezeichner sind nicht nur die Namen von Variablen, sondern sp\u00e4ter auch f\u00fcr Methoden, Klassen, Enumerations, Exceptions und Interfaces. Es gibt einige Regeln f\u00fcr Bezeichner, die wir beachten m\u00fcssen: Bezeichner m\u00fcssen mit einem Java-Buchstaben beginnen Bezeichner setzen sich aus Java-Buchstaben und Java-Zahlen zusammen Java-Buchstaben sind mehr als a - z und A - Z z.B. auch \u20ac , \u00a3 , \u00a5 , $ , Umlaute \u00e4 , \u00f6 , \u00fc , \u00df sowie Buchstaben mit Apostrophen Aber: wir verwenden nur die normalen Buchstaben a - z und A - Z !!! Alles andere f\u00fchrt zu Problemen wichtig: keine Leerzeichen, keine reservierten Schl\u00fcsselw\u00f6rter und keine Sonderzeichen, wie z.B. ! , / , * , { , [ , . , ] , } In Java wird Gro\u00df- und Kleinschreibung unterschieden ( case sensitive )! Reservierte Schl\u00fcsselw\u00f6rter sind Begriffe aus dem Java-Sprachumfang (alle kleingeschrieben) 2 . Dazu geh\u00f6ren: abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while \u00dcbung Bezeichner Warum sind das keine g\u00fcltigen Bezeichner in Java? 2und2macht4 class Hose gewaschen Hurtig! null Konventionen \u00b6 Wir wissen jetzt, was g\u00fcltige Bezeichner sind und was ung\u00fcltige. Dar\u00fcber hinaus gibt es aber auch Vereinbarungen, die helfen, einen besser verst\u00e4ndlichen und konsistenteren Code zu schreiben: wir vergeben nur \"sprechende\" Namen, d.h. man erkennt bereits am Bezeichner, wozu die Variable dient, z.B. sum , input , checkIfEmpty usw. Variablennamen beginnen stets mit einem Kleinbuchstaben (einzige Ausnahmen sind Konstanten, diese schreiben wir vollst\u00e4ndig gro\u00df, d.h. aus lauter Gro\u00dfbuchstaben) Methodennamen beginnen ebenfalls mit einem Kleinbuchstaben, Klassen und Interfaces beginnen stets mit einem Gro\u00dfbuchstaben verwenden die sogenannte camelCaseSchreibweise . Da keine Leerzeichen erlaubt sind, wir aber sprechende Namen haben wollen, die aus mehreren W\u00f6rtern bestehen k\u00f6nnen, schreiben wir den Beginn eines neuen Wortes immer gro\u00df (au\u00dfer ganz am Anfang, denn Methoden- und Variablennamen beginnen ja mit einem Kleinbuchstaben.) Initialisierung von Variablen \u00b6 Nach der Deklaration einer Variablen existiert diese zwar, sie hat jedoch noch keinen Wert. Wir wollen sicherstellen, dass Variablen immer einen Wert haben. Deshalb weisen wir den Variablen direkt nach der Deklaration einen Wert zu. Die erstmalige Wertzuweisung einer Variablen wird Initialisierung genannt. Der Wertzuweisungsoperator = \u00b6 Um einer Variablen einen Wert zuzuweisen, wird der Wertzuweisungsoperator verwendet. Dieser ist ein einfaches Gleichheitszeichen = . Die Syntax der Wertzuweisung ist wie folgt: variablenName = wert ; Auf der linken Seite steht also immer die Variable und auf der rechten Seite der Wert. Auch hier muss am Ende wieder zwingend das Semikolon stehen, denn es handelt sich um eine Anweisung. Wichtig ist, dass der Wert dem Datentyp der Variablen entspricht! Wir geben einige Beispiele f\u00fcr Variablen an, die wir oben deklariert hatten: ganzeZahl = 5 ; // int number = - 1234 ; // int bigNumber = 12345678 ; // long nr1 = 6.54321 ; // double condition = true ; // boolean character = 'a' ; // char Nachdem einer Zahl mithilfe des Wertzuweisungsoperators ein Wert zugewiesen wurde, beh\u00e4lt die Variable den Wert so lange bis ihr ein neuer Wert (mithilfe des Wertzuweisungsoperators) zugewiesen wird. Einer Variablen kann beliebig oft ein neuer Wert zugewiesen werden. Deklaration und Initialisierung in einem Schritt \u00b6 Da wir m\u00f6chten, dass eine Variable sofort nach ihrer Deklaration einen Wert zugewiesen bekommt, ist es \u00fcblich, die Deklaration und die Initialisierung in einem Schritt, d.h. durch eine Anweisung durchzuf\u00fchren. Die Syntax der kombinierten Anweisung (Deklaration und Initialisierung) ist wie folgt: datentyp variablenName = wert ; Wir zeigen die Anwendung der kombinierten Deklaration und Initialisierung anhand der bereits verwendeten Beispiele: int ganzeZahl = 5 ; int number = - 1234 ; long bigNumber = 12345678 ; double nr1 = 6.54321 ; boolean condition = true ; char character = 'a' ; Beachte Wie bereits erw\u00e4hnt, kann eine Variable genau ein Mal deklariert, ihr aber beliebig oft ein neuer Wert zugewiesen werden. Angenommen, Sie wollen der Variablen ganzeZahl einen neuen Wert zuweisen, dann schreiben Sie die Anweisung ganzeZahl = 6; . Sie d\u00fcrfen auf keinen Fall int ganzeZahl = 6; schreiben, denn dann w\u00fcrden Sie ja versuchen, die Variable ganzeZahl erneut zu deklarieren. Diese existiert aber bereits. Sie bekommen einen Compilerfehler und k\u00f6nnen ihr Programm gar nicht erst \u00fcbersetzen. Details zu primitiven Datentypen (Wertetypen) \u00b6 Wie wir bereits bei der Vorstellung der primitiven Datentypen erw\u00e4hnt haben, ist f\u00fcr jeden Datentyp eine gewisse Speichergr\u00f6\u00dfe reserviert. Hier noch einmal die Gr\u00f6\u00dfe der primitiven Datentypen: Datentyp Gr\u00f6\u00dfe Wertebereich boolean 1 Byte 3 true / false char 16 bit 0 ... 65.535 (z.B. 'A' ) byte 8 bit -128 ... 127 short 16 bit -32.768 ... 32.767 int 32 bit -2.147.483.648 ... 2.147.483.647 long 64 bit -2^63 ... 2^63-1 float 32 bit +/-1,4E-45 ... +/-3,4E+38 double 64 bit +/-4,9E-324 ... +/-1,7E+308 Wir schauen uns jetzt noch einige interssante Details zu den Datentypen an. Ganzzahlige Datentypen int , long , short , byte \u00b6 Eine ganze Zahl in einem Java-Programm ist vom Typ int . Dieser Datentyp ist der Standard-Datentyp f\u00fcr ganze Zahlen. Ganze Zahlen werden intern im sogenannten Zweierkomplement dargestellt. Wir schauen uns diese Darstellung am Beispiel des Datentyps byte (der 8 bit gro\u00df ist) einmal genauer an. In der folgenden Darstellung steht die Bedeutung der Position der einzelnen bits ganz oben, beginnend mit der 1 ( 2^0 ) auf der rechten Seite (\"kleinstes\" bit) bis hin zu 2^7 auf der linken Seite (\"gr\u00f6\u00dftest\" bit). Beim Zweierkomplement entspricht diese h\u00f6chste Position jedoch nicht der 128 , sondern der -128 . Dies hat drei Vorteile es wird nicht ein ganzes bit daf\u00fcr verwendet, um zu unterscheiden, ob es sich um eine positive oder negative Zahl handelt die 0 kommt nicht 2x vor ( 1000 0000 und 0000 0000 w\u00e4re jeweils 0 , wenn das f\u00fchrende bit dar\u00fcber entscheiden w\u00fcrde, ob die Zahl positiv oder negativ ist) sowohl die Addition als auch die Subtraktion geht einfacher Die Abbildung zeigt in den oberen drei Zeilen die interne Darstellung von -128 , 127 und 0 . In den drei Zeilen darunter ist dargestellt, wie z.B. die Zahlen 85 , -43 und -85 als Zweierkomplement repr\u00e4sentiert werden. Die folgende Abbildung zeigt die Addition (und somit auch die Subtraktion) zweier Zahlen im Zweierkomplement. Dargestellt sind die Repr\u00e4sentationen von -4 und 3 als Zweierkomplement. Es wird die Addition der beiden Zahlen gezeigt. Da die Werte alle einen begrenzten Wertebereich haben, kann es zu einem Wertebereichs\u00fcberlauf kommen. Ein solcher \u00dcberlauf ist in der folgenden Abbildung dargestellt. Im Datentyp byte ist 127 die gr\u00f6\u00dfte positive Zahl. Die Abbildung verdeutlicht, was passiert, wenn zu dieser gr\u00f6\u00dften Zahl eine 1 hinzuaddiert wird. Beachten Sie, dass ein solcher \u00dcberlauf unbemerkt passiert. Das bedeutet, dass Sie weder einen Fehler noch eine Warnung erhalten. Sie m\u00fcssen sich also immer gut \u00fcberlegen, ob ein solcher \u00dcberlauf bei Ihren Werten passieren kann. Wenn ja, dann sollten Sie zum n\u00e4chstgr\u00f6\u00dferen Datentypen wechseln, also z.B. von int nach long . Datentyp gr\u00f6\u00dfter Wert kleinster Wert byte 127 -128 short 32.767 -32.768 int 2.147.483.647 -2.147.483.648 long 9.223.372.036.854.775.807 -9.223.372.036.854.775.808 \u00dcbung Zweierkomplement Warum ist 1111 1111 als Zweierkomplement im Datentyp byte die Dezimalzahl -1 ? Wie ist die Repr\u00e4sentation der Zahlen -99 und 99 als Zweierkomplement im Datentyp byte ? Was ist das Ergebnis der Rechnung 2.147.483.647 + 1 im Datentyp int und warum? Initialisierung von long -Variablen. \u00b6 Eine ganze Zahl als Literal , also als alleinstehender Wert ist vom Typ int . Wenn wir folgende kombinierte Deklaration und Initialisierung betrachten: long bigNumber = 12345678 ; dann stellen wir fest, dass die Variable bigNumber auf der linken Seite des Wertzuweisungsoperators vom Typ long ist, die Zahl 12345678 aber vom Typ int . Wir werden sp\u00e4ter noch auf solche Typkonvertierung zu sprechen kommen. Es sei hier jedoch bereits angemerkt, dass man eine ganze Zahl auch um das Postfix L erg\u00e4nzen kann (man k\u00f6nnte auch mit dem kleinen Buchstaben l erg\u00e4nzen, das macht man aber nicht, weil die Verwechselungsgefahr mit der 1 zu gro\u00df ist) - mit der Wirkung, dass die Zahl dann nicht mehr vom Typ int , sondern vom Typ long ist. Die \"richtige\" Initialisierung sieht so aus: long bigNumber = 12345678L ; Es ist nur in wenigen F\u00e4llen wirklich erforderlich, das L an die Zahl zu h\u00e4ngen, wenn wir eine long -Variable initialisieren. Warum das so ist, werden wir kennenlernen, wenn wir uns \u00fcber Typkonvertierung Gedanken machen. Trotzdem sei hier schonmal erw\u00e4hnt, dass diese Deklaration und Initialisierung kein Problem ist long bigNumber = 2147483647 ; aber hier bekommen wir einen Fehler und k\u00f6nnen das Programm gar nicht \u00fcbersetzen: long bigNumber = 2147483648 ; Warum k\u00f6nnte das wohl so sein? Wenn wir es \"richtig\" machen, also mit angeh\u00e4ngtem L , dann ist auch wieder alles in Ordnung und das Programm l\u00e4sst sich compilieren: long bigNumber = 2147483648L ; In unseren Programmen werden wir zu 99% den Datentyp int f\u00fcr ganzzahlige Werte verwenden und zu 1% long . Die anderen ganzzahligen Datentypen byte und short braucht man eigentlich gar nicht mehr, da wir keinen Wert mehr darauf legen m\u00fcssen, Arbeitsspeicher zu sparen. char \u00b6 Der Datentyp char ist f\u00fcr das Speichern von Zeichen vorgesehen. Es handelt sich um einen ganzzahligen Datentypen. Mit den ersten Computern stellte sich die Frage, wie Zeichen (also Ziffern und Buchstaben) intern codiert werden k\u00f6nnen. Es hat sich dann zun\u00e4chst die Zeichencodierung des American Standard Code for Information Interchange (ASCII) durchgesetzt, bei der 7 Bit (=128 Zeichen) dazu verwendet wurden, die wichtigsten Zeichen zu kodieren. Neben einigen Steuerzeichen (die ersten 33 \"Zeichen\", z.B. Zeilenvorschub, ESC -Zeichen) wurden z.B. folgende Zeichen wie folgt kodiert: Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 33 ! 47 / 61 = 34 \"\" 48 0 62 > 35 # 49 1 63 ? 36 $ 50 2 64 @ 37 % 51 3 65 A 38 & 52 4 66 B 39 ' 53 5 67 C 40 ( 54 6 68 D 41 ) 55 7 69 E 42 * 56 8 70 F 43 + 57 9 71 G 44 , 58 : 72 H 45 - 59 ; 73 I 46 . 60 < 74 J Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 75 K 89 Y 103 g 76 L 90 Z 104 h 77 M 91 [ 105 i 78 N 92 \\ 106 j 79 O 93 ] 107 k 80 P 94 ^ 108 l 81 Q 95 _ 109 m 82 R 96 \u2035 110 n 83 S 97 a 111 o 84 T 98 b 112 p 85 U 99 c 113 q 86 V 100 d 114 r 87 W 101 e 115 s 88 X 102 f 116 t Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 117 u 121 y 125 } 118 v 122 z 126 ~ 119 w 123 { 127 DEL 120 x 124 | Diese Zeichenkodierung erkl\u00e4rt, warum es sich bei char um einen ganzzahligen Typ handelt. Anstelle eines Zeichens, welches immer in einfachen Hochkommata '' angegeben werden muss, kann auch der ASCII-Code als Zahl verwendet werden. Folgende Beispiele zeigen dies: char ganzzahliger Typ char c1 = 'a' ; System . out . println ( c1 ); // a char c2 = 97 ; System . out . println ( c2 ); // a char c3 = '`' ; c3 ++ ; System . out . println ( c3 ); // a Die 128 verschiedenen Zeichen gen\u00fcgten nat\u00fcrlich schnell nicht mehr und es wurden deutlich gr\u00f6\u00dfere Kodierungstabellen entwickelt. Ein de-facto Standard ist UTF-8 , welcher Bytes (also 8 Bit) zur Kodierung der Zeichen verwendet. Die ersten 128 Zeichen sind dabei mit dem ASCII-Code identisch. Im UTF-8 k\u00f6nnen aber mehrere Bytes hintereinander geschrieben werden und erm\u00f6glichen so einen beliebig gro\u00dfen Kodierungsraum. Der Datentyp char ist 16 Bit gro\u00df, kann also 2 Byte gro\u00dfe Kodierungsr\u00e4ume darstellen (65 536 verschiedene Zeichen). Eine UTF-8-Tabelle finden Sie z.B. hier . Die linke Spalte in dieser Tabelle zeigt den Unicode . Dieser kann auch in Java (in leicht abgewandelter Form) verwendet werden. Scrollen Sie in der Tabelle ein wenig bis zur Position U+00A9 herunter. Dort sehen Sie z.B. die Codierung des \u00a9-Copyright-Zeichens. In Java kann dieser Code wie folgt verwendet werden: char UTF-8 Zeichen char u1 = '\\u00a9' ; System . out . println ( u1 ); // copyright-Zeichen char u2 = '\\u00b0' ; System . out . println ( u2 ); // Grad-Zeichen char u3 = '\\u00bd' ; System . out . println ( u3 ); // 1/2-Zeichen Gleitkomma-Datentypen double , float \u00b6 Eine Gleitkomma-Zahl (also eine Zahl mit einem Punkt, z.B. 5.0 oder -1.2345 ) in einem Java-Programm ist vom Typ double . Dieser Datentyp ist der Standard-Datentyp f\u00fcr Gleitkomma-Zahlen. Der Wertebereich der Datentypen double und float l\u00e4sst sich nicht so leicht angeben, denn entweder wird relativ viel \"Speicher\" f\u00fcr die Genauigkeit verwendet (f\u00fcr die Anzahl der Nachkommastellen, z.B. 0.123456789 ) oder f\u00fcr die Vorkommastellen (z.B. 987654321.0 ). Generell ist der Wertebereich (die Genauigkeit) bei double viel h\u00f6her, denn f\u00fcr eine Variable vom Typ double werden 64 bit reserviert, w\u00e4hrend eine Variable vom Typ float nur 32 bit gro\u00df ist. Bei float beschr\u00e4nkt sich die Genauigkeit auf ca. 7 signifikante Stellen (Nachkommastellen), w\u00e4hrend es bei double ca. 17 signifikante Stellen sind. Beispiel float float floatNumber = 1.0f / 3.0f ; System . out . println ( floatNumber ); // 0.33333334 Im obigen Beispiel wird mithilfe von float der Bruch 1/3 ausgerechnet. Zwei Sachen sind zu beachten Wie wir das schon beim Datentyp long gesehen haben, gibt es auch f\u00fcr Gleitkommazahlen ein Postfix, hier f , um zu sagen, dass eine Zahl vom Typ float sein soll. Ohne das f w\u00e4re sie vom Typ double und wir w\u00fcrden sogar einen Compilerfehler erhalten, wenn wir das f am Ende der Zahl nicht angeben w\u00fcrden. Hier ist es also wichtig, bei der Wertzuweisung anzugeben, dass die Zahl vom Typ float sein soll - n\u00e4mlich durch die Angabe von f ( F ginge auch). Die Genauigkeit bei float ist nicht sehr hoch. 1/3 im float -Wertebereich ergibt 0.33333334 . Schauen wir uns das gleiche Beispiel mit double an: Beispiel float double doubleNumber = 1.0 / 3.0 ; System . out . println ( doubleNumber ); // 0.3333333333333333 Erstens hat der double -Wert deutlich mehr Nachkommastellen (16 statt 8 bei float ) und zweitens ist der Wert somit korrekter. Die Speicherung von Gleikommazahlen erfolgt nach IEEE 754 - Standard . Wir merken uns: wir sollten float eher nicht verwenden, wenn wir Wert auf Genauigkeit legen, wenn wir float verwenden, dann m\u00fcssen wir beim Initialisieren und bei allen Wertezuweisungen darauf achten, dass wir an die Gleikommazahl ein f anh\u00e4ngen, da es sich ansonsten um eine Gleitkommazahl vom Typ double handelt, double ist der Standardtyp f\u00fcr Gleikommazahlen und wenn eine Gleitkommazahl im Programmcode vorkommt, dann handelt es sich um eine Zahl vom Typ double . Datentyp gr\u00f6\u00dfter positiver Wert kleinster positiver Wert float ~3.4028234663852886E+038 ~1.4012984643248171E-045 double ~1.7976931348623157E+308 ~4.9406564584124654E-324 Der Datentyp String \u00b6 Der Datentyp String ist kein primitiver Datentyp (kein Wertetyp), sondern ein sogenannter komplexer Datentyp (oder, wie wir sagen Referenztyp ). Wir erkennen das bereits daran, dass der Datentyp mit einem Gro\u00dfbuchstaben beginnt. Der Unterschied zwischen Variablen von einem Wertetypen und Variablen von Referenztypen ist der, dass die ersten \"nur\" Werte speichern ( 3 , 5 , 'a' , 123.45 , true , ...) und die anderen speichern Objekte (oder richtiger: Referenzen auf Objekte) - darum k\u00fcmmern wir uns sp\u00e4ter sehr ausf\u00fchrlich. Wir k\u00f6nnen uns merken (ist aber derzeit noch nicht wichtig), dass ein String ein Objekt und kein einfacher Wert ist, aber derzeit betrachten wir den Datentyp String wie die primitiven Wertetypen auch. Ein String -Literal erkennt man an den doppelten Anf\u00fchrungsstrichen. Darin kann ein beliebiger Text (bestehend aus allen m\u00f6glichen Zeichen, Buchstaben, Sonderzeichen, Umlauten etc.) stehen, z.B. \"Hallo FIW!\" , \"2und2gleich4 und $ % & 0? | \\ !\" , \" \u00e4 \u00fc \u00f6 \u00df\" . Die Deklaration und Initialisierung einer String -Variablen sieht also so aus: String s1 = \"Informatik\" ; Auch f\u00fcr den Datentyp String gibt es einen Operator, der zwei Strings miteinander verbindet. Er wird Konkatenation ( String-Konkatenation oder Zeichenkettenverbindungsoperator genannt). Das Operatorsymbol der Konkatenation ist in Java + . String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); Die folgenden drei Ausgaben sind alle gleich: String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); // Informatik und Wirtschaft String s2 = \"Informatik\" ; String s3 = \" und\" ; String s4 = \" Wirtschaft\" ; System . out . println ( s2 + s3 + s4 ); // Informatik und Wirtschaft String s5 = \"Informatik\" ; String s6 = s5 + \" und\" ; String s7 = s6 + \" Wirtschaft\" ; System . out . println ( s7 ); //Informatik und Wirtschaft Doppelte Bedeutung des Operatorzeichens + \u00b6 Das + wird sowohl als arithmetischer Operator f\u00fcr numerische Datentypen als auch als Konkatenation f\u00fcr Strings verwendet. In den obigen Beispielen kommen wir damit nicht durcheinander, da v\u00f6llig klar ist, dass es sich dabei um die Konkatenation handelt. Es gibt aber Beispiele, bei denen in einem Ausdruck beide Bedeutungen vorkommen. Diese diskutieren wir jetzt. Zun\u00e4chst schauen wir uns noch eine typische Verwendung der Konkatenation an: typisches Beispiel f\u00fcr die Konkatenation 1 2 3 4 int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 Die Ausgabe bei dem obigen Beispiel ist 3 + 4 = 7 . Schauen wir uns das Beispiel genauer an: In Zeile 3 wird das + eindeutig als arithmetischer Operator verwendet, denn es steht zwischen zwei numerischen Werten ( summand1 und summand2 sind jeweils vom Typ int ) In Zeile 4 kommt + mehrmals vor. Der Ausdruck in den runden Klammern von println() wird von links nach rechts aufgel\u00f6st: Das Literal \" + \" ist ein String. Hier ist + gar kein Operator, sondern nur ein Zeichen. Das + in summand1 + \" + \" ist die Konkatenation. Das liegt daran, dass einer der beiden Operanden, die das + verbindet, vom Typ String ist. Intern wird der Wert von summand1 ( die 3 ) zu einem String und dieser wird mit \" + \" verbunden. Es entsteht ein String \"3 + \" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + \" + summand2 enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn einer der beiden Operanden (der erste) ist vom Typ String . Intern wird der Wert von summand2 ( die 4 ) zu einem String und dieser wird mit \"3 + \" verbunden. Es entsteht ein String \"3 + 4\" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + 4\" + \" = \" enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn beide Operanden (der erste und der zweite) sind vom Typ String . Es entsteht der String \"3 + 4 = \" . Das letzte + steht also in dem Ausdruck \"3 + 4 = \" + summe . Auch hier handelt es sich wieder um die Konkatenation, da einer der beiden Operanden (der erste) vom Typ String ist. Intern wird der Wert von summe ( die 7 ) zu einem String und dieser wird mit \"3 + 4 = \" verbunden. Es entsteht ein String \"3 + 4 = 7\" . Dieser String wird ausgegegeben. \u00dcbung Doppelte Bedeutung von + Angenommen, in dem obigen Beispiel wollen Sie die Summe der beiden Summanden nicht erst in einer Variablen zwischenspeichern, sondern gleich ausgeben. Sie schreiben deshalb folgendes Programm: int summand1 = 3 ; int summand2 = 4 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summand1 + summand2 ); Sie erhalten jedoch nicht die gew\u00fcnschte Ausgabe. Warum nicht? Wie k\u00f6nnen Sie doch die Summe ausgeben, ohne diese zwischenspeichern zu m\u00fcssen? Success Wir k\u00f6nnen nun Variablen deklarieren und initialisieren. Wir kennen alle acht primitiven Datentypen. Wir nennen diese Datentypen Wertetypen . Wir wissen, dass eine ganze Zahl im Java-Programm vom Typ int ist und eine Gleikommazahl vom Typ double . Wir kennen die interne Darstellung von ganzen Zahlen und wir wissen \u00fcber die Kodierung von Zeichen Bescheid. Der datentyp char ist ein ganzzahliger Typ, obwohl er f\u00fcr das Speichern von Zeichen zust\u00e4ndig ist. Dies liegt an der Kodierung der Zeichen als ganze Zahlen. Der Wertzuweisungsoperator ist = . Wenn einer Variablen ein Wert zugewiesen werden soll, dann muss die Variablen links stehen, der Wertzuweisungsoperator in der Mitte und rechts der Wert. Konstanten \u00b6 Wir haben gesagt, dass Variablen beliebig oft einer neuer Wert zugewisen werden kann. Manchmal m\u00f6chte man aber genau das nicht. Sogenannten Konstanten m\u00f6chte man genau einmal einen Wert zuweisen und dann soll dieser Wert nicht mehr \u00fcberschrieben werden k\u00f6nnen. In Java kann man solche Konstanten mithilfe des Schl\u00fcsselwortes final deklarieren: final datentyp KONSTANTE = Wert; Eine Konstante wird zun\u00e4chst wie eine Variable deklariert, d.h. man vergibt einen Namen f\u00fcr die Variable und weist ihr einen Datentyp zu. Au\u00dferdem wird ihr mithilfe des Zuweisungsoperators ein Wert zugewiesen. Um zu verhindern, dass dieser Variablen erneut ein Wert zugewiesen kann, setzt man vor den Datentyp noch das Schl\u00fcsselwort final . Damit ist diese Variable schreibgesch\u00fctzt und es kann ihr nie wieder ein neuer Wert zugewiesen werden. Schauen wir uns ein Beispiel an: final double PI = 3.14159265359 ; Es wird eine Konstante PI deklariert und ihr der Wert 3.14159265359 zugewiesen. Damit wir Konstanten von \"normalen\" Variablen unterscheiden k\u00f6nnen, schreiben wir Konstenten immer gro\u00df . Wenn der Name einer Konstanten aus mehreren W\u00f6rtern besteht, verwendet man typischerweise den Unterstrich _ zum Verbinden der beiden W\u00f6rter, z.B. final int NOT_FOUND = - 1 ; final int MIN_VALUE = - 2147483648 ; final int MAX_VALUE = 2147483647 ; final char DEGREE_SYMBOL = '\\u00b0' ; final char DEGREE_CELSIUS = '\\u2103' ; final char DEGREE_FAHRENHEIT = '\\u2109' ; Ansonsten k\u00f6nnen Sie Konstanten ganz normal verwenden, aber immer nur lesend, also z.B. double area = PI * 25.0 ; System . out . println ( area ); System . out . println ( DEGREE_FAHRENHEIT ); System . out . println ( DEGREE_CELSIUS ); String fahrenheit = DEGREE_SYMBOL + \"F\" ; System . out . println ( fahrenheit ); ergibt folgende Ausgabe: 78 .53981633975 \u2109 \u2103 \u00b0F Wenn Sie in Ihrem Programm versuchen, einer Konstanten einen neuen Wert zuzuweisen, erhalten Sie einen Fehler ( The final variable cannot be assigned ) und Sie k\u00f6nnen das Programm gar nicht erst compilieren. Wann immer Sie in Ihrem Programm ein Literal verwenden, also einen Wert, sollten Sie \u00fcberlegen, ob Sie diesem Wert nicht besser einen Namen geben k\u00f6nnen, n\u00e4mlich daf\u00fcr eine Konstante verwenden, und dann stets die Konstante anstelle des Wertes verwenden. Damit werden sogenannte magic numbers vermieden und das Programm ist lesbarer. Typkonvertierung (type-cast) \u00b6 Java ist statisch typisiert , d.h. dass jede Variable (und jedes Literal) einen Datentyp hat. Dieser wird bei der Deklaration der Variablen festegelgt und ist somit bereits zur Compile-Zeit bekannt. Der Datentyp einer Variablen kann auch nicht mehr ge\u00e4ndert werden 4 . Die Typisierung einer Variablen gibt den Wertebereich vor, aus dem die Variable Werte annehmen kann ( int -Variablen aus dem int -Wertebereich, boolean aus dem Wertebereich {true, false} usw.). Trotzdem ist in Java auch erlaubt, dass Wertezuweisungen nicht nur aus identischen Datentypen m\u00f6glich sind, sondern auch aus kompatiblen Datentypen: 1 2 3 4 5 int a = 5 ; // links ist int und rechts ist int --> identische Datentypen long b = 5 ; // links ist long und rechts ist int --> kompatible Datentypen int c = boolean ; // nicht erlaubt --> Fehler!!! keine kompatiblen Datentypen (int vs. boolean) float d = 5.0f ; // links ist float und rechts ist float --> identische Datentypen double e = d ; // links ist double und rechts ist float --> kompatible Datentypen In den Zeilen 2 und 5 werden die Datentypen bei der Zuweisung automatisch vom Compiler umgewandelt (in Zeile 2 automatisch von int nach long und in Zeile 5 automatisch von float nach double ). Diese Umwandlung von Datentypen nennt sich Typkonvertierung (engl. type cast ). Die beiden Beispiele aus Zeile 2 und Zeile 5 hei\u00dfen implizite Typkonvertierung. Implizite Typkonvertierung \u00b6 Jeder Wert (jedes Literal ) in Java ist von einem bestimmten Typ, z.B. 1 2 3 4 5 4 // Datentyp int 4.0 // Datentyp double true // Datentyp boolean 'a' // Datentyp char \"FIW\" // Datentyp String Was passiert bei double number = 4 ; ? Wir haben links eine Variable vom Typ double und rechts einen Wert vom Typ int . Die Antwort ist, dass der Compiler implizit den Wert 4 in den Wert 4.0 umwandelt und diesen Wert der Variablen number zuweist. Es findet also eine implizite Typkonvertierung statt. Typkonvertierung immer, wenn in einer Zuweisung verschiedene Typen im Spiel sind, erfolgt eine Typkonvertierung der Typ, der rechts vom Zuweisungsoperator steht, muss in den Typ konvertiert werden, der links vom Zuweisungsoperator steht hier: von int nach double Wenn von Typen mit einem kleineren Wertebereich zu Typen mit einem gr\u00f6\u00dferen Wertebereich umgewandelt (konvertiert) werden sollen, kann dies automatisch (implizit) erfolgen \u2192 implizite Typkonvertierung 1 2 3 4 5 6 7 8 // Beispiel Umrechnung Fahrenheit in Celsius --> ohne Typkonvertierung final char DEGREE_SYMBOL = '\\u00b0' ; int celsius = 0 ; for ( int fahrenheit = 0 ; fahrenheit <= 100 ; fahrenheit += 20 ) { celsius = 5 * ( fahrenheit - 32 ) / 9 ; System . out . printf ( \"%3d %cF --> %3d %cC %n\" , fahrenheit , DEGREE_SYMBOL , celsius , DEGREE_SYMBOL ); } In dem Beispiel werden fahrenheit -Werte in celsius -Werte umgerechnet. Die Variablen celsius und fahrenheit und auch die Werte 5 , 32 und 9 sind vom Typ int . Die Berechnungen laufen ohne Typkonvertierung ab, alles bleibt im Wertebereich von int . Deshalb handelt es sich bei (fahrenheit - 32) / 9 um eine ganzzahlige Division . Die Ausgabe ist wie folgt: 0 \u00b0F --> -17 \u00b0C 20 \u00b0F --> -6 \u00b0C 40 \u00b0F --> 4 \u00b0C 60 \u00b0F --> 15 \u00b0C 80 \u00b0F --> 26 \u00b0C 100 \u00b0F --> 37 \u00b0C Wir \u00e4ndern das Beispiel und deklarieren die beiden Variablen fahrenheit und celsius als double : 1 2 3 4 5 6 7 8 // Beispiel Umrechnung Fahrenheit in Celsius --> mit Typkonvertierung final char DEGREE_SYMBOL = '\\u00b0' ; double celsius = 0 ; for ( double fahrenheit = 0 ; fahrenheit <= 100 ; fahrenheit += 20 ) { celsius = 5 * ( fahrenheit - 32 ) / 9 ; System . out . printf ( \"%6.2f %cF --> %7.3f %cC %n\" , fahrenheit , DEGREE_SYMBOL , celsius , DEGREE_SYMBOL ); } Dadurch ergibt sich eine andere Ausgabe (die Platzhalter in printf() mussten auch angepasst werden): 0 ,00 \u00b0F --> -17,778 \u00b0C 20 ,00 \u00b0F --> -6,667 \u00b0C 40 ,00 \u00b0F --> 4 ,444 \u00b0C 60 ,00 \u00b0F --> 15 ,556 \u00b0C 80 ,00 \u00b0F --> 26 ,667 \u00b0C 100 ,00 \u00b0F --> 37 ,778 \u00b0C Was ist passiert? Dadurch, dass in der Wertezuweisung celsius = 5 * (fahrenheit - 32) / 9; auf der linken Seite ein double steht, wird der gesamte Ausdruck auf der rechten Seite in ein double konvertiert . Das w\u00fcrde aber erst nach Ausrechnen des Ausdrucks erfolgen, wenn nicht auch fahrenheit ein double w\u00e4re. Es passiert folgendes: zuerst wird der Ausdruck (fahrenheit - 32) aufgel\u00f6st, da er in Klammern steht. Hier ist die Operation double - int . Sobald einer der beiden Operanden ein double ist, wird der double -Operator - verwendet \u2192 dazu wird die 32 in eine 32.0 konvertiert \u2192 das Ergebnis ist ein double dann wird von links nach rechts aufgel\u00f6st, also zun\u00e4chst 5 * double . Auch hier ist die Operation also int * double , d.h. double -Multiplikation und somit wird aus der 5 eine 5.0 . Das Ergebnis dieser Multiplikation ist double dann erfolgt die Berechnung von double / 9 . Wenn einer der beiden Operanden ein double ist, handelt es sich bei der Division um eine Gleitkommadivision . Also gibt es auch Nachkommastellen \u2192 das Ergebnis ist ein double Diese implizite Typkonvertierung macht der Compiler automatisch. Implizite Typkonvertierung kann immer dann erfolgen, wenn von einem schmalen in einen breiten Datentyp konvertiert wird, d.h. wenn alle Werte aus dem \"schmalen\" Wertebereich auch Werte aus dem \"breiten\" Wertebereich sind. Dies ist bei int (schmal) nach double (breit) der Fall, da alle int -Werte auch im double -Wertebereich enthalten sind. Das hier ist also kein Problem: int v1 = 1 ; double v2 = v1 ; // ok System . out . println ( \"Wert von v2: \" + v2 ); // 1.0 aber das geht nicht : double v3 = 1.0 ; int v4 = v3 ; // Fehler! System . out . println ( \"Wert von v4: \" + v4 ); Obwohl ja die 1.0 ein Wert aus int darstellt, pr\u00fcft der Compiler nicht den Wert, sondern den Typ. Da der double -Wertebereich viele Werte umfasst, die nicht Teil des Wertebereichs von int sind (z.B. 1.5 ), kann hier keine implizite Typkonvertierung erfolgen, denn diese w\u00e4re von einem \"breiten\" in einen \"schmalen\" Datentypen. Wenn man sich jedoch ganz sicher ist, dass eine solche Typkonvertierung sinnvoll ist (z.B. kann man ja 1.0 nach 1 und somit int ohne Verlust umwandeln), kann eine solche Typkonvertierung explizit angesto\u00dfen werden. Explizite Typkonvertierung \u00b6 In dem Beispiel von eben double v3 = 1.0 ; int v4 = v3 ; // Fehler! System . out . println ( \"Wert von v4: \" + v4 ); f\u00fchrt der Compiler keine implizite Typkonvertierung durch. Das Programm wird gar nicht compiliert. Wenn wir nun aber wollen, dass diese Typkonvertierung trotzdem durchgef\u00fchrt wird, m\u00fcssen wir den Typkonvertierungsoperator (auch type cast operator ) verwenden. Der Typkonvertierungsoperator enth\u00e4lt in runden Klammern den Zieltyp und steht vor dem Wert der umgewandelt werden soll: typ_A variable = (typ_A)wert; Die variable sei vom typ_A und der Wert von einem Typ, der nicht impliziert nach typ_A konvertiert werden kann. Unter Angabe von (typ_A) direkt vor dem wert wird der Wert explizit in typ_A konvertiert. Obiges Beispiel w\u00fcrde dann so aussehen: double v3 = 1.0 ; int v4 = ( int ) v3 ; // ok System . out . println ( \"Wert von v4: \" + v4 ); // 1 Da wir wissen, dass die 1 (der von uns zugewiesene Wert von v3 ) im Wertebereich von int liegt, k\u00f6nnen wir den Compiler anweisen, von double nach int zu konvertieren \u2192 explizite Typkonvertierung. Aber Achtung! Explizite Typkonvertierung kann zu Informationsverlust f\u00fchren! double v3 = 1.23456 ; int v4 = ( int ) v3 ; // explizite TK System . out . println ( \"Wert von v4: \" + v4 ); // 1 Wird ein double in ein int konvertiert, werden die Nachkommastellen einfach abgeschnitten (kein Runden!). Aber Achtung! Explizite Typkonvertierung kann zu ganz anderen Werten f\u00fchren! long v5 = 2147483648L ; // L mit angeben! int v6 = ( int ) v5 ; // 2 hoch 31 System . out . println ( \"Wert von v6: \" + v6 ); // -2147483648 2147483648 ist zwar ganzzahlig, ist aber nicht mehr Teil des Wertebereiches von int (um 1 zu gro\u00df) \u2192 aufgrund der internen Zahlendarstellung (Zweierkomplement) , bekommt v6 den Wert -2147483648 . Bei expliziter Typkonvertierung muss selbst\u00e4ndig darauf geachtet werden, dass der Wertebereich nicht \u00fcberschritten bzw. nicht verlassen wird! Sinnvolle Anwendungen des Typkonvertierungsoperators \u00b6 Angenommen, wir haben ein int -Array ia und wollen aus den Werten in diesem Array den Mittelwert berechnen. Dann w\u00e4re folgender erster Implementierungsversuch denkbar: int [] ia = { 1 , 2 , 3 , 4 }; int sum = 0 ; for ( int index = 0 ; index < ia . length ; index ++ ) { sum = sum + ia [ index ] ; } double average = sum / ia . length ; System . out . println ( \"Durchschnitt ist \" + average ); // 2.0 Wir bilden also die Summe \u00fcber alle Werte und teilen durch die Anzahl der Werte. Das entspricht der Definition des Durchschnitts. Wir \u00fcberschlagen im Kopf, dass f\u00fcr die vier Werte 1 , 2 , 3 und 4 der Durchschnitt 2.5 ist. Ausgegeben wird aber Durchschnitt ist 2 .0 Das ist falsch und der Grund daf\u00fcr liegt darin, dass es sich bei sum / ia.length um die ganzzahlige Divsion handelt, da beide Operanden vom Typ int sind. Eine M\u00f6glichkeit w\u00e4re, die Variable sum als double zu deklarieren. Dann haben wir bereits das gew\u00fcnschte Ergebnis. Eine andere ist, einen der beiden (oder beide) explizit nach double zu konvertieren: int [] ia = { 1 , 2 , 3 , 4 }; int sum = 0 ; for ( int index = 0 ; index < ia . length ; index ++ ) { sum = sum + ia [ index ] ; } double average = sum / ( double ) ia . length ; System . out . println ( \"Durchschnitt ist \" + average ); // 2.5 Wir haben jetzt die L\u00e4nge explizit nach double konvertiert und somit ist einer der beiden Operanden der Division ein double und somit wird die Gleitkommadivision durchgef\u00fchrt. Nun erhalten wir das richtige Ergebnis: Durchschnitt ist 2 .5 Ein anderes sinnvolles Beispiel ist die explizite Konvertierung eines int -Wertes nach char . Beides sind ganzzahlige Datentypen, aber der Wertebereich von char (8 Bit) umfasst viel weniger Werte als der Wertebereich von int (16 Bit). int ist der \"breite\" Datentyp und char der schmale und somit findet keine implizite Typkonvertierung von int nach char statt. Trotzdem m\u00f6chte man h\u00e4ufig int in Bezug auf char nutzen, weil man unter Verwendung der numerischen ASCII-Codes ( int ) gut mit Zeichen \"rechnen\" kann: for ( int ascii = 65 ; ascii < 91 ; ascii ++ ) { char c = ( char ) ascii ; System . out . print ( c + \" \" ); } Wir m\u00fcssen hier explizit konvertieren, da die implizite Typkonvertierung char c = ascii; nicht existiert. Das w\u00e4re also ein Fehler. Mit der expliziten Typkonvertierung klappt aber alles wie gew\u00fcnscht: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Hier nochmal zur Veranschaulichung, zwischen welchen Datentypen eine implizite Typkonvertierung durchgef\u00fchrt wird: Beachten Sie, dass von und nach boolean in Java keine implizite Typkonvertierung durchgef\u00fchrt wird! Hier nochmal zur Veranschaulichung, zwischen welchen Datentypen eine explizite Typkonvertierung durchgef\u00fchrt werden kann ( kompatible Datentypen): Beachten Sie, dass von und nach boolean in Java auch keine explizite Typkonvertierung m\u00f6glich ist! Wenn wir ganz genau sein wollen, dann ist out vom Typ PrintStream und wir greifen auf die Objektmethode println() des PrintStream -Objektes out zu. \u21a9 const und goto geh\u00f6ren eigentlich gar nicht zum Sprachumfang von Java und sind aber trotzdem reservierte Schl\u00fcsselw\u00f6rter. \u21a9 Tats\u00e4chlich ist die Gr\u00f6\u00dfe eines boolean gar nicht genau definiert (siehe hier ). man braucht ja eigentlich nur ein bit. Man liest aber sehr h\u00e4ufig davon, dass einer Variablen vom Typ boolean ein ganzes Byte reserviert wird. \u21a9 Das ist nicht in Allen Programmiersprachen so. Beispielsweise wird in JavaScript erst zur Laufzeit ermittelt, von welchem Typ die Variable ist, denn das h\u00e4ngt von ihrem Wert ab. Dort kann eine Variable foo=\"String\" vom Typ string sein und dann durch foo=4 vom Typ number . Die Typisierung in solchen Programmiersprachen nennt man dynamisch typisiert . \u21a9","title":"Variablen"},{"location":"variablen/#variablen-und-datentypen","text":"Sowohl in dem euklidischen Algorithmus als auch bei der (3n+1)-Vermutung haben wir mit Zahlen gerechnet. Diese haben wir in Variablen gespeichert (z.B. a , b , n ). Wir kennen Variablen bereits aus der Mathematik. Dort \"speichern\" wir Werte in diesen Variablen. Das gleiche passiert auch beim Programmieren.","title":"Variablen und Datentypen"},{"location":"variablen/#unsere-erste-klasse","text":"Damit wir das Thema Variablen und Datentypen auch gleich anwenden k\u00f6nnen, schreiben wir nun endlich unser erstes Programm, d.h. wir implementieren unsere erste Klasse. Dazu \u00f6ffnen wir BlueJ und w\u00e4hlen im Men\u00fc Project --> New Project . Es \u00f6ffnet sich ein Dateiauswahlfenster. Unter Location sollten Sie sich einen Ordner aussuchen, in den Sie zuk\u00fcnftig Ihre BlueJ-Projekte speichern, z.B. unter Ihren Dokumenten/Prog1/BlueJ . Als Projektname k\u00f6nnen Sie z.B. variablen nehmen. Es erscheint Klicken Sie auf den Button New Class... und geben Sie Ihrer Klasse den Namen Variablen . Beachten Sie, dass wir Klassennamen stets mit einem Gro\u00dfbuchstaben beginnen! Klicken Sie den Button Compile , dann verschwinden die Streifen im Klassen-Icon. Doppelklicken Sie auf die Klasse Variablen , es \u00f6ffnet sich das Editor-Fenster: Wir schauen uns den darin enthaltenen Code mal etwas genauer an (die erste leere Zeile habe ich gel\u00f6scht, deshalb ist die Zeilennummerierung um 1 versetzt): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Write a description of class Variablen here. * * @author (your name) * @version (a version number or a date) */ public class Variablen { // instance variables - replace the example below with your own private int x ; /** * Constructor for objects of class Variablen */ public Variablen () { // initialise instance variables x = 0 ; } /** * An example of a method - replace this comment with your own * * @param y a sample parameter for a method * @return the sum of x and y */ public int sampleMethod ( int y ) { // put your code here return x + y ; } } Die Zeilen 1 - 6 enthalten einen Kommentar, einen sogenannten JavaDoc-Kommentar . JavaDoc-Kommentare beginnen mit /** und enden mit */ . Dazwischen kann alles stehen und solche Kommentare gehen meistens \u00fcber mehrere Zeilen. Wir werden JavaDoc noch n\u00e4her kennenlernen. In Zeile 7 steht die Klassensignatur. Es handelt sich um eine \u00f6ffentliche Klasse (deshalb public - lernen wir noch) und nach dem Schl\u00fcsselwort class steht der Klassenname Variablen . In Zeile 8 beginnt die Implementierung der Klasse. Diese Implementierung wird durch eine \u00f6ffnende geschweifte Klammer { begonnen und endet in Zeile 32 mit der schlie\u00dfenden geschweiften Klammer } . In Zeile 9 steht ein sogenannter Zeilenkommentar . Ein Zeilenkommentar beginnt mit // und endet automatisch am Ende der Zeile. Hier dient der Kommentar dazu, \u00fcber die Objektvariable x zu informieren, die in Zeile 10 deklariert wird. In Zeile 10 wird eine Variable deklariert . Der Name der Variable ist x . Sie ist vom Datentyp int . Wir k\u00f6nnen nur innerhalb der Klasse Variablen auf diese Variable zugreifen, da sie als private deklariert wird. Zu Variablen und Datentypen kommen wir gleich ausf\u00fchrlich. In den Zeilen 12-14 steht erneut ein JavaDoc-Kommentar - dieses Mal kommentiert er die nachfolgende Methode, den sogenannten Konstruktor . In den Zeilen 15-19 sehen wir die erste Methode der Klasse. Diese Methode ist speziell, denn sie hei\u00dft exakt so, wie die Klasse selbst. Es handelt sich um einen sogenannten Konstruktor . Diese Methode wird aufgerufen, um ein Objekt der Klasse zu erzeugen. Wir werden uns ausf\u00fchrlich mit Konstruktoren besch\u00e4ftigen. Typischerweise werden im Konstruktor alle Objektvariablen initialisiert , d.h. die Objektvariablen bekommen einen initialen Wert. Hier wird der Objektvariablen x der Wert 0 zugewiesen (Zeile 18 ). In den Zeilen 27-31 wird die Methode sampleMethod() implementiert. Dieser Methode wird ein Parameter y vom Typ int \u00fcbergeben. Diese Methode gibt den Wert der Summe von x und y zur\u00fcck. Wir kommen dazu, wenn wir uns ausgiebiger mit Methoden besch\u00e4ftigen. Zun\u00e4chst \u00e4ndern wir dieses Programm, indem wir (fast) alle Kommentare l\u00f6schen und die sampleMethod() -Methode umbenennen und umprogrammieren. Unsere Klasse sieht nun so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); } } Die Implementierung unserer Objektmethode hat sich ge\u00e4ndert: der Name der Methode ist nun printObjectState() , die Methode erwartet keinen Parameter mehr, der R\u00fcckgabetyp (kennen wir noch nicht) der Methode ist nicht mehr int , sondern void und die Implementierung der Methode besteht aus einer einzigen Anweisung System.out.println(x); . Wir klicken auf den Compile -Button, dann erzeugen wir uns ein Objekt von der Klasse Variablen und nennen es variable1 und f\u00fchren f\u00fcr dieses Objekt die Methode printObjectState() aus. Es erscheint Dieses Fenster ist unser Terminal-Fenster (auch Konsole genannt). In diesem Terminal-Fenster wird der Wert der Objektvariablen x ausgegeben. Dieser Wert ist 0 .","title":"Unsere erste Klasse"},{"location":"variablen/#systemoutprintlnx","text":"Schauen wir uns System.out.println(x); zun\u00e4chst etwas genauer an. Wir verwenden hier eine Klasse, n\u00e4mlich die Klasse System . Diese Klasse existiert bereits und wurde von den Java-Entwicklern f\u00fcr uns geschrieben. Sie geh\u00f6rt zum Standardpaket von Java, existiert bereits seit der ersten Version von Java und befindet sich im Paket java.lang (zu Paketen kommen wir sp\u00e4ter). Diese Klasse hat eine interessante (Klassen-)Variable, die wir verwenden, n\u00e4mlich out . Diese Variable stellt in unserem (Betriebs-)System die Verbindung zu unserem Standardausgabeger\u00e4t bereit, in unserem Fall die Konsole (das Terminal-Fenster ). Um nun eine Ausgabe auf diese Konsole zu generieren, verwenden wir die Methode println() . Wir sehen hier eine typische Notation in Java, die sogenannte Punktnotation . Mithilfe dieser Punktnotation greifen wir auf Eigenschaften von Klassen und Objekten zu. In unserem Beispiel greifen wir mit System.out auf das Standardausgabeger\u00e4t zu und mit System.out.println() auf die println() -Methode des Ausgabeger\u00e4tes 1 . Die Methode println() erzeugt also eine Ausgabe auf unsere Konsole. Jetzt m\u00fcssen wir nur noch sagen, WAS ausgegeben werden sollen. Dazu \u00fcbergeben wir dieser Methode hier die Variable x . Der Wert dieser Variablen ( 0 ) wird gelesen und ausgegeben. Bei System.out.println(x); handelt es sich um eine Anweisung . Eine Anweisung endet in Java immer mit einem Semikolon ; . Dieses d\u00fcrfen wir nicht vergessen, ansonsten haben wir einen Syntaxfehler und unser Programm kann nicht compiliert und nicht ausgef\u00fchrt werden.","title":"System.out.println(x);"},{"location":"variablen/#println-vs-print","text":"In unserem ersten Programm haben wir die Methode println() verwendet, um etwas auf der Konsole auszugeben. Es gibt noch eine andere M\u00f6glichkeit f\u00fcr die Ausgabe auf die Konsole, n\u00e4mlich die Methode print() , also ohne ln . Das ln steht f\u00fcr Line und gibt an, dass nach der Ausgabe ein Zeilenumbruch erfolgt. Wir \u00e4ndern zun\u00e4chst unser Programm, indem wir die Anweisung System.out.println(x); kopieren und weitere 2x einf\u00fcgen. printObjectState()-Methode mit println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); System . out . println ( x ); System . out . println ( x ); } } Um das \u00dcberpr\u00fcfen unserer \u00c4nderungen zu beschleunigen, klicken wir mit der rechten Maustaste auf die Klasse Variablen und w\u00e4hlen Create Test Class . Es entsteht eine Testklasse VariablenTest (gr\u00fcner Kasten). Wir klicken mit der rechten Maustaste auf diesen gr\u00fcnen Kasten und w\u00e4hlen Create Test Method... . Wir werden nach einem Namen f\u00fcr die testmethode gefragt und w\u00e4hlen testPrintObjectState . Nun wird unser Test \"aufgenommen\". Wir erzeugen ein Objekt der Klasse Variablen , nennen dieses Objekt variable1 und rufen f\u00fcr dieses Objekt die Methode printObjectState() auf. Dann beenden wir die \"Aufnahme\" des Tests, indem wir unter recording auf den Button End klicken. Nun brauchen wir f\u00fcr das Ausf\u00fchren unserer Methode immer nur noch die testPrintObjectState() -Methode der Klasse VariablenTest auszuf\u00fchren (Rechtsklick auf die Klasse und Methode ausw\u00e4hlen). Das ruft die Erzeugung eines Variablen -Objektes auf und f\u00fchrt daf\u00fcr die Methode printObjectState() aus. In unserem Terminal (der Konsole) erscheinen 0 0 0 Eventuell sind bei Ihnen vier 0 untereinander, weil das Terminal noch die 0 vom ersten Test angezeigt hatte. Das k\u00f6nnen Sie verhindern, indem Sie im BlueJ -Men\u00fc Options ausw\u00e4hlen und darin einen Haken bei Clear screen at method call setzen. Das hei\u00dft, dass jede der Ausgaben mithilfe der println() -Methode in einer neuen Zeile erfolgt. Nach jeder Ausgabe erfolgt also ein Zeilenumbruch, der Ausgabecursor wird in die n\u00e4chste Zeile gesetzt. Die n\u00e4chste Ausgabe beginnt am Anfang der neuen Zeile. Wir wollen nun unser Programm \u00e4ndern und verwenden nicht mehr die println() - Methode, sondern print() : printObjectState()-Methode mit print() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . print ( x ); System . out . print ( x ); System . out . print ( x ); } } Wir f\u00fchren den Test erneut aus und erhalten auf der Konsole die Ausgabe: 000 Die print() -Methode gibt also nur den Wert der Variablen x aus, f\u00fchrt aber danach keinen Zeilenumbruch durch. Der Ausgabecursor bleibt hinter dem letzten ausgegebenen Zeichen stehen. Unsere drei Nullen werden in der Konsole deshalb hintereinander ausgegeben. Wir \u00e4ndern nun unser Programm erneut und f\u00fcgen folgende Anweisungen hinzu: System.out.println() . Wir rufen also die println() -Methode auf, ohne eine Zeichenkette zu \u00fcbergeben, die ausgegeben werden soll. Diese Anweisung sorgt einfach daf\u00fcr, dass ein Zeilenumbruch erfolgt. Es wird also nichts ausgegeben, aber der Ausgabecursor an den Beginn der n\u00e4chsten Zeile gesetzt. printObjectState()-Methode mit print() und println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . print ( x ); System . out . println (); System . out . print ( x ); System . out . println (); System . out . print ( x ); System . out . println (); } } Wir f\u00fchren den Test erneut aus und erhalten auf der Konsole die Ausgabe: 0 0 0 \u00dcbung Erzeugen Sie folgende Ausgabe auf der Konsole: 0 0 0 Eine m\u00f6gliche L\u00f6sung 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Variablen { // Objektvariablen private int x ; public Variablen () { x = 0 ; } // Objektmethoden public void printObjectState () { System . out . println ( x ); System . out . println (); System . out . println ( x ); System . out . println (); System . out . println ( x ); System . out . println (); } } So, jetzt haben wir unser erstes Programm geschrieben und k\u00f6nnen nun Variablen kennenlernen und dieses Konzept auch gleich anwenden.","title":"println() vs. print()"},{"location":"variablen/#variablen","text":"Eine Variable kann man sich wie eine Kiste vorstellen, in die genau ein Wert passt. Diese Kiste hat einen Namen (den Namen der Variable) und in der Programmierung wird auch noch gesagt, welche Art von Wert dort hineinpasst. Man spricht auch vom Typ der Variablen oder noch besser vom Datentyp . Eine Variable besteht also aus drei Dingen: dem Wert der Variablen (genau einer) dem Datentyp der Variablen (bestimmt den Wertebereich, also die m\u00f6glichen Werte, die die Variable annehmen kann) dem Namen der Variablen (daf\u00fcr gibt es Regeln, wie solche Bezeichner aussehen d\u00fcrfen) Das Erstellen einer Variablen (die Definition einer Variablen ) besteht in der Programmierung aus zwei Schritten: der Variablendeklaration : in der Deklaration wird festgelegt, wie die Variable hei\u00dft und von welchem Datentyp sie ist der Initialisierung : bei der Initialisierung wird der Variablen ihr erster Wert zugewiesen Damit wir einer Variablen ihren Datentyp zuweisen k\u00f6nnen, m\u00fcssen wir die Datentypen zun\u00e4chst kennenlernen, die eine Variable haben kann.","title":"Variablen"},{"location":"variablen/#datentypen-in-java","text":"In Java gibt es acht sogenannte primitive Datentypen . Wir bezeichnen diese primitiven Datentypen als Wertetypen . Eine Variable von einem Wertetyp kann genau einen Wert annehmen. In folgender Tabelle sind diese Datentypen aufgelistet und ihre jeweilige Bedeutung erkl\u00e4rt. Datentyp Bedeutung int eine Variable vom Datentyp int kann ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Die kleinste Zahl vom Typ int ist -2^31 \"klein\" und die gr\u00f6\u00dfte Zahl vom Typ int ist 2^31-1 gro\u00df. int ist der Standard-Typ f\u00fcr ganze Zahlen in Java. int steht f\u00fcr integer . byte eine Variable vom Datentyp byte kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Die kleinste byte -Zahl ist -2^7 klein und die gr\u00f6\u00dfte byte -Zahl ist 2^7-1 gro\u00df. short eine Variable vom Datentyp short kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Im Gegensatz zu byte ist er aber gr\u00f6\u00dfer. Die kleinste short -Zahl ist -2^15 klein und die gr\u00f6\u00dfte short -Zahl ist 2^15-1 gro\u00df. long eine Variable vom Datentyp long kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel gr\u00f6\u00dfer. long wird immer dann verwendet, wenn der Wertebereich von int nicht ausreicht, also entweder f\u00fcr sehr, sehr kleine oder sehr, sehr gro\u00dfe Zahlen. Die kleinste long -Zahl ist -2^63 klein und die gr\u00f6\u00dfte long -Zahl ist 2^63-1 gro\u00df. char Der Datenyp char steht f\u00fcr character . Mit diesem Datentypen werden einzelne Zeichen gespeichert. Der Datentyp char ist ebenfalls ein ganzzahliger Datentyp, nimmt aber nur positive Werte (aus dem Wertebereich 0 bis 65535 an.) Diese Werte sind Zahlenwerte, die der Codierung eines Zeichens entsprechen, z.B. dem Zeichen 'a' . Ein solches Zeichen steht immer in einfachen Hochkommata '' . boolean Der Datentyp boolean kennt nur genau zwei Werte true und false . Eine Variable vom Datentyp boolean kann also entweder genau true sein oder genau false , nichts anderes. double Der Datentyp double ist in Java der Standard-Datentyp f\u00fcr Gleitkommazahlen (also gebrochene Zahlen mit Komma). Die kleinste und gr\u00f6\u00dfte double -Zahl l\u00e4sst sich nicht genau bestimmen, denn das h\u00e4ngt von der Genauigkeit der Angabe hinter dem Komma ab. Es werden aber 64 bit verwendet, um eine double -Zahl zu speichern. float float ist neben double ein weiterer Datentyp f\u00fcr Gleitkommazahlen. Die Genauigkeit der Speicherung als float ist aber nicht so gro\u00df wie bei double , da float nur 32 bit zur Speicherung einer Zahl zur Verf\u00fcgung hat.","title":"Datentypen in Java"},{"location":"variablen/#deklaration-von-variablen","text":"Nun, da wir Datentypen kennen, k\u00f6nnen wir Variablen \"erzeugen\". Das \"Erzeugen\" von Variablen besteht aus zwei Schritten: wir vergeben einen Namen f\u00fcr unsere Variable und wir weisen der Variablen einen Datentyp zu. Dieses Erzeugen von Variablen nennt sich Deklaration (oder Variablendeklaration ). Die allgemeine Syntax der Variablendeklaration ist wie folgt: datentyp variablenName ; Wir geben also zuerst den Datentyp an, dann kommt ein Leerschritt, dann den Bezeichner f\u00fcr die Variable (den Namen) und dann folgt ein Semikolon, weil es sich um eine Anweisung handelt. Beispiele: int ganzeZahl ; int number ; long bigNumber ; byte smallNumber ; double nr1 ; float nr2 ; boolean condition ; char character ; F\u00fcr eine Variable wird die Deklaration genau einmal durchgef\u00fchrt. Danach existiert sie und sie kann auch (in Java) nicht ihren Datentypen \u00e4ndern. Noch haben unsere Variablen keine Werte. Das erfolgt erst durch die Initialisierung, also die erste Wertzuweisung. Ehe wir uns das anschauen, \u00fcberlegen wir uns zun\u00e4chst, welche m\u00f6glichen Bezeichner wir f\u00fcr unsere Variablennamen verwenden k\u00f6nnen.","title":"Deklaration von Variablen"},{"location":"variablen/#bezeichner","text":"Wenn es um Namen geht, die wir in Java selbst vergeben wollen, dann sprechen wir von Bezeichnern . Bezeichner sind nicht nur die Namen von Variablen, sondern sp\u00e4ter auch f\u00fcr Methoden, Klassen, Enumerations, Exceptions und Interfaces. Es gibt einige Regeln f\u00fcr Bezeichner, die wir beachten m\u00fcssen: Bezeichner m\u00fcssen mit einem Java-Buchstaben beginnen Bezeichner setzen sich aus Java-Buchstaben und Java-Zahlen zusammen Java-Buchstaben sind mehr als a - z und A - Z z.B. auch \u20ac , \u00a3 , \u00a5 , $ , Umlaute \u00e4 , \u00f6 , \u00fc , \u00df sowie Buchstaben mit Apostrophen Aber: wir verwenden nur die normalen Buchstaben a - z und A - Z !!! Alles andere f\u00fchrt zu Problemen wichtig: keine Leerzeichen, keine reservierten Schl\u00fcsselw\u00f6rter und keine Sonderzeichen, wie z.B. ! , / , * , { , [ , . , ] , } In Java wird Gro\u00df- und Kleinschreibung unterschieden ( case sensitive )! Reservierte Schl\u00fcsselw\u00f6rter sind Begriffe aus dem Java-Sprachumfang (alle kleingeschrieben) 2 . Dazu geh\u00f6ren: abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while \u00dcbung Bezeichner Warum sind das keine g\u00fcltigen Bezeichner in Java? 2und2macht4 class Hose gewaschen Hurtig! null","title":"Bezeichner"},{"location":"variablen/#konventionen","text":"Wir wissen jetzt, was g\u00fcltige Bezeichner sind und was ung\u00fcltige. Dar\u00fcber hinaus gibt es aber auch Vereinbarungen, die helfen, einen besser verst\u00e4ndlichen und konsistenteren Code zu schreiben: wir vergeben nur \"sprechende\" Namen, d.h. man erkennt bereits am Bezeichner, wozu die Variable dient, z.B. sum , input , checkIfEmpty usw. Variablennamen beginnen stets mit einem Kleinbuchstaben (einzige Ausnahmen sind Konstanten, diese schreiben wir vollst\u00e4ndig gro\u00df, d.h. aus lauter Gro\u00dfbuchstaben) Methodennamen beginnen ebenfalls mit einem Kleinbuchstaben, Klassen und Interfaces beginnen stets mit einem Gro\u00dfbuchstaben verwenden die sogenannte camelCaseSchreibweise . Da keine Leerzeichen erlaubt sind, wir aber sprechende Namen haben wollen, die aus mehreren W\u00f6rtern bestehen k\u00f6nnen, schreiben wir den Beginn eines neuen Wortes immer gro\u00df (au\u00dfer ganz am Anfang, denn Methoden- und Variablennamen beginnen ja mit einem Kleinbuchstaben.)","title":"Konventionen"},{"location":"variablen/#initialisierung-von-variablen","text":"Nach der Deklaration einer Variablen existiert diese zwar, sie hat jedoch noch keinen Wert. Wir wollen sicherstellen, dass Variablen immer einen Wert haben. Deshalb weisen wir den Variablen direkt nach der Deklaration einen Wert zu. Die erstmalige Wertzuweisung einer Variablen wird Initialisierung genannt.","title":"Initialisierung von Variablen"},{"location":"variablen/#der-wertzuweisungsoperator","text":"Um einer Variablen einen Wert zuzuweisen, wird der Wertzuweisungsoperator verwendet. Dieser ist ein einfaches Gleichheitszeichen = . Die Syntax der Wertzuweisung ist wie folgt: variablenName = wert ; Auf der linken Seite steht also immer die Variable und auf der rechten Seite der Wert. Auch hier muss am Ende wieder zwingend das Semikolon stehen, denn es handelt sich um eine Anweisung. Wichtig ist, dass der Wert dem Datentyp der Variablen entspricht! Wir geben einige Beispiele f\u00fcr Variablen an, die wir oben deklariert hatten: ganzeZahl = 5 ; // int number = - 1234 ; // int bigNumber = 12345678 ; // long nr1 = 6.54321 ; // double condition = true ; // boolean character = 'a' ; // char Nachdem einer Zahl mithilfe des Wertzuweisungsoperators ein Wert zugewiesen wurde, beh\u00e4lt die Variable den Wert so lange bis ihr ein neuer Wert (mithilfe des Wertzuweisungsoperators) zugewiesen wird. Einer Variablen kann beliebig oft ein neuer Wert zugewiesen werden.","title":"Der Wertzuweisungsoperator ="},{"location":"variablen/#deklaration-und-initialisierung-in-einem-schritt","text":"Da wir m\u00f6chten, dass eine Variable sofort nach ihrer Deklaration einen Wert zugewiesen bekommt, ist es \u00fcblich, die Deklaration und die Initialisierung in einem Schritt, d.h. durch eine Anweisung durchzuf\u00fchren. Die Syntax der kombinierten Anweisung (Deklaration und Initialisierung) ist wie folgt: datentyp variablenName = wert ; Wir zeigen die Anwendung der kombinierten Deklaration und Initialisierung anhand der bereits verwendeten Beispiele: int ganzeZahl = 5 ; int number = - 1234 ; long bigNumber = 12345678 ; double nr1 = 6.54321 ; boolean condition = true ; char character = 'a' ; Beachte Wie bereits erw\u00e4hnt, kann eine Variable genau ein Mal deklariert, ihr aber beliebig oft ein neuer Wert zugewiesen werden. Angenommen, Sie wollen der Variablen ganzeZahl einen neuen Wert zuweisen, dann schreiben Sie die Anweisung ganzeZahl = 6; . Sie d\u00fcrfen auf keinen Fall int ganzeZahl = 6; schreiben, denn dann w\u00fcrden Sie ja versuchen, die Variable ganzeZahl erneut zu deklarieren. Diese existiert aber bereits. Sie bekommen einen Compilerfehler und k\u00f6nnen ihr Programm gar nicht erst \u00fcbersetzen.","title":"Deklaration und Initialisierung in einem Schritt"},{"location":"variablen/#details-zu-primitiven-datentypen-wertetypen","text":"Wie wir bereits bei der Vorstellung der primitiven Datentypen erw\u00e4hnt haben, ist f\u00fcr jeden Datentyp eine gewisse Speichergr\u00f6\u00dfe reserviert. Hier noch einmal die Gr\u00f6\u00dfe der primitiven Datentypen: Datentyp Gr\u00f6\u00dfe Wertebereich boolean 1 Byte 3 true / false char 16 bit 0 ... 65.535 (z.B. 'A' ) byte 8 bit -128 ... 127 short 16 bit -32.768 ... 32.767 int 32 bit -2.147.483.648 ... 2.147.483.647 long 64 bit -2^63 ... 2^63-1 float 32 bit +/-1,4E-45 ... +/-3,4E+38 double 64 bit +/-4,9E-324 ... +/-1,7E+308 Wir schauen uns jetzt noch einige interssante Details zu den Datentypen an.","title":"Details zu primitiven Datentypen (Wertetypen)"},{"location":"variablen/#ganzzahlige-datentypen-int-long-short-byte","text":"Eine ganze Zahl in einem Java-Programm ist vom Typ int . Dieser Datentyp ist der Standard-Datentyp f\u00fcr ganze Zahlen. Ganze Zahlen werden intern im sogenannten Zweierkomplement dargestellt. Wir schauen uns diese Darstellung am Beispiel des Datentyps byte (der 8 bit gro\u00df ist) einmal genauer an. In der folgenden Darstellung steht die Bedeutung der Position der einzelnen bits ganz oben, beginnend mit der 1 ( 2^0 ) auf der rechten Seite (\"kleinstes\" bit) bis hin zu 2^7 auf der linken Seite (\"gr\u00f6\u00dftest\" bit). Beim Zweierkomplement entspricht diese h\u00f6chste Position jedoch nicht der 128 , sondern der -128 . Dies hat drei Vorteile es wird nicht ein ganzes bit daf\u00fcr verwendet, um zu unterscheiden, ob es sich um eine positive oder negative Zahl handelt die 0 kommt nicht 2x vor ( 1000 0000 und 0000 0000 w\u00e4re jeweils 0 , wenn das f\u00fchrende bit dar\u00fcber entscheiden w\u00fcrde, ob die Zahl positiv oder negativ ist) sowohl die Addition als auch die Subtraktion geht einfacher Die Abbildung zeigt in den oberen drei Zeilen die interne Darstellung von -128 , 127 und 0 . In den drei Zeilen darunter ist dargestellt, wie z.B. die Zahlen 85 , -43 und -85 als Zweierkomplement repr\u00e4sentiert werden. Die folgende Abbildung zeigt die Addition (und somit auch die Subtraktion) zweier Zahlen im Zweierkomplement. Dargestellt sind die Repr\u00e4sentationen von -4 und 3 als Zweierkomplement. Es wird die Addition der beiden Zahlen gezeigt. Da die Werte alle einen begrenzten Wertebereich haben, kann es zu einem Wertebereichs\u00fcberlauf kommen. Ein solcher \u00dcberlauf ist in der folgenden Abbildung dargestellt. Im Datentyp byte ist 127 die gr\u00f6\u00dfte positive Zahl. Die Abbildung verdeutlicht, was passiert, wenn zu dieser gr\u00f6\u00dften Zahl eine 1 hinzuaddiert wird. Beachten Sie, dass ein solcher \u00dcberlauf unbemerkt passiert. Das bedeutet, dass Sie weder einen Fehler noch eine Warnung erhalten. Sie m\u00fcssen sich also immer gut \u00fcberlegen, ob ein solcher \u00dcberlauf bei Ihren Werten passieren kann. Wenn ja, dann sollten Sie zum n\u00e4chstgr\u00f6\u00dferen Datentypen wechseln, also z.B. von int nach long . Datentyp gr\u00f6\u00dfter Wert kleinster Wert byte 127 -128 short 32.767 -32.768 int 2.147.483.647 -2.147.483.648 long 9.223.372.036.854.775.807 -9.223.372.036.854.775.808 \u00dcbung Zweierkomplement Warum ist 1111 1111 als Zweierkomplement im Datentyp byte die Dezimalzahl -1 ? Wie ist die Repr\u00e4sentation der Zahlen -99 und 99 als Zweierkomplement im Datentyp byte ? Was ist das Ergebnis der Rechnung 2.147.483.647 + 1 im Datentyp int und warum?","title":"Ganzzahlige Datentypen int, long, short, byte"},{"location":"variablen/#initialisierung-von-long-variablen","text":"Eine ganze Zahl als Literal , also als alleinstehender Wert ist vom Typ int . Wenn wir folgende kombinierte Deklaration und Initialisierung betrachten: long bigNumber = 12345678 ; dann stellen wir fest, dass die Variable bigNumber auf der linken Seite des Wertzuweisungsoperators vom Typ long ist, die Zahl 12345678 aber vom Typ int . Wir werden sp\u00e4ter noch auf solche Typkonvertierung zu sprechen kommen. Es sei hier jedoch bereits angemerkt, dass man eine ganze Zahl auch um das Postfix L erg\u00e4nzen kann (man k\u00f6nnte auch mit dem kleinen Buchstaben l erg\u00e4nzen, das macht man aber nicht, weil die Verwechselungsgefahr mit der 1 zu gro\u00df ist) - mit der Wirkung, dass die Zahl dann nicht mehr vom Typ int , sondern vom Typ long ist. Die \"richtige\" Initialisierung sieht so aus: long bigNumber = 12345678L ; Es ist nur in wenigen F\u00e4llen wirklich erforderlich, das L an die Zahl zu h\u00e4ngen, wenn wir eine long -Variable initialisieren. Warum das so ist, werden wir kennenlernen, wenn wir uns \u00fcber Typkonvertierung Gedanken machen. Trotzdem sei hier schonmal erw\u00e4hnt, dass diese Deklaration und Initialisierung kein Problem ist long bigNumber = 2147483647 ; aber hier bekommen wir einen Fehler und k\u00f6nnen das Programm gar nicht \u00fcbersetzen: long bigNumber = 2147483648 ; Warum k\u00f6nnte das wohl so sein? Wenn wir es \"richtig\" machen, also mit angeh\u00e4ngtem L , dann ist auch wieder alles in Ordnung und das Programm l\u00e4sst sich compilieren: long bigNumber = 2147483648L ; In unseren Programmen werden wir zu 99% den Datentyp int f\u00fcr ganzzahlige Werte verwenden und zu 1% long . Die anderen ganzzahligen Datentypen byte und short braucht man eigentlich gar nicht mehr, da wir keinen Wert mehr darauf legen m\u00fcssen, Arbeitsspeicher zu sparen.","title":"Initialisierung von long-Variablen."},{"location":"variablen/#char","text":"Der Datentyp char ist f\u00fcr das Speichern von Zeichen vorgesehen. Es handelt sich um einen ganzzahligen Datentypen. Mit den ersten Computern stellte sich die Frage, wie Zeichen (also Ziffern und Buchstaben) intern codiert werden k\u00f6nnen. Es hat sich dann zun\u00e4chst die Zeichencodierung des American Standard Code for Information Interchange (ASCII) durchgesetzt, bei der 7 Bit (=128 Zeichen) dazu verwendet wurden, die wichtigsten Zeichen zu kodieren. Neben einigen Steuerzeichen (die ersten 33 \"Zeichen\", z.B. Zeilenvorschub, ESC -Zeichen) wurden z.B. folgende Zeichen wie folgt kodiert: Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 33 ! 47 / 61 = 34 \"\" 48 0 62 > 35 # 49 1 63 ? 36 $ 50 2 64 @ 37 % 51 3 65 A 38 & 52 4 66 B 39 ' 53 5 67 C 40 ( 54 6 68 D 41 ) 55 7 69 E 42 * 56 8 70 F 43 + 57 9 71 G 44 , 58 : 72 H 45 - 59 ; 73 I 46 . 60 < 74 J Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 75 K 89 Y 103 g 76 L 90 Z 104 h 77 M 91 [ 105 i 78 N 92 \\ 106 j 79 O 93 ] 107 k 80 P 94 ^ 108 l 81 Q 95 _ 109 m 82 R 96 \u2035 110 n 83 S 97 a 111 o 84 T 98 b 112 p 85 U 99 c 113 q 86 V 100 d 114 r 87 W 101 e 115 s 88 X 102 f 116 t Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 117 u 121 y 125 } 118 v 122 z 126 ~ 119 w 123 { 127 DEL 120 x 124 | Diese Zeichenkodierung erkl\u00e4rt, warum es sich bei char um einen ganzzahligen Typ handelt. Anstelle eines Zeichens, welches immer in einfachen Hochkommata '' angegeben werden muss, kann auch der ASCII-Code als Zahl verwendet werden. Folgende Beispiele zeigen dies: char ganzzahliger Typ char c1 = 'a' ; System . out . println ( c1 ); // a char c2 = 97 ; System . out . println ( c2 ); // a char c3 = '`' ; c3 ++ ; System . out . println ( c3 ); // a Die 128 verschiedenen Zeichen gen\u00fcgten nat\u00fcrlich schnell nicht mehr und es wurden deutlich gr\u00f6\u00dfere Kodierungstabellen entwickelt. Ein de-facto Standard ist UTF-8 , welcher Bytes (also 8 Bit) zur Kodierung der Zeichen verwendet. Die ersten 128 Zeichen sind dabei mit dem ASCII-Code identisch. Im UTF-8 k\u00f6nnen aber mehrere Bytes hintereinander geschrieben werden und erm\u00f6glichen so einen beliebig gro\u00dfen Kodierungsraum. Der Datentyp char ist 16 Bit gro\u00df, kann also 2 Byte gro\u00dfe Kodierungsr\u00e4ume darstellen (65 536 verschiedene Zeichen). Eine UTF-8-Tabelle finden Sie z.B. hier . Die linke Spalte in dieser Tabelle zeigt den Unicode . Dieser kann auch in Java (in leicht abgewandelter Form) verwendet werden. Scrollen Sie in der Tabelle ein wenig bis zur Position U+00A9 herunter. Dort sehen Sie z.B. die Codierung des \u00a9-Copyright-Zeichens. In Java kann dieser Code wie folgt verwendet werden: char UTF-8 Zeichen char u1 = '\\u00a9' ; System . out . println ( u1 ); // copyright-Zeichen char u2 = '\\u00b0' ; System . out . println ( u2 ); // Grad-Zeichen char u3 = '\\u00bd' ; System . out . println ( u3 ); // 1/2-Zeichen","title":"char"},{"location":"variablen/#gleitkomma-datentypen-double-float","text":"Eine Gleitkomma-Zahl (also eine Zahl mit einem Punkt, z.B. 5.0 oder -1.2345 ) in einem Java-Programm ist vom Typ double . Dieser Datentyp ist der Standard-Datentyp f\u00fcr Gleitkomma-Zahlen. Der Wertebereich der Datentypen double und float l\u00e4sst sich nicht so leicht angeben, denn entweder wird relativ viel \"Speicher\" f\u00fcr die Genauigkeit verwendet (f\u00fcr die Anzahl der Nachkommastellen, z.B. 0.123456789 ) oder f\u00fcr die Vorkommastellen (z.B. 987654321.0 ). Generell ist der Wertebereich (die Genauigkeit) bei double viel h\u00f6her, denn f\u00fcr eine Variable vom Typ double werden 64 bit reserviert, w\u00e4hrend eine Variable vom Typ float nur 32 bit gro\u00df ist. Bei float beschr\u00e4nkt sich die Genauigkeit auf ca. 7 signifikante Stellen (Nachkommastellen), w\u00e4hrend es bei double ca. 17 signifikante Stellen sind. Beispiel float float floatNumber = 1.0f / 3.0f ; System . out . println ( floatNumber ); // 0.33333334 Im obigen Beispiel wird mithilfe von float der Bruch 1/3 ausgerechnet. Zwei Sachen sind zu beachten Wie wir das schon beim Datentyp long gesehen haben, gibt es auch f\u00fcr Gleitkommazahlen ein Postfix, hier f , um zu sagen, dass eine Zahl vom Typ float sein soll. Ohne das f w\u00e4re sie vom Typ double und wir w\u00fcrden sogar einen Compilerfehler erhalten, wenn wir das f am Ende der Zahl nicht angeben w\u00fcrden. Hier ist es also wichtig, bei der Wertzuweisung anzugeben, dass die Zahl vom Typ float sein soll - n\u00e4mlich durch die Angabe von f ( F ginge auch). Die Genauigkeit bei float ist nicht sehr hoch. 1/3 im float -Wertebereich ergibt 0.33333334 . Schauen wir uns das gleiche Beispiel mit double an: Beispiel float double doubleNumber = 1.0 / 3.0 ; System . out . println ( doubleNumber ); // 0.3333333333333333 Erstens hat der double -Wert deutlich mehr Nachkommastellen (16 statt 8 bei float ) und zweitens ist der Wert somit korrekter. Die Speicherung von Gleikommazahlen erfolgt nach IEEE 754 - Standard . Wir merken uns: wir sollten float eher nicht verwenden, wenn wir Wert auf Genauigkeit legen, wenn wir float verwenden, dann m\u00fcssen wir beim Initialisieren und bei allen Wertezuweisungen darauf achten, dass wir an die Gleikommazahl ein f anh\u00e4ngen, da es sich ansonsten um eine Gleitkommazahl vom Typ double handelt, double ist der Standardtyp f\u00fcr Gleikommazahlen und wenn eine Gleitkommazahl im Programmcode vorkommt, dann handelt es sich um eine Zahl vom Typ double . Datentyp gr\u00f6\u00dfter positiver Wert kleinster positiver Wert float ~3.4028234663852886E+038 ~1.4012984643248171E-045 double ~1.7976931348623157E+308 ~4.9406564584124654E-324","title":"Gleitkomma-Datentypen double, float"},{"location":"variablen/#der-datentyp-string","text":"Der Datentyp String ist kein primitiver Datentyp (kein Wertetyp), sondern ein sogenannter komplexer Datentyp (oder, wie wir sagen Referenztyp ). Wir erkennen das bereits daran, dass der Datentyp mit einem Gro\u00dfbuchstaben beginnt. Der Unterschied zwischen Variablen von einem Wertetypen und Variablen von Referenztypen ist der, dass die ersten \"nur\" Werte speichern ( 3 , 5 , 'a' , 123.45 , true , ...) und die anderen speichern Objekte (oder richtiger: Referenzen auf Objekte) - darum k\u00fcmmern wir uns sp\u00e4ter sehr ausf\u00fchrlich. Wir k\u00f6nnen uns merken (ist aber derzeit noch nicht wichtig), dass ein String ein Objekt und kein einfacher Wert ist, aber derzeit betrachten wir den Datentyp String wie die primitiven Wertetypen auch. Ein String -Literal erkennt man an den doppelten Anf\u00fchrungsstrichen. Darin kann ein beliebiger Text (bestehend aus allen m\u00f6glichen Zeichen, Buchstaben, Sonderzeichen, Umlauten etc.) stehen, z.B. \"Hallo FIW!\" , \"2und2gleich4 und $ % & 0? | \\ !\" , \" \u00e4 \u00fc \u00f6 \u00df\" . Die Deklaration und Initialisierung einer String -Variablen sieht also so aus: String s1 = \"Informatik\" ; Auch f\u00fcr den Datentyp String gibt es einen Operator, der zwei Strings miteinander verbindet. Er wird Konkatenation ( String-Konkatenation oder Zeichenkettenverbindungsoperator genannt). Das Operatorsymbol der Konkatenation ist in Java + . String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); Die folgenden drei Ausgaben sind alle gleich: String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); // Informatik und Wirtschaft String s2 = \"Informatik\" ; String s3 = \" und\" ; String s4 = \" Wirtschaft\" ; System . out . println ( s2 + s3 + s4 ); // Informatik und Wirtschaft String s5 = \"Informatik\" ; String s6 = s5 + \" und\" ; String s7 = s6 + \" Wirtschaft\" ; System . out . println ( s7 ); //Informatik und Wirtschaft","title":"Der Datentyp String"},{"location":"variablen/#doppelte-bedeutung-des-operatorzeichens","text":"Das + wird sowohl als arithmetischer Operator f\u00fcr numerische Datentypen als auch als Konkatenation f\u00fcr Strings verwendet. In den obigen Beispielen kommen wir damit nicht durcheinander, da v\u00f6llig klar ist, dass es sich dabei um die Konkatenation handelt. Es gibt aber Beispiele, bei denen in einem Ausdruck beide Bedeutungen vorkommen. Diese diskutieren wir jetzt. Zun\u00e4chst schauen wir uns noch eine typische Verwendung der Konkatenation an: typisches Beispiel f\u00fcr die Konkatenation 1 2 3 4 int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 Die Ausgabe bei dem obigen Beispiel ist 3 + 4 = 7 . Schauen wir uns das Beispiel genauer an: In Zeile 3 wird das + eindeutig als arithmetischer Operator verwendet, denn es steht zwischen zwei numerischen Werten ( summand1 und summand2 sind jeweils vom Typ int ) In Zeile 4 kommt + mehrmals vor. Der Ausdruck in den runden Klammern von println() wird von links nach rechts aufgel\u00f6st: Das Literal \" + \" ist ein String. Hier ist + gar kein Operator, sondern nur ein Zeichen. Das + in summand1 + \" + \" ist die Konkatenation. Das liegt daran, dass einer der beiden Operanden, die das + verbindet, vom Typ String ist. Intern wird der Wert von summand1 ( die 3 ) zu einem String und dieser wird mit \" + \" verbunden. Es entsteht ein String \"3 + \" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + \" + summand2 enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn einer der beiden Operanden (der erste) ist vom Typ String . Intern wird der Wert von summand2 ( die 4 ) zu einem String und dieser wird mit \"3 + \" verbunden. Es entsteht ein String \"3 + 4\" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + 4\" + \" = \" enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn beide Operanden (der erste und der zweite) sind vom Typ String . Es entsteht der String \"3 + 4 = \" . Das letzte + steht also in dem Ausdruck \"3 + 4 = \" + summe . Auch hier handelt es sich wieder um die Konkatenation, da einer der beiden Operanden (der erste) vom Typ String ist. Intern wird der Wert von summe ( die 7 ) zu einem String und dieser wird mit \"3 + 4 = \" verbunden. Es entsteht ein String \"3 + 4 = 7\" . Dieser String wird ausgegegeben. \u00dcbung Doppelte Bedeutung von + Angenommen, in dem obigen Beispiel wollen Sie die Summe der beiden Summanden nicht erst in einer Variablen zwischenspeichern, sondern gleich ausgeben. Sie schreiben deshalb folgendes Programm: int summand1 = 3 ; int summand2 = 4 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summand1 + summand2 ); Sie erhalten jedoch nicht die gew\u00fcnschte Ausgabe. Warum nicht? Wie k\u00f6nnen Sie doch die Summe ausgeben, ohne diese zwischenspeichern zu m\u00fcssen? Success Wir k\u00f6nnen nun Variablen deklarieren und initialisieren. Wir kennen alle acht primitiven Datentypen. Wir nennen diese Datentypen Wertetypen . Wir wissen, dass eine ganze Zahl im Java-Programm vom Typ int ist und eine Gleikommazahl vom Typ double . Wir kennen die interne Darstellung von ganzen Zahlen und wir wissen \u00fcber die Kodierung von Zeichen Bescheid. Der datentyp char ist ein ganzzahliger Typ, obwohl er f\u00fcr das Speichern von Zeichen zust\u00e4ndig ist. Dies liegt an der Kodierung der Zeichen als ganze Zahlen. Der Wertzuweisungsoperator ist = . Wenn einer Variablen ein Wert zugewiesen werden soll, dann muss die Variablen links stehen, der Wertzuweisungsoperator in der Mitte und rechts der Wert.","title":"Doppelte Bedeutung des Operatorzeichens +"},{"location":"variablen/#konstanten","text":"Wir haben gesagt, dass Variablen beliebig oft einer neuer Wert zugewisen werden kann. Manchmal m\u00f6chte man aber genau das nicht. Sogenannten Konstanten m\u00f6chte man genau einmal einen Wert zuweisen und dann soll dieser Wert nicht mehr \u00fcberschrieben werden k\u00f6nnen. In Java kann man solche Konstanten mithilfe des Schl\u00fcsselwortes final deklarieren: final datentyp KONSTANTE = Wert; Eine Konstante wird zun\u00e4chst wie eine Variable deklariert, d.h. man vergibt einen Namen f\u00fcr die Variable und weist ihr einen Datentyp zu. Au\u00dferdem wird ihr mithilfe des Zuweisungsoperators ein Wert zugewiesen. Um zu verhindern, dass dieser Variablen erneut ein Wert zugewiesen kann, setzt man vor den Datentyp noch das Schl\u00fcsselwort final . Damit ist diese Variable schreibgesch\u00fctzt und es kann ihr nie wieder ein neuer Wert zugewiesen werden. Schauen wir uns ein Beispiel an: final double PI = 3.14159265359 ; Es wird eine Konstante PI deklariert und ihr der Wert 3.14159265359 zugewiesen. Damit wir Konstanten von \"normalen\" Variablen unterscheiden k\u00f6nnen, schreiben wir Konstenten immer gro\u00df . Wenn der Name einer Konstanten aus mehreren W\u00f6rtern besteht, verwendet man typischerweise den Unterstrich _ zum Verbinden der beiden W\u00f6rter, z.B. final int NOT_FOUND = - 1 ; final int MIN_VALUE = - 2147483648 ; final int MAX_VALUE = 2147483647 ; final char DEGREE_SYMBOL = '\\u00b0' ; final char DEGREE_CELSIUS = '\\u2103' ; final char DEGREE_FAHRENHEIT = '\\u2109' ; Ansonsten k\u00f6nnen Sie Konstanten ganz normal verwenden, aber immer nur lesend, also z.B. double area = PI * 25.0 ; System . out . println ( area ); System . out . println ( DEGREE_FAHRENHEIT ); System . out . println ( DEGREE_CELSIUS ); String fahrenheit = DEGREE_SYMBOL + \"F\" ; System . out . println ( fahrenheit ); ergibt folgende Ausgabe: 78 .53981633975 \u2109 \u2103 \u00b0F Wenn Sie in Ihrem Programm versuchen, einer Konstanten einen neuen Wert zuzuweisen, erhalten Sie einen Fehler ( The final variable cannot be assigned ) und Sie k\u00f6nnen das Programm gar nicht erst compilieren. Wann immer Sie in Ihrem Programm ein Literal verwenden, also einen Wert, sollten Sie \u00fcberlegen, ob Sie diesem Wert nicht besser einen Namen geben k\u00f6nnen, n\u00e4mlich daf\u00fcr eine Konstante verwenden, und dann stets die Konstante anstelle des Wertes verwenden. Damit werden sogenannte magic numbers vermieden und das Programm ist lesbarer.","title":"Konstanten"},{"location":"variablen/#typkonvertierung-type-cast","text":"Java ist statisch typisiert , d.h. dass jede Variable (und jedes Literal) einen Datentyp hat. Dieser wird bei der Deklaration der Variablen festegelgt und ist somit bereits zur Compile-Zeit bekannt. Der Datentyp einer Variablen kann auch nicht mehr ge\u00e4ndert werden 4 . Die Typisierung einer Variablen gibt den Wertebereich vor, aus dem die Variable Werte annehmen kann ( int -Variablen aus dem int -Wertebereich, boolean aus dem Wertebereich {true, false} usw.). Trotzdem ist in Java auch erlaubt, dass Wertezuweisungen nicht nur aus identischen Datentypen m\u00f6glich sind, sondern auch aus kompatiblen Datentypen: 1 2 3 4 5 int a = 5 ; // links ist int und rechts ist int --> identische Datentypen long b = 5 ; // links ist long und rechts ist int --> kompatible Datentypen int c = boolean ; // nicht erlaubt --> Fehler!!! keine kompatiblen Datentypen (int vs. boolean) float d = 5.0f ; // links ist float und rechts ist float --> identische Datentypen double e = d ; // links ist double und rechts ist float --> kompatible Datentypen In den Zeilen 2 und 5 werden die Datentypen bei der Zuweisung automatisch vom Compiler umgewandelt (in Zeile 2 automatisch von int nach long und in Zeile 5 automatisch von float nach double ). Diese Umwandlung von Datentypen nennt sich Typkonvertierung (engl. type cast ). Die beiden Beispiele aus Zeile 2 und Zeile 5 hei\u00dfen implizite Typkonvertierung.","title":"Typkonvertierung (type-cast)"},{"location":"variablen/#implizite-typkonvertierung","text":"Jeder Wert (jedes Literal ) in Java ist von einem bestimmten Typ, z.B. 1 2 3 4 5 4 // Datentyp int 4.0 // Datentyp double true // Datentyp boolean 'a' // Datentyp char \"FIW\" // Datentyp String Was passiert bei double number = 4 ; ? Wir haben links eine Variable vom Typ double und rechts einen Wert vom Typ int . Die Antwort ist, dass der Compiler implizit den Wert 4 in den Wert 4.0 umwandelt und diesen Wert der Variablen number zuweist. Es findet also eine implizite Typkonvertierung statt. Typkonvertierung immer, wenn in einer Zuweisung verschiedene Typen im Spiel sind, erfolgt eine Typkonvertierung der Typ, der rechts vom Zuweisungsoperator steht, muss in den Typ konvertiert werden, der links vom Zuweisungsoperator steht hier: von int nach double Wenn von Typen mit einem kleineren Wertebereich zu Typen mit einem gr\u00f6\u00dferen Wertebereich umgewandelt (konvertiert) werden sollen, kann dies automatisch (implizit) erfolgen \u2192 implizite Typkonvertierung 1 2 3 4 5 6 7 8 // Beispiel Umrechnung Fahrenheit in Celsius --> ohne Typkonvertierung final char DEGREE_SYMBOL = '\\u00b0' ; int celsius = 0 ; for ( int fahrenheit = 0 ; fahrenheit <= 100 ; fahrenheit += 20 ) { celsius = 5 * ( fahrenheit - 32 ) / 9 ; System . out . printf ( \"%3d %cF --> %3d %cC %n\" , fahrenheit , DEGREE_SYMBOL , celsius , DEGREE_SYMBOL ); } In dem Beispiel werden fahrenheit -Werte in celsius -Werte umgerechnet. Die Variablen celsius und fahrenheit und auch die Werte 5 , 32 und 9 sind vom Typ int . Die Berechnungen laufen ohne Typkonvertierung ab, alles bleibt im Wertebereich von int . Deshalb handelt es sich bei (fahrenheit - 32) / 9 um eine ganzzahlige Division . Die Ausgabe ist wie folgt: 0 \u00b0F --> -17 \u00b0C 20 \u00b0F --> -6 \u00b0C 40 \u00b0F --> 4 \u00b0C 60 \u00b0F --> 15 \u00b0C 80 \u00b0F --> 26 \u00b0C 100 \u00b0F --> 37 \u00b0C Wir \u00e4ndern das Beispiel und deklarieren die beiden Variablen fahrenheit und celsius als double : 1 2 3 4 5 6 7 8 // Beispiel Umrechnung Fahrenheit in Celsius --> mit Typkonvertierung final char DEGREE_SYMBOL = '\\u00b0' ; double celsius = 0 ; for ( double fahrenheit = 0 ; fahrenheit <= 100 ; fahrenheit += 20 ) { celsius = 5 * ( fahrenheit - 32 ) / 9 ; System . out . printf ( \"%6.2f %cF --> %7.3f %cC %n\" , fahrenheit , DEGREE_SYMBOL , celsius , DEGREE_SYMBOL ); } Dadurch ergibt sich eine andere Ausgabe (die Platzhalter in printf() mussten auch angepasst werden): 0 ,00 \u00b0F --> -17,778 \u00b0C 20 ,00 \u00b0F --> -6,667 \u00b0C 40 ,00 \u00b0F --> 4 ,444 \u00b0C 60 ,00 \u00b0F --> 15 ,556 \u00b0C 80 ,00 \u00b0F --> 26 ,667 \u00b0C 100 ,00 \u00b0F --> 37 ,778 \u00b0C Was ist passiert? Dadurch, dass in der Wertezuweisung celsius = 5 * (fahrenheit - 32) / 9; auf der linken Seite ein double steht, wird der gesamte Ausdruck auf der rechten Seite in ein double konvertiert . Das w\u00fcrde aber erst nach Ausrechnen des Ausdrucks erfolgen, wenn nicht auch fahrenheit ein double w\u00e4re. Es passiert folgendes: zuerst wird der Ausdruck (fahrenheit - 32) aufgel\u00f6st, da er in Klammern steht. Hier ist die Operation double - int . Sobald einer der beiden Operanden ein double ist, wird der double -Operator - verwendet \u2192 dazu wird die 32 in eine 32.0 konvertiert \u2192 das Ergebnis ist ein double dann wird von links nach rechts aufgel\u00f6st, also zun\u00e4chst 5 * double . Auch hier ist die Operation also int * double , d.h. double -Multiplikation und somit wird aus der 5 eine 5.0 . Das Ergebnis dieser Multiplikation ist double dann erfolgt die Berechnung von double / 9 . Wenn einer der beiden Operanden ein double ist, handelt es sich bei der Division um eine Gleitkommadivision . Also gibt es auch Nachkommastellen \u2192 das Ergebnis ist ein double Diese implizite Typkonvertierung macht der Compiler automatisch. Implizite Typkonvertierung kann immer dann erfolgen, wenn von einem schmalen in einen breiten Datentyp konvertiert wird, d.h. wenn alle Werte aus dem \"schmalen\" Wertebereich auch Werte aus dem \"breiten\" Wertebereich sind. Dies ist bei int (schmal) nach double (breit) der Fall, da alle int -Werte auch im double -Wertebereich enthalten sind. Das hier ist also kein Problem: int v1 = 1 ; double v2 = v1 ; // ok System . out . println ( \"Wert von v2: \" + v2 ); // 1.0 aber das geht nicht : double v3 = 1.0 ; int v4 = v3 ; // Fehler! System . out . println ( \"Wert von v4: \" + v4 ); Obwohl ja die 1.0 ein Wert aus int darstellt, pr\u00fcft der Compiler nicht den Wert, sondern den Typ. Da der double -Wertebereich viele Werte umfasst, die nicht Teil des Wertebereichs von int sind (z.B. 1.5 ), kann hier keine implizite Typkonvertierung erfolgen, denn diese w\u00e4re von einem \"breiten\" in einen \"schmalen\" Datentypen. Wenn man sich jedoch ganz sicher ist, dass eine solche Typkonvertierung sinnvoll ist (z.B. kann man ja 1.0 nach 1 und somit int ohne Verlust umwandeln), kann eine solche Typkonvertierung explizit angesto\u00dfen werden.","title":"Implizite Typkonvertierung"},{"location":"variablen/#explizite-typkonvertierung","text":"In dem Beispiel von eben double v3 = 1.0 ; int v4 = v3 ; // Fehler! System . out . println ( \"Wert von v4: \" + v4 ); f\u00fchrt der Compiler keine implizite Typkonvertierung durch. Das Programm wird gar nicht compiliert. Wenn wir nun aber wollen, dass diese Typkonvertierung trotzdem durchgef\u00fchrt wird, m\u00fcssen wir den Typkonvertierungsoperator (auch type cast operator ) verwenden. Der Typkonvertierungsoperator enth\u00e4lt in runden Klammern den Zieltyp und steht vor dem Wert der umgewandelt werden soll: typ_A variable = (typ_A)wert; Die variable sei vom typ_A und der Wert von einem Typ, der nicht impliziert nach typ_A konvertiert werden kann. Unter Angabe von (typ_A) direkt vor dem wert wird der Wert explizit in typ_A konvertiert. Obiges Beispiel w\u00fcrde dann so aussehen: double v3 = 1.0 ; int v4 = ( int ) v3 ; // ok System . out . println ( \"Wert von v4: \" + v4 ); // 1 Da wir wissen, dass die 1 (der von uns zugewiesene Wert von v3 ) im Wertebereich von int liegt, k\u00f6nnen wir den Compiler anweisen, von double nach int zu konvertieren \u2192 explizite Typkonvertierung. Aber Achtung! Explizite Typkonvertierung kann zu Informationsverlust f\u00fchren! double v3 = 1.23456 ; int v4 = ( int ) v3 ; // explizite TK System . out . println ( \"Wert von v4: \" + v4 ); // 1 Wird ein double in ein int konvertiert, werden die Nachkommastellen einfach abgeschnitten (kein Runden!). Aber Achtung! Explizite Typkonvertierung kann zu ganz anderen Werten f\u00fchren! long v5 = 2147483648L ; // L mit angeben! int v6 = ( int ) v5 ; // 2 hoch 31 System . out . println ( \"Wert von v6: \" + v6 ); // -2147483648 2147483648 ist zwar ganzzahlig, ist aber nicht mehr Teil des Wertebereiches von int (um 1 zu gro\u00df) \u2192 aufgrund der internen Zahlendarstellung (Zweierkomplement) , bekommt v6 den Wert -2147483648 . Bei expliziter Typkonvertierung muss selbst\u00e4ndig darauf geachtet werden, dass der Wertebereich nicht \u00fcberschritten bzw. nicht verlassen wird!","title":"Explizite Typkonvertierung"},{"location":"variablen/#sinnvolle-anwendungen-des-typkonvertierungsoperators","text":"Angenommen, wir haben ein int -Array ia und wollen aus den Werten in diesem Array den Mittelwert berechnen. Dann w\u00e4re folgender erster Implementierungsversuch denkbar: int [] ia = { 1 , 2 , 3 , 4 }; int sum = 0 ; for ( int index = 0 ; index < ia . length ; index ++ ) { sum = sum + ia [ index ] ; } double average = sum / ia . length ; System . out . println ( \"Durchschnitt ist \" + average ); // 2.0 Wir bilden also die Summe \u00fcber alle Werte und teilen durch die Anzahl der Werte. Das entspricht der Definition des Durchschnitts. Wir \u00fcberschlagen im Kopf, dass f\u00fcr die vier Werte 1 , 2 , 3 und 4 der Durchschnitt 2.5 ist. Ausgegeben wird aber Durchschnitt ist 2 .0 Das ist falsch und der Grund daf\u00fcr liegt darin, dass es sich bei sum / ia.length um die ganzzahlige Divsion handelt, da beide Operanden vom Typ int sind. Eine M\u00f6glichkeit w\u00e4re, die Variable sum als double zu deklarieren. Dann haben wir bereits das gew\u00fcnschte Ergebnis. Eine andere ist, einen der beiden (oder beide) explizit nach double zu konvertieren: int [] ia = { 1 , 2 , 3 , 4 }; int sum = 0 ; for ( int index = 0 ; index < ia . length ; index ++ ) { sum = sum + ia [ index ] ; } double average = sum / ( double ) ia . length ; System . out . println ( \"Durchschnitt ist \" + average ); // 2.5 Wir haben jetzt die L\u00e4nge explizit nach double konvertiert und somit ist einer der beiden Operanden der Division ein double und somit wird die Gleitkommadivision durchgef\u00fchrt. Nun erhalten wir das richtige Ergebnis: Durchschnitt ist 2 .5 Ein anderes sinnvolles Beispiel ist die explizite Konvertierung eines int -Wertes nach char . Beides sind ganzzahlige Datentypen, aber der Wertebereich von char (8 Bit) umfasst viel weniger Werte als der Wertebereich von int (16 Bit). int ist der \"breite\" Datentyp und char der schmale und somit findet keine implizite Typkonvertierung von int nach char statt. Trotzdem m\u00f6chte man h\u00e4ufig int in Bezug auf char nutzen, weil man unter Verwendung der numerischen ASCII-Codes ( int ) gut mit Zeichen \"rechnen\" kann: for ( int ascii = 65 ; ascii < 91 ; ascii ++ ) { char c = ( char ) ascii ; System . out . print ( c + \" \" ); } Wir m\u00fcssen hier explizit konvertieren, da die implizite Typkonvertierung char c = ascii; nicht existiert. Das w\u00e4re also ein Fehler. Mit der expliziten Typkonvertierung klappt aber alles wie gew\u00fcnscht: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Hier nochmal zur Veranschaulichung, zwischen welchen Datentypen eine implizite Typkonvertierung durchgef\u00fchrt wird: Beachten Sie, dass von und nach boolean in Java keine implizite Typkonvertierung durchgef\u00fchrt wird! Hier nochmal zur Veranschaulichung, zwischen welchen Datentypen eine explizite Typkonvertierung durchgef\u00fchrt werden kann ( kompatible Datentypen): Beachten Sie, dass von und nach boolean in Java auch keine explizite Typkonvertierung m\u00f6glich ist! Wenn wir ganz genau sein wollen, dann ist out vom Typ PrintStream und wir greifen auf die Objektmethode println() des PrintStream -Objektes out zu. \u21a9 const und goto geh\u00f6ren eigentlich gar nicht zum Sprachumfang von Java und sind aber trotzdem reservierte Schl\u00fcsselw\u00f6rter. \u21a9 Tats\u00e4chlich ist die Gr\u00f6\u00dfe eines boolean gar nicht genau definiert (siehe hier ). man braucht ja eigentlich nur ein bit. Man liest aber sehr h\u00e4ufig davon, dass einer Variablen vom Typ boolean ein ganzes Byte reserviert wird. \u21a9 Das ist nicht in Allen Programmiersprachen so. Beispielsweise wird in JavaScript erst zur Laufzeit ermittelt, von welchem Typ die Variable ist, denn das h\u00e4ngt von ihrem Wert ab. Dort kann eine Variable foo=\"String\" vom Typ string sein und dann durch foo=4 vom Typ number . Die Typisierung in solchen Programmiersprachen nennt man dynamisch typisiert . \u21a9","title":"Sinnvolle Anwendungen des Typkonvertierungsoperators"},{"location":"vererbung/","text":"Vererbung \u00b6 Vererbung (engl. Inheritance ) geh\u00f6rt zu den grundlegenden Konzepten der objektorientierten Programmierung. Dieses Konzept basiert auf Beobachtungen aus der realen Welt: Dinge (Objekte) kommen in verschiedenen Varianten vor, die sich hierarchisch klassifizieren lassen Dinge (Objekte), die hierarchisch tiefer stehen, sind speziellere Varianten der \u00fcbergeordneten, generelleren Dinge Speziellere Dinge besitzen die Eigenschaften der generelleren Dinge plus weitere, spezifischere Eigenschaften H\u00e4ufig werden f\u00fcr solche Beispiele aus der Realen Welt die Klassifikationen von Tieren oder Pflanzen verwendet, z.B. S\u00e4ugetiere sind eine Spezialisierung der Tiere , Katzen und Hunde wiederum sind Spezialisierungen von S\u00e4ugetieren usw. Eine solche Hierarchie, wie z.B. in der folgenden Abbildung gezeigt, kommt jedenfalls in der realen Welt sehr h\u00e4ufig vor. Tiere sind dabei die allgemeinste Klasse . Sie haben Eigenschaften, die f\u00fcr alle Tiere zutreffen, z.B. dass sie sich bewegen k\u00f6nnen und fortpflanzen. Wirbeltiere haben alle Eigenschaften der Tiere , aber zus\u00e4tzlich noch speziellerere Eigenschaften, wie z.B. dass sie ein Skellett besitzen. S\u00e4ugetiere besitzen alle Eigenschaften von Wirbeltieren (und also auch von Tieren ) und dar\u00fcber hinaus speziellere Eigenschaften, n\u00e4mlich z.B. lebend geb\u00e4rend usw. F\u00fcr die Programmierung bedeutet das, dass Klassen von anderen Klassen die Eigenschaften erben k\u00f6nnen, d.h. Kindklassen \u00fcbernehmen (erben) Eigenschaften (Objektvariablen und Objektmethoden) der Elternklasse Kindklassen k\u00f6nnen zus\u00e4tzlich weitere Eigenschaften (Objektvariablen und Objektmethoden) enthalten Wichtig f\u00fcr das Verst\u00e4ndnis der Vererbung ist, dass zwischen den Kind- und der Elternklasse eine is-a - ( ist-ein -) Relation besteht. F\u00fcr unser Beispiel oben bedeutet das z.B. der Hund ist ein S\u00e4ugetier , das S\u00e4ugetier ist ein Wirbeltier usw. Wenn wir uns also eine Vererbungshierarchie aufmalen, dann gehen die Pfleile immer von der Kind- zur Elternklasse: F\u00fcr die Vererbung gilt also: Die Vererbung ist eine sehr bedeutende M\u00f6glichkeit der Wiederverwendbarkeit von Klassen Vererbung basiert auf der Idee, dass Elternklassen ihren Kindern Variablen und Methoden vererben Durch Vererbung entsteht eine Klassenhierarchie: Vererbung in Java \u00b6 Angenommen, wir haben eine Klasse Elternklasse und eine Kindklasse soll von dieser Klasse erben. Wir verwenden das Schl\u00fcsselwort extends , um die Kindklasse von der Elternklasse erben zu lassen: public class Kindklasse extends Elternklasse { } In Java kann eine Klasse nur von genau einer Klasse erben. Mehrfachvererbung (das Erben von mehreren Klassen) ist nicht m\u00f6glich. Ein erstes Beispiel \u00b6 Wir betrachten ein erstes Beispiel. Wir werden eine Klasse Viereck erstellen. Von dieser Klasse wird eine Klasse Rechteck abgeleitet , d.h. Rechteck erbt von Viereck . Danach erzeugen wir noch eine weitere Klasse Quadrat , die wiederum von Rechteck erbt. Die Klasse Viereck \u00b6 Als Objektvariablen der Klasse Viereck w\u00e4hlen wir die vier Seitenl\u00e4ngen eines Vierecks a , b , c und d . Au\u00dferdem definieren wir uns noch einen Konstruktor und zwei Objektmethoden, die Methode umfang() , die den Umfang des Rechtecks zur\u00fcckgibt und die Methode print() , die die vier Seitenl\u00e4ngen auf die Konsole ausgibt und den Umfang: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Viereck { private int a , b , c , d ; // Seiten public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; } public int umfang () { return this . a + this . b + this . c + this . d ; } public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . println ( \" Umfang des Vierecks : \" + this . umfang ()); } } In einer TestViereck -Klasse erzeugen wir Objekte von Viereck und testen die Methoden: 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestViereck { public void main () { Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); } } Auf der Konsole erscheint folgende Ausgabe: [ a = 10 , b = 20 , c = 30 , d = 40 ] Umfang des Vierecks : 100 [ a = 15 , b = 20 , c = 25 , d = 20 ] Umfang des Vierecks : 80 Soweit nichts Neues. Jetzt wollen wir aber von dieser Klasse erben und erzeugen eine Klasse Rechteck . Ein Rechteck ist ein Viereck. Die Klasse Rechteck \u00b6 Die Klasse Rechteck erbt von Viereck , d.h. wir verwenden das Schl\u00fcsselwort extends . Wir erzeugen uns im gleichen package, in dem auch Viereck und TestViereck liegen, eine Klasse Rechteck : 1 2 3 4 public class Rechteck extends Viereck { } Hinter den Klassennamen Rechteck schreiben wir nun extends und den Namen der Klasse, von der geerbt werden soll, hier Viereck . Das ist soweit gut, jedoch wird leider ein Fehler angezeigt: Implicit super constructor Viereck () is undefined for default constructor. Must define an explicit constructor Der Konstruktor von Rechteck - das Schl\u00fcsselwort super \u00b6 Wir erinnern uns : Wenn wir eine neue Klasse erstellen und keinen Konstruktor definieren, dann existiert immer ein sogenannter impliziter Konstruktor (oder Standardkonstruktor ). Dieser hei\u00dft exakt wie die Klasse und ist parameterlos. Wenn wir uns einen eigenen Konstruktor definieren , dann existiert dieser implizite Konstruktor ( Standardkonstruktor ) nicht mehr. In der Klasse Viereck haben wir uns einen eigenen Konstruktor erstellt ( Viereck(int a, int b, int c, int d) ), d.h. es gibt keinen impliziten Konstruktor Viereck() (mehr). In Java gilt nun aber folgendes: Wird in Java ein Objekt einer Kindklasse erzeugt, wird auch immer ein Objekt der Elternklasse erzeugt. Wir m\u00fcssen nun daf\u00fcr sorgen, dass beim Erzeugen eines Objektes von Rechteck auch ein Objekt von Viereck erzeugt werden kann. Dies machen wir wie folgt: 1 2 3 4 5 6 7 public class Rechteck extends Viereck { public Rechteck ( int laenge , int breite ) { super ( laenge , breite , laenge , breite ); // Aufruf des Konstruktors von Viereck } } Erl\u00e4uterung: in den Zeilen 3-6 wird der Konstruktor von Rechteck definiert. bei einem Rechteck sind die gegen\u00fcberliegenden Seiten gleich lang, deshalb ben\u00f6tigen wir f\u00fcr die Seitenl\u00e4ngen auch nur noch zwei Werte, n\u00e4mlich laenge und breite . in Zeile 5 wird der Konstruktor von Viereck aufgerufen! Das passiert in der Kindklasse nicht durch Viereck(int, int, int, int) , sondern durch die Verwendung des Schl\u00fcsselwortes super . Hier wird also explizit der Konstruktor der Elternklasse aufgerufen! Wenn wir uns den Konstruktor von Viereck nochmal anschauen, dann sehen wir, dass nun der Wert von laenge der Seite a zugeordnet wird, der Wert von breite der Seite b , der Wert von laenge der Seite c und der Wert von breite der Seite d . Wenn wir in einer Kindklasse einen Konstruktor definieren, sollten wir immer explizit den Konstruktor der Elternklasse aufrufen (mithilfe von super() ). Dieser Aufruf muss die erste Anweisung innerhalb des Konstruktors sein! Der Umgang mit den Konstruktoren ist schon das Komplizierteste in Bezug auf Vererbung. Wir kommen sp\u00e4ter nochmal darauf zur\u00fcck. Rechteck hat alle Eigenschaften von Viereck geerbt \u00b6 Unsere Klasse Rechteck ist nun anwendbar. Die Klasse rechteck hat alle Eigenschaften der Klasse Viereck geerbt, d.h. die Objektvariablen a , b , c und d sowie die Objektmethoden umfang() und print() . Das testen wir gleich in der TestViereck -Klasse und erzeugen uns Objekte von Rechteck : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class TestViereck { public void main () { System . out . printf ( \"%n%n------- Objekte von Viereck erzeugen ------------%n%n\" ); Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); System . out . printf ( \"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\" ); Rechteck r1 = new Rechteck ( 10 , 20 ); r1 . print (); Rechteck r2 = new Rechteck ( 20 , 30 ); r2 . print (); } } Auf der Konsole erscheinen folgende Ausgaben: ------- Objekte von Viereck erzeugen ------------ [ a = 10 , b = 20 , c = 30 , d = 40 ] Umfang des Vierecks : 100 [ a = 15 , b = 20 , c = 25 , d = 20 ] Umfang des Vierecks : 80 ------- Objekte von Rechteck erzeugen ------------ [ a = 10 , b = 20 , c = 10 , d = 20 ] Umfang des Vierecks : 60 [ a = 20 , b = 30 , c = 20 , d = 30 ] Umfang des Vierecks : 100 Wir erzeugen uns also zwei Objekte von Rechteck und rufen f\u00fcr beide Objekte die Objektmethode print() auf. Diese Methode hat Rechteck von Viereck geerbt. Diese Methode gibt nun korrekt die jeweiligen Seitenl\u00e4ngen aus ( laenge wird a und c zugewiesen und breite den Seiten b und d - siehe Aufruf des Konstruktors von Viereck im Konstruktor von Rechteck : super(laenge, breite, laenge, breite) ). In der Methode print() wird die Methode umfang() aufgerufen, die ebenfalls geerbt wurde. Wir k\u00f6nnten diese Methode zum Testen auch direkt in der Testklasse f\u00fcr die Rechteck -Objekte aufrufen, z.B. 1 2 3 4 5 6 7 8 System . out . printf ( \"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\" ); Rechteck r1 = new Rechteck ( 10 , 20 ); r1 . print (); System . out . println ( \"Umfang des Rechtecks : \" + r1 . umfang ()); Rechteck r2 = new Rechteck ( 20 , 30 ); r2 . print (); System . out . println ( \"Umfang des Rechtecks : \" + r2 . umfang ()); und erhalten dann die Ausgaben: ------- Objekte von Rechteck erzeugen ------------ [ a = 10 , b = 20 , c = 10 , d = 20 ] Umfang des Vierecks : 60 Umfang des Rechtecks : 60 [ a = 20 , b = 30 , c = 20 , d = 30 ] Umfang des Vierecks : 100 Umfang des Rechtecks : 100 Wichtig ist, dass Rechteck alle Objektvariablen und Objektmethoden der Klasse Viereck geerbt hat. Allerdings sind die Objektvariablen a , b , c und d in Viereck als private deklariert und deshalb kann nur in Viereck auf diese Objektvariablen zugegriffen werden. Wenn wir auch in Rechteck darauf zugreifen wollen, dann m\u00fcssen wir die Sichtbarkeit der Objektvariablen \u00e4ndern. Das wollen wir im n\u00e4chsten Schritt machen. Der Sichtbarkeitsmodifizierer protected \u00b6 Wir kennen bisher zwei Sichtbarkeitsmodifizierer (auch Zugriffsmodifizierer ): private und public . auf Objektvariablen und -methoden, die als private deklariert wurden, kann nur innerhalb der Klasse zugegriffen werden, auf Objektvariablen und -methoden, die als public deklariert wurden, kann in allen anderen Klassen (auch Klassen aus anderen Paketen) zugegriffen werden. Wir lernen jetzt einen weiteren Sichtbarkeitsmodifizierer kennen: protected . Auf Objektvariablen und -methoden, die als protected deklariert wurden, kann in den Klassen einer Vererbungshierarchie zugegriffen werden. Bis jetzt k\u00f6nnen wir in der Klasse Rechteck nicht auf die Objektvariablen a , b , c und d zugreifen, da diese in Viereck als private deklariert wurden und deshalb nur innerhalb von Viereck zugreifbar sind. Aus Gr\u00fcnden der Datenkapselung sollen diese aber auch nicht public sein. Wir deklarieren sie deshalb als protected : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Viereck { protected int a , b , c , d ; // Seiten innerhalb der Vererbungshierarchie sichtbar public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; } public int umfang () { return this . a + this . b + this . c + this . d ; } public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . println ( \" Umfang des Vierecks : \" + this . umfang ()); } } Nun kann auf die Objektvariablen in allen abgeleiteten Klassen (also in Rechteck ) zugegriffen werden. Nicht aber in anderen Klassen. Man muss also von Viereck erben, um Zugriff auf die als protected deklarierten Variablen zu bekommen. Erweitern der Klasse Rechteck um eine weitere Eigenschaft \u00b6 Rechteck hat alle Eigenschaften von Viereck geerbt. Ganz am Anfang des Vererbungskapitels haben wir aber gesagt, dass speziellere Klassen auch speziellere Eigenschaften haben k\u00f6nnen. Wir wollen Rechteck nun eine weitere Eigenschaft hinzuf\u00fcgen: die Objektmethode flaecheninhalt() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Rechteck extends Viereck { public Rechteck ( int laenge , int breite ) { super ( laenge , breite , laenge , breite ); // Aufruf des Konstruktors von Viereck } /* * neue Objektmethode * spezielle Eigenschaft fuer Rechteck * gilt nicht f\u00fcr Viereck * */ public int flaecheninhalt () { return this . a * this . b ; // Zugriff moeglich wegen protected in Viereck } } Die Klasse Rechteck hat somit eine weitere Eigenschaft. Diese ist nicht von Viereck geerbt, sondern ist eine spezielle Eigenschaft von Rechteck . Die Klasse Viereck besitzt diese Eigenschaft nicht! Das bedeutet, dass f\u00fcr Objekte der Klasse Viereck existiert die Eigenschaft flaecheninhalt() nicht, f\u00fcr Objekte der Klasse Rechteck aber schon. In der Testklasse k\u00f6nnen wir die neue Methode testen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public void main () { System . out . printf ( \"%n%n------- Objekte von Viereck erzeugen ------------%n%n\" ); Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); System . out . printf ( \"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\" ); Rechteck r1 = new Rechteck ( 10 , 20 ); r1 . print (); System . out . println ( \"Umfang des Rechtecks : \" + r1 . umfang ()); System . out . println ( \"Flaecheninhalt des Rechtecks \" + r1 . flaecheninhalt ()); Rechteck r2 = new Rechteck ( 20 , 30 ); r2 . print (); System . out . println ( \"Umfang des Rechtecks : \" + r2 . umfang ()); System . out . println ( \"Flaecheninhalt des Rechtecks \" + r2 . flaecheninhalt ()); } und erhalten dann die Ausgaben (hier nur f\u00fcr Rechteck gezeigt): ------- Objekte von Rechteck erzeugen ------------ [ a = 10 , b = 20 , c = 10 , d = 20 ] Umfang des Vierecks : 60 Umfang des Rechtecks : 60 Flaecheninhalt des Rechtecks 200 [ a = 20 , b = 30 , c = 20 , d = 30 ] Umfang des Vierecks : 100 Umfang des Rechtecks : 100 Flaecheninhalt des Rechtecks 600 Beachten Sie, es ist nicht m\u00f6glich, die Objektmethode flaecheninhalt() f\u00fcr die Objekte von Viereck aufzurufen! F\u00fcr diese Objekte existiert die Eigenschaft nicht! 1 2 3 4 5 6 7 8 9 10 11 12 public void main () { System . out . printf ( \"%n%n------- Objekte von Viereck erzeugen ------------%n%n\" ); Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); // System.out.println(\"Flaecheninhalt des Vierecks \" + v1.flaecheninhalt()); // existiert nicht!!! Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); // System.out.println(\"Flaecheninhalt des Vierecks \" + v1.flaecheninhalt()); // existiert nicht!!! } \u00dcberschreiben von Methoden \u00b6 Die Klasse Rechteck hat unter anderem die Objektmethode print() von der Klasse Viereck geerbt. Wir k\u00f6nnen geerbte Methoden entweder so lassen, wie wir sie geerbt haben oder wir implementieren sie neu. Das Neuimplementieren von geerbten Methoden nennt sich \u00dcberschreiben . Wird eine Methode von der Elternklasse geerbt, diese Methode in der Kindklasse jedoch neu implementiert, so wird diese Methode \u00fcberschrieben . Die geerbte print() -Methode gef\u00e4llt uns nicht wirklich gut, denn erfolgt innerhalb der Methode die Ausschrift Umfang des Vierecks anstelle von Umfang des Rechtecks und k\u00f6nnten wir die print() -Methode in Rechteck um die Ausgabe des Fl\u00e4cheninhaltes des Rechteckes erweitern. Wir wollen deshalb diese Methode \u00fcberschreiben : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Rechteck extends Viereck { public Rechteck ( int laenge , int breite ) { super ( laenge , breite , laenge , breite ); // Aufruf des Konstruktors von Viereck } /* * neue Objektmethode * spezielle Eigenschaft fuer Rechteck * gilt nicht f\u00fcr Viereck * */ public int flaecheninhalt () { return this . a * this . b ; // Zugriff moeglich wegen protected in Viereck } @Override public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . print ( \" Umfang des Rechtecks : \" + this . umfang ()); System . out . println ( \" Flaecheninhalt des Rechtecks : \" + this . flaecheninhalt ()); } } In den Zeilen 20-26 haben wir nun die Methode print() neu implementiert, d.h. wir haben sie \u00fcberschrieben. Beachten Sie die sogenannte Annotation @Override , die direkt \u00fcber dem Methodenkopf steht. Mit dieser Annotation geben wir dem Compiler an, dass die folgende Methode \u00fcberschrieben wird. Der Compiler pr\u00fcft nun, ob wir die Methode \u00fcberhaupt so geerbt haben, wie wir sie \u00fcberschreiben, d.h. es wird \u00fcberpr\u00fcft, ob der Name der Methode korrekt ist (wir m\u00fcssen eine Methode geerbt haben, die genau so hei\u00dft - auch hier Gro\u00df- und Kleinschreibung beachten), die Anzahl und die Typreihenfolge der Parameter mit der geerbten Methode \u00fcbereinstimmen (die Namen der Parameter sind egal), der R\u00fcckgabetyp der Methode mit der geerbten Methode \u00fcbereinstimmt (der kann innerhalb der Vererbungshierarchie ge\u00e4ndert werden, aber das ist ein sp\u00e4teres Thema), die Sichtbarkeit nicht eingeschr\u00e4nkt wird (eine Methode, die in der Elternklasse als public deklariert wurde, darf beim \u00dcberschreiben nicht protected oder private werden). Wir m\u00fcssen in der Testklasse nun gar nichts \u00e4ndern, es wird f\u00fcr die Rechteck-Objekte die neue Implementierung der print() -Methode verwendet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void main () { System . out . printf ( \"%n%n------- Objekte von Viereck erzeugen ------------%n%n\" ); Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); System . out . printf ( \"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\" ); Rechteck r1 = new Rechteck ( 10 , 20 ); r1 . print (); Rechteck r2 = new Rechteck ( 20 , 30 ); r2 . print (); } erzeugt folgende Ausgaben: ------- Objekte von Viereck erzeugen ------------ [ a = 10 , b = 20 , c = 30 , d = 40 ] Umfang des Vierecks : 100 [ a = 15 , b = 20 , c = 25 , d = 20 ] Umfang des Vierecks : 80 ------- Objekte von Rechteck erzeugen ------------ [ a = 10 , b = 20 , c = 10 , d = 20 ] Umfang des Rechtecks : 60 Flaecheninhalt des Rechtecks : 200 [ a = 20 , b = 30 , c = 20 , d = 30 ] Umfang des Rechtecks : 100 Flaecheninhalt des Rechtecks : 600 Wir werden das \u00dcberschreiben von Methoden noch weiter \u00fcben, wenn wir uns mit der Klasse Object besch\u00e4ftigen. Wir merken uns zun\u00e4chst, dass wir geerbte Methoden \u00fcberschreiben k\u00f6nnen und dass wir die Annotation @Override verwenden sollten, wenn wir eine Methode \u00fcberschreiben, um zu vermeiden, dass wir - z.B. weil wir den Namen der Methode falsch schreiben - die Methode gar nicht \u00fcberschreiben, sondern eine neue Methode hinzuf\u00fcgen. \u00dcbrigens : Wir kennen das Schl\u00fcsselwort final ja bereits von Variablen. Eine als final deklarierte Variable kann ihren einmal zugewiesenen Wert nicht mehr \u00e4ndern. Wir haben mit final sogenannte Konstanten definiert. Eine als final deklarierte Methode kann nicht \u00fcberschrieben werden! Von einer als final deklarierten Klasse kann nicht geerbt werden! Die Klasse Quadrat \u00b6 Das folgende Beispiel dient nur zur Wiederholung. Wir erben nun eine Klasse Quadrat von der Klasse Rechteck . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Quadrat extends Rechteck { Quadrat ( int seite ) { super ( seite , seite ); // Aufruf des Konstruktors von Rechteck } @Override public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . print ( \" Umfang des Quadrats : \" + this . umfang ()); System . out . println ( \" Flaecheninhalt des Quadrats : \" + this . flaecheninhalt ()); } } In Zeile 1 geben wir mithilfe von extends Rechteck an, dass die Klasse Quadrat von der Klasse Rechteck erbt. In den Zeilen 3-6 definieren wir den Konstruktor von Quadrat . Darin rufen wir als erstes den Konstruktor von Rechteck auf. Der Konstruktor von Quadrat erwartet nur noch eine Parameter, da im Quadrat alle Seiten gleich lang sind. Den Wert des Parameters \u00fcbergeben wir dem Konstruktor von Rechteck , der zwei Parameterwerte erwartet (f\u00fcr laenge und breite ). In den Zeilen 8-15 \u00fcberschreiben wir wieder die print() -Methode und passen sie an das Quadrat an. Beachten Sie, dass Quadrat alle Eigenschaften von Rechteck erbt, also die Objektvariablen a , b , c , d und die Objektmethoden print() , umfang() und flaecheninhalt() . Die Testklasse k\u00f6nnten wir nun wie folgt erweiteren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public void main () { System . out . printf ( \"%n%n------- Objekte von Viereck erzeugen ------------%n%n\" ); Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); System . out . printf ( \"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\" ); Rechteck r1 = new Rechteck ( 10 , 20 ); r1 . print (); Rechteck r2 = new Rechteck ( 20 , 30 ); r2 . print (); System . out . printf ( \"%n%n------- Objekte von Quadrat erzeugen ------------%n%n\" ); Quadrat q1 = new Quadrat ( 30 ); q1 . print (); Quadrat q2 = new Quadrat ( 40 ); q2 . print (); } und bek\u00e4men folgende Ausgaben: ------- Objekte von Viereck erzeugen ------------ [ a = 10 , b = 20 , c = 30 , d = 40 ] Umfang des Vierecks : 100 [ a = 15 , b = 20 , c = 25 , d = 20 ] Umfang des Vierecks : 80 ------- Objekte von Rechteck erzeugen ------------ [ a = 10 , b = 20 , c = 10 , d = 20 ] Umfang des Rechtecks : 60 Flaecheninhalt des Rechtecks : 200 [ a = 20 , b = 30 , c = 20 , d = 30 ] Umfang des Rechtecks : 100 Flaecheninhalt des Rechtecks : 600 ------- Objekte von Quadrat erzeugen ------------ [ a = 30 , b = 30 , c = 30 , d = 30 ] Umfang des Quadrats : 120 Flaecheninhalt des Quadrats : 900 [ a = 40 , b = 40 , c = 40 , d = 40 ] Umfang des Quadrats : 160 Flaecheninhalt des Quadrats : 1600 Success Mit Vererbung haben wir ein wichtiges Konzept der objektorientierten Programmierung kennengelernt. Um von einer Klasse zu erben, verwenden wir das Schl\u00fcsselwort extends . Eine Kindklasse erbt von ihrer Elternklasse alle Eigenschaften, also alle Objektvariablen und Objektmethoden. Eine geerbte Methode kann in der Kindklasse \u00fcberschrieben werden. Wird eine Methode \u00fcberschrieben, verwenden wir die Annotation @Override . Im Konstruktor der Kindklasse wird der Konstruktor der Elternklasse aufgerufen. Dies kann implizit erfolgen, wenn der implizite Konstruktor der Elternklasse existiert, oder es erfolgt explizit durch die Verwendung des Schl\u00fcsselwortes super . Mithilfe von Vererbung erh\u00f6hen wir die Wiederverwendbarkeit von Code und vermeiden doppelte Implementierungen. Au\u00dferdem sorgen wir f\u00fcr eine bessere Strukturierung des Codes.","title":"Vererbung"},{"location":"vererbung/#vererbung","text":"Vererbung (engl. Inheritance ) geh\u00f6rt zu den grundlegenden Konzepten der objektorientierten Programmierung. Dieses Konzept basiert auf Beobachtungen aus der realen Welt: Dinge (Objekte) kommen in verschiedenen Varianten vor, die sich hierarchisch klassifizieren lassen Dinge (Objekte), die hierarchisch tiefer stehen, sind speziellere Varianten der \u00fcbergeordneten, generelleren Dinge Speziellere Dinge besitzen die Eigenschaften der generelleren Dinge plus weitere, spezifischere Eigenschaften H\u00e4ufig werden f\u00fcr solche Beispiele aus der Realen Welt die Klassifikationen von Tieren oder Pflanzen verwendet, z.B. S\u00e4ugetiere sind eine Spezialisierung der Tiere , Katzen und Hunde wiederum sind Spezialisierungen von S\u00e4ugetieren usw. Eine solche Hierarchie, wie z.B. in der folgenden Abbildung gezeigt, kommt jedenfalls in der realen Welt sehr h\u00e4ufig vor. Tiere sind dabei die allgemeinste Klasse . Sie haben Eigenschaften, die f\u00fcr alle Tiere zutreffen, z.B. dass sie sich bewegen k\u00f6nnen und fortpflanzen. Wirbeltiere haben alle Eigenschaften der Tiere , aber zus\u00e4tzlich noch speziellerere Eigenschaften, wie z.B. dass sie ein Skellett besitzen. S\u00e4ugetiere besitzen alle Eigenschaften von Wirbeltieren (und also auch von Tieren ) und dar\u00fcber hinaus speziellere Eigenschaften, n\u00e4mlich z.B. lebend geb\u00e4rend usw. F\u00fcr die Programmierung bedeutet das, dass Klassen von anderen Klassen die Eigenschaften erben k\u00f6nnen, d.h. Kindklassen \u00fcbernehmen (erben) Eigenschaften (Objektvariablen und Objektmethoden) der Elternklasse Kindklassen k\u00f6nnen zus\u00e4tzlich weitere Eigenschaften (Objektvariablen und Objektmethoden) enthalten Wichtig f\u00fcr das Verst\u00e4ndnis der Vererbung ist, dass zwischen den Kind- und der Elternklasse eine is-a - ( ist-ein -) Relation besteht. F\u00fcr unser Beispiel oben bedeutet das z.B. der Hund ist ein S\u00e4ugetier , das S\u00e4ugetier ist ein Wirbeltier usw. Wenn wir uns also eine Vererbungshierarchie aufmalen, dann gehen die Pfleile immer von der Kind- zur Elternklasse: F\u00fcr die Vererbung gilt also: Die Vererbung ist eine sehr bedeutende M\u00f6glichkeit der Wiederverwendbarkeit von Klassen Vererbung basiert auf der Idee, dass Elternklassen ihren Kindern Variablen und Methoden vererben Durch Vererbung entsteht eine Klassenhierarchie:","title":"Vererbung"},{"location":"vererbung/#vererbung-in-java","text":"Angenommen, wir haben eine Klasse Elternklasse und eine Kindklasse soll von dieser Klasse erben. Wir verwenden das Schl\u00fcsselwort extends , um die Kindklasse von der Elternklasse erben zu lassen: public class Kindklasse extends Elternklasse { } In Java kann eine Klasse nur von genau einer Klasse erben. Mehrfachvererbung (das Erben von mehreren Klassen) ist nicht m\u00f6glich.","title":"Vererbung in Java"},{"location":"vererbung/#ein-erstes-beispiel","text":"Wir betrachten ein erstes Beispiel. Wir werden eine Klasse Viereck erstellen. Von dieser Klasse wird eine Klasse Rechteck abgeleitet , d.h. Rechteck erbt von Viereck . Danach erzeugen wir noch eine weitere Klasse Quadrat , die wiederum von Rechteck erbt.","title":"Ein erstes Beispiel"},{"location":"vererbung/#die-klasse-viereck","text":"Als Objektvariablen der Klasse Viereck w\u00e4hlen wir die vier Seitenl\u00e4ngen eines Vierecks a , b , c und d . Au\u00dferdem definieren wir uns noch einen Konstruktor und zwei Objektmethoden, die Methode umfang() , die den Umfang des Rechtecks zur\u00fcckgibt und die Methode print() , die die vier Seitenl\u00e4ngen auf die Konsole ausgibt und den Umfang: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Viereck { private int a , b , c , d ; // Seiten public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; } public int umfang () { return this . a + this . b + this . c + this . d ; } public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . println ( \" Umfang des Vierecks : \" + this . umfang ()); } } In einer TestViereck -Klasse erzeugen wir Objekte von Viereck und testen die Methoden: 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestViereck { public void main () { Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); } } Auf der Konsole erscheint folgende Ausgabe: [ a = 10 , b = 20 , c = 30 , d = 40 ] Umfang des Vierecks : 100 [ a = 15 , b = 20 , c = 25 , d = 20 ] Umfang des Vierecks : 80 Soweit nichts Neues. Jetzt wollen wir aber von dieser Klasse erben und erzeugen eine Klasse Rechteck . Ein Rechteck ist ein Viereck.","title":"Die Klasse Viereck"},{"location":"vererbung/#die-klasse-rechteck","text":"Die Klasse Rechteck erbt von Viereck , d.h. wir verwenden das Schl\u00fcsselwort extends . Wir erzeugen uns im gleichen package, in dem auch Viereck und TestViereck liegen, eine Klasse Rechteck : 1 2 3 4 public class Rechteck extends Viereck { } Hinter den Klassennamen Rechteck schreiben wir nun extends und den Namen der Klasse, von der geerbt werden soll, hier Viereck . Das ist soweit gut, jedoch wird leider ein Fehler angezeigt: Implicit super constructor Viereck () is undefined for default constructor. Must define an explicit constructor","title":"Die Klasse Rechteck"},{"location":"vererbung/#der-konstruktor-von-rechteck-das-schlusselwort-super","text":"Wir erinnern uns : Wenn wir eine neue Klasse erstellen und keinen Konstruktor definieren, dann existiert immer ein sogenannter impliziter Konstruktor (oder Standardkonstruktor ). Dieser hei\u00dft exakt wie die Klasse und ist parameterlos. Wenn wir uns einen eigenen Konstruktor definieren , dann existiert dieser implizite Konstruktor ( Standardkonstruktor ) nicht mehr. In der Klasse Viereck haben wir uns einen eigenen Konstruktor erstellt ( Viereck(int a, int b, int c, int d) ), d.h. es gibt keinen impliziten Konstruktor Viereck() (mehr). In Java gilt nun aber folgendes: Wird in Java ein Objekt einer Kindklasse erzeugt, wird auch immer ein Objekt der Elternklasse erzeugt. Wir m\u00fcssen nun daf\u00fcr sorgen, dass beim Erzeugen eines Objektes von Rechteck auch ein Objekt von Viereck erzeugt werden kann. Dies machen wir wie folgt: 1 2 3 4 5 6 7 public class Rechteck extends Viereck { public Rechteck ( int laenge , int breite ) { super ( laenge , breite , laenge , breite ); // Aufruf des Konstruktors von Viereck } } Erl\u00e4uterung: in den Zeilen 3-6 wird der Konstruktor von Rechteck definiert. bei einem Rechteck sind die gegen\u00fcberliegenden Seiten gleich lang, deshalb ben\u00f6tigen wir f\u00fcr die Seitenl\u00e4ngen auch nur noch zwei Werte, n\u00e4mlich laenge und breite . in Zeile 5 wird der Konstruktor von Viereck aufgerufen! Das passiert in der Kindklasse nicht durch Viereck(int, int, int, int) , sondern durch die Verwendung des Schl\u00fcsselwortes super . Hier wird also explizit der Konstruktor der Elternklasse aufgerufen! Wenn wir uns den Konstruktor von Viereck nochmal anschauen, dann sehen wir, dass nun der Wert von laenge der Seite a zugeordnet wird, der Wert von breite der Seite b , der Wert von laenge der Seite c und der Wert von breite der Seite d . Wenn wir in einer Kindklasse einen Konstruktor definieren, sollten wir immer explizit den Konstruktor der Elternklasse aufrufen (mithilfe von super() ). Dieser Aufruf muss die erste Anweisung innerhalb des Konstruktors sein! Der Umgang mit den Konstruktoren ist schon das Komplizierteste in Bezug auf Vererbung. Wir kommen sp\u00e4ter nochmal darauf zur\u00fcck.","title":"Der Konstruktor von Rechteck - das Schl\u00fcsselwort super"},{"location":"vererbung/#rechteck-hat-alle-eigenschaften-von-viereck-geerbt","text":"Unsere Klasse Rechteck ist nun anwendbar. Die Klasse rechteck hat alle Eigenschaften der Klasse Viereck geerbt, d.h. die Objektvariablen a , b , c und d sowie die Objektmethoden umfang() und print() . Das testen wir gleich in der TestViereck -Klasse und erzeugen uns Objekte von Rechteck : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class TestViereck { public void main () { System . out . printf ( \"%n%n------- Objekte von Viereck erzeugen ------------%n%n\" ); Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); System . out . printf ( \"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\" ); Rechteck r1 = new Rechteck ( 10 , 20 ); r1 . print (); Rechteck r2 = new Rechteck ( 20 , 30 ); r2 . print (); } } Auf der Konsole erscheinen folgende Ausgaben: ------- Objekte von Viereck erzeugen ------------ [ a = 10 , b = 20 , c = 30 , d = 40 ] Umfang des Vierecks : 100 [ a = 15 , b = 20 , c = 25 , d = 20 ] Umfang des Vierecks : 80 ------- Objekte von Rechteck erzeugen ------------ [ a = 10 , b = 20 , c = 10 , d = 20 ] Umfang des Vierecks : 60 [ a = 20 , b = 30 , c = 20 , d = 30 ] Umfang des Vierecks : 100 Wir erzeugen uns also zwei Objekte von Rechteck und rufen f\u00fcr beide Objekte die Objektmethode print() auf. Diese Methode hat Rechteck von Viereck geerbt. Diese Methode gibt nun korrekt die jeweiligen Seitenl\u00e4ngen aus ( laenge wird a und c zugewiesen und breite den Seiten b und d - siehe Aufruf des Konstruktors von Viereck im Konstruktor von Rechteck : super(laenge, breite, laenge, breite) ). In der Methode print() wird die Methode umfang() aufgerufen, die ebenfalls geerbt wurde. Wir k\u00f6nnten diese Methode zum Testen auch direkt in der Testklasse f\u00fcr die Rechteck -Objekte aufrufen, z.B. 1 2 3 4 5 6 7 8 System . out . printf ( \"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\" ); Rechteck r1 = new Rechteck ( 10 , 20 ); r1 . print (); System . out . println ( \"Umfang des Rechtecks : \" + r1 . umfang ()); Rechteck r2 = new Rechteck ( 20 , 30 ); r2 . print (); System . out . println ( \"Umfang des Rechtecks : \" + r2 . umfang ()); und erhalten dann die Ausgaben: ------- Objekte von Rechteck erzeugen ------------ [ a = 10 , b = 20 , c = 10 , d = 20 ] Umfang des Vierecks : 60 Umfang des Rechtecks : 60 [ a = 20 , b = 30 , c = 20 , d = 30 ] Umfang des Vierecks : 100 Umfang des Rechtecks : 100 Wichtig ist, dass Rechteck alle Objektvariablen und Objektmethoden der Klasse Viereck geerbt hat. Allerdings sind die Objektvariablen a , b , c und d in Viereck als private deklariert und deshalb kann nur in Viereck auf diese Objektvariablen zugegriffen werden. Wenn wir auch in Rechteck darauf zugreifen wollen, dann m\u00fcssen wir die Sichtbarkeit der Objektvariablen \u00e4ndern. Das wollen wir im n\u00e4chsten Schritt machen.","title":"Rechteck hat alle Eigenschaften von Viereck geerbt"},{"location":"vererbung/#der-sichtbarkeitsmodifizierer-protected","text":"Wir kennen bisher zwei Sichtbarkeitsmodifizierer (auch Zugriffsmodifizierer ): private und public . auf Objektvariablen und -methoden, die als private deklariert wurden, kann nur innerhalb der Klasse zugegriffen werden, auf Objektvariablen und -methoden, die als public deklariert wurden, kann in allen anderen Klassen (auch Klassen aus anderen Paketen) zugegriffen werden. Wir lernen jetzt einen weiteren Sichtbarkeitsmodifizierer kennen: protected . Auf Objektvariablen und -methoden, die als protected deklariert wurden, kann in den Klassen einer Vererbungshierarchie zugegriffen werden. Bis jetzt k\u00f6nnen wir in der Klasse Rechteck nicht auf die Objektvariablen a , b , c und d zugreifen, da diese in Viereck als private deklariert wurden und deshalb nur innerhalb von Viereck zugreifbar sind. Aus Gr\u00fcnden der Datenkapselung sollen diese aber auch nicht public sein. Wir deklarieren sie deshalb als protected : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Viereck { protected int a , b , c , d ; // Seiten innerhalb der Vererbungshierarchie sichtbar public Viereck ( int a , int b , int c , int d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; } public int umfang () { return this . a + this . b + this . c + this . d ; } public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . println ( \" Umfang des Vierecks : \" + this . umfang ()); } } Nun kann auf die Objektvariablen in allen abgeleiteten Klassen (also in Rechteck ) zugegriffen werden. Nicht aber in anderen Klassen. Man muss also von Viereck erben, um Zugriff auf die als protected deklarierten Variablen zu bekommen.","title":"Der Sichtbarkeitsmodifizierer protected"},{"location":"vererbung/#erweitern-der-klasse-rechteck-um-eine-weitere-eigenschaft","text":"Rechteck hat alle Eigenschaften von Viereck geerbt. Ganz am Anfang des Vererbungskapitels haben wir aber gesagt, dass speziellere Klassen auch speziellere Eigenschaften haben k\u00f6nnen. Wir wollen Rechteck nun eine weitere Eigenschaft hinzuf\u00fcgen: die Objektmethode flaecheninhalt() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Rechteck extends Viereck { public Rechteck ( int laenge , int breite ) { super ( laenge , breite , laenge , breite ); // Aufruf des Konstruktors von Viereck } /* * neue Objektmethode * spezielle Eigenschaft fuer Rechteck * gilt nicht f\u00fcr Viereck * */ public int flaecheninhalt () { return this . a * this . b ; // Zugriff moeglich wegen protected in Viereck } } Die Klasse Rechteck hat somit eine weitere Eigenschaft. Diese ist nicht von Viereck geerbt, sondern ist eine spezielle Eigenschaft von Rechteck . Die Klasse Viereck besitzt diese Eigenschaft nicht! Das bedeutet, dass f\u00fcr Objekte der Klasse Viereck existiert die Eigenschaft flaecheninhalt() nicht, f\u00fcr Objekte der Klasse Rechteck aber schon. In der Testklasse k\u00f6nnen wir die neue Methode testen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public void main () { System . out . printf ( \"%n%n------- Objekte von Viereck erzeugen ------------%n%n\" ); Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); System . out . printf ( \"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\" ); Rechteck r1 = new Rechteck ( 10 , 20 ); r1 . print (); System . out . println ( \"Umfang des Rechtecks : \" + r1 . umfang ()); System . out . println ( \"Flaecheninhalt des Rechtecks \" + r1 . flaecheninhalt ()); Rechteck r2 = new Rechteck ( 20 , 30 ); r2 . print (); System . out . println ( \"Umfang des Rechtecks : \" + r2 . umfang ()); System . out . println ( \"Flaecheninhalt des Rechtecks \" + r2 . flaecheninhalt ()); } und erhalten dann die Ausgaben (hier nur f\u00fcr Rechteck gezeigt): ------- Objekte von Rechteck erzeugen ------------ [ a = 10 , b = 20 , c = 10 , d = 20 ] Umfang des Vierecks : 60 Umfang des Rechtecks : 60 Flaecheninhalt des Rechtecks 200 [ a = 20 , b = 30 , c = 20 , d = 30 ] Umfang des Vierecks : 100 Umfang des Rechtecks : 100 Flaecheninhalt des Rechtecks 600 Beachten Sie, es ist nicht m\u00f6glich, die Objektmethode flaecheninhalt() f\u00fcr die Objekte von Viereck aufzurufen! F\u00fcr diese Objekte existiert die Eigenschaft nicht! 1 2 3 4 5 6 7 8 9 10 11 12 public void main () { System . out . printf ( \"%n%n------- Objekte von Viereck erzeugen ------------%n%n\" ); Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); // System.out.println(\"Flaecheninhalt des Vierecks \" + v1.flaecheninhalt()); // existiert nicht!!! Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); // System.out.println(\"Flaecheninhalt des Vierecks \" + v1.flaecheninhalt()); // existiert nicht!!! }","title":"Erweitern der Klasse Rechteck um eine weitere Eigenschaft"},{"location":"vererbung/#uberschreiben-von-methoden","text":"Die Klasse Rechteck hat unter anderem die Objektmethode print() von der Klasse Viereck geerbt. Wir k\u00f6nnen geerbte Methoden entweder so lassen, wie wir sie geerbt haben oder wir implementieren sie neu. Das Neuimplementieren von geerbten Methoden nennt sich \u00dcberschreiben . Wird eine Methode von der Elternklasse geerbt, diese Methode in der Kindklasse jedoch neu implementiert, so wird diese Methode \u00fcberschrieben . Die geerbte print() -Methode gef\u00e4llt uns nicht wirklich gut, denn erfolgt innerhalb der Methode die Ausschrift Umfang des Vierecks anstelle von Umfang des Rechtecks und k\u00f6nnten wir die print() -Methode in Rechteck um die Ausgabe des Fl\u00e4cheninhaltes des Rechteckes erweitern. Wir wollen deshalb diese Methode \u00fcberschreiben : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Rechteck extends Viereck { public Rechteck ( int laenge , int breite ) { super ( laenge , breite , laenge , breite ); // Aufruf des Konstruktors von Viereck } /* * neue Objektmethode * spezielle Eigenschaft fuer Rechteck * gilt nicht f\u00fcr Viereck * */ public int flaecheninhalt () { return this . a * this . b ; // Zugriff moeglich wegen protected in Viereck } @Override public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . print ( \" Umfang des Rechtecks : \" + this . umfang ()); System . out . println ( \" Flaecheninhalt des Rechtecks : \" + this . flaecheninhalt ()); } } In den Zeilen 20-26 haben wir nun die Methode print() neu implementiert, d.h. wir haben sie \u00fcberschrieben. Beachten Sie die sogenannte Annotation @Override , die direkt \u00fcber dem Methodenkopf steht. Mit dieser Annotation geben wir dem Compiler an, dass die folgende Methode \u00fcberschrieben wird. Der Compiler pr\u00fcft nun, ob wir die Methode \u00fcberhaupt so geerbt haben, wie wir sie \u00fcberschreiben, d.h. es wird \u00fcberpr\u00fcft, ob der Name der Methode korrekt ist (wir m\u00fcssen eine Methode geerbt haben, die genau so hei\u00dft - auch hier Gro\u00df- und Kleinschreibung beachten), die Anzahl und die Typreihenfolge der Parameter mit der geerbten Methode \u00fcbereinstimmen (die Namen der Parameter sind egal), der R\u00fcckgabetyp der Methode mit der geerbten Methode \u00fcbereinstimmt (der kann innerhalb der Vererbungshierarchie ge\u00e4ndert werden, aber das ist ein sp\u00e4teres Thema), die Sichtbarkeit nicht eingeschr\u00e4nkt wird (eine Methode, die in der Elternklasse als public deklariert wurde, darf beim \u00dcberschreiben nicht protected oder private werden). Wir m\u00fcssen in der Testklasse nun gar nichts \u00e4ndern, es wird f\u00fcr die Rechteck-Objekte die neue Implementierung der print() -Methode verwendet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void main () { System . out . printf ( \"%n%n------- Objekte von Viereck erzeugen ------------%n%n\" ); Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); System . out . printf ( \"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\" ); Rechteck r1 = new Rechteck ( 10 , 20 ); r1 . print (); Rechteck r2 = new Rechteck ( 20 , 30 ); r2 . print (); } erzeugt folgende Ausgaben: ------- Objekte von Viereck erzeugen ------------ [ a = 10 , b = 20 , c = 30 , d = 40 ] Umfang des Vierecks : 100 [ a = 15 , b = 20 , c = 25 , d = 20 ] Umfang des Vierecks : 80 ------- Objekte von Rechteck erzeugen ------------ [ a = 10 , b = 20 , c = 10 , d = 20 ] Umfang des Rechtecks : 60 Flaecheninhalt des Rechtecks : 200 [ a = 20 , b = 30 , c = 20 , d = 30 ] Umfang des Rechtecks : 100 Flaecheninhalt des Rechtecks : 600 Wir werden das \u00dcberschreiben von Methoden noch weiter \u00fcben, wenn wir uns mit der Klasse Object besch\u00e4ftigen. Wir merken uns zun\u00e4chst, dass wir geerbte Methoden \u00fcberschreiben k\u00f6nnen und dass wir die Annotation @Override verwenden sollten, wenn wir eine Methode \u00fcberschreiben, um zu vermeiden, dass wir - z.B. weil wir den Namen der Methode falsch schreiben - die Methode gar nicht \u00fcberschreiben, sondern eine neue Methode hinzuf\u00fcgen. \u00dcbrigens : Wir kennen das Schl\u00fcsselwort final ja bereits von Variablen. Eine als final deklarierte Variable kann ihren einmal zugewiesenen Wert nicht mehr \u00e4ndern. Wir haben mit final sogenannte Konstanten definiert. Eine als final deklarierte Methode kann nicht \u00fcberschrieben werden! Von einer als final deklarierten Klasse kann nicht geerbt werden!","title":"\u00dcberschreiben von Methoden"},{"location":"vererbung/#die-klasse-quadrat","text":"Das folgende Beispiel dient nur zur Wiederholung. Wir erben nun eine Klasse Quadrat von der Klasse Rechteck . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Quadrat extends Rechteck { Quadrat ( int seite ) { super ( seite , seite ); // Aufruf des Konstruktors von Rechteck } @Override public void print () { System . out . print ( \"[ a=\" + this . a + \", b=\" + this . b + \", c=\" + this . c + \", d=\" + this . d + \" ] \" ); System . out . print ( \" Umfang des Quadrats : \" + this . umfang ()); System . out . println ( \" Flaecheninhalt des Quadrats : \" + this . flaecheninhalt ()); } } In Zeile 1 geben wir mithilfe von extends Rechteck an, dass die Klasse Quadrat von der Klasse Rechteck erbt. In den Zeilen 3-6 definieren wir den Konstruktor von Quadrat . Darin rufen wir als erstes den Konstruktor von Rechteck auf. Der Konstruktor von Quadrat erwartet nur noch eine Parameter, da im Quadrat alle Seiten gleich lang sind. Den Wert des Parameters \u00fcbergeben wir dem Konstruktor von Rechteck , der zwei Parameterwerte erwartet (f\u00fcr laenge und breite ). In den Zeilen 8-15 \u00fcberschreiben wir wieder die print() -Methode und passen sie an das Quadrat an. Beachten Sie, dass Quadrat alle Eigenschaften von Rechteck erbt, also die Objektvariablen a , b , c , d und die Objektmethoden print() , umfang() und flaecheninhalt() . Die Testklasse k\u00f6nnten wir nun wie folgt erweiteren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public void main () { System . out . printf ( \"%n%n------- Objekte von Viereck erzeugen ------------%n%n\" ); Viereck v1 = new Viereck ( 10 , 20 , 30 , 40 ); v1 . print (); Viereck v2 = new Viereck ( 15 , 20 , 25 , 20 ); v2 . print (); System . out . printf ( \"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\" ); Rechteck r1 = new Rechteck ( 10 , 20 ); r1 . print (); Rechteck r2 = new Rechteck ( 20 , 30 ); r2 . print (); System . out . printf ( \"%n%n------- Objekte von Quadrat erzeugen ------------%n%n\" ); Quadrat q1 = new Quadrat ( 30 ); q1 . print (); Quadrat q2 = new Quadrat ( 40 ); q2 . print (); } und bek\u00e4men folgende Ausgaben: ------- Objekte von Viereck erzeugen ------------ [ a = 10 , b = 20 , c = 30 , d = 40 ] Umfang des Vierecks : 100 [ a = 15 , b = 20 , c = 25 , d = 20 ] Umfang des Vierecks : 80 ------- Objekte von Rechteck erzeugen ------------ [ a = 10 , b = 20 , c = 10 , d = 20 ] Umfang des Rechtecks : 60 Flaecheninhalt des Rechtecks : 200 [ a = 20 , b = 30 , c = 20 , d = 30 ] Umfang des Rechtecks : 100 Flaecheninhalt des Rechtecks : 600 ------- Objekte von Quadrat erzeugen ------------ [ a = 30 , b = 30 , c = 30 , d = 30 ] Umfang des Quadrats : 120 Flaecheninhalt des Quadrats : 900 [ a = 40 , b = 40 , c = 40 , d = 40 ] Umfang des Quadrats : 160 Flaecheninhalt des Quadrats : 1600 Success Mit Vererbung haben wir ein wichtiges Konzept der objektorientierten Programmierung kennengelernt. Um von einer Klasse zu erben, verwenden wir das Schl\u00fcsselwort extends . Eine Kindklasse erbt von ihrer Elternklasse alle Eigenschaften, also alle Objektvariablen und Objektmethoden. Eine geerbte Methode kann in der Kindklasse \u00fcberschrieben werden. Wird eine Methode \u00fcberschrieben, verwenden wir die Annotation @Override . Im Konstruktor der Kindklasse wird der Konstruktor der Elternklasse aufgerufen. Dies kann implizit erfolgen, wenn der implizite Konstruktor der Elternklasse existiert, oder es erfolgt explizit durch die Verwendung des Schl\u00fcsselwortes super . Mithilfe von Vererbung erh\u00f6hen wir die Wiederverwendbarkeit von Code und vermeiden doppelte Implementierungen. Au\u00dferdem sorgen wir f\u00fcr eine bessere Strukturierung des Codes.","title":"Die Klasse Quadrat"}]}