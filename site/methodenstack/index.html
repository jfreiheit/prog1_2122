
<!doctype html>
<html lang="de" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Lehrmaterial, Übungen, Aufgaben und Hilfen für Programmieren I">
      
      
      
        <meta name="author" content="Jörn Freiheit">
      
      
        <link rel="canonical" href="http://freiheit.f4.htw-berlin.de/prog1/methodenstack/">
      
      <link rel="icon" href="../img/favicon.png">
      <meta name="generator" content="mkdocs-1.2.2, mkdocs-material-7.2.6">
    
    
      
        <title>Methodenstack - Programmieren I</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.802231af.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.3f5d1f46.min.css">
        
          
          
          <meta name="theme-color" content="#757575">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="../extra.css">
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="grey" data-md-color-accent="indigo">
  
    
    <script>function __prefix(e){return new URL("..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#methodenstack" class="md-skip">
          Zum Inhalt
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Programmieren I" class="md-header__button md-logo" aria-label="Programmieren I" data-md-component="logo">
      
  <img src="../img/fiw.jpg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Programmieren I
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Methodenstack
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Suche" placeholder="Suche" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Suche">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Zurücksetzen" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Suche wird initialisiert
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/jfreiheit/prog1/" title="Quellcode" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    prog1
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Programmieren I" class="md-nav__button md-logo" aria-label="Programmieren I" data-md-component="logo">
      
  <img src="../img/fiw.jpg" alt="logo">

    </a>
    Programmieren I
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/jfreiheit/prog1/" title="Quellcode" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    prog1
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../start/" class="md-nav__link">
        Start
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../bluej/" class="md-nav__link">
        BlueJ
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../variablen/" class="md-nav__link">
        Variablen
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../ausdruecke/" class="md-nav__link">
        Ausdrücke
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../methoden/" class="md-nav__link">
        Methoden
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../selektion/" class="md-nav__link">
        Selektion
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../iteration/" class="md-nav__link">
        Iteration
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../objekte/" class="md-nav__link">
        Klassen und Objekte
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Methodenstack
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Methodenstack
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Inhaltsverzeichnis">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Inhaltsverzeichnis
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#abarbeitung-von-methoden" class="md-nav__link">
    Abarbeitung von Methoden
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lebensdauer-und-sichtbarkeit-von-lokalen-variablen" class="md-nav__link">
    Lebensdauer und Sichtbarkeit von lokalen Variablen
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#werte-vs-referenztypen" class="md-nav__link">
    Werte- vs. Referenztypen
  </a>
  
    <nav class="md-nav" aria-label="Werte- vs. Referenztypen">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arrays-sind-auch-objekte" class="md-nav__link">
    Arrays sind (auch) Objekte!
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#das-leben-der-objekte" class="md-nav__link">
    Das "Leben" der Objekte
  </a>
  
    <nav class="md-nav" aria-label="Das "Leben" der Objekte">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#der-null-wert" class="md-nav__link">
    Der null-Wert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#referenzvergleiche-mit" class="md-nav__link">
    Referenzvergleiche mit ==
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../vererbung/" class="md-nav__link">
        Vererbung
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../object/" class="md-nav__link">
        Object
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../ide/" class="md-nav__link">
        IDE (Eclipse)
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../arrays/" class="md-nav__link">
        Arrays
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../sortieren/" class="md-nav__link">
        Sortieren
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../uebungen/" class="md-nav__link">
        Übungen
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../aufgaben/" class="md-nav__link">
        Aufgaben
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../tools/" class="md-nav__link">
        Werkzeuge
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../hilfsklassen/" class="md-nav__link">
        Hilfsklassen
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Inhaltsverzeichnis">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Inhaltsverzeichnis
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#abarbeitung-von-methoden" class="md-nav__link">
    Abarbeitung von Methoden
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lebensdauer-und-sichtbarkeit-von-lokalen-variablen" class="md-nav__link">
    Lebensdauer und Sichtbarkeit von lokalen Variablen
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#werte-vs-referenztypen" class="md-nav__link">
    Werte- vs. Referenztypen
  </a>
  
    <nav class="md-nav" aria-label="Werte- vs. Referenztypen">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arrays-sind-auch-objekte" class="md-nav__link">
    Arrays sind (auch) Objekte!
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#das-leben-der-objekte" class="md-nav__link">
    Das "Leben" der Objekte
  </a>
  
    <nav class="md-nav" aria-label="Das "Leben" der Objekte">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#der-null-wert" class="md-nav__link">
    Der null-Wert
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#referenzvergleiche-mit" class="md-nav__link">
    Referenzvergleiche mit ==
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/jfreiheit/prog1/edit/master/docs/methodenstack.md" title="Seite editieren" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="methodenstack">Methodenstack<a class="headerlink" href="#methodenstack" title="Permanent link">&para;</a></h1>
<p>Programme und die dazugehörigen Variablen (und deren Werte) befinden sich zur Ausführung im Arbeitsspeicher. Der Speicher ist in Blöcke (Bytes) unterteilt, die jeweils adressierbar sind. So könnte alles jeweils eine Adresse zugeordnet werden und mit einer komplexen Adressverwaltung ließen sich die Einzelteile ansprechen. Das ist jedoch viel zu aufwendig und inperformant. Deshalb werden Speichermodelle verwendet, die die Verwaltung der Programmteile erleichtern. Ein solches Speichermodell ist der <em>Stack</em> (<em>Stapelspeicher</em>). </p>
<p>Bei einem Stack gilt das <em>Last in first out (LIFO)</em> Prinzip, also das, was zuletzt in den Stack kam, muss auch als erstes wieder hinaus. tatsächlich gibt es nur ganz wenige Funktionalitäten, um einen solchen Stack zu verwalten: </p>
<ul>
<li><code>push</code>: Element oben auf den Stack hinzufügen </li>
<li><code>pop</code>: Element von oben aus dem Stack entfernen</li>
<li><code>top</code> (manchmal auch <code>peek</code> genannt): auf oberes Element zugreifen (lesen, aber im Stack belassen)</li>
</ul>
<p>Folgende Abbildung stellt diese Methoden grafisch dar:</p>
<p><img alt="stack" src="../files/19_stack.png" /></p>
<p>Für einen solchen Stack gibt es jetzt nur drei Möglichkeiten:</p>
<ul>
<li>Element <code>E</code> kann gelesen werden (aber im Stack belassen) - <code>top</code></li>
<li>Element <code>E</code>kann aus dem Stack entfernt werden - <code>pop</code></li>
<li>ein neues Element (z.B. <code>F</code>) kann zum Stack hinzugefügt werden - <code>push</code> (dann kann auch <code>E</code> nicht mehr gelesen werden; so wie bereits <code>A</code>-<code>D</code>)</li>
</ul>
<h2 id="abarbeitung-von-methoden">Abarbeitung von Methoden<a class="headerlink" href="#abarbeitung-von-methoden" title="Permanent link">&para;</a></h2>
<p>Wir betrachten das Speichermodell <em>Stack</em>, weil die Abarbeitung von Methoden nach diesem Prinzip funktioniert. Methoden, die abgearbeitet (aufgerufen) werden, werden in einem solchen Stack angeordnet. Wir betrachten ein Beispiel:</p>
<div class="tabbed-set" data-tabs="1:1"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><label for="__tabbed_1_1">Methodenstack.java</label><div class="tabbed-content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Methodenstack</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">a</span><span class="p">(</span><span class="kt">int</span> <span class="n">vaa</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">vab</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;+--a()   --&gt; vaa  = &quot;</span> <span class="o">+</span> <span class="n">vaa</span> <span class="o">+</span> <span class="s">&quot; vab  = &quot;</span> <span class="o">+</span> <span class="n">vab</span><span class="p">);</span>
        <span class="n">b</span><span class="p">(</span><span class="n">vaa</span><span class="p">,</span> <span class="n">vab</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">b</span><span class="p">(</span><span class="kt">int</span> <span class="n">vba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vbb</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;+----b() --&gt; vba = &quot;</span> <span class="o">+</span> <span class="n">vba</span> <span class="o">+</span> <span class="s">&quot; vbb = &quot;</span> <span class="o">+</span> <span class="n">vbb</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">va</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">va</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="n">va</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;start()  --&gt; va  = &quot;</span> <span class="o">+</span> <span class="n">va</span><span class="p">);</span>
            <span class="n">a</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</td></tr></table>
</div>
</div>
<p>In diesem Beispiel gibt es drei Methoden: </p>
<ul>
<li>die <code>start()</code>-Methode mit der Variablen <code>va</code>,</li>
<li>die <code>a()</code>-Methode mit den Variablen <code>vaa</code> und <code>vab</code> und </li>
<li>die <code>b()</code>-Methode mit den Variablen <code>vba</code> und <code>vbb</code>.</li>
</ul>
<p>Die <code>start()</code>-Methode ruft die Methode <code>a()</code> auf und die <code>a()</code>-Methode ruft die <code>b()</code>-Methode auf. </p>
<p>Die Ausgabe des Programms ist wie folgt:</p>
<div class="highlight"><pre><span></span><code>start<span class="o">()</span>  --&gt; <span class="nv">va</span>  <span class="o">=</span> <span class="m">0</span>
+--a<span class="o">()</span>   --&gt; <span class="nv">vaa</span> <span class="o">=</span> <span class="m">0</span> <span class="nv">vab</span> <span class="o">=</span> <span class="m">1</span>
+----b<span class="o">()</span> --&gt; <span class="nv">vba</span> <span class="o">=</span> <span class="m">0</span> <span class="nv">vbb</span> <span class="o">=</span> <span class="m">1</span>

start<span class="o">()</span>  --&gt; <span class="nv">va</span>  <span class="o">=</span> <span class="m">1</span>
+--a<span class="o">()</span>   --&gt; <span class="nv">vaa</span> <span class="o">=</span> <span class="m">1</span> <span class="nv">vab</span> <span class="o">=</span> <span class="m">1</span>
+----b<span class="o">()</span> --&gt; <span class="nv">vba</span> <span class="o">=</span> <span class="m">1</span> <span class="nv">vbb</span> <span class="o">=</span> <span class="m">1</span>

start<span class="o">()</span>  --&gt; <span class="nv">va</span>  <span class="o">=</span> <span class="m">2</span>
+--a<span class="o">()</span>   --&gt; <span class="nv">vaa</span> <span class="o">=</span> <span class="m">2</span> <span class="nv">vab</span> <span class="o">=</span> <span class="m">1</span>
+----b<span class="o">()</span> --&gt; <span class="nv">vba</span> <span class="o">=</span> <span class="m">2</span> <span class="nv">vbb</span> <span class="o">=</span> <span class="m">1</span>
</code></pre></div>
<p>Die <code>start()</code>-Methode ruft also drei Mal (innerhalb der Schleife) die <code>a()</code>-Methode auf, welche wiederum die <code>b()</code>-Methode aufruft. </p>
<p>Bei dem Aufruf von Methoden passiert folgendes:</p>
<ul>
<li>bei jedem Methodenaufruf wird eine <strong>Methodeninstanz</strong> auf den Stack gelegt</li>
<li>eine <strong>Methodeninstanz</strong> sind alle zur Laufzeit veränderlichen Daten, die zur Methode gehören (Parameter und lokale Variablen)</li>
<li>nach Abarbeitung der Methode (oft durch <code>return</code> - muss aber nicht, wie in unserem Beispiel) wird die Methodeninstanz wieder aus dem Stack entfernt (und somit auch alle dazu gehörenden Daten (Parameter, lokale Variablen und deren Werte))</li>
</ul>
<p>In unserem Beispiel passiert also folgendes:</p>
<p><img alt="stack" src="../files/20_stack.png" />
<img alt="stack" src="../files/21_stack.png" />
<img alt="stack" src="../files/22_stack.png" /></p>
<ol>
<li>Die <code>start()</code>-Methode wird ausgeführt; die Variable <code>va</code> wird <strong>erzeugt</strong> und bekommt den Wert <code>0</code>. Die <code>start()</code>-Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode <code>a()</code> auf.</li>
<li>Die <code>a()</code>-Methode wird ausgeführt; die Variablen <code>vaa</code> und <code>vab</code> werden <strong>erzeugt</strong> und bekommen die Werte <code>0</code>und <code>1</code>. In der <code>a()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Die <code>a()</code>-Methode ruft die Methode <code>b()</code> auf. </li>
<li>Die <code>b()</code>-Methode wird ausgeführt; die Variablen <code>vba</code> und <code>vbb</code> werden <strong>erzeugt</strong> und bekommen die Werte <code>0</code>und <code>1</code>. In der <code>b()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausführung der <code>b()</code>-Methode zu Ende. Alles, was mit der <code>b()</code>-Methode zu tun hat, insb. die Variablen <code>vba</code> und <code>vbb</code> werden aus dem Speicher <strong>gelöscht</strong>.  </li>
<li>Zurück zur Ausführung von <code>a()</code>. Keine weitere Anweisung - die Ausführung der <code>a()</code>-Methode zu Ende. Alles, was mit der <code>a()</code>-Methode zu tun hat, insb. die Variablen <code>vaa</code> und <code>vab</code> werden aus dem Speicher <strong>gelöscht</strong>.  </li>
<li>Zurück zur Ausführung von <code>start()</code>. Die Variable <code>va</code> bekommt innerhalb der Schleife den neuen Wert <code>1</code>. </li>
<li>Die Variable <code>va</code> hat nun den Wert <code>1</code>. Die <code>start()</code>-Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode <code>a()</code> auf.</li>
<li>Die <code>a()</code>-Methode wird ausgeführt; die Variablen <code>vaa</code> und <code>vab</code> werden <strong>erzeugt</strong> und bekommen die Werte <code>1</code>und <code>1</code>. In der <code>a()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Die <code>a()</code>-Methode ruft die Methode <code>b()</code> auf. </li>
<li>Die <code>b()</code>-Methode wird ausgeführt; die Variablen <code>vba</code> und <code>vbb</code> werden <strong>erzeugt</strong> und bekommen die Werte <code>1</code>und <code>1</code>. In der <code>b()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausführung der <code>b()</code>-Methode zu Ende. Alles, was mit der <code>b()</code>-Methode zu tun hat, insb. die Variablen <code>vba</code> und <code>vbb</code> werden aus dem Speicher <strong>gelöscht</strong>.  </li>
<li>Zurück zur Ausführung von <code>a()</code>. Keine weitere Anweisung - die Ausführung der <code>a()</code>-Methode zu Ende. Alles, was mit der <code>a()</code>-Methode zu tun hat, insb. die Variablen <code>vaa</code> und <code>vab</code> werden aus dem Speicher <strong>gelöscht</strong>.  </li>
<li>Zurück zur Ausführung von <code>start()</code>. Die Variable <code>va</code> bekommt innerhalb der Schleife den neuen Wert <code>2</code>. </li>
<li>Die Variable <code>va</code> hat nun den Wert <code>2</code>. Die <code>start()</code>-Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode <code>a()</code> auf.</li>
<li>Die <code>a()</code>-Methode wird ausgeführt; die Variablen <code>vaa</code> und <code>vab</code> werden <strong>erzeugt</strong> und bekommen die Werte <code>2</code>und <code>1</code>. In der <code>a()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Die <code>a()</code>-Methode ruft die Methode <code>b()</code> auf. </li>
<li>Die <code>b()</code>-Methode wird ausgeführt; die Variablen <code>vba</code> und <code>vbb</code> werden <strong>erzeugt</strong> und bekommen die Werte <code>2</code>und <code>1</code>. In der <code>b()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausführung der <code>b()</code>-Methode zu Ende. Alles, was mit der <code>b()</code>-Methode zu tun hat, insb. die Variablen <code>vba</code> und <code>vbb</code> werden aus dem Speicher <strong>gelöscht</strong>.  </li>
<li>Zurück zur Ausführung von <code>a()</code>. Keine weitere Anweisung - die Ausführung der <code>a()</code>-Methode zu Ende. Alles, was mit der <code>a()</code>-Methode zu tun hat, insb. die Variablen <code>vaa</code> und <code>vab</code> werden aus dem Speicher <strong>gelöscht</strong>.  </li>
<li>Zurück zur Ausführung von <code>start()</code>. Die Variable <code>va</code> bekommt innerhalb der Schleife den neuen Wert <code>3</code>. Die Bedingung der Schleife <code>va&lt;3</code> ist somit <code>false</code>. Die Schleife wird verlassen, keine weitere Anweisung in <code>start()</code>. Die Abarbeitung des Programms ist zu Ende. Alles, was mit der <code>start()</code>-Methode zu tun hat, insb. Variable <code>va</code> wird aus dem Speicher gelöscht. </li>
</ol>
<h2 id="lebensdauer-und-sichtbarkeit-von-lokalen-variablen">Lebensdauer und Sichtbarkeit von lokalen Variablen<a class="headerlink" href="#lebensdauer-und-sichtbarkeit-von-lokalen-variablen" title="Permanent link">&para;</a></h2>
<p>Die Variablen, die wir bis jetzt verwendet haben, wurden in Methoden deklariert oder in Anweisungsblöcken, die in Methoden liegen (z.B. in <code>for</code>-Schleifen). Bei solchen Variablen sprechen wir von <em>lokalen</em> Variablen. Wir werden später noch <em>globale</em> Variablen kennenlernen. Zunächst interessieren uns aber nur die <em>lokalen</em> Variablen. Das obige Beispiel zeigt, dass <em>lokale</em> Variablen, also solche, die in Methoden deklariert werden, nur so lange <strong>existieren</strong>, wie diese Methode ausgeführt wird. Generell gilt:</p>
<blockquote>
<p>Eine Variable <strong>existiert</strong> in dem Anweisungsblock, in dem sie deklariert wurde, solange dieser Anweisungsblock <strong>ausgeführt</strong> wird. </p>
</blockquote>
<p>Schauen wir uns dazu die Situationen in dem oberen Beispiel an:</p>
<ul>
<li>Die Variable <code>va</code> wird in der <code>start()</code>-Methode deklariert. Die <code>start()</code>-Methode wird die ganze Zeit ausgeführt. Also existiert auch die Variable <code>va</code> die gesamte Zeit des Programmablaufs. </li>
<li>Die Variablen <code>vaa</code> und <code>vab</code> werden in der <code>a()</code>-Methode deklariert. Sie existieren immer nur dann, wenn die <code>a()</code>-Methode ausgeführt wird. In unserem Beispiel existieren die Variablen <code>vaa</code> und <code>vab</code> also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollständig gelöscht). Da die Methode <code>a()</code> die Methode <code>b()</code> aufruft, existieren die Variablen <code>vaa</code> und <code>vab</code> auch während der Ausführung von <code>b()</code>, da zur Zeit der Ausführung von <code>b()</code> ja auch <code>a()</code> ausgeführt wird (und <code>start()</code>).</li>
<li>Die Variablen <code>vba</code> und <code>vbb</code> werden in der <code>b()</code>-Methode deklariert. Sie existieren immer nur dann, wenn die <code>b()</code>-Methode ausgeführt wird. In unserem Beispiel existieren die Variablen <code>vba</code> und <code>vbb</code> also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollständig gelöscht). </li>
</ul>
<p>Die Lebensdauer eine Variable wird somit von der Ausführungsdauer des Anweisungsblockes bestimmt, in dem die Variable deklariert wurde. </p>
<div class="admonition note">
<p class="admonition-title">Lebensdauer</p>
<p>Es ist eine gängige Praxis, alle Variablen, die man in einer Methode verwenden möchte, am Anfang der Methode zu deklarieren. Erstens sieht man dann, welche Variablen innerhalb der Methode alle verwendet werden und zweitens kann man diese Variablen in allen Anweisungsblöcken innerhalb der Methode verwenden. Einzige Ausnahme stellen Laufvariablen der <code>for</code>-Schleifen dar. Diese werden häufig direkt in der <code>for</code>-Schleife deklariert (<code>for(int i=0, i&lt;10; i++){}</code>). Sie existieren dann aber auch nur in dieser <code>for</code>-Schleife! Außerhalb der <code>for</code>-Schleife existiert diese Variable dann nicht (mehr)! Das bedeutet auch, dass wenn Sie diese Variable in einer anderen <code>for</code>-Schleife verwenden wollen, müssen Sie sie dort erneut deklarieren. </p>
</div>
<p>Unter <em>Sichtbarkeit</em> einer Variablen versteht man die Möglichkeit, auf diese Variable zuzugreifen (also ihr entweder einen neuen Wert zuzuweisen oder ihren Wert auszulesen). Generell gilt:</p>
<blockquote>
<p>Eine lokale Variable ist in dem Anweisungsblock sichtbar, in dem sie deklariert wird und in allen Anweisungsblöcken, die sich in diesem Anweisungsblock befinden. Außerhalb des Anweisungsblockes, in dem die Variable deklariert wurde, ist die Variable nicht sichtbar. </p>
</blockquote>
<p>Das heißt für unser Beispiel, dass die Variable <code>va</code> nur in der <code>start()</code>-Methode sichtbar ist (also nur dort auf sie zugegriffen werden kann/sie nur dort verwendet werden kann), die Variablen <code>vaa</code> und <code>vab</code> nur in der <code>a()</code>-Methode verwendet werden können (sichtbar sind) und die Variablen <code>vba</code> und <code>vbb</code> nur in <code>b()</code>. </p>
<div class="admonition note">
<p class="admonition-title">Sichtbarkeit</p>
<p>Der Vorteil dieser <em>lokalen</em> Sichtbarkeit besteht darin, dass man sich z.B. keine Sorgen machen muss, ob eine gleichnamige Variable evtl. bereits in einer anderen Methode deklariert wurde. Eine Variable darf ja immer nur einmal deklariert werden. Da alle anderen Variablen aber nicht in der eigenen Methode sichtbar sind, gibt es keinerlei Konflikte mit anderen lokalen Variablen. Die lokalen Variablen aus anderen Methoden haben mit den Variablen aus der eigenen Methode gar nichts zu tun. Außerdem ist es auch nicht möglich, einfach Werte von Variablen aus anderen Methoden zu schreiben oder zu lesen. Das würde ansonsten große Sicherheitsprobleme mit sich bringen und man könnte Programme auch leicht zum Absturz bringen. </p>
</div>
<h2 id="werte-vs-referenztypen">Werte- vs. Referenztypen<a class="headerlink" href="#werte-vs-referenztypen" title="Permanent link">&para;</a></h2>
<p>Es ist ganz wichtig, zu verstehen, dass es ganz wesentliche Unterschiede zwischen Werte- und Referenztypen gibt. Einige der Unterschiede sind in der folgenden Tabelle aufgelistet:</p>
<table>
<thead>
<tr>
<th></th>
<th> Wertetypen</th>
<th> Referenztypen</th>
</tr>
</thead>
<tbody>
<tr>
<td>Beispiele</td>
<td> <code>int</code>, <code>double</code>, <code>boolean</code>, <code>char</code>, <code>long</code>, <code>float</code>, <code>byte</code>, <code>short</code></td>
<td> <code>String</code>, <code>Point</code>, <code>Triangle</code>, <code>Circle</code>, <code>Adresse</code>, <code>System</code>, ...</td>
</tr>
<tr>
<td> neue erzeugbar?</td>
<td> nein</td>
<td> ja - einfach eigene Klasse erstellen</td>
</tr>
<tr>
<td> Was ist der "Wert" einer Variablen?</td>
<td> ein Wert (<code>5</code>, <code>true</code>, <code>1.234</code>, <code>'a'</code>, ...)</td>
<td> die Referenz auf ein Objekt</td>
</tr>
<tr>
<td> Manipulation von Werten</td>
<td> mit Operatoren (<code>+</code>, <code>==</code>, <code>&amp;&amp;</code>, ...)</td>
<td> mit Methoden</td>
</tr>
<tr>
<td> <code>variable1 = variable2;</code></td>
<td> Kopie des <strong>Wertes</strong> (<code>variable1</code> hat den Wert und <code>variable2</code> hat den Wert)</td>
<td> Kopie der <strong>Referenz</strong> auf das Objekt (beide Variablen zeigen auf das gleiche Objekt)</td>
</tr>
</tbody>
</table>
<p>Insbesondere den letzten Punkt wollen wir uns genauer anschauen. Zunächst Wertetypen. Angenommen, wir haben folgende Anweisungen:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div>
<p>Nach Abarbeitung dieser Anweisungen hat sowohl die Variable <code>a</code> den Wert <code>5</code> als auch die Variable <code>b</code>. Wenn wir nun <code>a=6;</code> setzen, dann hat <code>a</code> den Wert <code>6</code> und <code>b</code> immer noch den Wert <code>5</code>. </p>
<blockquote>
<p>Der Wert einer Variablen von einem Wertetyp kann sich nur durch den Zuweisungsoperator <code>=</code> ändern!</p>
</blockquote>
<p>Folgende Abbildung zeigt die Verwaltung der beiden <code>int</code>-Variablen <code>a</code> und <code>b</code> im Speicher:</p>
<p><img alt="wertetyp" src="../files/74_wertetyp.png" /></p>
<p>Die Zahlen in den Kästchen unter <code>a</code> und <code>b</code> stehen für Speicheradressen. Das Gute an Java ist, dass wir uns um solche Adressen nicht kümmern müssen. Wir greifen auf die Werte von <code>a</code> und <code>b</code> einfach über die Variablennamen <code>a</code> und <code>b</code> zu. Die Speicherdressen interessieren uns dabei (zum Glück) gar nicht. Wichtig ist, dass jede Variable <strong>ihren eigenen Wert</strong> hat. Wenn wir den Wert von <code>a</code> ändern, ändert sich nur der Wert von <code>a</code>, wenn wir den Wert von <code>b</code> ändern, ändert sich nur der Wert von <code>b</code>. Dabei ist ganz egal, ob <code>b</code> den Wert <code>5</code> durch die Wertzuweisung <code>b=5;</code> erhalten hat oder durch <code>b=a;</code>, wobei <code>a</code> den Wert <code>5</code> hatte. </p>
<p>Anders ist es bei Referenzvariablen, also bei Variablen, die von einem Referenztyp sind. Nehmen wir z.B. unsere Klasse <code>Point</code> und führen folgende Anweisungen aus:</p>
<div class="highlight"><pre><span></span><code><span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="n">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
</code></pre></div>
<p>Hier gibt es <strong>genau ein</strong> Objekt, nämlich das Objekt, in dem die Objektvariablen <code>x</code> und <code>y</code> den Wert <code>3</code> bzw. <code>4</code> haben. Die beiden Variablen <code>p1</code> und <code>p2</code> referenzieren <strong>das gleiche</strong> Objekt, d.h. sie zeigen darauf. Die folgende Abbildung verdeutlicht diesen Fall:</p>
<p><img alt="referenztyp" src="../files/75_referenztyp.png" /></p>
<p>Beide Variablen <code>p1</code> und <code>p2</code> zeigen auf <strong>dasselbe</strong> Objekt. Es gibt ja auch nur <strong>ein</strong> Objekt. Ein Objekt kann nur durch <code>new</code> und die Angabe des Konstruktors erzeugt werden. Das passiert hier genau einmal. Während also bei <code>int b = a;</code> eine <strong>Kopie des Wertes</strong> erfolgt, erfolgt bei <code>Point p2 = p1;</code> eine <strong>Kopie der Referenz</strong> (aber keine Kopie des Objektes!).</p>
<p>Wichtig ist jetzt noch zu wissen, dass wir auf die Objekteigenschaften des <code>Point</code>-Objektes sowohl über die Referenz <code>p1</code> als auch über die Referenz <code>p2</code> zugreifen können, d.h. dass z.B. <code>p1.print()</code> und <code>p2.print()</code> exakt die gleiche <code>print()</code>-Methode aufrufen, nämlich die des obigen <code>Point</code>-Objektes. Sowohl <code>p1.getX()</code> als auch <code>p2.getX()</code> geben <code>3</code> zurück, da sie den Wert <strong>derselben</strong> Objektvariablen <code>x</code> abfragen.</p>
<blockquote>
<p>Wenn mehrere Referenzen auf dasselbe Objekt existieren, ist es egal, über welche Referenz wir auf die Objekteigenschaften zugreifen; es handelt sich um genau <strong>ein</strong> Objekt (mit mehreren Referenzen darauf).</p>
</blockquote>
<p>Wir müssen nun also wissen, dass bei den folgenden Anweisungen </p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre></div>
<p>der Wert von <code>a</code> ausgegeben wird und der ist <code>5</code>, denn es gibt genau eine Wertzuweisung für <code>a</code> und das ist <code>a=5;</code>. Es spielt gar keine Rolle, ob <code>b</code> seinen Wert zwischendurch ändert oder nicht - bei der Anweisung <code>b = a;</code> ist der Wert <code>5</code> kopiert worden und der Wert von <code>a</code> ist danach völlig unabhängig von <code>b</code> und umgedreht. </p>
<p>Wir müssen nun auch wissen, dass bei den folgenden Anweisungen </p>
<div class="highlight"><pre><span></span><code><span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="n">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
<span class="n">p2</span><span class="p">.</span><span class="na">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="na">getX</span><span class="p">());</span>
</code></pre></div>
<p>der Wert der Objektvariablen <code>x</code> des <strong>einen</strong> Objektes ausgegeben wird, das existiert. Durch die <code>translate()</code>-Methode ist der <code>x</code>-Wert des Objektes nun <code>4</code> (und der <code>y</code>-Wert ist <code>6</code>). Das heißt, es wird eine <code>4</code> ausgegeben. Dabei ist völlig egal, ob die <code>translate()</code>-Methode über die Referenz <code>p1</code> oder über die Referenz <code>p2</code> aufgerufen wird und es ist auch völlig egal, ob die <code>print()</code>-Methode über die Referenz <code>p1</code> oder über die Referenz <code>p2</code> aufgerufen wird. Beide referenzieren dasselbe Objekt.</p>
<h3 id="arrays-sind-auch-objekte">Arrays sind (auch) Objekte!<a class="headerlink" href="#arrays-sind-auch-objekte" title="Permanent link">&para;</a></h3>
<p>Schauen wir uns folgenden Fall an:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a1</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a1</span><span class="p">;</span>
<span class="n">a2</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">a1</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">);</span>
</code></pre></div>
<p>Arrays sind (auch) Objekte. Also haben wir hier den gleichen Fall, wie bene bei <code>Point</code>. Auch referenzieren sowohl <code>a1</code> als auch <code>a2</code> <strong>dasselbe</strong> Array (es gibt ja nur eins). Wenn wir also über die Referenz <code>a2</code> den zweiten Wert im Array auf <code>5</code> setzen und wir danach über die Referenz <code>a1</code> den zweiten Wert dieses Array auslesen, dann ist er <code>5</code>.</p>
<p>Sie werden sich jetzt sicherlich fragen, warum wir uns überhaupt Kopien der Referenzen machen - das ist doch nur verwirrend. Die Antwort ist, dass dieser Fall sogar sehr oft vorkommt, nämlich immer genau dann, wenn wir Referenzen von Objekten als Parameter übergeben. Schauen wir uns folgendes Beispiel an:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">index1</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index1</span><span class="o">&lt;</span><span class="n">arr</span><span class="p">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">index2</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index2</span><span class="o">&lt;</span><span class="n">arr</span><span class="p">.</span><span class="na">length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">index1</span><span class="o">]</span><span class="p">;</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">index1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">index2</span><span class="o">]</span><span class="p">;</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">index2</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</td></tr></table>
<p>Diese Methode implementiert das Vertauschen zweier Elemente in einem <code>int</code>-Array. So, wie wir es z.B. in vielen Sortieralgorithmen benötigen. Die Werte der Elemente an den Indizes <code>index1</code> und <code>index2</code> werden miteinander getauscht. Wir speichern den einen Wert zwischen, damit wir ihn nicht überschreiben. Es wird vorab geprüft, ob die beiden Indizes <code>index1</code> und <code>index2</code> überhaupt im Array <code>arr</code> existieren. </p>
<p>Angenommen, wir haben nun in der <code>start()</code>-Methode (oder einer anderen Methode) folgende Anweisungen</p>
<p><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a1</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
<span class="n">swap</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>         <span class="c1">// Uebergabe der Referenz auf das Array</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">a1</span><span class="p">.</span><span class="na">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">a1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</td></tr></table>
, dann ist die Ausgabe </p>
<div class="highlight"><pre><span></span><code><span class="m">2</span> <span class="m">1</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span>
</code></pre></div>
<p>Wir übergeben bei Aufruf der Methode <code>swap(a1, 0, 1);</code> die Referenz auf das Array und in der Methode wird die lokale Variable <code>arr</code> mit genau dieser Referenz initialisiert, d.h. es existieren dann zwei Referenzen auf das Array! Die Referenz <code>arr</code> innnerhalb der <code>swap()</code>-Methode und die Referenz <code>a1</code> innerhalb der <code>start()</code>-Methode. Zwei Referenzen, aber nur ein Objekt!</p>
<p>Lösen Sie die folgenden Übungsaufgaben durch Überlegen!</p>
<details><summary>Was wird ausgegeben? (start() wird ausgeführt)</summary><div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</details>
<details><summary>Was wird ausgegeben?</summary><div class="tabbed-set" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><label for="__tabbed_2_1">I.java</label><div class="tabbed-content">
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">I</span>
<span class="p">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">o</span><span class="p">;</span>

    <span class="kd">public</span> <span class="nf">I</span><span class="p">(</span><span class="kt">int</span> <span class="n">o</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">o</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getO</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="na">o</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add1</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">o</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>
<input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><label for="__tabbed_2_2">TestI.java</label><div class="tabbed-content">
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="p">(</span><span class="n">I</span> <span class="n">i2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">i2</span><span class="p">.</span><span class="na">add1</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">I</span> <span class="n">i1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">I</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">I</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">i1</span><span class="p">;</span>
    <span class="n">i2</span><span class="p">.</span><span class="na">add1</span><span class="p">();</span>
    <span class="n">I</span> <span class="n">i3</span> <span class="o">=</span> <span class="n">i1</span><span class="p">;</span>
    <span class="n">doSomething</span><span class="p">(</span><span class="n">i3</span><span class="p">);</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">i1</span><span class="p">.</span><span class="na">getO</span><span class="p">());</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">i2</span><span class="p">.</span><span class="na">getO</span><span class="p">());</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">i3</span><span class="p">.</span><span class="na">getO</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>
</div>
</div>
</details>
<h2 id="das-leben-der-objekte">Das "Leben" der Objekte<a class="headerlink" href="#das-leben-der-objekte" title="Permanent link">&para;</a></h2>
<p>Wir haben uns bereits eingehend mit der <a href="./#lebensdauer-und-sichtbarkeit-von-lokalen-variablen">Lebensdauer und der Sichtbarkeit</a> von <em>lokalen</em> Variablen beschäftigt. Es ist dabei übrigens gaz egal, ob es sich um Variablen von einem Werte- oder einem Referenztyp handelt. Auf die Lebensdauer und Sichtbarkeit hat das keinen Einfluss. </p>
<p>Wir wissen auch bereits, dass <em>Objektvariablen</em> für jeweils ein Objekt existieren. Die Lebensdauer einer Objektvariablen entspricht also der Lebensdauer ihres Objektes. Wir wissen auch über die Sichtbarkeit der Objektvariablen Bescheid, denn sie sind in der gesamten Klasse sichtbar, in der sie deklariert werden, also auch in allen Methoden dieser Klasse. Ob sie darüber hinaus auch über eine Referenz auf ein Objekt in anderen Klassen sichtbar sind, hängt vom Sichtbarkeitsmodifizierer ab. Normalerweise nicht, denn wir deklarieren alle Objektvariablen als <code>private</code>.</p>
<p>Wir wollen nun untersuchen, wie lange Objekte existieren. Wir wissen bereits, dass ihre Existenz mit der Anweisung <code>new</code> gefolgt vom Konstruktor beginnt. </p>
<p>Wir haben gelernt, dass Methoden in einem sogenannten <em>Stack</em> abgearbeitet werden und dass in diesem Stack auch die lokalen Variablen existieren - und zwar so lange, so lange die Methode abgearbeitet wird, also im Stack existiert. Sichtbar sind jedoch nur die lokalen Variablen, die zur Methode gehören, die im Stack ganz oben liegt, also <em>gerade</em> abgearbeitet wird. Objekte werden <strong>nicht</strong> im Stack abgelegt. Der Speicherbereich für Objekte nennt sich <em>Heap</em>. Wir wollen auf die Speicherstruktur des <em>Heap</em> gar nicht weiter eingehen, wichtig ist nur, dass bei Erzeugung eines Objektes Speicherplatz im <em>Heap</em> für das Objekt reserviert wird. Die Größe des reservierten Speicherplatzes bestimmt der Konstruktor und ist von den Objektvariablen des Objektes abhängig, also von der Größe und der Anzahl der Objektvariablen<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>. Die Objektvariablen existieren auf dem Heap. Lebt das Objekt nicht mehr, wird der Speicherplatz auf dem Heap (automatisch) freigegeben.</p>
<p>Wir wissen, wann Objekte anfangen, zu existieren (wenn sie erzeugt werden), aber wann hören Sie auf, zu existieren? Wir betrachten "das Leben" eines Objektes am Beispiel eines <code>Point</code>-Objektes:</p>
<ol>
<li>
<p>Objekt-Referenz deklarieren</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Damit ist bereits eine Referenz mit dem Namen <code>p1</code> auf ein <code>Point</code>-Objekt definiert. Das Objekt existiert aber noch gar nicht! Aber es sind schonmal 64Bit im Heap reserviert. </p>
<p>Die (Referenz-)Variable <code>p1</code> ist eine <em>lokale</em> Variable der Methode <code>start()</code>. <code>p1</code> ist nur in der <code>start()</code>-Methode sichtbar, sie existiert so lange, solange <code>start()</code> ausgeführt wird und sie existiert im <em>Stack</em>. </p>
</li>
<li>
<p>Objekt erzeugen</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Jetzt existiert ein <code>Point</code>-Objekt! Es wird im <em>Heap</em> abgelegt. Insbesondere werden die Objektvariablen <code>x</code> und <code>y</code> im Heap abgelegt und bekommen die Werte <code>3</code> und <code>4</code>. </p>
<p>Jetzt gibt es eine Referenzvariable <code>p1</code> im Stack und ein Objekt mit Objektvariablen im Heap. Durch den Zuweisungsoperator <code>=</code> werden die beiden miteinander verbunden, d.h <code>p1</code> <em>zeigt</em> jetzt auf das <code>Point</code>-Objekt. </p>
<p><img alt="referenztyp" src="../files/76_referenztyp.png" /></p>
<p>An dieser Stelle ist es schonmal sinnvoll zu betonen, dass die <strong>einzige</strong> Möglichkeit, auf das <code>Point</code>-Objekt zuzugreifen, derzeit über die <code>p1</code>-Variable existiert. Gäbe es diese Variable nicht, hätten wir keinen Zugriff auf das Objekt!</p>
</li>
<li>
<p>Ein weiteres Objekt und eine Referenz darauf erzeugen</p>
<p>Wir erzeugen zur Veranschaulichung ein weiteres Objekt und die Referenzvariable <code>p2</code>, die darauf zeigt.</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Jetzt existieren zwei <code>Point</code>-Objekte im Heap und zwei Referenzvariablen <code>p1</code> und <code>p2</code>, die jeweils auf eines der beiden Objekte zeigen. <code>p1</code> und <code>p2</code> sind lokale Variablen der <code>start()</code>-Methode und existieren im Stack. </p>
<p><img alt="referenztyp" src="../files/77_referenztyp.png" /></p>
<p>Beachten Sie, dass die beiden Objekte zwar Objektvariablen haben, die gleiche Werte aufweisen, aber es handelt sich um zwei (verschiedene) Objekte!</p>
</li>
<li>
<p>Eine weitere Referenz erzeugen</p>
<p>Jetzt erzeugen wir noch eine weitere Referenz auf das erste <code>Point</code>-Objekt. Wir nennen die Referenzvariable <code>p3</code>. </p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Diese Situation lässt sich so veranschaulichen:</p>
<p><img alt="referenztyp" src="../files/78_referenztyp.png" /></p>
<p>Auf das erste Objekt existieren also gleich zwei Referenzen. Über beide Referenzen kann mittels Punktnotation auf das Objekt (dessen Objekteigenschaften) zugegriffen werden. Es ist also egal, ob man <code>p1</code> oder <code>p3</code> schreibt, beide zeigen auf das gleiche Objekt. </p>
</li>
<li>
<p>Eine Referenz ändern</p>
<p>Wir ändern nun die soeben erstellte Referenz und lassen sie nun auf das zweite Objekt zeigen:</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>p3</code> darf natürlich nicht erneut deklariert werden. Wir kopieren die Referenz von <code>p2</code> nach <code>p3</code>. <code>p3</code> zeigt damit nun auf das zweite Objekt. </p>
<p><img alt="referenztyp" src="../files/79_referenztyp.png" /></p>
<p>Nun zeigen <code>p2</code> und <code>p3</code> auf dasselbe Objekt. Nun ist es also egal, ob man <code>p2</code> oder <code>p3</code> schreibt, beide zeigen auf dasselbe - das "zweite" - Objekt. Auf das "erste" Objekt zeigt nur noch <code>p1</code>. </p>
</li>
<li>
<p>Eine weitere Referenz ändern</p>
<p>Nun lassen wir auch noch <code>p1</code> auf das zweite Objekt zeigen. </p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>        <span class="c1">// exakt gleich zu p1 = p3;</span>
<span class="p">}</span>
</code></pre></div>
<p>Die nun entstandene Situation lässt sich wie folgt veranschaulichen:</p>
<p><img alt="referenztyp" src="../files/80_referenztyp.png" /></p>
<p>Der entscheidende Punkt ist nun der, dass es auf das erste Objekt <strong>keine Referenz</strong> mehr gibt. Damit ist das Objekt für uns verloren - wir haben <strong>keinen Zugriff</strong> mehr darauf!</p>
<p>Was passiert mit einem solchen Objekt? Es wird aus dem Speicher gelöscht. Dies erfolgt automatisch. Die Laufzeitumgebung erkennt solche Objekte, auf die keine Referenz mehr zeigt. Die sogenannte <em>Garbage Collection</em> gibt diesen Speicher wieder für die weitere Verwendung frei. In Java müssen wir uns - im Gegensatz zu anderen Programmiersprachen - nicht um die Speicherfreigabe kümmern. Das erfolgt im Hintergrund und ganz automatisch. </p>
</li>
</ol>
<p>Neben der Änderung einer Referenz kann eine Referenzvariable auch aufhören, zu existieren und damit ist ein Objekt ohne Referenz. Das folgende Beispiel zeigt einen solchen Fall:</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">createPoint</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">createPoint</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>In der <code>start()</code>-Methode wird die <code>createPoint()</code>-Methode aufgerufen. Darin wird eine Referenz <code>p</code> erzeugt und ein <code>Point</code>-Objekt. <code>p</code> zeigt auf dieses Objekt. Sobald die Methode abgearbeitet ist und verlassen wird, hört die lokale Variable <code>p</code> jedoch auf zu existieren. Sie wird aus dem Stack gelöscht. Somit ist das <code>Point</code>-Objekt im Heap ohne eine Referenz und muss von der <em>Garbage Collection</em> entsorgt werden. </p>
<details><summary>Erweitern Sie obiges Programm so, dass eine Referenz auf das <code>Point</code>-Objekt nicht verloren geht</summary></details>
<h3 id="der-null-wert">Der <code>null</code>-Wert<a class="headerlink" href="#der-null-wert" title="Permanent link">&para;</a></h3>
<p>Zeigt eine Referenzvariable auf <strong>kein</strong> Objekt, so ist ihr Wert <code>null</code>. Beispiel:</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span><span class="p">;</span>   <span class="c1">// p1 hat den Wert null</span>
<span class="p">}</span>
</code></pre></div>
<p>Die Referenzvariable <code>p1</code> vom Typ <code>Point</code> existiert bereits, aber es existiert (noch) kein <code>Point</code>-Objekt, auf das sie zeigt. Somit ist der "Wert" der Referenzvariable <code>p1</code> <code>null</code>. Referenzvariablen können auch explizit auf <code>null</code> gesetzt werden:</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>  <span class="c1">// Point-Objekt existiert, p1 zeigt auf das Point-Objekt</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>                  <span class="c1">// p1 zeigt auf kein Objekt (mehr) - das Point-Objekt wird von der GC entsorgt</span>
<span class="p">}</span>
</code></pre></div>
<p>Im oberen Beispiel wurde die <code>p1</code>-Referenzvariable vom Typ <code>Point</code> deklariert und ein <code>Point</code>-Objekt. Die <code>p1</code>-Variable referenziert (zeigt auf) das <code>Point</code>-Objekt. Danach wird <code>p1</code> explizit der "Wert" <code>null</code> zugeordnet. Die <code>p1</code>-Variable zeigt auf <em>kein</em> <code>Point</code>-Objekt mehr. Da das <code>Point</code>-Objekt nun keine Referenz mehr auf sich hat (und somit nicht mehr verwendet werden kann), wird es durch die Garbage Collection entsorgt. </p>
<h3 id="referenzvergleiche-mit">Referenzvergleiche mit <code>==</code><a class="headerlink" href="#referenzvergleiche-mit" title="Permanent link">&para;</a></h3>
<p>Wir kennen den Operator <code>==</code> als logischen Vergleichsoperator von Werten, z.B. können wir <code>int</code>-Werte damit vergleichen oder <code>char</code>-Werte oder <code>boolean</code>-Werte usw. Der Vergleichsoperator <code>==</code> kann auch für Referenzvergleiche verwendet werden, aber <strong>Achtung!</strong>, es handelt sich dann ausschließlich um Referenzvergleiche und nicht um eine <strong>Gleichheit</strong> von Objekten (dazu verwenden wir später <code>equals()</code>). Beispiele:</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span><span class="p">);</span>   <span class="c1">// false - nicht die gleiche Referenz (zwei verschiedene Objekte)</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="n">p3</span><span class="p">);</span>   <span class="c1">// true - die gleiche Referenz (ein Objekt)</span>
    <span class="n">Point</span> <span class="n">p4</span><span class="p">;</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">p4</span> <span class="o">==</span> <span class="kc">null</span><span class="p">);</span> <span class="c1">// true - keine Referenz auf ein Objekt</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">);</span> <span class="c1">// true - Referenz auf ein Objekt, deshalb ungleich null</span>

<span class="p">}</span>
</code></pre></div>
<p>Es ist eigentlich ungünstig, den Gleichheitsoperator <code>==</code> von Werten auch für Referenzen zu verwenden, da dies am Anfang verwirrend sein kann. Wichtig ist, dass der "Wert" einer Referenz die Referenz(-adresse) auf ein Objekt ist. Haben zwei Referenzvariablen den gleichen "Wert", dann zeigen sie auf dasselbe Objekt (und somit ist <code>==</code> <code>true</code>). Der Gleichheitsoperator <code>==</code> prüft <strong>nicht</strong> die Gleichheit von Objekten (z.B. beide <code>x</code>-variablen <code>3</code> und beide <code>y</code>-Variablen <code>4</code> - das erledigen wir später, indem wir die <code>equals()</code>-Methode überschreiben)!</p>
<blockquote>
<p>Wird der Vergleichsoperator <code>==</code> für Referenztypen verwendet, so wird nur die Gleichheit von Referenzen verglichen, nicht aber die Gleichheit von Objekten!</p>
</blockquote>
<div class="admonition success">
<p class="admonition-title">Success</p>
<p>Wir haben zwei Aspekte diskutiert, die beide sehr wichtig für das Verständnis der objektorientierten Programmierung sind. Einerseits den Unterschied zwischen Werte- und Referenztypen und andererseits, dass ein Objekt aufhört, zu existieren, sobald es keine Referenz mehr gibt, die auf dieses Objekt zeigt. Insbesondere das Verständnis über den Unterschied zwischen Werte- und Referenztypen ist wirklich wichtig, um die Konzepte der objektorientierten Programmierung gut verstehen zu können!</p>
</div>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Ein <code>Point</code>-Objekt besteht z.B. aus zwei <code>int</code>-Variablen (<code>x</code> und <code>y</code>) und benötigt somit 2 x 32Bit, also 64Bit.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href="../objekte/" class="md-footer__link md-footer__link--prev" aria-label="Zurück: Klassen und Objekte" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Zurück
              </span>
              Klassen und Objekte
            </div>
          </div>
        </a>
      
      
        
        <a href="../vererbung/" class="md-footer__link md-footer__link--next" aria-label="Weiter: Vererbung" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Weiter
              </span>
              Vererbung
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2021 Jörn Freiheit
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": ["instant", "tabs"], "translations": {"clipboard.copy": "In Zwischenablage kopieren", "clipboard.copied": "In Zwischenablage kopiert", "search.config.lang": "de", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Suche", "search.result.placeholder": "Suchbegriff eingeben", "search.result.none": "Keine Suchergebnisse", "search.result.one": "1 Suchergebnis", "search.result.other": "# Suchergebnisse", "search.result.more.one": "1 weiteres Suchergebnis auf dieser Seite", "search.result.more.other": "# weitere Suchergebnisse auf dieser Seite", "search.result.term.missing": "Es fehlt", "select.version.title": "Version ausw\u00e4hlen"}, "search": "../assets/javascripts/workers/search.409db549.min.js", "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.756773cc.min.js"></script>
      
    
  </body>
</html>